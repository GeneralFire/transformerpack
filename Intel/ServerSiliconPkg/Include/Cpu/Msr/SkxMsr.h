
/** @file
  SkxMsr.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

#ifndef _SKXMSR_h
#define _SKXMSR_h
#include <Base.h>

/**
  Enhanced MCA Core error injection control
**/
#define SKX_MSR_CORE_SMI_ERR_INJ_CONTROL 0x0000002C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ifu : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dcu : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dtlb : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mlc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CORE_SMI_ERR_INJ_CONTROL_REGISTER;

/**
  Enhanced MCA Uncore error injection control
**/
#define SKX_MSR_UNCORE_SMI_ERR_INJ_CONTROL 0x0000002D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pcu : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mee : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo0 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo1 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo2 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo3 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Edram : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd11 : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_SMI_ERR_INJ_CONTROL_REGISTER;

/**
  MSR used to select the mode for the Data Cache Unit (DCU). This MSR is only available when more than one DCU Mode is selectable and is only intended for use in early BIOS before the first transition of the CR0.CD from 1 to 0.
**/
#define SKX_MSR_DCU_MODE_CONTROL 0x00000031

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableDcu16kMode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When read as 0 (default), the DCU Mode is 32-KB
                               8-way without ECC. When read as 1, the BIOS has
                               changed the DCU mode to 16-KB 4-way with ECC. If
                               the DCU Mode is 0 and the first transition of
                               the CR0.CD bit from 1 to 0 has not occurred by
                               either thread in this core, then a write of 1
                               selects the DCU mode as 16-KB 4-way with ECC.
                               After the first write, all further writes are
                               ignored.
                            */
    UINT32 Dcu256bReportEn : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enable 256b granualirty for POISON
                               detection check in the DCU, this means that DCU
                               will not overflow for multiple POISONes accesses
                               if it exist in same 2 lines (256byte), when not
                               set that default value is line granualarity (64
                               bytes).
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_DCU_MODE_CONTROL_REGISTER;

/**
  Register to disable split locks, which are locked instructions that split a cache line.
**/
#define SKX_MSR_MEMORY_CONTROL 0x00000033

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 31;

                            /* Bits[30:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SplitLockDisable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If set to 1, disables split locks. If clear to
                               0, enables split locks. Setting this bit will
                               cause split locks to be non-atomic, despite the
                               lock attribute of the instruction.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MEMORY_CONTROL_REGISTER;

/**
  The SOCKET_ID MSR is used to reassign the package-specific portions of the APIC ID.  This MSR is intended only to be used on scalable DP and high-end MP platforms to resolve legacy-mode APIC ID conflicts.
**/
#define SKX_MSR_SOCKET_ID 0x00000039

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PackageId : 8;

                            /* Bits[7:0], Access Type=RO_V, default=None*/

                            /*
                               Holds package ID. This reflects the upper 8 bits
                               of the APIC ID
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SOCKET_ID_REGISTER;

/**
  Contains bits that determine what additional state SMI/RSM must save and restore
  FSCP Crunch - 1 : 32
**/
#define SKX_MSR_SMM_SAVE_CONTROL 0x0000003E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SaveFpState : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* If set, SMI/RSM will save/restore FP state */
    UINT32 Reserved1 : 31;

                            /* Bits[31:1], Access Type=RW, default=0x00000000*/

                            /* Unallocated bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SMM_SAVE_CONTROL_REGISTER;

/**
  Peci Downstream Cfg Write Enable MSR. Allow Peci to
  modify downstream PCI Cfg registers if bit0 of MSR set
**/
#define SKX_MSR_PECI_DNSTRM_WRITE_EN 0x00000054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pdcwe : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Peci Downstream Cfg Write Enable. Allow Peci to
                               modify downstream PCI Cfg registers if this bit
                               is 1
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PECI_DNSTRM_WRITE_EN_REGISTER;
/**
  POISON_CONTAINMENT_NONSPEC
**/
#define SKX_MSR_POISON_CONTAINMENT_NONSPEC 0x00000055

/**
  new MSR to flush caches
**/
#define SKX_MSR_ADR_CACHE_FLUSH 0x00000056

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CboSlice : 28;

                            /* Bits[27:0], Access Type=RW, default=0x00000000*/

                            /* LLC slice mask */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ADR_CACHE_FLUSH_REGISTER;

/**
  tell the SW when CPU supports the non-broadcast opt-in.
**/
#define SKX_MSR_MCA_EXT 0x00000059

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lma : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /*
                               it indicates to SW that local MCE (non-broadcast
                               behavior) for SRAR errors is supported by the
                               CPU
                            */
    UINT32 Pfa : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /*
                               it indicates to SW the existence of the PFR MSR
                               pair
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCA_EXT_REGISTER;

/**
  SW opt-in for none-broadcast behavior
**/
#define SKX_MSR_MCA_OPT 0x0000005A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lmce : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Local MCE SW opt-in */
    UINT32 Lmsmi : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Local MSMI SW opt-in */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCA_OPT_REGISTER;

/**
  poison filter range base Register
**/
#define SKX_MSR_PFR_BASE 0x0000005B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Address0 : 20;

                            /* Bits[31:12], Access Type=RW, default=None*/

                            /* physical address of poison filter range */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RW, default=None*/

                            /* physical address of poison filter range */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PFR_BASE_REGISTER;

/**
  poison filter range base Register
**/
#define SKX_MSR_PFR_MASK 0x0000005C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Reserved8 : 2;

                            /* Bits[9:8], Access Type=RW, default=None*/

                            /* reserved unused bits */
    UINT32 Lock : 1;

                            /* Bits[10:10], Access Type=RW, default=None*/

                            /*
                               if this bit is set no write to this CR is
                               allowed
                            */
    UINT32 Valid : 1;

                            /* Bits[11:11], Access Type=RW, default=None*/

                            /* CMI valid bit */
    UINT32 Address0 : 20;

                            /* Bits[31:12], Access Type=RW, default=None*/

                            /* physical address of poison filter range */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RW, default=None*/

                            /* physical address of poison filter range */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PFR_MASK_REGISTER;

/**
  This MSR reads/writes CBO_CR_INGRESS_SPARE[14:0]. SKX bug 305646
**/
#define SKX_MSR_LLC_WAYS_UPDATE 0x0000005F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DdioIioLlcCoswaysMask : 15;

                            /* Bits[14:0], Access Type=RW, default=None*/

                            /*
                               Expanded IO LLC CosWays Mask used when modified
                               data moves from core to LLC on IO RdCur or IO
                               I2M requests. If Ingress_Spare is not enabled,
                               it should be set to the same value as normal IO
                               CosWay mask. If Ingress_Spare is enabled, it
                               should contain at least 1-way, and expand beyond
                               that without any restriction. The default value
                               for Ingress_Spare should be the same as normal
                               LLC IIO ways(Not Enabled)
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RemoteWays : 11;

                            /* Bits[26:16], Access Type=RW, default=None*/

                            /* REMOTE WAYS */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LLC_WAYS_UPDATE_REGISTER;

/**
  This MSR reads/writes CBO_CR_CBO_COH_CONFIG[0]. SKX bug 305692
**/
#define SKX_MSR_MCA_ON_NONNEW_CACHABLEMMIO_EN 0x00000061

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McaNonnemCacheableMmioEn : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /*
                               This bit when set enables MCA on nonnem
                               cacheable MMIO
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCA_ON_NONNEW_CACHABLEMMIO_EN_REGISTER;

/**
  This MSR reads/writes . SKX bug 305
**/
#define SKX_MSR_UPDATE_RDTRKR_BLCK_THRESH 0x00000062

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mc0 : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /*
                               when bios sets this bit, chicken0.rdtrkrthresh
                               is updated to 0x30 else 0
                            */
    UINT32 Mc1 : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /*
                               when bios sets this bit, chicken0.rdtrkrthresh
                               is updated to 0x30 else 0
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UPDATE_RDTRKR_BLCK_THRESH_REGISTER;

/**
  This MSR reads/writes CBO_CR_INGRESS_SPARE[20:16]. SKX bug 305287
**/
#define SKX_MSR_RRQ_THRESHOLD_TUNING 0x00000063

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* This field is used to lock the register. */
    UINT32 RrqThresholdValue : 5;

                            /* Bits[5:1], Access Type=RW, default=None*/

                            /*
                               This field holds the Remote-Request(RRQ)-count-
                               threshold value. If the count of Remote-requests
                               allocated in the CHA-tor exceeds this threshold
                               the ingress logic will block Remote-Request
                               bidding(RRQ) into the CHA-tor-pipeline. to avoid
                               performance impact on IRQ/PRQ transactions(local
                               Requests)
                            */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_RRQ_THRESHOLD_TUNING_REGISTER;

/**
  This MSR reads/writes CBO_CR_CBREGS_SPARE[9:5]. SKX bug 307546
**/
#define SKX_MSR_IRQ_THROTTLING 0x00000064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 IrqThrottlingValue : 5;

                            /* Bits[4:0], Access Type=RW, default=None*/

                            /* This field holds the IRQ Throttling value. */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRQ_THROTTLING_REGISTER;
/**

**/
#define SKX_MSR_FPGA_BBS_PARAM 0x00000065
/**

**/
#define SKX_MSR_FPGA_BBS_TRIGGER 0x00000066

/**

**/
#define SKX_MSR_FPGA_LOAD_CMD 0x00000067

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Command : 4;

                            /* Bits[3:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 DataSize : 8;

                            /* Bits[11:4], Access Type=RW, default=None*/

                            /* Data size in blocks */
    UINT32 Data0 : 20;

                            /* Bits[31:12], Access Type=RW, default=None*/

                            /* Command Associated data. */
    UINT32 Data1 : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /* Command Associated data. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_FPGA_LOAD_CMD_REGISTER;

/**
  This msr Manipulates IIO_ERRPINSTS register
**/
#define SKX_MSR_IIO_ERR_PINSTS 0x00000069

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Status : 3;

                            /* Bits[2:0], Access Type=RW, default=None*/

                            /* updates IIO_ERRPINSTS bits 2:0 */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IIO_ERR_PINSTS_REGISTER;

/**

**/
#define SKX_MSR_QOS_APP_DIRECT_MODE_BW_THRTL 0x0000006D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 OptimizeValue : 3;

                            /* Bits[2:0], Access Type=RW, default=None*/

                            /*
                               This value is used to optimize the QOS APP
                               DIRECT MODE for EXT BW THRTL.
                            */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_QOS_APP_DIRECT_MODE_BW_THRTL_REGISTER;
/**
  New Xucode Write Only MSR for SKL-R0 issue 1351587
**/
#define SKX_MSR_SGXSETLEKEY0 0x0000008C
/**
  New Xucode Write Only MSR for SKL-R0 issue 1351587
**/
#define SKX_MSR_SGXSETLEKEY1 0x0000008D
/**
  New Xucode Write Only MSR for SKL-R0 issue 1351587
**/
#define SKX_MSR_SGXSETLEKEY2 0x0000008E
/**
  New Xucode Write Only MSR for SKL-R0 issue 1351587
**/
#define SKX_MSR_SGXSETLEKEY3 0x0000008F
/**
  New Xucode MSR for SKL-R0 issue 1351586
**/
#define SKX_MSR_PS_NONCE0 0x00000090
/**
  New Xucode MSR for SKL-R0 issue 1351586
**/
#define SKX_MSR_PS_NONCE1 0x00000091

/**
  Bios AVX Disable MSR
**/
#define SKX_MSR_BIOS_AVX_DIS 0x000000AF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 2;

                            /* Bits[1:0], Access Type=RW, default=None*/

                            /* AVX Disable */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_BIOS_AVX_DIS_REGISTER;

/**
  OS Mailbox Interface
**/
#define SKX_MSR_OS_MAILBOX_INTERFACE 0x000000B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 OsMboxIntr : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_OS_MAILBOX_INTERFACE_REGISTER;

/**
  OS Mailbox Interface
**/
#define SKX_MSR_OS_MAILBOX_DATA 0x000000B1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 OsMboxData : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_OS_MAILBOX_DATA_REGISTER;

/**
  Platform Info Register contains read-only package-level ratio information.
**/
#define SKX_MSR_PLATFORM_INFO 0x000000CE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MaxNonTurboLimRatio : 8;

                            /* Bits[15:8], Access Type=RWS, default=0x00000000*/

                            /*
                               Contains the max non-turbo ratio. Contains the
                               max non-turbo ratio. This is the ratio of the
                               frequency that invariant TSC runs at. Frequency
                               = ratio * 100 MHz. Note: The Maximum Non-Turbo
                               Ratio is adjusted to the flexible limit ratio
                               (as specified in the FLEX_RATIO MSR 194h
                               FLEX_RATIO field bits [15:8]) if flexible limit
                               is enabled (by setting the FLEX_RATIO MSR 194h
                               FLEX_EN field bit[16]=1. Note: In case of
                               Configurable TDP feature, the maximum of the
                               available TDP levels is reported in this field.
                            */
    UINT32 SmmSaveCap : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000001*/

                            /*
                               When set to '1' indicates this feature exists
                               and is configured by SMM_SAVE_CONTROL
                            */
    UINT32 Tapunlock : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Current Tap Unlock Status */
    UINT32 Rsvd18 : 5;

                            /* Bits[22:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PpinCap : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, indicates that this part supports
                               the Protected Processor Inventory Number (PPIN)
                               feature.
                            */
    UINT32 OcvoltOvrdAvail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               0b Indicates that the part does not support
                               Voltage override overclocking. 1b Indicates that
                               the part supports Voltage override overclocking.
                            */
    UINT32 FivrRfiTuningAvail : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* FIVR RFI Tuning Support */
    UINT32 Dcu16kModeAvail : 1;

                            /* Bits[26:26], Access Type=RWS, default=0x00000000*/

                            /* DCU 16K Mode Support */
    UINT32 SamplePart : 1;

                            /* Bits[27:27], Access Type=RWS, default=0x00000000*/

                            /* Indicates if this part is a sample */
    UINT32 PrgTurboRatioEn : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Programmable Turbo Ratios per number of Active
                               Cores
                            */
    UINT32 PrgTdpLimEn : 1;

                            /* Bits[29:29], Access Type=RWS, default=0x00000001*/

                            /*
                               Programmable TDP Limits for Turbo Mode. When set
                               to 1, indicates that TDP Limits for Turbo mode
                               are programmable, and when set to 0, indicates
                               TDP Limits for Turbo mode are not programmable.
                               When this bit is 0, an attempt to write to
                               PP0_POWER_LIMIT, PP1_POWER_LIMIT and
                               PACKAGE_POWER_LIMIT MSR will result in a GP
                               fault.
                            */
    UINT32 PrgTjOffsetEn : 1;

                            /* Bits[30:30], Access Type=RWS, default=0x00000001*/

                            /*
                               Programmable TJ Offset Enable. When set to 1,
                               indicates that the TCC Activation Offset field
                               in IA32_TEMPERATURE_TARGET MSR is valid and
                               programmable. When set to 0, indicates it's not
                               programmable. When this bit is 0, an attempt to
                               write to MSR_TEMPERATURE_TARGET bits [27:24]
                               will result in a GP fault.
                            */
    UINT32 CpuidFaultingEn : 1;

                            /* Bits[31:31], Access Type=RWS, default=0x00000001*/

                            /*
                               When set to 1, indicates that the processor
                               supports raising a #GP if CPUID is executed when
                               not in SMM and the CPL > 0. When this bit is
                               set, it indicates that (140h)
                               MISC_FEATURE_ENABLES bit 0 can be written by a
                               VMM.
                            */
    UINT32 LpmSupport : 1;

                            /* Bits[32:32], Access Type=RWS, default=0x00000000*/

                            /*
                               When set to 1, indicates that BIOS may program
                               IA32_PERF_CTL to levels below the max efficiency
                               ratio downto Minimum Ratio bits [55:48]. 0 - Low
                               Power mode not supported 1 - Low Power mode
                               supported
                            */
    UINT32 ConfigTdpLevels : 2;

                            /* Bits[34:33], Access Type=RWS, default=0x00000000*/

                            /*
                               Indicates the number of configurable TDP levels
                               supported. 00 - Config TDP not supported 01 -
                               One additional TDP level supported 10 - Two
                               additional TDP levels supported
                            */
    UINT32 PfatEnable : 1;

                            /* Bits[35:35], Access Type=RWS, default=0x00000000*/

                            /*
                               0 indicates that the Platform Firmware Armoring
                               Technology (PFAT) feature is not available, 1
                               indicates that the PFAT feature is available.
                            */
    UINT32 Rsvd36 : 1;

                            /* Bits[36:36], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 TimedMwaitEnable : 1;

                            /* Bits[37:37], Access Type=RWS, default=0x00000000*/

                            /*
                               0 indicates that Timed MWAIT feature is not
                               available, 1 indicates that Timed MWAIT feature
                               is available.
                            */
    UINT32 Rsvd38 : 2;

                            /* Bits[39:38], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MaxEfficiencyRatio : 8;

                            /* Bits[47:40], Access Type=RWS, default=0x00000000*/

                            /*
                               Contains the maximum efficiency ratio in units
                               of 100 MHz. System BIOS must use this as the
                               minimum ratio in the _PSS table.
                            */
    UINT32 MinOperatingRatio : 8;

                            /* Bits[55:48], Access Type=RW, default=0x00000008*/

                            /*
                               Indicates the minimum ratio supported by the
                               processor (in units of 100MHz)
                            */
    UINT32 Rsvd56 : 8;

                            /* Bits[63:56], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PLATFORM_INFO_REGISTER;
/**
  Soft SKU Data MSR
**/
#define SKX_MSR_SKX_SSKU_DATA 0x000000D0

/**
  Soft SKU Command MSR
**/
#define SKX_MSR_SKX_SSKU_CMD 0x000000D1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cmd : 16;

                            /* Bits[15:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SKX_SSKU_CMD_REGISTER;
/**
  Soft SKU Address Blacklist MSR
**/
#define SKX_MSR_SKX_SSKU_ADDR_BLACKLIST 0x000000D2
/**
  Soft SKU Blacklist Data MSR
**/
#define SKX_MSR_SKX_SSKU_DATA_BLACKLIST 0x000000D3

/**
  MSR to fine-tune FIVR switching frequency
**/
#define SKX_MSR_RFI_TUNING 0x000000E3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TargetFreqPercentShift : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Requested target FIVR frequency offset
                               percentage
                            */
    UINT32 CpuSwitchingFrequency : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Current FFC FIVR switching frequency in MHz */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_RFI_TUNING_REGISTER;

/**
  Software override for each C-state in Power Aware Interrupt Routing feature.
**/
#define SKX_MSR_PAIR_WEIGHT_MSR 0x00000102

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cc1Weight : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* Weight override for Core C1 state */
    UINT32 C0xWeight : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Weight override for any core with one thread in
                               C0 and the other in any deeper C-state
                            */
    UINT32 C00Weight : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               Weight override for any core with both threads
                               in C0
                            */
    UINT32 Cc3Weight : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /* Weight override value for Core C3 state */
    UINT32 Cc6Weight : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /* Weight override value for Core C6 state */
    UINT32 Rsvd15 : 16;

                            /* Bits[30:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 OverrideEnable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When software writes 1 to this field, the CPU
                               reads the other fields in this register and
                               updates the PAIR weights internally
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PAIR_WEIGHT_MSR_REGISTER;

/**
  AEP_QOS_DISTRS_MSR_ADDR
**/
#define SKX_MSR_AEP_QOS_DISTRS 0x00000108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 24;

                            /* Bits[23:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RW, default=None*/

                            /*  */
    UINT32 CboEgressSpareData : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_AEP_QOS_DISTRS_REGISTER;
/**
  CLX GPZ
**/
#define SKX_MSR_ARCH_CAPABILITIES 0x0000010A

/**
  This RO MSR will be used to read the Ubox CPUBUSNO/CPUBUSNO1/CPUBUSNO_VALID CSRs
**/
#define SKX_MSR_CPU_BUSNUMBER_ALIAS 0x00000128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cpubusno0 : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Bus Number 0 */
    UINT32 Cpubusno1 : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /* Bus Number 1 */
    UINT32 Cpubusno2 : 8;

                            /* Bits[23:16], Access Type=RO, default=0x00000000*/

                            /* Bus Number 2 */
    UINT32 Cpubusno3 : 8;

                            /* Bits[31:24], Access Type=RO, default=0x00000000*/

                            /* Bus Number 3 */
    UINT32 Cpubusno4 : 8;

                            /* Bits[39:32], Access Type=RO, default=0x00000000*/

                            /* Bus Number 4 */
    UINT32 Cpubusno5 : 8;

                            /* Bits[47:40], Access Type=RO, default=0x00000000*/

                            /* Bus Number 5 */
    UINT32 Rsvd48 : 15;

                            /* Bits[62:48], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RO, default=0x00000000*/

                            /*
                               Set when the CSR is written with valid bus
                               numbers
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CPU_BUSNUMBER_ALIAS_REGISTER;
/**
  This RO MSR will be used to read the Ubox MMCFG_RULE_CFG list
**/
#define SKX_MSR_MMCFG_RULE_CFG 0x00000129
/**
  This RO MSR will be used to read the Ubox MMCFG_RULE_TARGET_LIST
**/
#define SKX_MSR_MMCFG_RULE_TARGET_LIST 0x0000012A
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_0 0x00000130
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_1 0x00000131
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_2 0x00000132
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_3 0x00000133
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_4 0x00000134
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_5 0x00000135
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_6 0x00000136
/**
  Anchor Cove MSR for reading boot policy information from the PCH.
  8 new RDMSR range (addr 0x130-0x137), which read 64b each.
  Base addr is 0xFED58000 and reads are consecutive.
**/
#define SKX_MSR_ANC_BOOT_POLICY_7 0x00000137

/**
  An MSR for communicating basic policy information from the Anchor Cove ACM to early BIOS.
  Things like executing in NEM, thread protection enabled etc., will be communicated.
**/
#define SKX_MSR_ANC_SACM_INFO 0x0000013A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SacmData : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               Anchor Cove boot policy information populated by
                               the AnC StartupACM
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 AnchorCoveEnFuse : 1;

                            /* Bits[32:32], Access Type=RW, default=None*/

                            /*
                               Read-only bit to reflect the Anchor Cove enable
                               fuse
                            */
    UINT32 Pbe : 1;

                            /* Bits[33:33], Access Type=RW, default=None*/

                            /*
                               Read-only bit to reflect the PCH Protect BIOS
                               Environment bit
                            */
    UINT32 LtSxEnFuse : 1;

                            /* Bits[34:34], Access Type=RW, default=None*/

                            /* Read-only bit to reflect the LT-SX enable fuse */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ANC_SACM_INFO_REGISTER;
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_CORE_SPECIFIC_SPARE_0 0x0000013D
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_CORE_SPECIFIC_SPARE_1 0x0000013E
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_CORE_SPECIFIC_SPARE_2 0x0000013F
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_0 0x00000141
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_1 0x00000142
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_2 0x00000143
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_3 0x00000144
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_4 0x00000145
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_5 0x00000146
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_6 0x00000147
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_7 0x00000148
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_8 0x00000149
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_9 0x0000014A
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_10 0x0000014B
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_11 0x0000014C
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_12 0x0000014D
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_13 0x0000014E
/**
  Spare thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. WSM eco 653232
**/
#define SKX_MSR_THREAD_SPECIFIC_SPARE_14 0x0000014F

/**
  SNC_CONFIG_BASE register decription
**/
#define SKX_MSR_SNC_CONFIG 0x00000152

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SncEnable : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /* SNC Enable bit */
    UINT32 SncIndicationEnable : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /* SNC Enable bit */
    UINT32 NumberOfClusters : 2;

                            /* Bits[3:2], Access Type=RW_V, default=0x00000001*/

                            /* Number Of Clusters */
    UINT32 Cluster1Base : 5;

                            /* Bits[8:4], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 2 Base */
    UINT32 Cluster2Base : 5;

                            /* Bits[13:9], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 3 Base */
    UINT32 Cluster3Base : 5;

                            /* Bits[18:14], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 4 Base */
    UINT32 Rsvd19 : 9;

                            /* Bits[27:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SncLock : 1;

                            /* Bits[28:28], Access Type=RW_V, default=0x00000000*/

                            /*
                               Due to SKL B0 freeze this late arrving bit is
                               implemented in
                               FSCP_CR_MISC_FEATURE_ENABLES[SNC_LOCK]
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SNC_CONFIG_REGISTER;

/**
  Read-only MSR that specifies the maximum number of memory controllers on the platform capable of supporting memory persistence
**/
#define SKX_MSR_PERMEM_CONFIG_INFO 0x0000015C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ControllerCount : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /*
                               maximum number of memory controllers on the
                               platform capable of supporting memory
                               persistence
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERMEM_CONFIG_INFO_REGISTER;

/**
  Index into the list of persistent memory addresses which is accessed when the PERMEM_CTRLR_ID MSR is read/written
**/
#define SKX_MSR_PERMEM_CTRLR_INDEX 0x0000015D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ControllerIndex : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /* Index into persistent memory address list */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 31;

                            /* Bits[62:32], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[63:63], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERMEM_CTRLR_INDEX_REGISTER;

/**
  Read-only MSR that specifies the maximum number of memory controllers on the platform capable of supporting memory persistence
**/
#define SKX_MSR_PERMEM_CTRLR_ID 0x0000015E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 ControllerIdentifier0 : 26;

                            /* Bits[31:6], Access Type=RW, default=None*/

                            /*
                               memory address that uniquely identifies a
                               persistent memory controller, whose index in
                               list is specified by PERMEM_CTRLR_INDEX
                            */
    UINT32 ControllerIdentifier1 : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /*
                               memory address that uniquely identifies a
                               persistent memory controller, whose index in
                               list is specified by PERMEM_CTRLR_INDEX
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERMEM_CTRLR_ID_REGISTER;

/**
  Core SMI Error Source
**/
#define SKX_MSR_CORE_SMI_ERR_SRC 0x0000017C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ifu : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dcu : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dtlb : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mlc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CORE_SMI_ERR_SRC_REGISTER;

/**
  Uncore SMI Error Source
**/
#define SKX_MSR_UNCORE_SMI_ERR_SRC 0x0000017E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pcu : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mee : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo0 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo1 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo2 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Cbo3 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Edram : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd11 : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_SMI_ERR_SRC_REGISTER;

/**
  A non-architectural, package-scoped MSR intended for use by BIOS. ERROR_CONTROL[4] is a r/w bit that defeatures CMCI.
  Storage for this bit is in the UNCORE_SCP_MISC2_CREG[4]. The bit will be saved and restored in C7+ states.
  The reset value for the bit is 0. It will not survive warm reset.
  When MSR 0x17f bit 4 is set, two actions will happen:
  1. Rdmsr to MCG_CAP will have bit 10 cleared to 0.
  2. Wrmsr to MCi_MISC2 registers will clear bits[31:0] in all modes.
  For SKK Server bit 1,2,5 and 6 are used
  bits 2:1  is r/w - Read the value of MC*_DP_UCR_CHKN_BIT and modify the EN_CORR_RD_ERR_LOG bit
  and ignore_pat_scrub_uc_err bit based on memory mirroring is enabled/disabled and UNCORE_RECOVERY_DISABLE setting.
  bit 5 is r/w to update bit MMCFGMCA*.CFGMCALOGMEMCORR(bit 0).
  and bit 6 is r/w, will be used to enable KTI to not overwrite the first COR error mode for shelf 4, 3.
**/
#define SKX_MSR_ERROR_CONTROL 0x0000017F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CmciDisable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* When set will disable CMCI signalling */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ERROR_CONTROL_REGISTER;

/**
  Legacy register holding temperature related constants for Platform use.
**/
#define SKX_MSR_TEMPERATURE_TARGET 0x000001A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 FanTempTargetOfst : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Fan Temperature Target Offset (a.k.a. T-Control)
                               indicates the relative offset from the Thermal
                               Monitor Trip Temperature at which fans should be
                               engaged.
                            */
    UINT32 RefTemp : 8;

                            /* Bits[23:16], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the maximum junction
                               temperature, also referred to as the Throttle
                               Temperature, TCC Activation Temperature or
                               Prochot Temperature. This is the temperature at
                               which the Adaptive Thermal Monitor is activated.
                            */
    UINT32 TjMaxTccOffset : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /*
                               Temperature offset in degrees (C) from the TJ
                               Max. Used for throttling temperature. Will not
                               impact temperature reading. If offset is allowed
                               and set - the throttle will occur and reported
                               at lower then Tj_max.
                            */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TEMPERATURE_TARGET_REGISTER;

/**
  Miscellaneous Feature Control Register
**/
#define SKX_MSR_MISC_FEATURE_CONTROL 0x000001A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MlcStreamerPrefetchDisable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Set to disable MLC streamer prefetcher. */
    UINT32 MlcSpatialPrefetchDisable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set to disable MLC spatial prefetcher. */
    UINT32 DcuStreamerPrefetchDisable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Set to disable DCU streamer prefetcher. */
    UINT32 DcuIpPrefetchDisable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Set to disable DCU IP prefetcher. */
    UINT32 Rsvd4 : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Reserved on BDW. Was used for ACNT2. */
    UINT32 Rsvd6 : 5;

                            /* Bits[10:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DisableThreeStrikeCnt : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Prevent the Three Strike Counter from
                               incrementing
                            */
    UINT32 CoreCnt : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000000*/

                            /*
                               This is used by the reset patching to sync the
                               cores before BSP can continue.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MISC_FEATURE_CONTROL_REGISTER;

/**
  Offcore Response Event Select Register
**/
#define SKX_MSR_OFFCORE_RSP_0 0x000001A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reqtype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Request Type: MSR Bit 0 = Demand Data Rd = DCU
                               reads (includes partials) MSR Bit 1 = Demand RFO
                               = DCU RFOs MSR Bit 2 = Demand Ifetch = IFU
                               Fetches MSR Bit 3 = Writeback = Core modified WB
                               MSR Bit 4 = PF Data Rd = MPL Reads MSR Bit 5 =
                               PF RFO = MPL RFOs MSR Bit 6 = PF Ifetch = MPL
                               Fetches MSR Bit 7 = MLC prefetch to LLC - Load
                               (exclude LRUhints) MSR Bit 8 = MLC prefetch to
                               LLC - RFO MSR Bit 9 = MLC prefetch to LLC - Code
                               MSR Bit 10 = L1 Prefetch MSR Bit 11 = Write
                               Combining MSR Bit 12 = Core non-modified WB MSR
                               Bit 13 = Reserved MSR Bit 14 = Reserved MSR Bit
                               15 = Other
                            */
    UINT32 Any : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Account for any snoop response from Uncore. */
    UINT32 NoSupplierDetails : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* No Supplier Details. */
    UINT32 L3HitMState : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* L3 Hit M-State. */
    UINT32 L3HitEState : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* L3 Hit E-State. */
    UINT32 L3HitSState : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* L3 Hit S-State. */
    UINT32 L3HitFState : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* L3 Hit F-State. */
    UINT32 L4HitLocalNode : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* L4 Hit Local Node. */
    UINT32 L4HitRemote0hop : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 0 Hop */
    UINT32 L4HitRemote1hop : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 1 Hop */
    UINT32 L4HitRemote2hop : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 2 Hop. */
    UINT32 LlcMissLocalNode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Local Node. */
    UINT32 LlcMissRemote0hop : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 0 Hop. */
    UINT32 LlcMissRemote1hop : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 1 Hop. */
    UINT32 LlcMissRemote2hop : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 2 or more Hop. */
    UINT32 SplHit : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* SPL Hit */
    UINT32 None : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* No details as to Snoop-related info. */
    UINT32 NotNeeded : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 Miss : 1;

                            /* Bits[33:33], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 HitNoFwd : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it Hits in at least one
                               snooped cache. Hit denotes a cache-line was
                               valid before snoop effect
                            */
    UINT32 HitWithFwd : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and data was Forwarded from a
                               remote socket.
                            */
    UINT32 Hitm : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it HitMed in local or
                               remote cache. HitM denotes a cache-line was
                               modified before snoop effect.
                            */
    UINT32 NonDram : 1;

                            /* Bits[37:37], Access Type=RW, default=0x00000000*/

                            /* Target was non-DRAM system address. */
    UINT32 Rsvd38 : 26;

                            /* Bits[63:38], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_OFFCORE_RSP_0_REGISTER;

/**
  Offcore Response Event Select Register
**/
#define SKX_MSR_OFFCORE_RSP_1 0x000001A7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reqtype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Request Type: MSR Bit 0 = Demand Data Rd = DCU
                               reads (includes partials) MSR Bit 1 = Demand RFO
                               = DCU RFOs MSR Bit 2 = Demand Ifetch = IFU
                               Fetches MSR Bit 3 = Writeback = Core modified WB
                               MSR Bit 4 = PF Data Rd = MPL Reads MSR Bit 5 =
                               PF RFO = MPL RFOs MSR Bit 6 = PF Ifetch = MPL
                               Fetches MSR Bit 7 = MLC prefetch to LLC - Load
                               (exclude LRUhints) MSR Bit 8 = MLC prefetch to
                               LLC - RFO MSR Bit 9 = MLC prefetch to LLC - Code
                               MSR Bit 10 = L1 Prefetch MSR Bit 11 = Write
                               Combining MSR Bit 12 = Core non-modified WB MSR
                               Bit 13 = Reserved MSR Bit 14 = Reserved MSR Bit
                               15 = Other
                            */
    UINT32 Any : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Account for any snoop response from Uncore. */
    UINT32 NoSupplierDetails : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* No Supplier Details. */
    UINT32 L3HitMState : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* L3 Hit M-State. */
    UINT32 L3HitEState : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* L3 Hit E-State. */
    UINT32 L3HitSState : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* L3 Hit S-State. */
    UINT32 L3HitFState : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* L3 Hit F-State. */
    UINT32 L4HitLocalNode : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* L4 Hit Local Node. */
    UINT32 L4HitRemote0hop : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 0 Hop */
    UINT32 L4HitRemote1hop : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 1 Hop */
    UINT32 L4HitRemote2hop : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 2 Hop. */
    UINT32 LlcMissLocalNode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Local Node. */
    UINT32 LlcMissRemote0hop : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 0 Hop. */
    UINT32 LlcMissRemote1hop : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 1 Hop. */
    UINT32 LlcMissRemote2hop : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 2 or more Hop. */
    UINT32 SplHit : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* SPL Hit */
    UINT32 None : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* No details as to Snoop-related info. */
    UINT32 NotNeeded : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 Miss : 1;

                            /* Bits[33:33], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 HitNoFwd : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it Hits in at least one
                               snooped cache. Hit denotes a cache-line was
                               valid before snoop effect
                            */
    UINT32 HitWithFwd : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and data was Forwarded from a
                               remote socket.
                            */
    UINT32 Hitm : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it HitMed in local or
                               remote cache. HitM denotes a cache-line was
                               modified before snoop effect.
                            */
    UINT32 NonDram : 1;

                            /* Bits[37:37], Access Type=RW, default=0x00000000*/

                            /* Target was non-DRAM system address. */
    UINT32 Rsvd38 : 26;

                            /* Bits[63:38], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_OFFCORE_RSP_1_REGISTER;

/**
  This register defines the ratio limits.
  RATIO[0:7] must be populated in ascending order.
  RATIO[i+1] must be less than or equal to RATIO[i].
  Entries with RATIO[i] will be ignored
  If any of the rules above are broken, we will silently reject the configuration.
  If the programmed ratio is:
  Above the fused ratio for that core count, it will be clipped to the fuse limits  (assuming !OC)
  Below the min supported ratio, it will be clipped
**/
#define SKX_MSR_TURBO_RATIO_LIMIT_RATIOS 0x000001AD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ratio0 : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio1 : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio2 : 8;

                            /* Bits[23:16], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio3 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio4 : 8;

                            /* Bits[39:32], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio5 : 8;

                            /* Bits[47:40], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio6 : 8;

                            /* Bits[55:48], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */
    UINT32 Ratio7 : 8;

                            /* Bits[63:56], Access Type=RW_V, default=0x00000000*/

                            /* Defines ratio limits. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TURBO_RATIO_LIMIT_RATIOS_REGISTER;

/**
  This register defines the active core ranges for each frequency point
  NUMCORE[0:7] must be populated in ascending order.
  NUMCORE[i+1] must be greater than NUMCORE[i]
  Entries with NUMCORE[i] == 0 will be ignored
  The last valid entry must have NUMCORE >= the number of cores in the SKU
  If any of the rules above are broken, we will silently reject the configuration.
**/
#define SKX_MSR_TURBO_RATIO_LIMIT_CORES 0x000001AE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Numcore0 : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore1 : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore2 : 8;

                            /* Bits[23:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore3 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore4 : 8;

                            /* Bits[39:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore5 : 8;

                            /* Bits[47:40], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore6 : 8;

                            /* Bits[55:48], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */
    UINT32 Numcore7 : 8;

                            /* Bits[63:56], Access Type=RW_V, default=0x00000000*/

                            /*
                               defines the active core ranges for each
                               frequency point.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TURBO_RATIO_LIMIT_CORES_REGISTER;

/**
  NHM creg to filter LBR writes
**/
#define SKX_MSR_LBR_SELECT 0x000001C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CplEq0 : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* filter out ring 0 branches */
    UINT32 CplNeq0 : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* filter out non-ring 0 branches */
    UINT32 Jcc : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* filter out taken conditional branches */
    UINT32 NearRelCall : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /* filter out near relative calls */
    UINT32 NearIndirectCall : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /* filter out near indirect calls */
    UINT32 NearRet : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* filter out near returns */
    UINT32 NearIndirectJmp : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* filter out near unconditional indirect jumps */
    UINT32 NearRelJmp : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* filter out near unconditional relative branches */
    UINT32 FarBranch : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* filter out far branches */
    UINT32 CallStack : 1;

                            /* Bits[9:9], Access Type=RW, default=None*/

                            /* enable LBR to only collect calls */
    UINT32 Rsvd10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_SELECT_REGISTER;

/**
  LBR creg that holds the TOS value
**/
#define SKX_MSR_LBR_TOS 0x000001C9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Tos : 6;

                            /* Bits[5:0], Access Type=RW_V, default=None*/

                            /* LBR TOS */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TOS_REGISTER;

/**
  LAST_BRANCH LBR MSR that holds non-IP information
**/
#define SKX_MSR_LAST_BRANCH_INFO 0x000001DA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RO_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RO_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RO_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RO_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_BRANCH_INFO_REGISTER;

/**
  Top of LBR Stack
**/
#define SKX_MSR_LAST_BRANCH_FROM_IP 0x000001DB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /* FROM LBR at Top of stack */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RO_V, default=None*/

                            /* FROM LBR at Top of stack */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_BRANCH_FROM_IP_REGISTER;

/**
  Top of LBR Stack
**/
#define SKX_MSR_LAST_BRANCH_TO_IP 0x000001DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /* TO LBR at top of stack */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RO_V, default=None*/

                            /* TO LBR at top of stack */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_BRANCH_TO_IP_REGISTER;

/**
  Last Exeception Record
**/
#define SKX_MSR_LAST_INT_FROM_IP 0x000001DD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LoData : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* low FROM addr of Last Exeception Record */
    UINT32 HiData : 16;

                            /* Bits[47:32], Access Type=RW, default=None*/

                            /* high FROM addr of Last Exeception Record */
    UINT32 SignExt : 13;

                            /* Bits[60:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW, default=None*/

                            /* TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW, default=None*/

                            /* ROB is in TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW, default=None*/

                            /* high FROM addr of Last Exeception Record */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_INT_FROM_IP_REGISTER;

/**
  Last Exeception Record
**/
#define SKX_MSR_LAST_INT_TO_IP 0x000001DE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LoData : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* low TO addr of Last Exeception Record */
    UINT32 HiData : 16;

                            /* Bits[47:32], Access Type=RW, default=None*/

                            /* high TO addr of Last Exeception Record */
    UINT32 CycleCount : 16;

                            /* Bits[63:48], Access Type=RW, default=None*/

                            /* Elapsed cycle counter from previous branch */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_INT_TO_IP_REGISTER;

/**
  LER MSR that holds non-IP information
**/
#define SKX_MSR_LAST_INT_INFO 0x000001E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LAST_INT_INFO_REGISTER;

/**
  This MSR writes
**/
#define SKX_MSR_CUSTOMER_FEATURE_CONTROL 0x000001E2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 UserMwaitModeEn : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /*
                               This field updates bit 0 in
                               FSCP_CR_SMM_CFG_OPTIONS_ADDR when user enables
                               ULM.
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CUSTOMER_FEATURE_CONTROL_REGISTER;

/**
  This MSR writes
**/
#define SKX_MSR_ULI_VECTOR 0x000001E5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MatchVector : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /* update FSCP ULI_VECTOR_INFO.matchvector */
    UINT32 Enable : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* update FSCP ULI_VECTOR_INFO.enable */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ULI_VECTOR_REGISTER;
/**
  This MSR writes
**/
#define SKX_MSR_ULI_TARGET_RIP 0x000001E7

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define SKX_MSR_PRMRR_BASE 0x000001F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Rsvd3 : 9;

                            /* Bits[11:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PRMRR_BASE_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Mask Control Register
**/
#define SKX_MSR_PRMRR_MASK 0x000001F5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 9;

                            /* Bits[8:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, PRMRR is in assist-mode - else in page
                               abort-mode (defeature only)
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the PRMRR */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the PRMRR */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR MASK bits */
    UINT32 Mask1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR MASK bits */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PRMRR_MASK_REGISTER;

/**
  Valid PRMRR configurations
**/
#define SKX_MSR_PRMRR_VALID_CONFIG 0x000001FB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Config1m : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* 1M supported MEE size */
    UINT32 Rsvd1 : 4;

                            /* Bits[4:1], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Config32m : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* 32M supported MEE size */
    UINT32 Config64m : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* 64M supported MEE size */
    UINT32 Config128m : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* 128M supported MEE size */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PRMRR_VALID_CONFIG_REGISTER;

/**
  Power Control Register
**/
#define SKX_MSR_POWER_CTL 0x000001FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableBidirProchot : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used to enable or disable the response to
                               PROCHOT# input. When set/enabled, platform can
                               force CPU to throttle to a lower power condition
                               such as Pn/Pm by asserting prochot#. When
                               clear/disabled (default), CPU ignores the status
                               of the prochot input signal.
                            */
    UINT32 C1eEnable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Used to enable C1E behavior on every C1 entry
                               (even if MWAIT C1E substate bit was not set or
                               when using HLT). When this package-visible bit
                               is set, it will cause CPU to switch to minimum
                               GV point when all cores have entered C1.
                               Frequency will switch immediately, followed by
                               gradual voltage switching (GV3 style).
                            */
    UINT32 SapmImcC2Policy : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Enables Self Refresh entry when the CPU is in
                               package-C2 (popup) state. Should be disabled
                               only if platform traffic cannot withstand even
                               the SR exit latency while in C2.
                            */
    UINT32 FastBrkSnpEn : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the VID swing rate for Other_Snp_Wake
                               events detected at the iMPH. Will override a
                               "SLOW" sideband wake indication primarily for
                               PCIe traffic!). '1' - Use 'fast' VID swing rate
                            */
    UINT32 FastBrkIntEn : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Controls the VID swing rate for Other_Intp_Wake
                               events detected at the iMPH. Will override a
                               "SLOW" sideband wake indication (for C7 or
                               PCIe). '1' - Use 'fast' VID swing rate
                            */
    UINT32 Rsrvd5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Rsrvd uCode needs to copy this bit to/from
                               POWER_CTL1_CR[5] on writes.reads
                            */
    UINT32 PholdCstPreventionInit : 11;

                            /* Bits[16:6], Access Type=RW, default=0x00000001*/

                            /*
                               Init value for the PHOLD_CST_PREVENTION_Timer.
                               Values are between 0 and 1023 in 2^21*10nS
                               resolution (matching 0 - ~21sec)
                            */
    UINT32 PholdSrDisable : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               if set to '1', CPU will also prevent the memory
                               from going to SR during the CST_PREVENTION
                               timeout;
                            */
    UINT32 PwrPerfPltfrmOvr : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0 (default), will disable access to
                               IA32_ENERGY_PERFORMANCE_BIAS MSR 1B0h (causing a
                               GP# fault on access). CPUID.(EAX=6):ECX[3] will
                               read 0. When set to 1 will enable access to
                               IA32_ENERGY_PERFORMANCE_BIAS MSR 1B0h.
                               CPUID.(EAX=6):ECX[3] will read 1
                            */
    UINT32 EeTurboDisable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Energy Efficient Turbo Disable */
    UINT32 CstatePrewakeDisable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               This bit can be used to disable core/pkg C-state
                               Prewake timers.
                            */
    UINT32 DisProchotOut : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Prochot output disable */
    UINT32 PwrPerfTuningDisableSapmCtrl : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether power perf tuning
                               algorithm controls SAPM entities
                            */
    UINT32 PwrPerfTuningDisableEepCtrl : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether power perf tuning
                               algorithm control EE-P algorithm
                            */
    UINT32 PwrPerfTuningEnableDynSwitching : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether dynamic switching is
                               enabled in power perf tuning algorithm.
                            */
    UINT32 PwrPerfTuningCfgMode : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether power perf tuning should
                               use IA32_ENERGY_PERF_BIAS input or ALT input. 0
                               - Use IA32_ENERGY_PERF_BIAS input 1 - Use input
                               from ENERGY_PERF_BIAS_CONFIG Ucode needs to copy
                               this value to/from
                               PCU_CR_POWER_CTL1[PWR_PERF_TUNING_CFG_MODE].
                            */
    UINT32 Rsrvd26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Rsrvd. uCode needs to read 0 and preserve
                               POWER_CTL1_CR[26] on writes.
                            */
    UINT32 ProchotLock : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, locks bits 0, 21, 22 and 23 of
                               this MSR. Once set, a reset is required to clear
                               this bit.
                            */
    UINT32 VrThermAlertDisable : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, disables the VR_THERMAL_ALERT
                               signaling.
                            */
    UINT32 LtrIioDisable : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether Pcode should poll the IIO
                               for LTR updates.
                            */
    UINT32 PchNegDisable : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether latency should be
                               negotiated with PCH for PKGC.
                            */
    UINT32 ReservedMode31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_POWER_CTL_REGISTER;

/**
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define SKX_MSR_KTI0_MC_CTL2 0x00000285

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CorrThres : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Threshold Correctable Error
                               Threshold used for controlling when Corrected
                               Error Interrupts are sent.
                            */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CorrErrIntEn : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Interrupt Enable Enables the
                               generation of correctable Error Interrupts.
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CsmiEn : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Enables the generation of CSMI for correctable
                               errors. When enabled, also disables CMC signal
                               interrupts.
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MsmiEn : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Enables the generation of MSMI for uncorrectable
                               errors. When enabled, also disables UNC signal
                               interrupts. Note that if an error's flag is
                               disabled by MC_CTL, MSMI will not be generated
                               for that error type.
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_KTI0_MC_CTL2_REGISTER;

/**
  IMCx_CR_MCx_CTL2 is responsible for enabling and controlling the CMCI mechanism and the correctable threshold value. (described in section 2.2.1 of the MCA HAS).
**/
#define SKX_MSR_IMC0_MC_CTL2 0x0000028D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CorErrCntTh : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /* Corrected error count threshold. */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CmciEn : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MapCmciToCsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupts to
                               Correctable SM Interrupts
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MapMceToMsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine check SM
                               Interrupts
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC0_MC_CTL2_REGISTER;

/**
  This register holds flags used by the LT uCode.  Some of the bits in this register are duplicated in the Cbo and IMPH, by holding a copy of this register. It is the responsibility of the uCode to keep the various copies coherent.
  Bit 0-13 are control bits
  Bits i=16-29 are controls that clear the status of bit i-16
  Bits 30-31 are command bits (ucode only) to clear PMON regs (write 1's to these bits)
**/
#define SKX_MSR_LT_CONTROL 0x000002E7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Configlock : 1;

                            /* Bits[0:0], Access Type=RW1S, default=0x00000000*/

                            /*
                               This bit is copied in the NCU only. This bit is
                               used for indicating 'LT Config Lock' to read and
                               write operations over the message channel. Read
                               : 0 - Lock flag is cleared 1 - Lock flag is set
                               Write : 0 - ignored 1 -Set the Lock flag No
                               fucntionality required to be supported in CBo
                               iMPH
                            */
    UINT32 Memlockcpu : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000001*/

                            /*
                               This bit is implemented in the IMPH version of
                               the register only (as RO-VFW), the NCU holds a
                               shadow of the bit. This bit is used for
                               indicating 'LT Lock of CPU access to Memory'' to
                               read operations. The bit is cleared by a write
                               of 1 to the MemLockCPUClr bit. 0 - Memory access
                               is enabled 1 - Memory is Locked
                            */
    UINT32 Memlockdev : 1;

                            /* Bits[2:2], Access Type=RO_V, default=0x00000001*/

                            /*
                               This bit is implemented in the IMPH version of
                               the register only (as RO-VFW), the NCU holds a
                               shadow of the bit. This bit is used for
                               indicating 'LT Lock of Device access to Memory''
                               to read operations. The bit is cleared by a
                               write of 1 to the MemLockDevClr bit. 0 - Memory
                               access is enabled 1 - Memory is Locked
                            */
    UINT32 Smmlockoverride : 1;

                            /* Bits[3:3], Access Type=RW1S, default=0x00000001*/

                            /*
                               This bit is used for indicating 'SMM Override'
                               to read and write operations over the message
                               channel. Read : 0 - SMMOverride flag is cleared
                               1 - SMMOverride flag is set Write : 0 - ignored
                               1 -Set the SMMOverride flag
                            */
    UINT32 Rsvd4 : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PoisonRsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               This is NOT a feature in SKX, but implemented as
                               a placeholder for converged ucode covering SKL.
                               In SKL ucode will set this bit whenever it sends
                               out a poison cycle. cleared by PoisonClr bit.
                            */
    UINT32 Private : 1;

                            /* Bits[6:6], Access Type=RW1S, default=0x00000000*/

                            /*
                               This bit is copied in the NCU and Cbo. This bit
                               is cleared by the PrivateClr bit. Read : 0 -
                               Private flag is cleared 1 - Private flag is set
                               Write : 0 - ignored 1 -Set the Private flag
                            */
    UINT32 Inacm : 1;

                            /* Bits[7:7], Access Type=RW1S, default=0x00000000*/

                            /*
                               This bit is copied in the NCU IMPH and Cbo. This
                               bit is cleared by the respective bit in
                               NcuLTCtrClr register. Read : 0 - In ACM flag is
                               cleared 1 - In ACM flag is set Write : 0 -
                               ignored 1 -Set the InACM flag
                            */
    UINT32 Loc3guarddis : 1;

                            /* Bits[8:8], Access Type=RW1S, default=0x00000000*/

                            /*
                               This bit is implemented in the Cbo and has a
                               shadow in NCU. This bit is cleared by writint a
                               1 to the respective bit in NcuLTCtrClr register.
                               Read : 0 - Locality 3 Guard is Enabled 1 -
                               Locality 3 Guard is Disable Write : 0 - ignored
                               1 -Set the Loc3Guard
                            */
    UINT32 Hskinprog : 1;

                            /* Bits[9:9], Access Type=RW1SS, default=0x00000000*/

                            /*
                               Indicates that the core is in the process of
                               SENTER or SEXIT handshake. This is a sticky bit
                               used by uCode as part of LT flow. No HW action
                               in NCU. This bit is cleared by writint a 1 to
                               the respective bit in NcuLTCtrClr register. Read
                               : 0 - Hand Shake not in progress 1 - Hand Shake
                               in progress Write : 0 - ignored 1 -Set the
                               HskInProg
                            */
    UINT32 Faterrdursacm : 1;

                            /* Bits[10:10], Access Type=RW1SS, default=0x00000000*/

                            /*
                               FATAL_ERROR_DURING_SACM Indicates that an error
                               occurred during Startup ACM processing that
                               caused an LT-shutdown. This register is
                               preserved across warm reset, so reset uCode can
                               check this bit and skip Startup ACM processing
                               if it is set to prevent an infinite loop of
                               resets This is a sticky bit used by uCode as
                               part of LT flow. No HW action in NCU. This bit
                               is cleared by writint a 1 to the respective bit
                               in NcuLTCtrClr register. Read : 0 - No Error 1 -
                               Fatal Error During SACM Write : 0 - ignored 1
                               -Set the FatErrDurSACM
                            */
    UINT32 IlpMsegValid : 1;

                            /* Bits[11:11], Access Type=RW1SS, default=0x00000000*/

                            /*
                               This is a sticky bit used by uCode as part of LT
                               flow. It is used to stash the ILP's copy of
                               FSCP_CR_VMX_MSEG_BASE[VALID]. It is used by
                               UCODE for consistency check to verify that all
                               threads select the same type of SMM handling. No
                               HW action in NCU. This bit is cleared by writing
                               a 1 to the respective bit in NcuLTCtrClr
                               register. Read : 0 - Bit is at cleared state 1 -
                               Bit is set state Write : 0 - ignored 1 -Set the
                               ILP_MSEG_VALID
                            */
    UINT32 PostSenter : 1;

                            /* Bits[12:12], Access Type=RW1SS, default=0x00000000*/

                            /*
                               This is a sticky bit used by uCode as part of LT
                               flow. The POST_SENTER bit will be set between
                               SENTER and SEXIT. It is used to detect
                               spontaneous reset during secure mode. The
                               POST_SENTER bit must survive warm reset. It will
                               be checked along with the existing AC-mode check
                               in reset UCODE. No HW action in NCU. This bit is
                               cleared by writing a 1 to the respective bit in
                               NcuLTCtrClr register. Read : 0 - Bit is at
                               cleared state 1 - Bit is set state Write : 0 -
                               ignored 1 -Set the POST_SENTER bit
                            */
    UINT32 LtScp3Rsrv : 1;

                            /* Bits[13:13], Access Type=RW1SS, default=0x00000000*/

                            /*
                               This is a sticky bit used by uCode as part of LT
                               flow - currently as spare bit. No HW action in
                               NCU. This bit is cleared by writint a 1 to the
                               respective bit in NcuLTCtrClr register. Read : 0
                               - Bit is at cleared state 1 - Bit is set state
                               Write : 0 - ignored 1 -Set the LT_scp3_rsrv
                            */
    UINT32 Rsvd14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Configunloc : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               Writing a value of 0 to this bit has no effect.
                               Writing a value of 1 to this bit will clear the
                               ConfigLock flag. NOTE: The HW an assume that
                               only SW in ACM mode will write to this bit a
                               value of 1.
                            */
    UINT32 Memlockcpuclr : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               Writing 1 to this bit clears MemLockCPU bit in
                               this register. Writing 0 to this bit has no
                               effect.
                            */
    UINT32 Memlockdevclr : 1;

                            /* Bits[18:18], Access Type=WO, default=0x00000000*/

                            /*
                               Writing 1 to this bit clears MemLockDev bit in
                               this register. Writing 0 to this bit has no
                               effect.
                            */
    UINT32 Smmlockclr : 1;

                            /* Bits[19:19], Access Type=WO, default=0x00000000*/

                            /* Clear the SMM override */
    UINT32 Rsvd20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PoisonclrRsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               This is NOT a feature in SKX, but implemented as
                               a placeholder for converged ucode covering SKL.
                               Server has no logic, but in CLIENT the bit
                               means:0 : Ignored 1 : Clear the Poison bit in
                               this register
                            */
    UINT32 Privateclr : 1;

                            /* Bits[22:22], Access Type=WO, default=0x00000000*/

                            /*
                               0 : Ignored 1 : Clear the Private bit in this
                               register.
                            */
    UINT32 Inacmclr : 1;

                            /* Bits[23:23], Access Type=WO, default=0x00000000*/

                            /* 0 : ignored 1 : Clears the InACM flag */
    UINT32 Loc3guarddisclear : 1;

                            /* Bits[24:24], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If Loc3GuardDis=0 (including the result
                               of this write) - Ignored. else 0 - ignored 1 -
                               Clear the Loc3GuardDis flag
                            */
    UINT32 Hskinprogclr : 1;

                            /* Bits[25:25], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If HskInProgs=0 (including the result of
                               this write) - Ignored. else 0 - ignored 1 -
                               Clear the HskInProg flag
                            */
    UINT32 Faterrdursacmclr : 1;

                            /* Bits[26:26], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If FatErrDurSACM=0 (including the result
                               of this write) - Ignored. else 0 - ignored 1 -
                               Clear the FatErrDurSACM flag
                            */
    UINT32 IlpMsegValidClr : 1;

                            /* Bits[27:27], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If ILP_MSEG_VALID=0 (including the
                               result of this write) - Ignored. else 0 -
                               ignored 1 - Clear the ILP_MSEG_VALID flag
                            */
    UINT32 PostSenterClr : 1;

                            /* Bits[28:28], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If POST_SENTER=0 (including the result
                               of this write) - Ignored. else 0 - ignored 1 -
                               Clear the POST_SENTER flag
                            */
    UINT32 LtScp3RsrvClr : 1;

                            /* Bits[29:29], Access Type=WO, default=0x00000000*/

                            /*
                               Write : If LT_scp3_rsrv=0 (including the result
                               of this write) - Ignored. else 0 - ignored 1 -
                               Clear the LT_scp3_rsrv flag
                            */
    UINT32 Ltpmonctrclr : 1;

                            /* Bits[30:30], Access Type=WO, default=0x00000000*/

                            /*
                               This bit is copied in the NCU and Cbo. This bit
                               is used for LT uCode control over the PMON
                               counters. The NCU copy of the register must be
                               cleared last to prevent race conditions with
                               clear operations of other module's counters. 0b
                               No action 1b Clear all PMON control registers
                               (including Fixed counter control)
                            */
    UINT32 Ltpmoncntclr : 1;

                            /* Bits[31:31], Access Type=WO, default=0x00000000*/

                            /*
                               This bit is copied in the NCU and Cbo. This bit
                               is used for LT uCode control over the PMON
                               counters. 0b No Action 1b Clear all PMON Counter
                               registers and Unit overflow status registers
                               (including Fixed Counter and Global Overflow
                               Status).
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LT_CONTROL_REGISTER;

/**

**/
#define SKX_MSR_BIOS_SE_SVN 0x00000302

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reserved0 : 16;

                            /* Bits[15:0], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 SinitSeSvn : 8;

                            /* Bits[23:16], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 ScleanSeSvn : 8;

                            /* Bits[31:24], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 AncSeSvn : 8;

                            /* Bits[39:32], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 PfatSeSvn : 8;

                            /* Bits[47:40], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved48 : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_BIOS_SE_SVN_REGISTER;

/**
  Shows the programming status of architectural PerfMon counters and PMI enable.
**/
#define SKX_MSR_EMON_PERF_RES_PROGRAMMED 0x00000392

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnabledGenCntr : 4;

                            /* Bits[3:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               Range 3:0 relates to General 3, 2 ,1, 0
                               respecitively. A '1' indicates the counter is
                               either enabled or has HW errata. In either case
                               the counter is considered 'in use' 7:4 is the
                               non-Or'ed values, just hw errata
                            */
    UINT32 HwErrataGenCntr : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               7:4 is the non-Or'ed values, just hw errata
                               These are not visible to external SW. MSR ucode
                               will always mask these out.
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 EnabledFixedCntr : 3;

                            /* Bits[34:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               Range 34:32 relates to Fixed Cntr 2 ,1, 0
                               respectively. A '1' indicates the counter is
                               either enabled or has HW errata. In either case
                               the counter is considered 'in use' 37:35 is the
                               non-Or'ed values, just hw errata
                            */
    UINT32 HwErrataFixedCntr : 3;

                            /* Bits[37:35], Access Type=RW, default=0x00000000*/

                            /*
                               37:35 is the non-Or'ed values, just hw errata
                               These are not visible to external SW. MSR ucode
                               will always mask these out.
                            */
    UINT32 Rsvd38 : 25;

                            /* Bits[62:38], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pmi : 1;

                            /* Bits[63:63], Access Type=RO_V, default=0x00000000*/

                            /* PMI. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EMON_PERF_RES_PROGRAMMED_REGISTER;

/**
  Precise Performance Monitoring (PPMON) Event Control.  This register is read-write.
**/
#define SKX_MSR_PEBS_FRONTEND 0x000003F7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EventId : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Choose which event to monitor (ie. 1: L1_IMISS,
                               2: MLC_MISS, 3: ITLB_MISS, 4: STLB_MISS, 5:
                               DSB_MISS, 6: IDQ_READ_BUBBLES)
                            */
    UINT32 Rsvd3 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 CriticalFilter : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When asserted, cycles occurring while IDQ is
                               empty are filtered, otherwise they are
                               monitored.
                            */
    UINT32 Rsvd5 : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 FeLatency : 12;

                            /* Bits[19:8], Access Type=RW, default=0x00000008*/

                            /*
                               Number of consecutive cycles not having less
                               than FE_THRESHOLD bubbles which must occur
                               before logging the event.
                            */
    UINT32 FeThreshold : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Number of delivery bubbles (or more) of cycles
                               to count. If number of delivery bubbles is
                               greater than or equal to this field, then count
                               it.
                            */
    UINT32 Rsvd23 : 9;

                            /* Bits[31:23], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PEBS_FRONTEND_REGISTER;
/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define SKX_MSR_PKG_C3_RESIDENCY_COUNTER 0x000003F8
/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define SKX_MSR_PKG_C6_RESIDENCY_COUNTER 0x000003F9
/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define SKX_MSR_PKG_C7_RESIDENCY_COUNTER 0x000003FA
/**
  Time spent in the Core C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
**/
#define SKX_MSR_CC3_RCNTR 0x000003FC
/**
  Time spent in the Core C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
**/
#define SKX_MSR_CC6_RCNTR 0x000003FD
/**
  Time spent in the Core C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
**/
#define SKX_MSR_CC7_RCNTR 0x000003FE

/**
  Intel UPI MC CONTROL
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
  The MCi_CTL MSR controls the signaling of machine check exceptions generated by the bank.  Each of the defined bits in the register represents an uncorrectable error type.  Each of the defined bits is referred to as a flag.  Setting a flag enables signaling of a machine check exception upon the occurrence of the associated error.  When the flag is cleared, the error will still be logged but a machine check exception will not be signaled.
**/
#define SKX_MSR_KTI0_MC_CTL 0x00000414

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Err00PhyNuminit : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x00 Enable - Phy
                               Initialization Failure (NumInit)
                            */
    UINT32 Err01PhyDrift : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x01 Enable - Phy Detected
                               Drift Buffer Alarm
                            */
    UINT32 Err02PhyLatBuf : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x02 Enable - Phy Latency
                               Buffer Overflow
                            */
    UINT32 Err03PhyRsvd1 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x03 Enable - Reserved
                               encoding - No error hooked up to this.
                            */
    UINT32 Err04PhyRsvd2 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x04 Enable - Reserved
                               encoding - No error hooked up to this.
                            */
    UINT32 Rsvd5 : 11;

                            /* Bits[15:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Err10LlUnsuccRxcrc : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x10 Enable - LL Rx detected
                               Uncorrectable CRC error This error type detects
                               an unsuccessful link layer retry (ie. LRSM
                               enters ABORT state).
                            */
    UINT32 Err11LlUu : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x11 Enable - LL Rx
                               Unsupported Packet
                            */
    UINT32 Err12LlControl : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x12 Enable - LL or Phy
                               Generic Control This error type detects a Link
                               or Phy Layer ""control logic"" error. It could
                               be one of many things, including
                               overflows/underflows, illegal states, etc.
                            */
    UINT32 Err13LlParamException : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x13 Enable - LL Rx Parameter
                               exchange exception
                            */
    UINT32 Err14LlRsvd1 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x14 Enable - Reserved
                               encoding - No error hooked up to this.
                            */
    UINT32 Err15LlRsvd2 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x15 Enable - Reserved
                               encoding - No error hooked up to this.
                            */
    UINT32 Rsvd22 : 9;

                            /* Bits[30:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Err1fM3Ctl : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Error (mscod_code) 0x1F Enable - M3UPI Control
                               Error This error type detects an error in the
                               M3UPI ring stop. Note that because the M3UPI
                               ringstop services traffic to both UPI ports, it
                               is likely that both UPI ports will log this
                               error simultaneously if one occurs.
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_KTI0_MC_CTL_REGISTER;

/**
  Intel UPI MC STATUS
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define SKX_MSR_KTI0_MC_ST 0x00000415

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McacodLl : 2;

                            /* Bits[1:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD Bus Interconnect Error LL Set to 1 for all
                               Transmit Path Parity Protection errors
                               (MSCOD_Code=0x12 ""UC LL or Phy Control Error""
                               and KTIDBGERRST0.ctrl_txparerr=non-zero) such
                               that mcacod[15:0]=0x0405. Set to 3 for all other
                               errors. Encoding is: 0x0 - Level 0 0x1 - Level 1
                               0x2 - Level 2 0x3 - Generic LL
                            */
    UINT32 McacodIi : 2;

                            /* Bits[3:2], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD Bus Interconnect Error II Set to 1 for all
                               Transmit Path Parity Protection errors
                               (MSCOD_Code=0x12 ""UC LL or Phy Control Error""
                               and KTIDBGERRST0.ctrl_txparerr=non-zero) such
                               that mcacod[15:0]=0x0405. Set to 3 for all other
                               errors. Encoding is: 0x0 - Memory Access 0x1 -
                               Reserved II 0x2 - I/O 0x3 - Other Transaction
                            */
    UINT32 McacodRrrr : 4;

                            /* Bits[7:4], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodT : 1;

                            /* Bits[8:8], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodPp : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MCACOD - Bus Int Error PP Set to 2 for all
                               Transmit Path Parity Protection errors
                               (MSCOD_Code=0x12 ""UC LL or Phy Control Error""
                               and KTIDBGERRST0.ctrl_txparerr=non-zero) such
                               that mcacod[15:0]=0x0405. Set to 2 for all ""UC
                               LL Rx Unsupported/Undefined Packet"" errors
                               (MSCOD_Code=0x11). Set to 3 for all other
                               errors. Encoding is: 0x0 - Local Processor
                               Originated 0x1 - Local Processor Responded 0x2 -
                               Local Processor Observed Error 0x3 - Generic PP
                            */
    UINT32 McacodInt : 1;

                            /* Bits[11:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MCACOD - Bus Interconnect Error Set to 0 for all
                               Transmit Path Parity Protection errors
                               (MSCOD_Code=0x12 ""UC LL or Phy Control Error""
                               and KTIDBGERRST0.ctrl_txparerr=non-zero) such
                               that mcacod[15:0]=0x0405. Set to 1 for all other
                               errors. Encoding: 0 - Not Bus Interconnect Error
                               1 - Bus Interconnect Error
                            */
    UINT32 McacodRsvd : 4;

                            /* Bits[15:12], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 MscodCode : 6;

                            /* Bits[21:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD Error Code Error Code from Intel UPI
                               Agent. This field captures the error type based
                               on the standard MC_ST overwrite rules. The Error
                               Codes and handling are defined in the HAS. The
                               summary per ID is: Uncorrectable (UC) 0x00 - UC
                               Phy Initialization Failure (NumInit) 0x01 - UC
                               Phy Detected Drift Buffer Alarm 0x02 - UC Phy
                               Detected Latency Buffer Rollover 0x10 - UC LL Rx
                               detected CRC error: unsuccessful LLR (entered
                               Abort state) 0x11 - UC LL Rx
                               Unsupported/Undefined packet 0x12 - UC LL or Phy
                               Control Error 0x13 - UC LL Rx Parameter
                               Exception 0x1F - UC LL Detected Control Error
                               from M3UPI Correctable (COR) 0x20 - COR Phy
                               Initialization Abort 0x21 - COR Phy Reset 0x22 -
                               COR Phy Lane failure, recovery in x8 width 0x23
                               - COR Phy L0c error corrected without Phy reset
                               0x24 - COR Phy L0c error triggering Phy Reset
                               0x25 - COR Phy L0p exit error triggering Phy
                               Reset 0x30 - COR LL Rx detected CRC error:
                               successful LLR without Phy Reinit 0x31 - COR LL
                               Rx detected CRC error: successful LLR with Phy
                               Reinit
                            */
    UINT32 MscodSpare : 10;

                            /* Bits[31:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD SPARE Field used for design specific sub-
                               status fields for ""UC LL or Phy Control
                               Errors"" (mscode_code=0x12): [22] - Phy Control
                               Error (note: currently tied to 0 in processor)
                               [23] - Unexpected Retry.Ack flit [24] -
                               Unexpected Retry.Req flit [25] - RF parity error
                               [26] - Routeback Table error [27] - unexpected
                               Tx Protocol flit (EOP, Header or Data) [28] - Rx
                               Header-or-Credit BGF credit overflow/underflow
                               [29] - Link Layer Reset still in progress when
                               Phy enters L0 (Phy training should not be
                               enabled until after LL reset is complete as
                               indicated by KTILCL.LinkLayerReset going back to
                               0). [30] - Link Layer reset initiated while
                               protocol traffic not idle [31] - Link Layer Tx
                               Parity Error
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info Field used for design specific sub-
                               status fields for ""UC LL or Phy Control
                               Errors"" (mscode_code=0x12): [32] - Link layer
                               credit or queue (various) overflow/underflow
                               [33] - Flow Queue credit overflow/underflow
                               [37:34] - reserved
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Count 15-bit counter which is
                               incremented on every corrected error. MSB (bit
                               15) is a sticky overflow bit.
                            */
    UINT32 CorrErrStsInd : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               Field never set by hardware (but can be set by
                               software). 00 - No tracking - No hardware status
                               tracking is provided for the structure reporting
                               this event. 01 - Green - Status tracking is
                               provided for the structure posting the event;
                               the current status is green (below threshold).
                               For more information, see Section ""Enhanced
                               Cache Error reporting"" of the Software
                               Developer Manual. 10 - Yellow - Status tracking
                               is provided for the structure posting the event;
                               the current status is yellow (below threshold).
                               For more information, see Section ""Enhanced
                               Cache Error reporting"" of the Software
                               Developer Manual. 11 - Reserved
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Processor Context Corrupt Flag Bit set on all
                               uncorrectable errors
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Address Valid in KTI_MC_AD. Bit set on error
                               types which load Tx Address into KTI_MC_AD. The
                               applicable error types are: LL or Phy Generic
                               Control (error code 0x12)
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               KTI_MC_MISC valid flag Indicates (when set) that
                               the MCi_MISC register contains additional
                               information regarding the error. See individual
                               fields of MCi_MISC for details on which are
                               valid for a given error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Enable Flag Set by hardware when MCA
                               (uncorrectable) is signaled.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Uncorrected Set for error which was not
                               corrected.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /* MCA Overflow Flag Set on all second error cases */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Set by hardware when an uncorrectable or
                               correctable error is logged.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_KTI0_MC_ST_REGISTER;

/**
  Intel UPI MC ADDRESS
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define SKX_MSR_KTI0_MC_AD 0x00000416

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Address4560 : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Address4561 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_KTI0_MC_AD_REGISTER;

/**
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
  Register used to capture non-address bits of Intel UPI Flit when available. Intel UPI Flit i a an 80-bit chunk transmitted on Intel UPI, which includes 8-bits of CRC. In this register the bit fields are assume to be 79:0, where the bit 0 is CRC[3] and bit 79 is DNID[2] from the Intel UPI spec.
**/
#define SKX_MSR_KTI0_MC_MISC 0x00000417

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FlitHdr : 20;

                            /* Bits[19:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               HDR bits captured: [0] - HIB (if not set other
                               bits >4 in this log are not valid) [1] - VN [2]
                               - VNA [3] - ACK [4] - CRD [8:5]- Slot 0 opcode
                               [11:9] - Slot 0 MC [15:12] - Slot 1 Opcode [16]
                               - Slot 1 MC [19:17] - Slot 2 Opcode Note: This
                               field is valid for all Errors caused by flit
                               decode errors (mscod_code 0x11, 0x13, 0x22,
                               0x23, 0x30, 0x31). For all other codes, this
                               field should be ignored.
                            */
    UINT32 SyndromeOrL0cbadlanes0 : 12;

                            /* Bits[31:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes. For both
                               conditions need to check ""Phy_state"" field to
                               translate to a physical lane. Syndrome Applies
                               for errors where crc error cause the error
                               (mscod_code 0x30, 0x31, 0x10, 0x11) L0c bad lane
                               map applies in L0c errors (mscod_code 0x23,
                               0x24). For all other codes, this field should be
                               ignored.
                            */
    UINT32 SyndromeOrL0cbadlanes1 : 4;

                            /* Bits[35:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes. For both
                               conditions need to check ""Phy_state"" field to
                               translate to a physical lane. Syndrome Applies
                               for errors where crc error cause the error
                               (mscod_code 0x30, 0x31, 0x10, 0x11) L0c bad lane
                               map applies in L0c errors (mscod_code 0x23,
                               0x24). For all other codes, this field should be
                               ignored.
                            */
    UINT32 IllegalFlitField : 1;

                            /* Bits[36:36], Access Type=RWS_V, default=0x00000000*/

                            /*
                               For Unexpected Flit Errors this bit is set if
                               unsupported error was cause by bits not captured
                               in Flit_HDR fields. In processor some of the
                               cases that cause this are: CTRL flit (RSVD Types
                               and/or Sub-types), bit set in unsupported
                               payloads (Addr[51:46], RTID[10], HTID[10]).
                               Note: we still capture Flit_HDR information even
                               if this bit is set. This field is valid for the
                               following error codes (mscod_code): 0x11, 0x13,
                               0x30, 0x31. For all other codes, this field
                               should be ignored.
                            */
    UINT32 PhyState : 3;

                            /* Bits[39:37], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Link State from Physical Layer on error used for
                               isolating lane in CRC error cases: 0x0 - 20 lane
                               flit mux phase 0 0x1 - 20 lane flit mux phase 1
                               0x2 - 20 lane flit mux phase 2 0x3 - 20 lane
                               flit mux phase 3 0x4 - 20 lane flit mux phase 4
                               0x5 - Lower 8 logical lanes active in L0
                               (failover) 0x6 - Upper 8 logical lanes active in
                               L0 (failover) 0x7 - Lower 8 logical lane active
                               in L0p This field is valid for the following
                               error codes (mscod_code): 0x11, 0x13, 0x22,
                               0x23, 0x30, 0x31. For all other codes, this
                               field should be ignored. Note: This field is a
                               compressed encoding of the Intel UPI spec ERxCLM
                               (width) and ERxPhase (flit phasing info) fields:
                               - (ERxCLM=0b111 and ERxPhase=0x0-0x4) is equal
                               to PhyState=0x0-0x4 - ERxCLM=0b001 is equal to
                               PhyState 0x5(lower failover) or 0x7(L0p) -
                               ERxCLM=0b100 is equal to PhyState=0x6(upper
                               failover)
                            */
    UINT32 RxLaneReversal : 1;

                            /* Bits[40:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates if physical layer Rx is reversed. This
                               field is valid for the following error codes
                               (mscod_code): 0x11, 0x13, 0x22, 0x23, 0x30,
                               0x31. For all other codes, this field should be
                               ignored.
                            */
    UINT32 Rsvd41 : 1;

                            /* Bits[41:41], Access Type=RWS, default=0x00000000*/

                            /*
                               Unset by hardware. Placeholder bit in case h/w
                               finds reason to add a HDR_Valid
                            */
    UINT32 Nerr : 12;

                            /* Bits[53:42], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures the Next Error, which is any later
                               error which occurred after the primary error was
                               logged (in mscod_code). Only Uncorrectable
                               Errors (as listed in mscod_code) are logged in a
                               12-bit one hot encoding format. Note that in
                               cases where multiple errors (any mix of
                               correctable and uncorrectable) occur in the same
                               cycle, all uncorrectable errors that occur on
                               that cycle will be logged in this field (in a
                               multi-hot fashion). Format: {bit} - {hex
                               mscod_code} {description} [42] - 0x00 UC Phy
                               Initialization Failure (NumInit) [43] - 0x01 UC
                               Phy Detected Drift Buffer Alarm [44] - 0x02 UC
                               Phy Detected Latency Buffer Rollover [45] -
                               Reserved [46] - Reserved [47] - 0x10 UC LL Rx
                               detected CRC error: unsuccessful LLR (entered
                               Abort state) [48] - 0x11 UC LL Rx
                               Unsupported/Undefined packet [49] - 0x12 UC LL
                               or Phy Control Error [50] - 0x13 UC LL Rx
                               Parameter Exception [51] - Reserved [52] -
                               Reserved [53] - 0x1F UC LL Detected Control
                               Error from M3UPI
                            */
    UINT32 CorErr : 10;

                            /* Bits[63:54], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Correctable Errors, indicating all
                               correctable error cases that have occurred since
                               last cleared. Only Correctable Errors (as listed
                               in mscod_code) are logged in a 10-bit multi hot
                               encoding format: Format: {bit} - {hex
                               mscod_code} {description} [54] - 0x20 COR Phy
                               Initialization Abort [55] - 0x21 COR Phy Reset
                               [56] - 0x22 COR Phy Lane failure, recovery in x8
                               width [57] - 0x23 COR Phy L0c error corrected
                               without Phy reset [58] - 0x24 COR Phy L0c error
                               triggering Phy Reset [59] - 0x25 COR Phy L0p
                               exit error triggering Phy Reset [60] - Reserved
                               [61] - 0x30 COR LL Rx detected CRC error:
                               successful LLR without Phy Reinit [62] - 0x31
                               COR LL Rx detected CRC error: successful LLR
                               with Phy Reinit [63] - Reserved
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_KTI0_MC_MISC_REGISTER;

/**
  The MCi_CTL MSR controls the signaling of machine check exceptions generated by
  the bank.
  Each of the defined bits in the register represents an error type. Each of the defined bits is
  referred to as a flag. Setting a flag enables signaling of a machine check exception
  upon the occurrence of the associated error. When the flag is cleared, the error will still
  be logged but a machine check exception will not be signaled. Other than logging the
  error, the rest of the logic will proceed as if the error had never occurred.
  This is a 64 bit register. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_CTL
  creg_msr_mask: 64'h0000000000000000
  Note: A mirror failover event is defined as the mirror scrub check read returned an error
  (even after applying ECC correction) when reading the data after the good data was rewritten
  to the previously bad channel.
  A permanent failover is when either hardware observes a failover event and takes out
  the bad channel completely, or when BIOS decides (e.g. based on count of mirror scrub check
  reads being unsuccesful, or too many transient link errors in a short time frame) to completely
  take out the bad channel.
  Note that these are also correctable errors (even though they might not have been ECC corrected
  when mirroring) since the correct data is still delivered to the requester.
  M2M logs failover events (every mirror scrub check read which still had error) in the MC5_MISC register
  and counts the number of times this kind error occurs (when CfgMcaCountOnFailover is set).
  When an OS programmed correctable error threshold of this primary channel scrubbed is equal to the
  correctable error count, an interrupt may occur.
**/
#define SKX_MSR_MCI_CTL 0x0000041C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memrderr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable memory reads error signaling. A read in
                               this context is one of {MemSpecRd, MemRd,
                               MemRdData, MemRdXtoI/S/A}. Reset default:
                               0=Disable memory reads error signaling.
                            */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Memptlwrerr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enable partial writes memory error signaling. A
                               partial write in this context means one of
                               {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The error
                               would be caused by the underfill read which
                               reads the memory background data. Reset default:
                               0=Disable partial writes memory error signaling.
                            */
    UINT32 Memfullwrerr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable full writes memory error signaling. A
                               full write in this context means one of
                               {MemWr_I/S/A, MemWrNI_I/S/A, MemWrFlush}. The
                               error would be caused by a link error (DDR
                               Command/Address error or WrCRC error). In SKX,
                               this bit is irrelevant as all full writes are
                               posted to the memory controller channel. The
                               Machine Check Bank in the memory channel
                               controller itself will get set instead for a
                               full write error. Reset default: 0=Disable full
                               writes memory error signaling.
                            */
    UINT32 Bgferren : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Enable error signaling associated with clock-
                               domain-crossing buffers (BGFs). Reset default:
                               0=Disable BGF error signaling.
                            */
    UINT32 Timeouterren : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable time-out errors signaling. Reset default:
                               0=Disable time-out error signaling.
                            */
    UINT32 Parityerren : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable parity error signaling. Reset default:
                               0=Disable parity error signaling.
                            */
    UINT32 Bucket1erren : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bucket1 error signaling. Reset default:
                               0=Disable bucket1 error signaling.
                            */
    UINT32 Memmiscerrs : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bitfield is unused. Reset default:
                               0=Disable error signaling.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCI_CTL_REGISTER;

/**
  The MCi MSR is a 64 bit register and contains information related to a machine check error if its
  VAL (valid) flag is set. Software is responsible for clearing the MC5_STATUS register by writing it with all
  0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the
  combination of WRMSR microcode and the CregPLA features. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_STATUS
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define SKX_MSR_MCI_STATUS 0x0000041D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0000 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:7] = 0000 0010 0: Near-Memory Cache
                               controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory simultaneously encounter an error of the
                               same severity for a transaction then the channel
                               number logged here is the 1st level channel.
                            */
    UINT32 Mscoddatarderr : 1;

                            /* Bits[16:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for read error (MscodDataRdErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC read
                               data error logged; 1: Error logged is an MC read
                               data error. In this implementation, 'Read'
                               refers to one of {MemSpecRd, MemRd, MemRdData,
                               MemRdXtoI/S/A, MemInv*}.
                            */
    UINT32 Rsvd17 : 1;

                            /* Bits[17:17], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Mscodptlwrerr : 1;

                            /* Bits[18:18], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for partial write error
                               (MscodPtlWrErr): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected. 0:
                               No MC partial write data error logged; 1: Error
                               logged is an MC partial write data error. In
                               this implementation, 'partial write' refers to
                               one of {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The
                               error is detected on the read data of the
                               partial write command.
                            */
    UINT32 Mscodfullwrerr : 1;

                            /* Bits[19:19], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for full write error (MscodFullWrErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC full
                               write data error logged; 1: Error logged is a
                               full write data error. Here, the term 'full
                               write' refers to one of {MemWr_I/S/A,
                               MemWrNI_I/S/A, MemWrFlush}. In case of
                               MemWrFlush, the ADDRV bit will not get set
                               because there is no relevant physical memory
                               address associated with this command. In SKX,
                               this bit will only be set for MemWrNI, if the
                               error is on underfill read performed to check
                               for a hit or miss. Any 'full write' errors would
                               get logged in the memory channel controller
                               Machine Check banks instead of here.
                            */
    UINT32 Mscodbgferr : 1;

                            /* Bits[20:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for clock domains crossing error
                               (MscodBgfErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: No MC
                               cross-clock-domains buffer error logged; 1:
                               Logged an M2M clock-domain-crossing buffer (BGF)
                               error. This is a fatal error type.
                            */
    UINT32 Mscodtimeout : 1;

                            /* Bits[21:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for time out (MscodTimeout): Specifies
                               a model specific error code that uniquely
                               identifies the machine check error condition
                               that has been detected. 0: No M2M time-out
                               logged; 1: Error logged is an M2M time out. This
                               is a fatal error type.
                            */
    UINT32 Mscodparerr : 1;

                            /* Bits[22:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for M2M tracker parity error
                               (MscodParErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: An
                               M2M tracker parity error logged; 1: Error logged
                               is an M2M tracker parity error. This is a fatal
                               error type.
                            */
    UINT32 Mscodbucket1err : 1;

                            /* Bits[23:23], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Bucket1 errors (MscodBucket1Err):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No Bucket1
                               error logged; 1: Error logged is a Bucket1
                               error. This is a fatal error type. Bucket1
                               contains credit and buffer underflows and
                               overflows.
                            */
    UINT32 Mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 Mscodmiscerrs : 6;

                            /* Bits[31:26], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Miscellaneous errors
                               (MscodMiscErrs): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected.
                               For each bit in this bitvector: 0: No Misc error
                               logged; 1: Error logged is a Misc error. This
                               bitfield is unused in SKX.
                            */
    UINT32 Otherinfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this particular implementation,
                               no information is revealed in this field.
                            */
    UINT32 Corrcount : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events (except when
                               CfgMcaCountOnFailover=1), nor recoverable events
                               are counted. This count value will continue
                               being incremented until cleared by software. The
                               most significant bit, 52, is a sticky count
                               overflow bit.
                            */
    UINT32 Corrstatus : 2;

                            /* Bits[54:53], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCI_STATUS_REGISTER;

/**
  The MCi_ADDR MSR is a 64 bit register and contains the address of the memory location that
  produced the machine check error if the ADDRV flag in the MCi_STATUS register is set.
  If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be zero and,
  the MCi_ADDR value will be meaningless. The address returned is a full physical address. The upper address bits
  of this register (beyond the address size supported) are reserved for future address expansion and should
  always be set to zero by the HW. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_ADDR
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define SKX_MSR_MCI_ADDR 0x0000041E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvdlo0 : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */
    UINT32 Lophyaddr : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of a cache line.
                            */
    UINT32 Hiphyaddr : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 14 bits of physical
                               address [45:32] of the cache line.
                            */
    UINT32 Rsvdhi46 : 18;

                            /* Bits[63:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCI_ADDR_REGISTER;

/**
  This register is used for storing MCA miscellaneous information. Some of the errors are architectural errors,
  other errors are not.
  This is a 64 bits register. Refer to the MCA HAS for details.
  What we want to call out here specifically are the semantics of the ErrorType transient bit as well as the ErrorType ECC corrected bit:
  Interpretation of the 'transient' bit: transient from an MC perspective, in that a retry (might be without even applying MC ECC) resulted in good data.
  DDR4: It implies a transient error e.g. most likely a link transient error.
  DDRT: It might imply that the DDRT controller on the DDRT dimm fixed the data by ECC so in that case the DDRT controller itself might hold more accurate error information w.r.t. the DDRT storage devices.
  Interpretation of the 'ECC corrected' bit: ECC in the MC was applied to correct the data.
  DDR4: Implies a persistent (stored or simple link) error because a retry without ECC didn't correct the error and ECC was needed to get correct the data.
  DDRT: Implies a (persistent and simple) link error because a simple retry to the DDRT controller did not correct the data (Note, the DDRT controller on the DDRT dimm would apply ECC internally, invisible to the MC).
  x86_architectural: true
  creg_msr_symbol: MCi_MISC
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define SKX_MSR_MCI_MISC 0x0000041F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addrlsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 Addrmode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 Rsvd9 : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Errortype : 10;

                            /* Bits[20:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:8]: reserved. bit7: NM$ data-only-ECC-
                               uncorrectable: Might (or not) have corrected
                               this by data supplied from FM. PCC/UC tells what
                               end-result is, whether corrected from FM or not.
                               bit6: NM$ ECC-uncorrectable fatal: persistently
                               uncorrectable meta-data or data (latter case:
                               uncorr even after reloading from FM). No good
                               data was recovered. This is a fatal condition
                               (not recoverable). bit5: Txn caused permanent
                               hardware channel failover during mirroring.
                               bit4: Scrub check rd returned uncorrected data
                               (ECC correction is enabled during scrub check
                               rd); bit3: Scrub check rd returned good data
                               (note that ECC correction is enabled during
                               scrub check rd); bit2: Txn could not be
                               corrected by ECC; bit1: Txn had an ECC corrected
                               error (corrected by ECC during retry); bit0: Txn
                               had a transient error (corrected by retry
                               without ECC). It is possible for multiple bits
                               to be set in this bitvector. For 2LM, the case
                               of bit2 set and yet corrected error is signalled
                               (PCC=0, UC=0) represents a NMcache location that
                               could not be corrected, yet the FM stored data
                               saved the day.
                            */
    UINT32 Trkid : 9;

                            /* Bits[29:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = htid within that channel.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Smiopcode0 : 1;

                            /* Bits[31:31], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smiopcode1 : 3;

                            /* Bits[34:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smimsgclass : 3;

                            /* Bits[37:35], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Message Class (SmiMsgClass): The logged
                               transaction's message class. The expectation is
                               to only see following values: 0: Request message
                               class. 5: Write-back message class.
                            */
    UINT32 Smiad : 1;

                            /* Bits[38:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI AD message (SmiAD): The logged transaction
                               came in on AD. 0: txn from BL. 1: txn from AD.
                            */
    UINT32 Mccmdvld : 1;

                            /* Bits[39:39], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so don't interpret McCmd fields.
                               1: McCmd logged; can interpret McCmd fields.
                            */
    UINT32 Mccmdopcode : 6;

                            /* Bits[45:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL. See MC_REQ_TYPE_ in mc.vh file.
                            */
    UINT32 Mccmdmemregion : 4;

                            /* Bits[49:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. {cacheable, persistent}
                               encoding: 0 = 1LM DDR4 access, 1 = DDRT access,
                               2 = DDR4 NM cache access (non-Pmem), 3 = DDR4 NM
                               cache access for Pmem.
                            */
    UINT32 Mccmdchnl : 2;

                            /* Bits[51:50], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 Rsvd52 : 5;

                            /* Bits[56:52], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Mccmdmirrregion : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 Mccmdmirrsec : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 Mccmdmirrfo : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 Dataerrorchunk : 2;

                            /* Bits[61:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               These bits are not used in SKX. Chunk containing
                               Data Error (DataErrorChunk): Cache line half on
                               which the data error occured: 00: no data error.
                               01: a data error signal came on 1st half of
                               cache line (critical chunk). 10: a data error
                               signal came on 2nd half of cache line (non-
                               critical chunk). 11: a data error signal
                               asserted both on 1st and 2nd half of cache line.
                            */
    UINT32 Mirrorcorrerr : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel.
                            */
    UINT32 Mirrorfailover : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies a non-
                               ECC-correctable error, and not correctable by
                               mirror scrub on a channel. In this context
                               mirror failover is defined as the scrub check
                               read (after scrub wr) still had a non-ECC-
                               correctable error. In case of HW permanent
                               failover, as soon as one such failover event
                               happens, permanent failover i.e. taking out a
                               complete (failed) channel takes place.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCI_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank. Each of the defined bits in the register represents an error type. (Implementation note: Although sometimes it may be necessary to role some error types together under one flag, it is highly preferable to have fine grained control for each error type so that it would be easier to write a ucode patch to turn off an error type if there is a logic bug associated with it in production.) Each of the defined bits is referred to as a flag. Setting a flag enables signaling of a machine check exception upon the occurrence of the associated error. When the flag is cleared, the error will still be logged but a machine check exception will not be signaled. Other than logging the error, the rest of the logic will proceed as if the error had never occurred.
**/
#define SKX_MSR_IMC0_MC_CTL 0x00000434

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors Here is the explanation of how the error
                               handling work at the HA:MC interface: MC has two
                               datapaths that can handle read data from the
                               DIMMs. The normal path also called fast path is
                               the default mode of operation. Fast path is
                               capable of detecting an error using CRC and
                               parity but can not determine if the error is
                               correctable or uncorrectable. The other path is
                               called correction or slow path. In the slow
                               path, MC can determine if the incoming data is
                               correctable or uncorrectable and is able to
                               correct the correctable data. When fast path
                               detects an error, it asserts the MCRdError
                               signal to HA along with the read data. HA then
                               in effect empties the memory controller read and
                               write queues. It does this by making sure it got
                               back all read and write credits back from MC. At
                               this point, HA issues a retry read to memory
                               controller. This is just like normal read but
                               with a sideband retry bit set. When the read
                               data for the retry read comes back from the
                               DIMMs to MC, it takes the slow path (mux is
                               selected by the retry indication). In the slow
                               path, each codeword goes through a series of 17
                               substitutions (each substitution takes one
                               Dclk). At the end of the substitution pipe, MC
                               is able to detect correctable errors and the
                               failing device. After going through the
                               substitutions on both codewords, slow path will
                               use the regular read data path indication to
                               indicate HA the read data valid and error (if
                               uncorrectable). In almost all cases (except for
                               mirroring when the the primary channel only gets
                               retried once), HA will issue a second retry to
                               MC. MC handling of the first and second retries
                               is identical. In the following table, we call
                               the first HA retry as retry1 and second HA retry
                               as retry2. // New additions in JKT B0: // Three
                               primary modes of logging HA read errors in
                               Memory Controller HA MC (Mode 0) MC (Mode 1) MC
                               (Mode 2) Retry1 Retry2 NoErr X COR No Log COR
                               COR Err NoErr COR No Log COR COR Err Err UNCORR
                               No Log No Log COR Mode-0 is legacy behavior.
                               Mode-1 makes MC only log correctable read
                               errors. Mode-2 makes MC log uncorrectable read
                               errors as correctable errors with a sideband bit
                               set that tells whether the failing device logged
                               is valid or not.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC0_MC_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set. Software is responsible for clearing the MCiSTATUS register by writing it with all 0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the combination of WRMSR microcode and the CregPLA features.
**/
#define SKX_MSR_IMC0_MC_STATUS 0x00000435

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bit[15:0] = 0000 0100 0000 0101:
                               Parity error on structures bit[15:7] = 0000 0000
                               1: Memory Controller Errors in 1LM mode and the
                               bit[6:4] and bit[3:0] further sub-classify the
                               errors bit[15:7] = 0000 0010 1: Memory
                               Controller Errors in 2LM mode and the bit[6:4]
                               and bit[3:0] further sub-classify the errors
                               bit[6:4] = 000: Generic undefined request
                               bit[6:4] = 001: Memory Read Error bit[6:4] =
                               010: Memory Write Error bit[6:4] = 011:
                               Address/Command Error bit[6:4] = 100: Memory
                               Scrubbing Error bit[6:4] = 101-111: reserved
                               bit[3:0] = 0000-0010: Channel Number.
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected: // 16'h0002 -
                               M2M Wr data parity Error // 16'h0004 - M2M Wr BE
                               parity Error // 16'h0008 - Corr Patrol Scrub
                               Error // 16'h0010 - UnCorr Patrol Scrub Error //
                               16'h0020 - Corr Spare Error // 16'h0040 - UnCorr
                               Spare Error // 16'h0080 - Any Ha Rd Error //
                               16'h0100 - WDB Read Parity Error // 16'h0102 -
                               DDRT WDB Read Parity Error // 16'h0103 - RPQ0
                               Read Parity Error // 16'h0104 - RPQ1 Read Parity
                               Error // 16'h0105 - WPQ Read Parity Error //
                               16'h0106 - DDRT M2M Wr data parity Error //
                               16'h0107 - DDRT M2M Wr BE parity Error //
                               16'h0108 - Link fail // 16'h0200 - DDR4 CAParity
                               or WrCRC error // 16'h0400 - UnCorr APPP Error
                               // 16'h0800 - 2LM unrecognized request type //
                               16'h0801 - 2LM read response to an invalid
                               scoreboard entry // 16'h0802 - 2LM unexpected
                               read response // 16'h0803 - 2LM DDR4 completion
                               to an invalid scoreboard entry // 16'h0804 - 2LM
                               DDRt completion to an invalid scoreboard entry
                               // 16'h0805 - 2LM completion FIFO overflow //
                               16'h0806 - DDRT ERID correctable parity error //
                               16'h0807 - DDRT ERID Uncorrectable error. //
                               16'h0808 - DDRT interrupt received while
                               outstanding interrupt was not ACKed // 16'h0809
                               - DDRT ERID FIFO overflow // 16'h080a - DDRT
                               Error on FNV Write credits // 16'h080b - DDRT
                               Error on FNV Read credits // 16'h080c - DDRT
                               Scheduler error // 16'h080d - DDRT FNV Error
                               event // 16'h080e - DDRT FNV thermal error
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture. //HSD209224 Note:
                               other_info will show irrelavant information for
                               wdb_parity_error, Ha_to_mc_write_data_error, and
                               Ha_to_mc_write_byteenable_errors. bit[37]:
                               reserved for future use bit[36:32]: In Mode-1 or
                               Mode-2, MC logs the first error device. This is
                               an encoded 5-bit value of the device.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC0_MC_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set. If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be clear and, if this register exists, its value will be meaningless. The address returned is either a virtual, linear, physical or system address. The upper address bits of this register (beyond the address size supported) are reserved for future address expansion and should always be set to zero by the HW. The exact address range supported by SandyBridge is variable depending on market segment and processor addressing mode
**/
#define SKX_MSR_IMC0_MC_ADDR 0x00000436

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC0_MC_ADDR_REGISTER;

/**
  The MCiMISC MSR contains additional micro-architecture specific information describing the machine check error if the MISCV flag in the MCiSTATUS register is set. It is also possible to use the Other Info field in the MCiSTATUS register for the same type of model specific error reporting
**/
#define SKX_MSR_IMC0_MC_MISC 0x00000437

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RecErrLsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the LSB of the recoverable address
                               (this may differ from unit to unit). This tells
                               the OS to ignore bits from LSB-1:0
                            */
    UINT32 AddrMode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               defines the type of address captured in the
                               MC5ADDR MSR. Set by hardware, Clear by
                               programming. 000: Segment Offset 001: Linear
                               Address 010: Physical (system) Address 011:
                               Memory Address 111: Generic
                            */
    UINT32 ExtraErrInfo0 : 23;

                            /* Bits[31:9], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Bits[13:9]: If the error logged is WDB Read
                               Parity Error, this field is the WDB ID that has
                               the parity error. OR if the second error logged
                               is a correctable read error, In Mode-1 or
                               Mode-2, MC logs the second error device in this
                               field. //HSD209224 WDB ID is 6 bits wide and
                               bit[5] is logged in extra_err_info[46].
                               Bits[29:14]: In Mode-1 or Mode-2, MC logs the
                               first error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask Bits[45:30]:
                               In Mode-1 or Mode-2, MC logs the second error
                               bit mask here. This is the per bit error
                               indication in the failing device. Any bit set to
                               1 indicates that the data bit corresponding to
                               this location had to be flipped to correct the
                               device. In lockstep mode, each transfer is
                               4-bits from the device and the first transfer is
                               at the LSB of this mask Bits[50:46]: In Mode-1
                               or Mode-2, MC logs the first error failing rank
                               //HSD209224 bit[46] will show WDB ID bit 5 for
                               WDB Read Parity Error. Bits[55:51]: In Mode-1 or
                               Mode-2, MC logs the second error failing rank
                               Bits[58:56]: In Mode-1 or Mode-2, MC logs the
                               first error failing dimm slot Bits[61:59]: In
                               Mode-1 or Mode-2, MC logs the second error
                               failing dimm slot Bits[62]: In Mode-2, MC logs a
                               valid bit that tells if the information in first
                               correctable error device and the first bit-error
                               mask is useable. Only use the information if the
                               first error logged is correctable read error.
                               Bits[63]: In Mode-2, MC logs a valid bit that
                               tells if the information in second correctable
                               error device and the second bit-error mask is
                               useable. Only use the information if the first
                               error logged is correctable read error.
                            */
    UINT32 ExtraErrInfo1 : 32;

                            /* Bits[63:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Bits[13:9]: If the error logged is WDB Read
                               Parity Error, this field is the WDB ID that has
                               the parity error. OR if the second error logged
                               is a correctable read error, In Mode-1 or
                               Mode-2, MC logs the second error device in this
                               field. //HSD209224 WDB ID is 6 bits wide and
                               bit[5] is logged in extra_err_info[46].
                               Bits[29:14]: In Mode-1 or Mode-2, MC logs the
                               first error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask Bits[45:30]:
                               In Mode-1 or Mode-2, MC logs the second error
                               bit mask here. This is the per bit error
                               indication in the failing device. Any bit set to
                               1 indicates that the data bit corresponding to
                               this location had to be flipped to correct the
                               device. In lockstep mode, each transfer is
                               4-bits from the device and the first transfer is
                               at the LSB of this mask Bits[50:46]: In Mode-1
                               or Mode-2, MC logs the first error failing rank
                               //HSD209224 bit[46] will show WDB ID bit 5 for
                               WDB Read Parity Error. Bits[55:51]: In Mode-1 or
                               Mode-2, MC logs the second error failing rank
                               Bits[58:56]: In Mode-1 or Mode-2, MC logs the
                               first error failing dimm slot Bits[61:59]: In
                               Mode-1 or Mode-2, MC logs the second error
                               failing dimm slot Bits[62]: In Mode-2, MC logs a
                               valid bit that tells if the information in first
                               correctable error device and the first bit-error
                               mask is useable. Only use the information if the
                               first error logged is correctable read error.
                               Bits[63]: In Mode-2, MC logs a valid bit that
                               tells if the information in second correctable
                               error device and the second bit-error mask is
                               useable. Only use the information if the first
                               error logged is correctable read error.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC0_MC_MISC_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set. If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be clear and, if this register exists, its value will be meaningless. The address returned is either a virtual, linear, physical or system address. The upper address bits of this register (beyond the address size supported) are reserved for future address expansion and should always be set to zero by the HW. The exact address range supported by SandyBridge is variable depending on market segment and processor addressing mode
**/
#define SKX_MSR_IMC1_MC_ADDR 0x0000043A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC1_MC_ADDR_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set. If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be clear and, if this register exists, its value will be meaningless. The address returned is either a virtual, linear, physical or system address. The upper address bits of this register (beyond the address size supported) are reserved for future address expansion and should always be set to zero by the HW. The exact address range supported by SandyBridge is variable depending on market segment and processor addressing mode
**/
#define SKX_MSR_IMC2_MC_ADDR 0x00000446

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMC2_MC_ADDR_REGISTER;

/**
  LMCE (Local Machine Check) architecture control
**/
#define SKX_MSR_MCG_EXE_CTL 0x000004D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LmceOptIn : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* enable bit per thread */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MCG_EXE_CTL_REGISTER;

/**

**/
#define SKX_MSR_IA32_SE_SVN 0x00000500

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved1 : 15;

                            /* Bits[15:1], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 SinitSeSvn : 8;

                            /* Bits[23:16], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved24 : 8;

                            /* Bits[31:24], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RO_V, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IA32_SE_SVN_REGISTER;
/**
  Scratch Pad register PROBE_MODE_4
  C6NoSave Candidate
**/
#define SKX_MSR_PROBE_MODE_4 0x00000504

/**
  Extended Page Table Pointer
**/
#define SKX_MSR_EPTP 0x00000510

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* EPT Memory Type */
    UINT32 Rsvd3 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 EptADEnable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* EPT A/D enable */
    UINT32 EptMbeEnable : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit for EPT Mode Based Execution
                               (required also paging is ON in guest)
                            */
    UINT32 Rsvd8 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 Address0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page-Map Level-4 Address */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* Page-Map Level-4 Address */
    UINT32 Rsvd46 : 17;

                            /* Bits[62:46], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 Enable : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /* EPT enable bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EPTP_REGISTER;

/**
  Programmed in Probe mode, used in PDM.
  Need to save in C6
**/
#define SKX_MSR_PDM_LBR 0x00000511

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 HwInt : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* HW Interrupt trace enable */
    UINT32 Iret : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* IRET trace enable */
    UINT32 Exception : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Exception trace enable */
    UINT32 Msr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* MSR trace enable */
    UINT32 PowerEvent : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Io : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* IO trace enable */
    UINT32 Se : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Secure Enclaves entry and exit trace enable */
    UINT32 Wbinvd : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* WBINVD trace enable */
    UINT32 Rsvd8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 CodeBreakpoint : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Code breakpoint trace enable */
    UINT32 DataBreakpoint : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Data breakpoint trace enable */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Btm : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* BTM trace enable */
    UINT32 Smi : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* SMI trace enable */
    UINT32 Mwait : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Monitor/Mwait trace enable */
    UINT32 Rsvd15 : 13;

                            /* Bits[27:15], Access Type=RW, default=None*/

                            /* HW Interrupt trace enable */
    UINT32 LipDisable : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* disable LIP for the pdm packet. */
    UINT32 RicDisable : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* disnable RIC for the pdm packet. */
    UINT32 Gdxc : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* GDXC output enable */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDM_LBR_REGISTER;

/**
  PDM Control Register
**/
#define SKX_MSR_PDM_CTRL 0x00000512

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 HwInt : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* HW Interrupt trace enable */
    UINT32 Iret : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* IRET trace enable */
    UINT32 Exception : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Exception trace enable */
    UINT32 Msr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* MSR trace enable */
    UINT32 PowerEvent : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Io : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* IO trace enable */
    UINT32 Se : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Secure Enclaves entry and exit trace enable */
    UINT32 Wbinvd : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* WBINVD trace enable */
    UINT32 Rsvd8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 CodeBreakpoint : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Code breakpoint trace enable */
    UINT32 DataBreakpoint : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Data breakpoint trace enable */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Btm : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* BTM trace enable */
    UINT32 Smi : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* SMI trace enable */
    UINT32 Mwait : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Monitor/Mwait trace enable */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RW, default=None*/

                            /* HW Interrupt trace enable */
    UINT32 Npk : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* NPK output enable */
    UINT32 PdmMasterEnable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Mater enable for PDM. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDM_CTRL_REGISTER;
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_1 0x00000514
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_2 0x00000515
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_3 0x00000516
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_4 0x00000517
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_5 0x00000518
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_6 0x00000519
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_7 0x0000051A
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_8 0x0000051B
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_9 0x0000051C
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_10 0x0000051D
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_11 0x0000051E
/**
  This define is used to reserve some MSR addresses for probe mode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_PROBE_MODE_RESERVED_12 0x0000051F

/**
  Limitation on the maximum current consumption of the primary power plane.
**/
#define SKX_MSR_VR_CURRENT_CONFIG 0x00000601

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CurrentLimit : 13;

                            /* Bits[12:0], Access Type=RW_L, default=0x00000500*/

                            /*
                               Current limitation in 0.125 A increments. This
                               field is locked by VR_CURRENT_CONFIG[LOCK]. When
                               the LOCK bit is set to 1b, this field becomes
                               Read Only.
                            */
    UINT32 Rsvd13 : 18;

                            /* Bits[30:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[31:31], Access Type=RWS_KL, default=0x00000000*/

                            /*
                               This bit will lock the CURRENT_LIMIT settings in
                               this register and will also lock this setting.
                               This means that once set to 1b, the
                               CURRENT_LIMIT setting and this bit become Read
                               Only until the next Cold Reset.
                            */
    UINT32 Psi1Threshold : 10;

                            /* Bits[41:32], Access Type=RW, default=0x00000000*/

                            /*
                               Maximum current in 1A units supported at
                               external voltage regulator PS1
                            */
    UINT32 Psi2Threshold : 10;

                            /* Bits[51:42], Access Type=RW, default=0x00000000*/

                            /*
                               Maximum current in 1A units supported at
                               external voltage regulator PS2
                            */
    UINT32 Psi3Threshold : 10;

                            /* Bits[61:52], Access Type=RW, default=0x00000000*/

                            /*
                               Maximum current in 1A units supported at
                               external voltage regulator PS3
                            */
    UINT32 Reserved62 : 2;

                            /* Bits[63:62], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_VR_CURRENT_CONFIG_REGISTER;

/**
  Input voltage regulator configuration parameters.
**/
#define SKX_MSR_VR_MISC_CONFIG 0x00000603

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DynamicLoadLineR : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000036*/

                            /*
                               The Dynamic load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 IdleLoadLineR : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000036*/

                            /*
                               The Idle load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 LeakLoadLineR : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000036*/

                            /*
                               The Leakage load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 MinVid : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Used to constrain the CPU's minimum voltage
                               during package C-states. The default setting of
                               0x00 will result in full CPU control over the
                               minimum VID. VID resolution is 10mV / LSB.
                            */
    UINT32 IoutOffset : 8;

                            /* Bits[39:32], Access Type=RW, default=0x00000000*/

                            /*
                               Signed offset added to VR dIout readings for
                               correction. 2s-complement signed number
                               expressed as a fraction of the IccMax of the VR.
                               Format: S8.-4.11 (8bits, floating point shifted
                               by 4 points). Precision: 0.049% (1/2^11) Range:
                               +/-6.25% of IccMax of the VR. Allowable range
                               may be clipped by processor on a per-SKU basis.
                            */
    UINT32 IoutSlope : 10;

                            /* Bits[49:40], Access Type=RW, default=0x00000200*/

                            /*
                               This is a slope correction for VR dIout readings
                               for postitive/negative correction. This scalar
                               is applied to every dIout reading before it is
                               consumed by the CPU. This scalar represents a
                               1.x number in U10.1.9 format (0.0 to 2.0 scalar
                               in ~0.19% increments)
                            */
    UINT32 IdleExitRampRate : 1;

                            /* Bits[50:50], Access Type=RW, default=0x00000001*/

                            /*
                               Controls the VR ramp rate on package C-state
                               wake events. 1 == fast, 0 == slow.
                            */
    UINT32 IdleEntryRampRate : 1;

                            /* Bits[51:51], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the VR ramp rate on package C-state
                               entry events. 1 == fast, 0 == slow. If Decay is
                               set, it has priority.
                            */
    UINT32 IdleEntryDecayEnable : 1;

                            /* Bits[52:52], Access Type=RW, default=0x00000001*/

                            /*
                               Enables decay mode on package C-state entry.
                               Decay mode implies PS2 or deeper. When Decay is
                               enabled, it has priority over the
                               IDLE_ENTRY_RAMP_RATE.
                            */
    UINT32 Rsvd53 : 11;

                            /* Bits[63:53], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_VR_MISC_CONFIG_REGISTER;
/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define SKX_MSR_PKG_C2_RESIDENCY_COUNTER 0x0000060D

/**
  This register allows platform BIOS to limit the power consumption of the processor to the specified values.
**/
#define SKX_MSR_TURBO_POWER_LIMIT 0x00000610

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PkgPwrLim1 : 15;

                            /* Bits[14:0], Access Type=RW_L, default=0x00000118*/

                            /* This field indicates the power limitation #1. */
    UINT32 PkgPwrLim1En : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000001*/

                            /* Package Power Limit 1 is always enabled */
    UINT32 PkgClmpLim1 : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000000*/

                            /*
                               Package Clamping limitation #1 - Allow going
                               below P1. 0b PBM is limited between P1 and P0.
                               1b PBM can go below P1.
                            */
    UINT32 PkgPwrLim1Time : 7;

                            /* Bits[23:17], Access Type=RW_L, default=0x0000000A*/

                            /*
                               x = PKG_PWR_LIM_1_TIME[23:22] y =
                               PKG_PWR_LIM_1_TIME[21:17] The timing interval
                               window is Floating Point number given by 1.x *
                               power(2,y). The unit of measurement is defined
                               in PACKAGE_POWER_SKU_UNIT_MSR[TIME_UNIT]. The
                               maximal time window is bounded by
                               PACKAGE_POWER_SKU_MSR[PKG_MAX_WIN]. The minimum
                               time window is 1 unit of measurement (as defined
                               above).
                            */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgPwrLim2 : 15;

                            /* Bits[46:32], Access Type=RW_L, default=0x00000000*/

                            /*
                               This field indicates the power limitation #2.
                               The unit of measurement is defined in
                               PACKAGE_POWER_SKU_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 PkgPwrLim2En : 1;

                            /* Bits[47:47], Access Type=RW_L, default=0x00000000*/

                            /*
                               This bit enables/disables PKG_PWR_LIM_2. 0b
                               Package Power Limit 2 is Disabled 1b Package
                               Power Limit 2 is Enabled
                            */
    UINT32 PkgClmpLim2 : 1;

                            /* Bits[48:48], Access Type=RW_L, default=0x00000000*/

                            /*
                               Package Clamping limitation #2 - Allow going
                               below P1. 0b PBM is limited between P1 and P0.
                               1b PBM can go below P1.
                            */
    UINT32 PkgPwrLim2Time : 7;

                            /* Bits[55:49], Access Type=RW_L, default=0x00000000*/

                            /*
                               x = PKG_PWR_LIM_2_TIME[55:54] y =
                               PKG_PWR_LIM_2_TIME[53:49] The timing interval
                               window is Floating Point number given by 1.x *
                               power(2,y). The unit of measurement is defined
                               in PACKAGE_POWER_SKU_UNIT_MSR[TIME_UNIT]. The
                               maximal time window is bounded by
                               PACKAGE_POWER_SKU_MSR[PKG_MAX_WIN]. The minimum
                               time window is 1 unit of measurement (as defined
                               above).
                            */
    UINT32 Rsvd56 : 7;

                            /* Bits[62:56], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgPwrLimLock : 1;

                            /* Bits[63:63], Access Type=RW_KL, default=0x00000000*/

                            /*
                               When set, all settings in this register are
                               locked and are treated as Read Only. This bit
                               will typically set by BIOS during boot time or
                               resume from Sx.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TURBO_POWER_LIMIT_REGISTER;

/**
  Package Energy Status
**/
#define SKX_MSR_PKG_ENERGY_STATUS 0x00000612

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnergyStatus : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /*  */
    UINT32 Timestamp : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PKG_ENERGY_STATUS_REGISTER;
/**
  Read/write data from/to pcode through internal mailbox
**/
#define SKX_MSR_PL3_CONTROL 0x00000615

/**
  This register is used by BIOS/OS/Integrated Graphics
  Driver/CPM Driver to limit the power budget of DRAM Plane.
  The overall package turbo power limitation is controlled by
  DRAM_PLANE_POWER_LIMIT.
  This register is mapped as an MSR
**/
#define SKX_MSR_DRAM_POWER_LIMIT 0x00000618

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DramPpPwrLim : 15;

                            /* Bits[14:0], Access Type=RW_L, default=0x00000000*/

                            /*
                               This is the power limitation on the IA cores
                               power plane. The unit of measurement is defined
                               in DRAM_POWER_INFO_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 PwrLimCtrlEn : 1;

                            /* Bits[15:15], Access Type=RW_L, default=0x00000000*/

                            /*
                               This bit must be set in order to limit the power
                               of the DRAM power plane. 0b DRAM power plane
                               power limitation is disabled 1b DRAM power plane
                               power limitation is enabled
                            */
    UINT32 Reserved16 : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /* Reserved */
    UINT32 CtrlTimeWin : 7;

                            /* Bits[23:17], Access Type=RW_L, default=0x00000000*/

                            /*
                               x = CTRL_TIME_WIN[23:22] y =
                               CTRL_TIME_WIN[21:17] The timing interval window
                               is Floating Point number given by 1.x *
                               power(2,y). The unit of measurement is defined
                               in PACKAGE_POWER_SKU_UNIT_MSR[TIME_UNIT]. The
                               maximal time window is bounded by
                               PACKAGE_POWER_SKU_MSR[PKG_MAX_WIN]. The minimum
                               time window is 1 unit of measurement (as defined
                               above).
                            */
    UINT32 Rsvd24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PpPwrLimLock : 1;

                            /* Bits[31:31], Access Type=RW_KL, default=0x00000000*/

                            /*
                               When set, all settings in this register are
                               locked and are treated as Read Only.
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_DRAM_POWER_LIMIT_REGISTER;
/**
  DRAM energy consumed by all the DIMMS in all the Channels.  The counter will wrap around and continue counting when it reaches its limit.
  ENERGY_UNIT for DRAM domain is 15.3uJ.
  The data is updated by PCODE and is Read Only for all SW.
**/
#define SKX_MSR_DRAM_ENERGY_STATUS 0x00000619
/**
  This register is used by Pcode to report DRAM Plane Power limit violations in the Platform PBM.
  Provides information on the performance impact of the RAPL power limit.
  Provides the total time for which DRAM was throttled because of the RAPL power limit. Total time = Reg Value *1 s * 1/ (2^time_unit)
  Usage model: Enables the OS/Driver to learn about DRAM throttling as a result of RAPL limit.
  Can be used by other S/W components that control the DRAM power.
  This register is mapped as an MSR with the name DRAM_RAPL_PERF_STATUS.
**/
#define SKX_MSR_DRAM_RAPL_PERF_STATUS 0x0000061B

/**

**/
#define SKX_MSR_DRAM_POWER_INFO 0x0000061C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DramTdp : 15;

                            /* Bits[14:0], Access Type=RO_V, default=0x00000118*/

                            /*
                               The Spec power allowed for DRAM. The TDP setting
                               is typical (not guaranteed). The units for this
                               value are defined in
                               DRAM_POWER_INFO_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DramMinPwr : 15;

                            /* Bits[30:16], Access Type=RO_V, default=0x00000078*/

                            /*
                               The minimal power setting allowed for DRAM.
                               Lower values will be clamped to this value. The
                               minimum setting is typical (not guaranteed). The
                               units for this value are defined in
                               DRAM_POWER_INFO_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DramMaxPwr : 15;

                            /* Bits[46:32], Access Type=RO_V, default=0x00000258*/

                            /*
                               The maximal power setting allowed for DRAM.
                               Higher values will be clamped to this value. The
                               maximum setting is typical (not guaranteed). The
                               units for this value are defined in
                               DRAM_POWER_INFO_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DramMaxWin : 7;

                            /* Bits[54:48], Access Type=RO_V, default=0x00000028*/

                            /*
                               The maximal time window allowed for the DRAM.
                               Higher values will be clamped to this value. x =
                               PKG_MAX_WIN[54:53] y = PKG_MAX_WIN[52:48] The
                               timing interval window is Floating Point number
                               given by 1.x * power(2,y). The unit of
                               measurement is defined in
                               DRAM_POWER_INFO_UNIT_MSR[TIME_UNIT].
                            */
    UINT32 Rsvd55 : 8;

                            /* Bits[62:55], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[63:63], Access Type=RO_V, default=0x00000000*/

                            /* Lock bit to lock the Register */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_DRAM_POWER_INFO_REGISTER;

/**
  Time spent with LLC flushed.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define SKX_MSR_LLC_FLUSHED_RESIDENCY_COUNTER 0x0000061D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RO_V, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LLC_FLUSHED_RESIDENCY_COUNTER_REGISTER;

/**
  This register provides additional support for BCLK overclocking
**/
#define SKX_MSR_PCIE_PLL_RATIO 0x0000061E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PcieRatio : 3;

                            /* Bits[2:0], Access Type=RWS, default=0x00000000*/

                            /*
                               PCIE Ratio 000 - 100 MHz bclk (1000/10) 001 -
                               111 MHz bclk (1000/9 ) 010 - 125 MHz bclk
                               (1000/8 ) 011 - 143 MHz bclk (1000/7 ) 100 - 167
                               MHz bclk (1000/6 ) 101 - 200 MHz bclk (1000/5 )
                               110 - 250 MHz bclk (1000/4 )
                            */
    UINT32 LcSbSelect : 1;

                            /* Bits[3:3], Access Type=RWS, default=0x00000000*/

                            /*
                               LC vs. SB PLL Selection (0 = LC PLL, 1 = SB
                               PLL). Default 0x0
                            */
    UINT32 LongReset : 1;

                            /* Bits[4:4], Access Type=RWS, default=0x00000000*/

                            /*
                               If set to 1, wait additional timeout before
                               relocking Gen2/Gen3/Lclk PLLs
                            */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PCIE_PLL_RATIO_REGISTER;

/**
  Current Uncore Ratio
**/
#define SKX_MSR_UNCORE_PERF_STATUS 0x00000621

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CurrentClmRatio : 7;

                            /* Bits[6:0], Access Type=RO_V, default=0x00000000*/

                            /*  */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_PERF_STATUS_REGISTER;
/**
  Defined for ULT only. Does not exist on HSW/CRW.
  This MSR is used to read out the 24MHz alternative Time Stap Counter. Owner: Jay Schwartz
**/
#define SKX_MSR_COUNTER_24MHZ 0x00000637

/**
  Level 1 configurable TDP settings.
**/
#define SKX_MSR_CONFIG_TDP_LEVEL1 0x00000649

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PkgTdp : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power for this TDP level. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT] Similar to
                               PACKAGE_POWER_SKU[PKG_TDP]
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 TdpRatio : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* TDP ratio for config tdp level 1. */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMaxPwr : 15;

                            /* Bits[46:32], Access Type=RW, default=0x00000000*/

                            /*
                               Max pkg power setting allowed for this config
                               TDP level1. Higher values will be clamped down
                               to this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MAX_PWR].
                            */
    UINT32 PkgMinPwr : 16;

                            /* Bits[62:47], Access Type=RW, default=0x00000000*/

                            /*
                               Min pkg power setting allowed for this config
                               TDP level. Lower values will be clamped up to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MIN_PWR].
                            */
    UINT32 Rsvd63 : 1;

                            /* Bits[63:63], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CONFIG_TDP_LEVEL1_REGISTER;

/**
  Level 2 configurable TDP settings. On sku that does not support config tdp, these to registers will report out 0.
**/
#define SKX_MSR_CONFIG_TDP_LEVEL2 0x0000064A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PkgTdp : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power for this TDP level. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT] Similar to
                               PACKAGE_POWER_SKU[PKG_TDP].
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 TdpRatio : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* TDP ratio for level 2. */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMaxPwr : 15;

                            /* Bits[46:32], Access Type=RW, default=0x00000000*/

                            /*
                               Max pkg power setting allowed for config TDP
                               level 2. Higher values will be clamped down to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MAX_PWR].
                            */
    UINT32 PkgMinPwr : 16;

                            /* Bits[62:47], Access Type=RW, default=0x00000000*/

                            /*
                               Min pkg power setting allowed for this config
                               TDP level 2. Lower values will be clamped up to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MIN_PWR].
                            */
    UINT32 Rsvd63 : 1;

                            /* Bits[63:63], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CONFIG_TDP_LEVEL2_REGISTER;

/**
  LBR MSR that holds the from IP, canonical check for write, see Vol 3A
**/
#define SKX_MSR_LBR_FROM_IP_0 0x00000680

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_0_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_1 0x00000681

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_1_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_2 0x00000682

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_2_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_3 0x00000683

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_3_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_4 0x00000684

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_4_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_5 0x00000685

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_5_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_6 0x00000686

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_6_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_7 0x00000687

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_7_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_8 0x00000688

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_8_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_9 0x00000689

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_9_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_10 0x0000068A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_10_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_11 0x0000068B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_11_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_12 0x0000068C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_12_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_13 0x0000068D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_13_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_14 0x0000068E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_14_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_15 0x0000068F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_15_REGISTER;

/**
  LBR MSR that holds the from IP, canonical check for write, see Vol 3A
**/
#define SKX_MSR_LBR_FROM_IP_16 0x00000690

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_16_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_17 0x00000691

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_17_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_18 0x00000692

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_18_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_19 0x00000693

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_19_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_20 0x00000694

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_20_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_21 0x00000695

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_21_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_22 0x00000696

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_22_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_23 0x00000697

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_23_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_24 0x00000698

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_24_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_25 0x00000699

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_25_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_26 0x0000069A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_26_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_27 0x0000069B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_27_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_28 0x0000069C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_28_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_29 0x0000069D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_29_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_30 0x0000069E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_30_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_FROM_IP_31 0x0000069F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_FROM_IP_31_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_0 0x000006C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_0_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_1 0x000006C1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_1_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_2 0x000006C2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_2_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_3 0x000006C3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_3_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_4 0x000006C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_4_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_5 0x000006C5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_5_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_6 0x000006C6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_6_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_7 0x000006C7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_7_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_8 0x000006C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_8_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_9 0x000006C9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_9_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_10 0x000006CA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_10_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_11 0x000006CB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_11_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_12 0x000006CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_12_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_13 0x000006CD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_13_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_14 0x000006CE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_14_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_15 0x000006CF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_15_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_16 0x000006D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_16_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_17 0x000006D1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_17_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_18 0x000006D2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_18_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_19 0x000006D3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_19_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_20 0x000006D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_20_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_21 0x000006D5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_21_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_22 0x000006D6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_22_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_23 0x000006D7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_23_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_24 0x000006D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_24_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_25 0x000006D9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_25_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_26 0x000006DA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_26_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_27 0x000006DB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_27_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_28 0x000006DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_28_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_29 0x000006DD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_29_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_30 0x000006DE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_30_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define SKX_MSR_LBR_TO_IP_31 0x000006DF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_TO_IP_31_REGISTER;

/**
  Global PMON
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_PERF_GLOBAL_CTRL 0x00000700

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmiselc0 : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc1 : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc2 : 1;

                            /* Bits[2:2], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc3 : 1;

                            /* Bits[3:3], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc4 : 1;

                            /* Bits[4:4], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc5 : 1;

                            /* Bits[5:5], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc6 : 1;

                            /* Bits[6:6], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc7 : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc8 : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc9 : 1;

                            /* Bits[9:9], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc10 : 1;

                            /* Bits[10:10], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc11 : 1;

                            /* Bits[11:11], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc12 : 1;

                            /* Bits[12:12], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc13 : 1;

                            /* Bits[13:13], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc14 : 1;

                            /* Bits[14:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc15 : 1;

                            /* Bits[15:15], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc16 : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc17 : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc18 : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc19 : 1;

                            /* Bits[19:19], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc20 : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc21 : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc22 : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc23 : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc24 : 1;

                            /* Bits[24:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc25 : 1;

                            /* Bits[25:25], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc26 : 1;

                            /* Bits[26:26], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc27 : 1;

                            /* Bits[27:27], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the target cores. 0 - Don't send event to the
                               core (default) 1 - Send event to the core
                            */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 27;

                            /* Bits[58:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Resetcntrs : 1;

                            /* Bits[59:59], Access Type=WO, default=0x00000000*/

                            /*
                               ResetCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be frozen. 0 : No
                               effect 1 : Reset all the perfmon counters
                            */
    UINT32 Pmiovfenubp : 1;

                            /* Bits[60:60], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable the generation of uBP event when set. 0 -
                               Does not assert uBP event with the PMI Overflow.
                               1 - Assert uBP event with the PMI Overflow is
                               set.
                            */
    UINT32 Unfrzcountr : 1;

                            /* Bits[61:61], Access Type=WO, default=0x00000000*/

                            /*
                               UnfreezCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be unfrozen. 0 :
                               No effect 1 : Unfreeze all the perfmon counters,
                               start counting
                            */
    UINT32 Wkonpmi : 1;

                            /* Bits[62:62], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit determines whether PMI event is sent to
                               waken cores only or is broadcast to all cores
                               after waking up any sleeping core. 0 : Avoid
                               waking a core for PMI event - send event to
                               waken cores only. 1 : Wake any sleeping core and
                               send PMI event to all cores
                            */
    UINT32 Frzcountr : 1;

                            /* Bits[63:63], Access Type=WO, default=0x00000000*/

                            /*
                               FreezCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be frozen. 0 : No
                               effect 1 : Freeze all the perfmon counters, stop
                               counting
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_PERF_GLOBAL_CTRL_REGISTER;

/**
  PMON Global Status register.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_PERF_GLOBAL_STATUS 0x00000701

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Fixctrovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates that an overflow event occured on the
                               Fix Event. read 0 - No overflow detected 1 -
                               Event overflow event was detected (sticky) Write
                               0 - Ignore 1 - Clear this bit
                            */
    UINT32 Ncuctrovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates that an overflow event occured on the
                               NCU and IMPH Event. read 0 - No overflow
                               detected 1 - Event overflow event was detected
                               (sticky) Write 0 - Ignore 1 - Clear this bit
                            */
    UINT32 Pcuovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware to indicate that an overflow
                               happened in the PCU
                            */
    UINT32 Cbo0ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 0 */
    UINT32 Cbo1ovf : 1;

                            /* Bits[4:4], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 1 */
    UINT32 Cbo2ovf : 1;

                            /* Bits[5:5], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 2 */
    UINT32 Cbo3ovf : 1;

                            /* Bits[6:6], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 3 */
    UINT32 Cbo4ovf : 1;

                            /* Bits[7:7], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 4 */
    UINT32 Cbo5ovf : 1;

                            /* Bits[8:8], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 5 */
    UINT32 Cbo6ovf : 1;

                            /* Bits[9:9], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 6 */
    UINT32 Cbo7ovf : 1;

                            /* Bits[10:10], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 7 */
    UINT32 Cbo8ovf : 1;

                            /* Bits[11:11], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 8 */
    UINT32 Cbo9ovf : 1;

                            /* Bits[12:12], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 9 */
    UINT32 Cbo10ovf : 1;

                            /* Bits[13:13], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               10
                            */
    UINT32 Cbo11ovf : 1;

                            /* Bits[14:14], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               11
                            */
    UINT32 Cbo12ovf : 1;

                            /* Bits[15:15], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               15
                            */
    UINT32 Cbo13ovf : 1;

                            /* Bits[16:16], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               16
                            */
    UINT32 Cbo14ovf : 1;

                            /* Bits[17:17], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo15ovf : 1;

                            /* Bits[18:18], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo16ovf : 1;

                            /* Bits[19:19], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo17ovf : 1;

                            /* Bits[20:20], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo18ovf : 1;

                            /* Bits[21:21], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               18
                            */
    UINT32 Cbo19ovf : 1;

                            /* Bits[22:22], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               19
                            */
    UINT32 Cbo20ovf : 1;

                            /* Bits[23:23], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               20
                            */
    UINT32 Cbo21ovf : 1;

                            /* Bits[24:24], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               21
                            */
    UINT32 Cbo22ovf : 1;

                            /* Bits[25:25], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               22
                            */
    UINT32 Cbo23ovf : 1;

                            /* Bits[26:26], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               23
                            */
    UINT32 Cbo24ovf : 1;

                            /* Bits[27:27], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               24
                            */
    UINT32 Cbo25ovf : 1;

                            /* Bits[28:28], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               25
                            */
    UINT32 Cbo26ovf : 1;

                            /* Bits[29:29], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               26
                            */
    UINT32 Cbo27ovf : 1;

                            /* Bits[30:30], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               27
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 7;

                            /* Bits[38:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Imc0ovf : 1;

                            /* Bits[39:39], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in the
                               memory controller 0
                            */
    UINT32 Imc1ovf : 1;

                            /* Bits[40:40], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in the
                               memory controller 1
                            */
    UINT32 Kti00ag0ovf : 1;

                            /* Bits[41:41], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI00
                               Agent
                            */
    UINT32 Kti00ag1ovf : 1;

                            /* Bits[42:42], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI00
                               Agent
                            */
    UINT32 Kti40ag0ovf : 1;

                            /* Bits[43:43], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI40
                               Agent
                            */
    UINT32 Kti40ag1ovf : 1;

                            /* Bits[44:44], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI40
                               Agent
                            */
    UINT32 Kti50ag0ovf : 1;

                            /* Bits[45:45], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI50
                               Agent
                            */
    UINT32 Kti50ag1ovf : 1;

                            /* Bits[46:46], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI50
                               Agent
                            */
    UINT32 M3kti0ovf : 1;

                            /* Bits[47:47], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in
                               M3UPI0
                            */
    UINT32 M3kti1ovf : 1;

                            /* Bits[48:48], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in
                               M3UPI1
                            */
    UINT32 M3kti2ovf : 1;

                            /* Bits[49:49], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in
                               M3KTI3
                            */
    UINT32 Rsvd50 : 1;

                            /* Bits[50:50], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 M2pcie0ovf : 1;

                            /* Bits[51:51], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe0
                            */
    UINT32 M2pcie1ovf : 1;

                            /* Bits[52:52], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe1
                            */
    UINT32 M2pcie2ovf : 1;

                            /* Bits[53:53], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe2
                            */
    UINT32 M2pcie3ovf : 1;

                            /* Bits[54:54], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe3
                            */
    UINT32 M2pcie4ovf : 1;

                            /* Bits[55:55], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe4
                            */
    UINT32 Iio0ovf : 1;

                            /* Bits[56:56], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO0(CBDMA)
                            */
    UINT32 Iio1ovf : 1;

                            /* Bits[57:57], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO1
                            */
    UINT32 Iio2ovf : 1;

                            /* Bits[58:58], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO2
                            */
    UINT32 Iio3ovf : 1;

                            /* Bits[59:59], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO3
                            */
    UINT32 Mcplink0ovf : 1;

                            /* Bits[60:60], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in MCPLink0
                            */
    UINT32 Mcplink1ovf : 1;

                            /* Bits[61:61], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in MCPLink1
                            */
    UINT32 M2mem0ovf : 1;

                            /* Bits[62:62], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2MEM0. Independent from iMC as they are in
                               different clock domains
                            */
    UINT32 M2mem1ovf : 1;

                            /* Bits[63:63], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2MEM1. Independent from iMC as they are in
                               different clock domains
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_PERF_GLOBAL_STATUS_REGISTER;

/**
  This is MSR that shows to user configuration of uncore PMON's. In this particular case it shows the number of Cbo PMON banks
**/
#define SKX_MSR_UNCORE_PMON_CONFIG 0x00000702

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Numofcbopmon : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000008*/

                            /*  */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_PMON_CONFIG_REGISTER;

/**
  Holds the status information and control the operation of the PMON Fixed Counter.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_FIXED_PERF_CTR_CTRL 0x00000703

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 20;

                            /* Bits[19:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable generation of Overfolow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Rsvd23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_FIXED_PERF_CTR_CTRL_REGISTER;

/**
  PMON Fixed Counter data register
  The Fix counter is counting UCLK cycles.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_FIXED_PERF_CTR 0x00000704

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_FIXED_PERF_CTR_REGISTER;

/**
  Controls the operation of the the PMON Counter 1.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_NCU_PERF_EVT_SEL_0 0x00000705

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               a selector for measured signals Details of
                               events are TBD
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               A set of qualifiers defined for each of the
                               events. Details for the counter are TBD.
                            */
    UINT32 Enubp : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the generation of micro-breakpoint event
                               on event occurrence. 0b Do not assert micro-
                               breakpoint on event occurrence 1b Assert micro-
                               breakpoint on event occurrence
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               If we write 1 to this bit, it resets the
                               appropriate PMON counter
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable generation of Overfolow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the event for counting purposes : 0 :
                               Count when the event is asserted or on it's
                               rising edge 1. : Count when the event is de-
                               asserted or on it's falling edge
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming increment value from event increment
                               bus. The width of this field is determined by
                               the widest event in the iMPH (which is 5 bits
                               for queue occupancy). The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the Invert bit) no
                               matter how wide the original event was. When
                               this field is zero, threshold comparison is
                               disabled and the event is passed without
                               modification (i.e. the counter will adevance by
                               the specified increment value).
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_NCU_PERF_EVT_SEL_0_REGISTER;

/**
  Controls the operation of the the PMON Counte 2.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_NCU_PERF_EVT_SEL_1 0x00000706

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               a selector for measured signals Details of
                               events are TBD
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               A set of qualifiers defined for each of the
                               events. Details for the counter are TBD.
                            */
    UINT32 Enubp : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the generation of micro-breakpoint event
                               on event occurrence. 0b Do not assert micro-
                               breakpoint on event occurrence 1b Assert micro-
                               breakpoint on event occurrence
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               If we write 1 to this bit, it resets the
                               appropriate PMON counter
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable generation of Overfolow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the event for counting purposes : 0 :
                               Count when the event is asserted or on it's
                               rising edge 1. : Count when the event is de-
                               asserted or on it's falling edge
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming increment value from event increment
                               bus. The width of this field is determined by
                               the widest event in the iMPH (which is 5 bits
                               for queue occupancy). The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the Invert bit) no
                               matter how wide the original event was.
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_NCU_PERF_EVT_SEL_1_REGISTER;

/**
  Holds global control fields for the NCU PMON counters.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define SKX_MSR_NCU_PERF_UNIT_CTL 0x00000707

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Thread-ID format is given as follows: [0:0]
                               T0 or T1. For GT Core this bit must be 0. [6:1]
                               Core ID. When "TID Filter Enable" is clear in
                               the Counter Control register, then the specified
                               counter will count all events. Thread-ID value
                               of 0xE is reserved for non-associated requests
                               like LLC victims and External Snoops.
                            */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_NCU_PERF_UNIT_CTL_REGISTER;

/**
  NCU PMON Statsu register.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_NCU_PERF_UNIT_STATUS 0x00000708

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ovfcntr0 : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates overflow Condition on the NCU Counter
                               0. Read 0 - counter didn't overflow 1 - couner
                               overflow occured. Write 0 - ignored
                            */
    UINT32 Ovfcntr1 : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates overflow Condition on the NCU Counter
                               1. Read 0 - counter didn't overflow 1 - couner
                               overflow occured. Write 0 - ignored
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_NCU_PERF_UNIT_STATUS_REGISTER;

/**
  PMON Counter 1  data register
  The Fix counter is counting UCLK cycles.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_NCU_PERF_CTR_0 0x00000709

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_NCU_PERF_CTR_0_REGISTER;

/**
  PMON Counter 2  data register
  The Fix counter is counting UCLK cycles.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define SKX_MSR_UNCORE_NCU_PERF_CTR_1 0x0000070A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_UNCORE_NCU_PERF_CTR_1_REGISTER;

/**
  Ubox local PMON mask for NCDEC events
**/
#define SKX_MSR_NCU_PMON_MASK_CTL0 0x0000070B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask : 25;

                            /* Bits[24:0], Access Type=RWS, default=0x00000000*/

                            /*
                               event mask bit per ring message decode [ 0]
                               PMON_NCDEC_MASK_NCB_Int_CBO_IIO [ 1]
                               PMON_NCDEC_MASK_NCB_Int_UBX_QPI [ 2]
                               PMON_NCDEC_MASK_NCB_P2PB_IIO [ 3]
                               PMON_NCDEC_MASK_NCB_P2PB_CBO_UBX_QPI [ 4]
                               PMON_NCDEC_MASK_NCB_VLW_IIO_CBO [ 5]
                               PMON_NCDEC_MASK_NCB_VLW_UBX_QPI [ 6]
                               PMON_NCDEC_MASK_NCB_EOI_CBO [ 7]
                               PMON_NCDEC_MASK_NCB_EOI_UBX_QPI [ 8]
                               PMON_NCDEC_MASK_NCB_EOI_IIO [ 9]
                               PMON_NCDEC_MASK_NCB_STARTREQ234 [10]
                               PMON_NCDEC_MASK_NCB_PMREQ [11]
                               PMON_NCDEC_MASK_NCB_RSVD [12]
                               PMON_NCDEC_MASK_NCS_CfgRd_Wr [13]
                               PMON_NCDEC_MASK_NCS_IORd_Wr [14]
                               PMON_NCDEC_MASK_NCS_LTRd [15]
                               PMON_NCDEC_MASK_NCS_LTWr_IIO_CBO [16]
                               PMON_NCDEC_MASK_NCS_LTWr_UBX_QPI [17]
                               PMON_NCDEC_MASK_NCS_FERR [18]
                               PMON_NCDEC_MASK_NCS_RSVD [19]
                               PMON_NCDEC_MASK_NCS_SHUTDOWN_CBO [20]
                               PMON_NCDEC_MASK_NCS_LOCKS_UNLOCK_CBO_IIO [21]
                               PMON_NCDEC_MASK_NCS_LOCKS_UNLOCK_UBX_QPI [22]
                               PMON_NCDEC_MASK_NCS_STARTREQ1_STOPREQ1234 [23]
                               PMON_NCDEC_MASK_NCS_INVD_WBINVD_CBO_IIO [24]
                               PMON_NCDEC_MASK_NCS_INVD_WBINVD_UBX_QPI
                            */
    UINT32 Rsvd25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_NCU_PMON_MASK_CTL0_REGISTER;

/**
  Ubox local PMON mask for NCDEC events for subunit target
**/
#define SKX_MSR_NCU_PMON_MASK_CTL1 0x0000070C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask : 12;

                            /* Bits[11:0], Access Type=RWS, default=0x00000000*/

                            /*
                               event mask bit per sub unit target [ 0] GLOB_INT
                               [ 1] PMREQ [ 2] RACU [ 3] NCEVENT [ 4] NCLOCK [
                               5] GLOB_LOCK [ 6] MAST_LOCK [ 7] NCS_SPEC [ 8]
                               NCB_SPEC [ 9] GLOB_EOI [10] NCEOI [11] DROP
                            */
    UINT32 AddrMask : 16;

                            /* Bits[27:12], Access Type=RWS, default=0x00000000*/

                            /* Register address mask for addr[15:0] */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_NCU_PMON_MASK_CTL1_REGISTER;

/**
  Address offset match value for Ubox match/mask. Will compare bits that are not masked
**/
#define SKX_MSR_NCU_PMON_MATCH_ADDR 0x0000070D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 AddrMatch : 16;

                            /* Bits[15:0], Access Type=RWS, default=0x00000000*/

                            /* Address offset to match */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_NCU_PMON_MATCH_ADDR_REGISTER;

/**

**/
#define SKX_MSR_PERF_UNIT_CTRLS 0x00000710

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_UNIT_CTRLS_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_PERF_EVT_SEL_0 0x00000711

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Rsvd29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 -- "greater than or equal
                               to" comparison on the threshhold compare 1 --
                               "less than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_EVT_SEL_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_PERF_EVT_SEL_1 0x00000712

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Rsvd29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 -- "greater than or equal
                               to" comparison on the threshhold compare 1 --
                               "less than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_EVT_SEL_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_PERF_EVT_SEL_2 0x00000713

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Rsvd29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 -- "greater than or equal
                               to" comparison on the threshhold compare 1 --
                               "less than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_EVT_SEL_2_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_PERF_EVT_SEL_3 0x00000714

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Rsvd29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 -- "greater than or equal
                               to" comparison on the threshhold compare 1 --
                               "less than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_EVT_SEL_3_REGISTER;
/**
  Controls the filtering done by pcode for events that support filtering.
**/
#define SKX_MSR_PMON_PCU_FILTER 0x00000715

/**

**/
#define SKX_MSR_PERF_CTR_UNIT_STATUS 0x00000716

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counteroverflowbitmask : 7;

                            /* Bits[6:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               This is a bitmask that specifies which counter
                               (or counters) have overflowed. If the unit has a
                               fixed counter, it's corresponding bitmask will
                               be stored at position 0.
                            */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_CTR_UNIT_STATUS_REGISTER;

/**
  This register is a perfmon counter.  Software can both read
  it and write it.
**/
#define SKX_MSR_PERF_CTR_0 0x00000717

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_CTR_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read
  it and write it.
**/
#define SKX_MSR_PERF_CTR_1 0x00000718

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_CTR_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read
  it and write it.
**/
#define SKX_MSR_PERF_CTR_2 0x00000719

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_CTR_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_PERF_CTR_3 0x0000071A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERF_CTR_3_REGISTER;

/**
  Used by SKL ECO 5311926 - NOT TO BE PORTED TO CNL!!!!!
  This MSR provides the BIOS write access to various
  uncore MSRs, all with port-ids 0x2 or 0xA.
  This is the interface:
  EAX - Written data
  EDX - Index (or original address supposed to access)
  Microcode will convert EDX into funny IO address and write EAX into this CR.
**/
#define SKX_MSR_BIOS_DIRECT_PCIE_DMI_AFE_ACCESS 0x00000791

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* Data to be written - any value is legal */
    UINT32 Offset : 8;

                            /* Bits[39:32], Access Type=RW, default=None*/

                            /* register offset - any value is legal */
    UINT32 Portid : 8;

                            /* Bits[47:40], Access Type=RW, default=None*/

                            /*
                               portID , can be one of two possible values 0xA
                               or 0X2 , ucode to perform this check.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RW, default=None*/

                            /*
                               reserved , must be 0x00 , ucode to enforce this
                               check
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_BIOS_DIRECT_PCIE_DMI_AFE_ACCESS_REGISTER;
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define SKX_MSR_UNCORE_SPARE_1 0x00000792
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_0 0x00000800
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_1 0x00000801
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_2 0x00000804
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_3 0x00000805
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_4 0x00000806
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_5 0x00000807
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_6 0x00000809
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_7 0x0000080C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_8 0x0000080E
/**
  APIC In-Service register bits
**/
#define SKX_MSR_PIC_ISR_DWORD_0 0x00000810
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_1 0x00000811
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_2 0x00000812
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_3 0x00000813
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_4 0x00000814
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_5 0x00000815
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_6 0x00000816
/**
  Register decription
**/
#define SKX_MSR_PIC_ISR_DWORD_7 0x00000817
/**
  APIC Trigger Mode register bits
**/
#define SKX_MSR_PIC_TMR_DWORD_0 0x00000818
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_1 0x00000819
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_2 0x0000081A
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_3 0x0000081B
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_4 0x0000081C
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_5 0x0000081D
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_6 0x0000081E
/**
  Register decription
**/
#define SKX_MSR_PIC_TMR_DWORD_7 0x0000081F
/**
  APIC Interrupt Request register bits
**/
#define SKX_MSR_PIC_IRR_DWORD_0 0x00000820
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_1 0x00000821
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_2 0x00000822
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_3 0x00000823
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_4 0x00000824
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_5 0x00000825
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_6 0x00000826
/**
  Register decription
**/
#define SKX_MSR_PIC_IRR_DWORD_7 0x00000827
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_9 0x00000829
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_10 0x0000082A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_11 0x0000082B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_12 0x0000082C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_13 0x0000082D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_14 0x0000082E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_15 0x00000831
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_16 0x0000083A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_17 0x0000083B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_18 0x0000083C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_19 0x0000083D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_20 0x00000840
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_21 0x00000841
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_22 0x00000842
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_23 0x00000843
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_24 0x00000844
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_25 0x00000845
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_26 0x00000846
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_27 0x00000847
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_28 0x00000848
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_29 0x00000849
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_30 0x0000084A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_31 0x0000084B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_32 0x0000084C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_33 0x0000084D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_34 0x0000084E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_35 0x0000084F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_36 0x00000850
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_37 0x00000851
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_38 0x00000852
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_39 0x00000853
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_40 0x00000854
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_41 0x00000855
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_42 0x00000856
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_43 0x00000857
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_44 0x00000858
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_45 0x00000859
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_46 0x0000085A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_47 0x0000085B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_48 0x0000085C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_49 0x0000085D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_50 0x0000085E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_51 0x0000085F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_52 0x00000860
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_53 0x00000861
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_54 0x00000862
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_55 0x00000863
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_56 0x00000864
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_57 0x00000865
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_58 0x00000866
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_59 0x00000867
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_60 0x00000868
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_61 0x00000869
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_62 0x0000086A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_63 0x0000086B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_64 0x0000086C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_65 0x0000086D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_66 0x0000086E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_67 0x0000086F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_68 0x00000870
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_69 0x00000871
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_70 0x00000872
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_71 0x00000873
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_72 0x00000874
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_73 0x00000875
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_74 0x00000876
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_75 0x00000877
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_76 0x00000878
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_77 0x00000879
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_78 0x0000087A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_79 0x0000087B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_80 0x0000087C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_81 0x0000087D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_82 0x0000087E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_83 0x0000087F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_84 0x00000880
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_85 0x00000881
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_86 0x00000882
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_87 0x00000883
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_88 0x00000884
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_89 0x00000885
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_90 0x00000886
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_91 0x00000887
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_92 0x00000888
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_93 0x00000889
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_94 0x0000088A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_95 0x0000088B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_96 0x0000088C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_97 0x0000088D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_98 0x0000088E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_99 0x0000088F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_100 0x00000890
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_101 0x00000891
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_102 0x00000892
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_103 0x00000893
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_104 0x00000894
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_105 0x00000895
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_106 0x00000896
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_107 0x00000897
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_108 0x00000898
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_109 0x00000899
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_110 0x0000089A
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_111 0x0000089B
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_112 0x0000089C
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_113 0x0000089D
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_114 0x0000089E
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_115 0x0000089F
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_116 0x000008A0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_117 0x000008A1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_118 0x000008A2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_119 0x000008A3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_120 0x000008A4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_121 0x000008A5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_122 0x000008A6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_123 0x000008A7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_124 0x000008A8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_125 0x000008A9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_126 0x000008AA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_127 0x000008AB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_128 0x000008AC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_129 0x000008AD
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_130 0x000008AE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_131 0x000008AF
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_132 0x000008B0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_133 0x000008B1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_134 0x000008B2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_135 0x000008B3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_136 0x000008B4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_137 0x000008B5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_138 0x000008B6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_139 0x000008B7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_140 0x000008B8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_141 0x000008B9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_142 0x000008BA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_143 0x000008BB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_144 0x000008BC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_145 0x000008BD
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_146 0x000008BE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_147 0x000008BF
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_148 0x000008C0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_149 0x000008C1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_150 0x000008C2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_151 0x000008C3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_152 0x000008C4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_153 0x000008C5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_154 0x000008C6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_155 0x000008C7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_156 0x000008C8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_157 0x000008C9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_158 0x000008CA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_159 0x000008CB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_160 0x000008CC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_161 0x000008CD
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_162 0x000008CE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_163 0x000008CF
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_164 0x000008D0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_165 0x000008D1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_166 0x000008D2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_167 0x000008D3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_168 0x000008D4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_169 0x000008D5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_170 0x000008D6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_171 0x000008D7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_172 0x000008D8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_173 0x000008D9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_174 0x000008DA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_175 0x000008DB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_176 0x000008DC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_177 0x000008DD
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_178 0x000008DE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_179 0x000008DF
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_180 0x000008E0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_181 0x000008E1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_182 0x000008E2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_183 0x000008E3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_184 0x000008E4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_185 0x000008E5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_186 0x000008E6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_187 0x000008E7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_188 0x000008E8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_189 0x000008E9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_190 0x000008EA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_191 0x000008EB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_192 0x000008EC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_193 0x000008ED
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_194 0x000008EE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_195 0x000008EF
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_196 0x000008F0
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_197 0x000008F1
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_198 0x000008F2
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_199 0x000008F3
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_200 0x000008F4
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_201 0x000008F5
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_202 0x000008F6
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_203 0x000008F7
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_204 0x000008F8
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_205 0x000008F9
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_206 0x000008FA
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_207 0x000008FB
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_208 0x000008FC
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_209 0x000008FD
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_210 0x000008FE
/**
  Virtual APIC MSRs that are modeled by ucode
**/
#define SKX_MSR_VIRTUAL_APIC_211 0x000008FF

/**
  Holds XSAVE_AREA "triplet" w/ addition of XCompaction vector for the XMODIFIED optimization.
**/
#define SKX_MSR_XRSTOR_INFO 0x00000900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 XsaveAreaCpl : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* The full CPL from the last XRSTOR instruction. */
    UINT32 XsaveAreaVmmHostGuest : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               The VMM Host/Guest state from the last XRSTOR
                               instruction.
                            */
    UINT32 Rsvd3 : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */
    UINT32 XsaveAreaValid : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA valid bit is effectively an
                               address bit of the XSAVE_AREA. Since all
                               XSAVE_AREAs must be 64 byte aligned, setting
                               this bit forces the misalignment so compare of
                               this XSAVE_AREA and the XSAVE_AREA specified in
                               the XSAVE instruction must miscompare. The
                               miscompare will force all xmodified bits to be
                               treated as modified.
                            */
    UINT32 XsaveAreaAddress0 : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA linear address from the last
                               XRSTOR.
                            */
    UINT32 XsaveAreaAddress1 : 16;

                            /* Bits[47:32], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA linear address from the last
                               XRSTOR.
                            */
    UINT32 XcompactionVector : 10;

                            /* Bits[57:48], Access Type=RW, default=0x00000000*/

                            /*
                               Bit 0 => FP Bit 1 => SSE Bit 2 => GSSE Bit 3 =>
                               PL BNDREGS Bit 4 => PL BNDCFS Bit 5 => KMASK Bit
                               6 => AVX3(15:0) Bit 7 => AVX3(31:16) Bit 8 =>
                               RTIT (reserved - actual bit in IA_XSS) Bit 9 =>
                               PRKU
                            */
    UINT32 Rsvd58 : 5;

                            /* Bits[62:58], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */
    UINT32 XcompInUse : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XRSTOR_INFO_REGISTER;

/**
  Equivalent to architectural DR6 reg. 16 bit.
  (Mrm roctlregc/roctlregd/{tmpdr6lowSM306L|tmpdr6hiSM306L})
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define SKX_MSR_TMPDR6 0x00000902

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 B0 : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B0 */
    UINT32 B1 : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B1 */
    UINT32 B2 : 1;

                            /* Bits[2:2], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B2 */
    UINT32 B3 : 1;

                            /* Bits[3:3], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B3 */
    UINT32 Rsvd4 : 9;

                            /* Bits[12:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Bd : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* ROBTMPDR6BD */
    UINT32 Bs : 1;

                            /* Bits[14:14], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6BS */
    UINT32 Bt : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* ROBTMPDR6BT */
    UINT32 Hled : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6HLED */
    UINT32 EnclaveInterruption : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enclave interruption indication. Cleared by HW
                               on retired EOM
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TMPDR6_REGISTER;

/**
  Holds address bits [11:0] of a guest load/store access that hit the AVRR range
  C6NoSave Candidate
  FSCP Crunch:  12:32 Used only 12 bits out of 32
**/
#define SKX_MSR_VMX_VMENTRY_AVRR_TBIT_MAILBOX 0x00000907

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MailboxOffset : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mailbox address bits [11:0] of a guest
                               load/store access that hit the AVRR range
                            */
    UINT32 Reserved12 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Unused */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_VMX_VMENTRY_AVRR_TBIT_MAILBOX_REGISTER;

/**
  Millicode MSR used to control SMM states
  WRMSR will ignore the undefined bits (63:32, 30:1).
  RDMSR will always return 0 in bits 63:32, 30:1.
**/
#define SKX_MSR_XU_SMM_STATE 0x00000908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 InSmm : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting/clearing this bit will set/clear
                               CORE_CR_RR_MODE[IN_SMM] for the current thread
                               (see GQ1_CR_XU_SMM_STATE for uncore). 0 - Not in
                               SMM mode, 1 - In SMM mode
                            */
    UINT32 Rsvd1 : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SmmCodeAccessVioEnable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Tied to the following bits.
                               PMH_CR_RR_MODE[SMM_CODE_RANGE_CHK_EN] and
                               ROB1_CR_MISC_STATE[EIP_LOGGING].
                               Setting/clearing this bit will set/clear
                               PMH_CR_RR_MODE[SMM_CODE_RANGE_CHK_EN] and
                               ROB1_CR_MISC_STATE[EIP_LOGGING]
                            */
    UINT32 Rsvd5 : 16;

                            /* Bits[20:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PsmiBaseLocked : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               RDMSR only bit to report status of
                               SCP_CR_PSMI_CTRL_PSMI_BASE_LOCKED, ignored on
                               WRMSR
                            */
    UINT32 Rsvd22 : 9;

                            /* Bits[30:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SmmOutsideVmx : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Setting/clearing this bit will set/clear
                               FSCP_CR_LT_SMM_OPT_OUT_INFO[SMM_OUTSIDE_VMX]
                               (bit31) Indicates/controls opt-in to peer SMM
                               operation
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_SMM_STATE_REGISTER;

/**

**/
#define SKX_MSR_XU_STATUS 0x00000910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 C6DramEnabled : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* C6 DRAM ENABLE FUSE */
    UINT32 IncompleteResetTasksBiosDone : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /*
                               INCOMPLETE_RESET_TASKS_BIOS_DONE is being read
                               through pcode mailbox
                            */
    UINT32 Rsrvd2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_STATUS_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_1 0x00000911
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_2 0x00000912
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_3 0x00000913

/**
  Millicode MSR that reports information on whether a match on one of the 2 Xucode AMRRs occured.
**/
#define SKX_MSR_XU_AMRR_MATCH_VECTOR 0x00000914

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Match : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* Mapped to PMH_CR_RR_MATCH_RESULT[14:13] */
    UINT32 Splithi : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Match caused by high half of a *page* split load
                               or sta
                            */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_AMRR_MATCH_VECTOR_REGISTER;

/**
  APIC Virtualization Range Register - Base address of virtual APIC
**/
#define SKX_MSR_AVRR_BASE 0x00000916

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 11;

                            /* Bits[10:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the AVRR */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* AVRR Base Address */
    UINT32 Base1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* AVRR Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_AVRR_BASE_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_4 0x00000917
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_5 0x00000918
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_6 0x00000919
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_7 0x0000091A
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_8 0x0000091C
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_9 0x0000091D
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_10 0x0000091E
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_11 0x0000091F

/**
  The who-am-I register is used by uCode to set up the APIC ID.
  This register is initialized by the PCU according to the socket configuration using the NcuPcuWHOAMI register.
  The who-am-i register returns a thread specific identifier, however some of the fields of this registers are shared between all threads as indicated by the fields description.
**/
#define SKX_MSR_WHO_AM_I 0x00000920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Tid : 1;

                            /* Bits[0:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               Indicate the thread within the core. 0 - Thread
                               0 1 - Thread 1
                            */
    UINT32 Cid : 3;

                            /* Bits[3:1], Access Type=RO_V, default=0x00000000*/

                            /* Returns the Core Identification number. */
    UINT32 Pid : 11;

                            /* Bits[14:4], Access Type=RW_V, default=0x00000000*/

                            /*
                               A field that indicates the socket group number.
                               This field is common to all cores and the PCU- a
                               write operation by any one of the cores or the
                               PCU is seen by all. In sockets with up to 8
                               cores (CoreNum=00) : bits 14:4 are R/W by
                               SOCKET_ID MSR write operation. In sockets with
                               more than 8 cores and up to 16 (CoreNum=01) bits
                               14:5 are R/W by SOCKET_ID MSR write operation,
                               bit 4 is the msb of the cid. In sockets with
                               more than 16 cores (CoreNum=10) bits 14:6 are
                               R/W by SOCKET_ID MSR write operation, bit 5:4
                               are the msb's of the cid. Bit 4,5,6 is set to be
                               0 or 1 according to CID of the reading core.
                            */
    UINT32 Rsvd15 : 14;

                            /* Bits[28:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Corenum : 2;

                            /* Bits[30:29], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates how many common APIC ID bits there are
                               in the socket: 00 - up to 8 cores - all PID bits
                               are socket common. 01 - up to 16 cores - PID[0]
                               - indicate group number. PID[11:1] indicates
                               socket. 10- greater than 16 cores-
                               PID[1:0]-indicate group number PID[11:2]
                               indicates socket. 11- unused- not valid This
                               field is used by uCode for correctly handling
                               the number of variable bits in PID field.
                            */
    UINT32 Bsp : 1;

                            /* Bits[31:31], Access Type=RO_V, default=0x00000000*/

                            /*
                               Indicates to the core uCode that this thread
                               should be made the BSP of the socket, .
                               Selection among multi-socket BSP is done by BIOS
                               SW. 0 : this thread should not be set as BSP 1 :
                               this thread should be set as BSP
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_WHO_AM_I_REGISTER;

/**

**/
#define SKX_MSR_RESOLVED_CORES 0x00000921

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CoreMask : 28;

                            /* Bits[27:0], Access Type=RWS, default=0x00000000*/

                            /*
                               The resolved IA core mask contains the
                               functional (enabled in SKU) and non-defeatured
                               IA cores. The mask is indexed by logical ID. It
                               is normally contiguous, unless BIOS defeature is
                               activated on a particular core. BSP and APIC IDs
                               will be set by the processor based on this
                               value. This field is determined by FW based on
                               CSR_DESIRED_CORES[CORE_OFF_MASK].
                            */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_RESOLVED_CORES_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_STATUS (lower 32b) and ROB1_CR_PIC_EVENT_STATUS (upper 32b)
**/
#define SKX_MSR_PPPE_EVENT_STATUS 0x00000925

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : INTR */
    UINT32 A20m : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : MONITOR */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=RO_V, default=0x00000000*/

                            /* Event Status GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=RO_V, default=0x00000000*/

                            /* Event Status GO THREAD */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Restart micro */
    UINT32 Rsvd34 : 4;

                            /* Bits[37:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for Core Retirement Detector
                               (CRD) event
                            */
    UINT32 FerrOverflow : 1;

                            /* Bits[45:45], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for FERR_OVERFLOW event */
    UINT32 Pebs : 1;

                            /* Bits[46:46], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for PEBS event */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for NMIP */
    UINT32 Rsvd49 : 15;

                            /* Bits[63:49], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PPPE_EVENT_STATUS_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_SET (lower 32b) and ROB1_CR_PIC_EVENT_SET (upper 32b)
**/
#define SKX_MSR_PPPE_EVENT_SET 0x00000926

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /* Event Set : INTR */
    UINT32 A20m : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /* Event Set : A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Event Set : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Event Set : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=WO, default=0x00000000*/

                            /* Event Set : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=WO, default=0x00000000*/

                            /* Event Set : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=WO, default=0x00000000*/

                            /* Event Set : MONITOR */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=WO, default=0x00000000*/

                            /* Event Set : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /* Event Set : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /* Event Set : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=WO, default=0x00000000*/

                            /* Event Set : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=WO, default=0x00000000*/

                            /* Event Set : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=WO, default=0x00000000*/

                            /* Event Set : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=WO, default=0x00000000*/

                            /* Event Set : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=WO, default=0x00000000*/

                            /* Event Set : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=WO, default=0x00000000*/

                            /* Event Set : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /* Event Set GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /* Event Set GO THREAD */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=WO, default=0x00000000*/

                            /* Pending state for Restart micro */
    UINT32 Rsvd34 : 4;

                            /* Bits[37:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=WO, default=0x00000000*/

                            /* Pending state for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=WO, default=0x00000000*/

                            /* Pending state for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=WO, default=0x00000000*/

                            /* Pending state for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=WO, default=0x00000000*/

                            /* Pending state for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=WO, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=WO, default=0x00000000*/

                            /* Pending state for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=WO, default=0x00000000*/

                            /* Set Core Retirement Detector (CRD) pending state */
    UINT32 FerrOverflow : 1;

                            /* Bits[45:45], Access Type=WO, default=0x00000000*/

                            /* Pending state for FERR_OVERFLOW event */
    UINT32 Pebs : 1;

                            /* Bits[46:46], Access Type=WO, default=0x00000000*/

                            /* Set state for PEBS event */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=WO, default=0x00000000*/

                            /* Set state for NMIP event */
    UINT32 Rsvd49 : 15;

                            /* Bits[63:49], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PPPE_EVENT_SET_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_RESET (lower 32b) and ROB1_CR_PIC_EVENT_RESET (upper 32b)
**/
#define SKX_MSR_PPPE_EVENT_RESET 0x00000927

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /* Reset Event INTR */
    UINT32 A20m : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /* Event Reset : A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Event Reset : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Event Reset : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=WO, default=0x00000000*/

                            /* Event Reset : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=WO, default=0x00000000*/

                            /* Event Reset : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=WO, default=0x00000000*/

                            /*
                               Event Reset : MONITOR: Doesn't write
                               ML3_CR_PIC_EVENT_RESET_MONITOR but clears the
                               MONITOR FSM with a spcl cycle
                            */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=WO, default=0x00000000*/

                            /* Event Reset : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /* Event Reset : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /* Event Reset : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=WO, default=0x00000000*/

                            /* Event Reset : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=WO, default=0x00000000*/

                            /* Event Reset : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=WO, default=0x00000000*/

                            /* Event Reset : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=WO, default=0x00000000*/

                            /* Event Reset : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=WO, default=0x00000000*/

                            /* Event Reset : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=WO, default=0x00000000*/

                            /* Event Reset : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /* Event Reset GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /* Event Reset GO THREAD */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=WO, default=0x00000000*/

                            /* Pending state for Restart micro */
    UINT32 Rsvd34 : 4;

                            /* Bits[37:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=WO, default=0x00000000*/

                            /* Pending state for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=WO, default=0x00000000*/

                            /* Pending state for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=WO, default=0x00000000*/

                            /* Pending state for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=WO, default=0x00000000*/

                            /* Pending state for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=WO, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=WO, default=0x00000000*/

                            /* Pending state for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=WO, default=0x00000000*/

                            /*
                               Clear Core Retirement Detector (CRD) pending
                               state
                            */
    UINT32 FerrOverflow : 1;

                            /* Bits[45:45], Access Type=WO, default=0x00000000*/

                            /* Pending state for FERR_OVERFLOW event */
    UINT32 Pebs : 1;

                            /* Bits[46:46], Access Type=WO, default=0x00000000*/

                            /* Clear state for PEBS event */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=WO, default=0x00000000*/

                            /* Clear state for NMIP */
    UINT32 Rsvd49 : 15;

                            /* Bits[63:49], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PPPE_EVENT_RESET_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_12 0x00000928
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_13 0x00000929
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_14 0x0000092A
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_15 0x0000092B
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_16 0x0000092C
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_17 0x0000092D
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_18 0x0000092E
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_19 0x00000930
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_20 0x00000931
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_21 0x00000932
/**
  This is the virtual definition for the MSR to access PSMI_BASE on the other thread used by uncore_patch in millicode
**/
#define SKX_MSR_PSMI_BASE_OTHER_THREAD 0x00000935

/**
  Holds various SMX state
**/
#define SKX_MSR_LT_SMX_STATE 0x00000936

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 IlpFlag : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set during SENTER and SEXIT handshakes for the
                               ILP thread. Also set during ENTERACCS
                            */
    UINT32 SenterFlag : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set by SENTER for all threads, cleared by SEXIT */
    UINT32 AcmodeFlag : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Set while AC mode is active */
    UINT32 ShutdownFlag : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this caues leacy shutdown to morph to
                               LT-shutdown
                            */
    UINT32 AuthenticationBypassFlag : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set to bypass AC-module authentication to speed
                               up validation
                            */
    UINT32 PsmiEnable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Set to enable PSMI events during AC-mode */
    UINT32 CramLoadBypass : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Set to bypass CRAM load */
    UINT32 EnteraccsMacro : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Set during ENTERACCS */
    UINT32 SavedGqDisDca : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Saved value of the GQ DCA Disable bit */
    UINT32 LtAbortFlag : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 FitProcessing : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Set during patch load and startup ACM launch
                               while we're processing the FIT.
                            */
    UINT32 SavedSmrrValid : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Saved value of the SMRR valid bit. Used when
                               unlocking TSEG.
                            */
    UINT32 SavedSmrr2Valid : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Saved value of the SMRR2 valid bit. Used when
                               unlocking TSEG.
                            */
    UINT32 Reserved13 : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 SvSenterEn : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enables extended state saving for SV during
                               SENTER
                            */
    UINT32 CrashCode : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Holds the crash code for LT-shutdown. Written to
                               LSBs of LT_CRASH register. Dont change position
                               without CRASH_ACM_SVN
                            */
    UINT32 CrashCodeValid : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Indicates that the crash code is vaild */
    UINT32 PppeEnabled : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Indicates whether PPPE was enabled prior to AC-
                               mode
                            */
    UINT32 SavedTf : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* Saved value of EFLAGS.TF during SEXIT */
    UINT32 TpmBypass : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* Set to bypass TPM registration during SENTER */
    UINT32 Hotadd : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Reserved26 : 5;

                            /* Bits[30:26], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 LtPatchFlag : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 CrashAcmSvn : 8;

                            /* Bits[39:32], Access Type=RW, default=0x00000000*/

                            /*
                               Used in case of Crash-Code = 16, otherwise
                               zeroed. Should be 16 bits shifted left from the
                               CRASH_CODE field.
                            */
    UINT32 Reserved40 : 24;

                            /* Bits[63:40], Access Type=RW, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LT_SMX_STATE_REGISTER;
/**
  Millicode VMCS Cache MSR. Not really a register. R/W access to the VMCS Cache EXE H/W Dirty Bits (32b)
**/
#define SKX_MSR_XU_VMCS_CACHE_EXE_DIRTY_BITS 0x0000093A
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_22 0x0000093B

/**
  Millicode MSR for clearing APIC. Not really a register.
**/
#define SKX_MSR_XU_APIC_ACTION_TRIGGER 0x0000093D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reserved0 : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 ClearApic : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Clear the APIC */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 InterruptPerfmon : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /* Interrupt Perfmon */
    UINT32 Reservedhi4 : 28;

                            /* Bits[31:4], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_APIC_ACTION_TRIGGER_REGISTER;

/**
  This MSR allows Xucode to check which PPPE booted thread has shutdown.
**/
#define SKX_MSR_XU_THREAD_SHUTDOWN 0x0000093F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TheadBitmap : 8;

                            /* Bits[7:0], Access Type=RO_V, default=None*/

                            /*
                               Bitmap of all the threads in the package. HSW
                               client only needs 8 bits (4 cores * 2 threads).
                               When bit is set, it means that the
                               correspoinding thread has securely shutdown in
                               PPPE.
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_THREAD_SHUTDOWN_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define SKX_MSR_PDPTR_0 0x00000940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDPTR_0_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define SKX_MSR_PDPTR_1 0x00000941

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDPTR_1_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define SKX_MSR_PDPTR_2 0x00000942

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDPTR_2_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define SKX_MSR_PDPTR_3 0x00000943

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PDPTR_3_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_23 0x00000944
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_24 0x00000945
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_25 0x00000946
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_26 0x00000947
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_27 0x00000948
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_28 0x00000949
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_29 0x0000094A
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_30 0x0000094B
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_31 0x0000094C
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_32 0x0000094D
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define SKX_MSR_XU_RESERVED_33 0x0000094E
/**

**/
#define SKX_MSR_XU_OPTIN 0x0000094F

/**

**/
#define SKX_MSR_FUSED_CORES 0x00000950

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FusedCoreMask : 28;

                            /* Bits[27:0], Access Type=RWS, default=0x00000000*/

                            /* Vector of SKU enabled IA cores in the package. */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_FUSED_CORES_REGISTER;

/**

**/
#define SKX_MSR_SMT_CONTROL 0x00000951

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ThreadMask : 2;

                            /* Bits[9:8], Access Type=RWS, default=0x00000000*/

                            /*
                               Thread Mask indicates which threads are enabled
                               in the core. The LSB is the enable bit for
                               Thread 0, whereas the MSB is the enable bit for
                               Thread 1. This field is determined by FW based
                               on CSR_DESIRED_CORES[SMT_DISABLE].
                            */
    UINT32 Rsvd10 : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 FusedSmtCapability : 1;

                            /* Bits[24:24], Access Type=RWS, default=0x00000000*/

                            /*
                               Enabled threads in the package. 0b 1 thread 1b 2
                               threads
                            */
    UINT32 Rsvd25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SMT_CONTROL_REGISTER;

/**
  PPPE default memtype
**/
#define SKX_MSR_PPPE_MEMTYPE 0x00000953

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Memory type to use for the accesses defined in
                               Enable. It can be programmed to any value
                               allowed in the MTRRs.
                            */
    UINT32 Enable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the memory type in Memtype will be
                               forced by the PMH for all PPPE accesses,
                               overriding whatever memory type might be defined
                               by the MTRRs.
                            */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PPPE_MEMTYPE_REGISTER;

/**
  Enclave Linear Space Range Register - Physical Base Control Register
**/
#define SKX_MSR_ELSRR_BASE 0x00000955

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* ELSRR Base Address */
    UINT32 Base1 : 16;

                            /* Bits[47:32], Access Type=RW, default=0x00000000*/

                            /* ELSRR Base Address */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ELSRR_BASE_REGISTER;

/**
  Enclave Linear Space Range Register - Physical Mask Control Register
**/
#define SKX_MSR_ELSRR_MASK 0x00000956

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* ELSRR MASK bits */
    UINT32 Mask1 : 16;

                            /* Bits[47:32], Access Type=RW, default=0x00000000*/

                            /* ELSRR MASK bits */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_ELSRR_MASK_REGISTER;

/**
  EPCM Base Register
**/
#define SKX_MSR_EPCMBR 0x00000957

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 10;

                            /* Bits[9:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* EPCM Base Lock */
    UINT32 Rsvd11 : 7;

                            /* Bits[17:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /* EPCM Base Address */
    UINT32 Base1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* EPCM Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EPCMBR_REGISTER;

/**
  TCS Physical Address. Pointer to TCS structure, to be used at ASEX
**/
#define SKX_MSR_TCS_PA 0x00000958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TcsPhysAddr0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 TcsPhysAddr1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 RsvdB46 : 18;

                            /* Bits[63:46], Access Type=RW, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TCS_PA_REGISTER;

/**
  Holds SE Active SECS
**/
#define SKX_MSR_SECS_SID 0x00000959

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ActiveSecs : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* ACTIVE_SECS */
    UINT32 EnclaveMode : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* The thread is in Enclave Mode */
    UINT32 Rsvd17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SECS_SID_REGISTER;

/**
  Millicode Memory Range Register - Physical Base Control Register
**/
#define SKX_MSR_EMRR_BASE 0x00000962

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* EMRR BASE MemType */
    UINT32 Rsvd3 : 9;

                            /* Bits[11:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMRR Base Address */
    UINT32 Base1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* EMRR Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EMRR_BASE_REGISTER;

/**
  Millicode Memory Range Register - Physical Mask Control Register
**/
#define SKX_MSR_EMRR_MASK 0x00000963

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 9;

                            /* Bits[8:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, EMRR is in assist-mode - else in page
                               abort-mode (defeature only)
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the EMRR */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the EMRR */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMRR MASK bits */
    UINT32 Mask1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* EMRR MASK bits */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EMRR_MASK_REGISTER;

/**
  Xucode Memory Range Register - Physical Base Control Register
**/
#define SKX_MSR_EMXRR_BASE 0x00000964

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMXRR Base Address */
    UINT32 Base1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* EMXRR Base Address */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EMXRR_BASE_REGISTER;

/**
  Xucode Memory Range Register - Physical Mask Control Register
**/
#define SKX_MSR_EMXRR_MASK 0x00000965

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 10;

                            /* Bits[9:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the EMXRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMXRR MASK bits */
    UINT32 Mask1 : 14;

                            /* Bits[45:32], Access Type=RW, default=0x00000000*/

                            /* EMXRR MASK bits */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_EMXRR_MASK_REGISTER;

/**
  New command CR for pmons purpose
**/
#define SKX_MSR_PERFMON_COMMANDS 0x00000967

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 IncInstRetired : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /* Increment INST_RETIRED Architectural event */
    UINT32 IncBrRetired : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /* Increment BR_INST_RETIRED Architectural event */
    UINT32 IncBrMispred : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Increment BR_MISP_RETIRED Architectural event */
    UINT32 UcodeGenCntr : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Increment BR_MISP_RETIRED Architectural event */
    UINT32 AvxFalseFault : 1;

                            /* Bits[4:4], Access Type=WO, default=0x00000000*/

                            /* Increment MACHINE_CLEARS. AVX_FALSE_FAULT event */
    UINT32 PlBndxExtn : 1;

                            /* Bits[5:5], Access Type=WO, default=0x00000000*/

                            /*
                               Increments SubEv2 of INST_RETIRED (similar to
                               AVX_FALSE_FAULT) plus providing PEBS support.
                               ucode BD exception flow will set that bit upon
                               BNDX_EXCEPTION with proper serialization (pre
                               and post if precise).
                            */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PERFMON_COMMANDS_REGISTER;
/**
  32-bit read only XuMSRs to access GDXC MOT status.
**/
#define SKX_MSR_XU_GDXC_MOT_STATUS 0x00000968

/**
  64-bit read only XuMSRs to access GDXC OCLA status.
**/
#define SKX_MSR_XU_GDXC_OCLA_STATUS 0x00000969

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 GdxcOclaRegion : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 GdxcOclaAddressHi : 32;

                            /* Bits[63:32], Access Type=RO_V, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XU_GDXC_OCLA_STATUS_REGISTER;

/**
  Holds XCR0 and XSAVE Compaction Vector (used for XMODIFIED optimization check)
**/
#define SKX_MSR_XCR0 0x0000096D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 X87 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Bit 0 => FP */
    UINT32 Sse : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Bit 1 => SSE */
    UINT32 Gsse : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Bit 2 => GSSE */
    UINT32 PlBndregs : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Bit 3 => PL BNDREGS */
    UINT32 PlBndcfs : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Bit 4 => PL BNDCFS */
    UINT32 Kmask : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Bit 5 => KMASK */
    UINT32 Avx3150 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Bit 6 => AVX3(15:0) */
    UINT32 Avx33116 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Bit 7 => AVX3(31:16) */
    UINT32 RsvdIaXssRtit8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit 8 is reserved because of use as RTIT bit in
                               IA_XSS.
                            */
    UINT32 Pkru : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Bit 9 => Page Protection Keys User. */
    UINT32 Rsvd10 : 22;

                            /* Bits[31:10], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_XCR0_REGISTER;
/**
  This is Google specific MSR
**/
#define SKX_MSR_WHITELIST_MSR 0x00000972

/**
  Various controls
**/
#define SKX_MSR_IO_BW_PLIMIT_OVERRIDE 0x00000A00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FloorOffset : 6;

                            /* Bits[5:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This value specifies the number of bins below P1
                               at which the freq floor will be set to.
                               Frequency Floor = P1 - 100 * OVRD_VALUE By
                               default: Freq floor wil lbe set to P1.
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RW_V, default=0x00000000*/

                            /*  */
    UINT32 FloorEnable : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /* Overrides the Frequency Floor */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RW_V, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IO_BW_PLIMIT_OVERRIDE_REGISTER;

/**
  This register is a perfmon unit control.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONUNITCTRL 0x00000A40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONUNITCTRL_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONCNTR_0 0x00000A41

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTR_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONCNTR_1 0x00000A42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTR_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONCNTR_2 0x00000A43

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTR_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONCNTR_3 0x00000A44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTR_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTRCLK 0x00000A45

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTRCLK_REGISTER;

/**
  This field shows which registers have overflowed in the unit.
  a register overflows, it should set the relevant bit to 1.  An overflow should not effect the other status bits.  This status should only be cleared by software.
  defined 7 bits for this status.  This is overkill for many units.  See below for the bits that are used in the different units.
  al, if the unit has a fixed counter, it will use bit 0.  Counter 0 would use the next LSB, and the largest counter would use the MSB.
  ] w/ [4] = Counter4 and [0] = Counter 0
  0] w/ [0] = Fixed; [1] = Counter0 and [5] = Counter4
  I: [4:0] (same as HA)
  0]: [0] = Counter0 and [3] = Counter 3
  [0] = Counter0; [1] = Counter1
  [2] = Counter0; [3] = Counter1
  [3:0] w/ [3] = Counter 3 and [0] = Counter 0
**/
#define SKX_MSR_IMI_PMONUNITSTATUS 0x00000A47

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counteroverflowbitmask : 7;

                            /* Bits[6:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               This is a bitmask that specifies which counter
                               (or counters) have overflowed. If the unit has a
                               fixed counter, it's corresponding bitmask will
                               be stored at position 0.
                            */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONUNITSTATUS_REGISTER;

/**
  Perfmon Counter Control Register.
**/
#define SKX_MSR_IMI_PMONCNTRCFG_0 0x00000A48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. ect can also
                               be used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Threshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Chnlmask : 8;

                            /* Bits[43:36], Access Type=RW, default=0x000000FF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[46:44], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd47 : 17;

                            /* Bits[63:47], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTRCFG_0_REGISTER;

/**
  Perfmon Counter Control Register.
**/
#define SKX_MSR_IMI_PMONCNTRCFG_1 0x00000A49

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. ect can also
                               be used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Threshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Chnlmask : 8;

                            /* Bits[43:36], Access Type=RW, default=0x000000FF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[46:44], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd47 : 17;

                            /* Bits[63:47], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTRCFG_1_REGISTER;

/**
  Perfmon Counter Control Register.
**/
#define SKX_MSR_IMI_PMONCNTRCFG_2 0x00000A4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. ect can also
                               be used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Threshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Chnlmask : 8;

                            /* Bits[43:36], Access Type=RW, default=0x000000FF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[46:44], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd47 : 17;

                            /* Bits[63:47], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTRCFG_2_REGISTER;

/**
  Perfmon Counter Control Register.
**/
#define SKX_MSR_IMI_PMONCNTRCFG_3 0x00000A4B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. ect can also
                               be used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Threshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the
                               'invert' bit - see bit 23 below) no matter how
                               wide the original event was. When this field is
                               zero, threshold comparison is disabled and the
                               event is passed without modification.
                            */
    UINT32 Chnlmask : 8;

                            /* Bits[43:36], Access Type=RW, default=0x000000FF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[46:44], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd47 : 17;

                            /* Bits[63:47], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONCNTRCFG_3_REGISTER;
/**
  This register is a mask register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMASK_00 0x00000A4C

/**
  This register is a mask register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMASK_01 0x00000A4D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask7164 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This specified the mask to be used for the
                               debug_bus from PCIE
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONMASK_01_REGISTER;
/**
  This register is a mask register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMASK_10 0x00000A4E

/**
  This register is a mask register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMASK_11 0x00000A4F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask7164 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This specified the mask to be used for the
                               debug_bus from PCIE
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONMASK_11_REGISTER;
/**
  This register is a match register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMATCH_00 0x00000A50

/**
  This register is a match register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMATCH_01 0x00000A51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Match7164 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This specified the match to be used for the
                               debug_bus from PCIE
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONMATCH_01_REGISTER;
/**
  This register is a match register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMATCH_10 0x00000A52

/**
  This register is a match register for the debug bus to count the PMON events. Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONMATCH_11 0x00000A53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Match7164 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This specified the match to be used for the
                               debug_bus from PCIE
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONMATCH_11_REGISTER;

/**
  generated by critter 05_6_0x0f0
**/
#define SKX_MSR_IRP0_PMONUNITCTRL 0x00000A58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count.
                            */
    UINT32 Ptosel : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* 1 */
    UINT32 Rsvd19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONUNITCTRL_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IRP0_PMONCNTR_0 0x00000A59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONCNTR_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IRP0_PMONCNTR_1 0x00000A5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONCNTR_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_IRP0_PMONCNTRCFG_0 0x00000A5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L1 example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONCNTRCFG_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_IRP0_PMONCNTRCFG_1 0x00000A5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L1 example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONCNTRCFG_1_REGISTER;

/**
  This field shows which registers have overflowed in the unit.
  Whenever a register overflows, it should set the relevant bit to 1.  An overflow should not effect the other status bits.  This status should only be cleared by software.
  We have defined 7 bits for this status.  This is overkill for many units.  See below for the bits that are used in the different units.
  In general, if the unit has a fixed counter, it will use bit 0.  Counter 0 would use the next LSB, and the largest counter would use the MSB.
  HA: [4:0] w/ [4] = Counter4 and [0] = Counter 0
  IMC: [5:0] w/ [0] = Fixed; [1] = Counter0 and [5] = Counter4
  Intel QPI: [4:0] (same as HA)
  PCU: [3:0]: [0] = Counter0 and [3] = Counter 3
  IO IRP0: [0] = Counter0; [1] = Counter1
  IO IRP1: [2] = Counter0; [3] = Counter1
**/
#define SKX_MSR_IRP0_PMONUNITSTATUS 0x00000A5F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counteroverflowbitmask : 7;

                            /* Bits[6:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               This is a bitmask that specifies which counter
                               (or counters) have overflowed. If the unit has a
                               fixed counter, it's corresponding bitmask will
                               be stored at position 0.
                            */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IRP0_PMONUNITSTATUS_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_0 0x00000B00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_1 0x00000B01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_2 0x00000B02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_3 0x00000B03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_4 0x00000B04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_4_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_5 0x00000B05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_5_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_6 0x00000B06

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_6_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_TC_PMONFRCNTR_7 0x00000B07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_TC_PMONFRCNTR_7_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_8 0x00000B08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_8_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_9 0x00000B09

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_9_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_10 0x00000B0A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_10_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_11 0x00000B0B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_11_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_12 0x00000B0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_12_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_13 0x00000B0D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_13_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_14 0x00000B0E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_14_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_IMI_PMONFRCNTR_15 0x00000B0F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IMI_PMONFRCNTR_15_REGISTER;

/**
  Available only in SMM. SMRAM copy of CR3 saved by SMI
**/
#define SKX_MSR_SMRAM_CR3 0x00000C01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsv : 3;

                            /* Bits[2:0], Access Type=RW, default=None*/

                            /* Reserved bits, reset value T0 = 3'b0, T1=3'b111 */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /*
                               CR3 page level cache write through, reset value
                               T0 = 0, T1 = 1
                            */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /*
                               CR3 page level cache disable reset value T0 = 0,
                               T1 = 1
                            */
    UINT32 PdptrPdb : 7;

                            /* Bits[11:5], Access Type=RW, default=None*/

                            /*
                               PD Pntr Base, extended range for Mode-C paging,
                               reset val T0 ? 7'h78 : 7'h07
                            */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=None*/

                            /*
                               CR3 page directory base address , T0 ? 20'hfffff
                               : 20'hffff0
                            */
    UINT32 Pdba1 : 14;

                            /* Bits[45:32], Access Type=RW, default=None*/

                            /*
                               CR3 page directory base address , T0 ? 20'hfffff
                               : 20'hffff0
                            */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SMRAM_CR3_REGISTER;

/**
  Available only in SMM. SMRAM copy of CR0 saved by SMI
**/
#define SKX_MSR_SMRAM_CR4 0x00000C37

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Vme : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Enables virtual 8086-mode extensions */
    UINT32 Pvi : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Protected-Mode Virtual Interrupts */
    UINT32 Tsd : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* Time Stamp Disable */
    UINT32 De : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /* Debugging Extensions */
    UINT32 Pse : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /* Page Size Extensions */
    UINT32 Pae : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* Physical Address Extension */
    UINT32 Mce : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* Machine check Enable */
    UINT32 Pge : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* Page Global Enable */
    UINT32 Pce : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* Performance-monitoring Counter Enable */
    UINT32 Osfxsr : 1;

                            /* Bits[9:9], Access Type=RW, default=None*/

                            /* Enables the fast FXsave and FXrestore */
    UINT32 Xmmexc : 1;

                            /* Bits[10:10], Access Type=RW, default=None*/

                            /* Enables the exceptions for Katmia */
    UINT32 Rsvd11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 VmxEnable : 1;

                            /* Bits[13:13], Access Type=RW, default=None*/

                            /* Logic 1 indicates that VMX is enabled */
    UINT32 SmxEnable : 1;

                            /* Bits[14:14], Access Type=RW, default=None*/

                            /* Logic 1 indicates that SMX is enabled */
    UINT32 Slc64 : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /* Logic 1 indicates that SLC64 is enabled */
    UINT32 FsGsBase : 1;

                            /* Bits[16:16], Access Type=RW, default=None*/

                            /*
                               Logic 1 indicates that Ring3 Segment Base Access
                               is enabled. This allows reading/writing the
                               FS/GS segment bases through instructions
                               RDFSBASE. WRFSBASE, RDGSBASE or WRGSBASE.
                            */
    UINT32 Pcide : 1;

                            /* Bits[17:17], Access Type=RW, default=None*/

                            /* Logic 1 indicates that PCID is enabled */
    UINT32 Osxsave : 1;

                            /* Bits[18:18], Access Type=RW, default=None*/

                            /* Logic 1 indicates that XSAVE is enabled */
    UINT32 Rsvd19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_SMRAM_CR4_REGISTER;

/**
  This MSR writes
**/
#define SKX_MSR_CDP_ENABLING 0x00000C81

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CdpEn : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /*
                               this field updates the cbo_cr_ingress_spare code
                               data priorit enable bit (bit 15)
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CDP_ENABLING_REGISTER;

/**
  MBA min_max configuration
**/
#define SKX_MSR_MBA_CFG 0x00000C84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MinMax : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Min/Max of per core clos delays */
    UINT32 MbaHrdCntlDisable : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* MBA Hardware Control Disable */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_MBA_CFG_REGISTER;

/**
  Way Mask for IIO accesses (SF and LLC)
**/
#define SKX_MSR_IIO_LLC_WAYS 0x00000C8B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iiocosways : 23;

                            /* Bits[22:0], Access Type=RW, default=0x00600C00*/

                            /*
                               available LLC/SF way vectors for class of
                               service of IIO (default is way 10 and way 11)
                            */
    UINT32 Rsvd23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IIO_LLC_WAYS_REGISTER;

/**
  This MSR is used to configure QLRU
**/
#define SKX_MSR_QLRU_CONFIG 0x00000C8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CboQlruConfig : 30;

                            /* Bits[29:0], Access Type=RW, default=0x00000000*/

                            /*
                               LRU Update values for various opcodes that
                               update the LRU bits.
                            */
    UINT32 Rsvd30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 12;

                            /* Bits[43:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CboQlruConfig2 : 12;

                            /* Bits[55:44], Access Type=RW, default=0x00000000*/

                            /*
                               LRU Update values for various opcodes that
                               update the LRU bits.
                            */
    UINT32 Rsvd56 : 8;

                            /* Bits[63:56], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_QLRU_CONFIG_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define SKX_MSR_COSWAYS 0x00000C9F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnforcedWays : 11;

                            /* Bits[10:0], Access Type=RW, default=0x000007FF*/

                            /* The ways that can be enforced in LLC */
    UINT32 Reserved11 : 21;

                            /* Bits[31:11], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_COSWAYS_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define SKX_MSR_QOS_EXT_BW_THRTL 0x00000D5F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_QOS_EXT_BW_THRTL_REGISTER;

/**
  Extensible Supervisor State MSR
**/
#define SKX_MSR_IA32_XSS_AND_RTIT_INIT 0x00000DA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RtitInit : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               RTIT init indication is not part of the MSR but
                               was hidden here. Polarity matches headerbv: 0 -
                               INIT
                            */
    UINT32 Mbz : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /* Must-Be-Zero */
    UINT32 RtitSupport : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* RTIT X* support */
    UINT32 Reserved9 : 23;

                            /* Bits[31:9], Access Type=RW, default=0x00000000*/

                            /* Reserved for future growth */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_IA32_XSS_AND_RTIT_INIT_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_0 0x00000DC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_0_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_1 0x00000DC1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_1_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_2 0x00000DC2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_2_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_3 0x00000DC3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_3_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_4 0x00000DC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_4_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_5 0x00000DC5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_5_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_6 0x00000DC6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_6_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_7 0x00000DC7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_7_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_8 0x00000DC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_8_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_9 0x00000DC9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_9_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_10 0x00000DCA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_10_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_11 0x00000DCB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_11_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_12 0x00000DCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_12_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_13 0x00000DCD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_13_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_14 0x00000DCE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_14_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_15 0x00000DCF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_15_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_16 0x00000DD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_16_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_17 0x00000DD1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_17_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_18 0x00000DD2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_18_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_19 0x00000DD3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_19_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_20 0x00000DD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_20_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_21 0x00000DD5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_21_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_22 0x00000DD6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_22_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_23 0x00000DD7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_23_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_24 0x00000DD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_24_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_25 0x00000DD9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_25_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_26 0x00000DDA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_26_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_27 0x00000DDB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_27_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_28 0x00000DDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_28_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_29 0x00000DDD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_29_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_30 0x00000DDE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_30_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define SKX_MSR_LBR_INFO_31 0x00000DDF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RW_V, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RW_V, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_LBR_INFO_31_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_0 0x00000E00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_0 0x00000E01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_0 0x00000E02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_0 0x00000E03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_0_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_0 0x00000E04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_0_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_0 0x00000E05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_0_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_0 0x00000E06

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_0_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_0 0x00000E07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_0 0x00000E08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_0 0x00000E09

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_0 0x00000E0A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_0_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_0 0x00000E0B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_0_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_1 0x00000E10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_1 0x00000E11

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_1 0x00000E12

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_1 0x00000E13

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_1_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_1 0x00000E14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_1_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_1 0x00000E15

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_1_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_1 0x00000E16

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_1_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_1 0x00000E17

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_1 0x00000E18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_1 0x00000E19

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_1 0x00000E1A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_1_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_1 0x00000E1B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_1_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_2 0x00000E20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_2_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_2 0x00000E21

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_2_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_2 0x00000E22

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_2_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_2 0x00000E23

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_2_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_2 0x00000E24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_2_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_2 0x00000E25

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_2_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_2 0x00000E26

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_2_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_2 0x00000E27

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_2 0x00000E28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_2 0x00000E29

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_2 0x00000E2A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_2_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_2 0x00000E2B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_2_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_3 0x00000E30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_3_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_3 0x00000E31

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_3_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_3 0x00000E32

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_3_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_3 0x00000E33

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_3_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_3 0x00000E34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_3_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_3 0x00000E35

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_3_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_3 0x00000E36

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_3_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_3 0x00000E37

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_3 0x00000E38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_3 0x00000E39

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_3 0x00000E3A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_3_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_3 0x00000E3B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_3_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_4 0x00000E40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_4_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_4 0x00000E41

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_4_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_4 0x00000E42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_4_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_4 0x00000E43

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_4_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_4 0x00000E44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_4_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_4 0x00000E45

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_4_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_4 0x00000E46

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_4_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_4 0x00000E47

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_4_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_4 0x00000E48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_4_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_4 0x00000E49

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_4_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_4 0x00000E4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_4_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_4 0x00000E4B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_4_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_5 0x00000E50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_5_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_5 0x00000E51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_5_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_5 0x00000E52

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_5_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_5 0x00000E53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_5_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_5 0x00000E54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_5_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_5 0x00000E55

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_5_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_5 0x00000E56

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_5_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_5 0x00000E57

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_5_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_5 0x00000E58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_5_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_5 0x00000E59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_5_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_5 0x00000E5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_5_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_5 0x00000E5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_5_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_6 0x00000E60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_6_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_6 0x00000E61

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_6_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_6 0x00000E62

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_6_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_6 0x00000E63

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_6_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_6 0x00000E64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_6_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_6 0x00000E65

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_6_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_6 0x00000E66

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_6_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_6 0x00000E67

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_6_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_6 0x00000E68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_6_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_6 0x00000E69

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_6_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_6 0x00000E6A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_6_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_6 0x00000E6B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_6_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_7 0x00000E70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_7_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_7 0x00000E71

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_7_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_7 0x00000E72

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_7_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_7 0x00000E73

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_7_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_7 0x00000E74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_7_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_7 0x00000E75

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_7_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_7 0x00000E76

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_7_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_7 0x00000E77

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_7_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_7 0x00000E78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_7_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_7 0x00000E79

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_7_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_7 0x00000E7A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_7_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_7 0x00000E7B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_7_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_8 0x00000E80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_8_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_8 0x00000E81

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_8_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_8 0x00000E82

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_8_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_8 0x00000E83

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_8_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_8 0x00000E84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_8_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_8 0x00000E85

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_8_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_8 0x00000E86

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_8_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_8 0x00000E87

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_8_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_8 0x00000E88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_8_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_8 0x00000E89

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_8_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_8 0x00000E8A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_8_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_8 0x00000E8B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_8_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_9 0x00000E90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_9_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_9 0x00000E91

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_9_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_9 0x00000E92

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_9_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_9 0x00000E93

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_9_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_9 0x00000E94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_9_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_9 0x00000E95

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_9_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_9 0x00000E96

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_9_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_9 0x00000E97

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_9_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_9 0x00000E98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_9_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_9 0x00000E99

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_9_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_9 0x00000E9A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_9_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_9 0x00000E9B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_9_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_10 0x00000EA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_10_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_10 0x00000EA1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_10_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_10 0x00000EA2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_10_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_10 0x00000EA3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_10_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_10 0x00000EA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_10_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_10 0x00000EA5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_10_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_10 0x00000EA6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_10_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_10 0x00000EA7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_10_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_10 0x00000EA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_10_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_10 0x00000EA9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_10_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_10 0x00000EAA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_10_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_10 0x00000EAB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_10_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_11 0x00000EB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_11_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_11 0x00000EB1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_11_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_11 0x00000EB2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_11_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_11 0x00000EB3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_11_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_11 0x00000EB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_11_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_11 0x00000EB5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_11_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_11 0x00000EB6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_11_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_11 0x00000EB7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_11_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_11 0x00000EB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_11_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_11 0x00000EB9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_11_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_11 0x00000EBA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_11_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_11 0x00000EBB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_11_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_12 0x00000EC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_12_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_12 0x00000EC1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_12_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_12 0x00000EC2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_12_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_12 0x00000EC3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_12_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_12 0x00000EC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_12_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_12 0x00000EC5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_12_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_12 0x00000EC6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_12_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_12 0x00000EC7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_12_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_12 0x00000EC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_12_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_12 0x00000EC9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_12_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_12 0x00000ECA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_12_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_12 0x00000ECB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_12_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_13 0x00000ED0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_13_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_13 0x00000ED1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_13_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_13 0x00000ED2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_13_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_13 0x00000ED3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_13_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_13 0x00000ED4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_13_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_13 0x00000ED5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_13_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_13 0x00000ED6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_13_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_13 0x00000ED7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_13_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_13 0x00000ED8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_13_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_13 0x00000ED9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_13_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_13 0x00000EDA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_13_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_13 0x00000EDB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_13_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_14 0x00000EE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_14_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_14 0x00000EE1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_14_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_14 0x00000EE2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_14_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_14 0x00000EE3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_14_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_14 0x00000EE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_14_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_14 0x00000EE5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_14_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_14 0x00000EE6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_14_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_14 0x00000EE7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_14_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_14 0x00000EE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_14_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_14 0x00000EE9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_14_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_14 0x00000EEA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_14_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_14 0x00000EEB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_14_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_15 0x00000EF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_15_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_15 0x00000EF1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_15_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_15 0x00000EF2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_15_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_15 0x00000EF3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_15_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_15 0x00000EF4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_15_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_15 0x00000EF5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_15_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_15 0x00000EF6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_15_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_15 0x00000EF7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_15_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_15 0x00000EF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_15_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_15 0x00000EF9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_15_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_15 0x00000EFA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_15_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_15 0x00000EFB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_15_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_16 0x00000F00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_16_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_16 0x00000F01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_16_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_16 0x00000F02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_16_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_16 0x00000F03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_16_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_16 0x00000F04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_16_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_16 0x00000F05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_16_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_16 0x00000F06

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_16_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_16 0x00000F07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_16_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_16 0x00000F08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_16_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_16 0x00000F09

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_16_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_16 0x00000F0A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_16_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_16 0x00000F0B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_16_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_17 0x00000F10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_17_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_17 0x00000F11

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_17_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_17 0x00000F12

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_17_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_17 0x00000F13

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_17_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_17 0x00000F14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_17_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_17 0x00000F15

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_17_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_17 0x00000F16

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_17_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_17 0x00000F17

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_17_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_17 0x00000F18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_17_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_17 0x00000F19

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_17_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_17 0x00000F1A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_17_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_17 0x00000F1B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_17_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_18 0x00000F20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_18_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_18 0x00000F21

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_18_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_18 0x00000F22

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_18_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_18 0x00000F23

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_18_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_18 0x00000F24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_18_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_18 0x00000F25

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_18_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_18 0x00000F26

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_18_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_18 0x00000F27

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_18_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_18 0x00000F28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_18_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_18 0x00000F29

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_18_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_18 0x00000F2A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_18_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_18 0x00000F2B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_18_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_19 0x00000F30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_19_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_19 0x00000F31

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_19_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_19 0x00000F32

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_19_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_19 0x00000F33

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_19_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_19 0x00000F34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_19_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_19 0x00000F35

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_19_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_19 0x00000F36

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_19_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_19 0x00000F37

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_19_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_19 0x00000F38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_19_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_19 0x00000F39

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_19_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_19 0x00000F3A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_19_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_19 0x00000F3B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_19_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_20 0x00000F40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_20_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_20 0x00000F41

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_20_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_20 0x00000F42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_20_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_20 0x00000F43

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_20_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_20 0x00000F44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_20_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_20 0x00000F45

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_20_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_20 0x00000F46

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_20_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_20 0x00000F47

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_20_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_20 0x00000F48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_20_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_20 0x00000F49

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_20_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_20 0x00000F4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_20_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_20 0x00000F4B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_20_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_21 0x00000F50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_21_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_21 0x00000F51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_21_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_21 0x00000F52

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_21_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_21 0x00000F53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_21_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_21 0x00000F54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_21_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_21 0x00000F55

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_21_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_21 0x00000F56

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_21_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_21 0x00000F57

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_21_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_21 0x00000F58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_21_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_21 0x00000F59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_21_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_21 0x00000F5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_21_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_21 0x00000F5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_21_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_22 0x00000F60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_22_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_22 0x00000F61

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_22_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_22 0x00000F62

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_22_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_22 0x00000F63

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_22_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_22 0x00000F64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_22_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_22 0x00000F65

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_22_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_22 0x00000F66

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_22_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_22 0x00000F67

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_22_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_22 0x00000F68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_22_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_22 0x00000F69

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_22_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_22 0x00000F6A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_22_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_22 0x00000F6B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_22_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_23 0x00000F70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_23_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_23 0x00000F71

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_23_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_23 0x00000F72

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_23_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_23 0x00000F73

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_23_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_23 0x00000F74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_23_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_23 0x00000F75

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_23_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_23 0x00000F76

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_23_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_23 0x00000F77

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_23_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_23 0x00000F78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_23_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_23 0x00000F79

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_23_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_23 0x00000F7A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_23_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_23 0x00000F7B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_23_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_24 0x00000F80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_24_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_24 0x00000F81

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_24_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_24 0x00000F82

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_24_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_24 0x00000F83

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_24_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_24 0x00000F84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_24_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_24 0x00000F85

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_24_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_24 0x00000F86

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_24_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_24 0x00000F87

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_24_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_24 0x00000F88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_24_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_24 0x00000F89

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_24_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_24 0x00000F8A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_24_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_24 0x00000F8B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_24_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_25 0x00000F90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_25_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_25 0x00000F91

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_25_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_25 0x00000F92

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_25_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_25 0x00000F93

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_25_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_25 0x00000F94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_25_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_25 0x00000F95

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_25_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_25 0x00000F96

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_25_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_25 0x00000F97

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_25_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_25 0x00000F98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_25_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_25 0x00000F99

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_25_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_25 0x00000F9A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_25_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_25 0x00000F9B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_25_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_26 0x00000FA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_26_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_26 0x00000FA1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_26_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_26 0x00000FA2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_26_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_26 0x00000FA3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_26_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_26 0x00000FA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_26_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_26 0x00000FA5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_26_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_26 0x00000FA6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_26_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_26 0x00000FA7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_26_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_26 0x00000FA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_26_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_26 0x00000FA9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_26_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_26 0x00000FAA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_26_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_26 0x00000FAB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_26_REGISTER;

/**
  Pmon Unit control.
**/
#define SKX_MSR_PMONUNITCTRL_CHA_27 0x00000FB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. To reset the counters, this
                               bit need only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_PMONUNITCTRL_CHA_27_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_0_CHA_27 0x00000FB1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_0_CHA_27_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_1_CHA_27 0x00000FB2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_1_CHA_27_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_2_CHA_27 0x00000FB3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_2_CHA_27_REGISTER;

/**
  Perfmon Counter Control Register
**/
#define SKX_MSR_CBOPMONCTRCTRL_3_CHA_27 0x00000FB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event --
                               bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a \q1\q is written to
                               it. No action is taken when a \q0\q is written.
                               Note: Since the queue occupancy counters never
                               drop below zero, it is possible for the counters
                               to 'catch up' with the real occupancy of the
                               queue in question when the real occupancy drop
                               to zero.
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in QPI. By using edge
                               detect, one can count the number of times that
                               we entered L0s mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with threshholding. This is true even for events
                               that can only increment by 1 in a given cycle
                               (like the L0s example above). In this case, one
                               should set a threshhold of 1. One can also use
                               Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would selet the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThradID filter enable. This is only used by Cbo.
                               For other units it is Reserved.
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Unit's configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. There
                               will be some hardware that will disable counting
                               on locked parts. This will be reused from DFX.
                               This is a WIP. Note that MSR counters will
                               signal GP if someone attempts to write to this
                               bit on regular parts. This will not be the case
                               on PCI CFG counters because ucode is not a part
                               of the access flow.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the \qevent select\q, \qunit mask\q,
                               and \qinternal\q bits (see the fields below).
                               There is one bit per PerfMon Counter. Note that
                               if this bit is set to 1 but the Unit Control
                               Registers have determined that counting is
                               disabled, then the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold &lt; event. The
                               invert bit only works when Threshhold != 0. So,
                               if one would like to invert a non-occupancy
                               event (like LLC Hit), one needs to set the
                               threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRCTRL_3_CHA_27_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_CHA_27 0x00000FB5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format[2:0] - ThreadId. [8:3] - Core-
                               ID
                            */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_CHA_27_REGISTER;

/**
.
**/
#define SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_27 0x00000FB6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Remotenode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Localnode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Allopcodes : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Nearmemcacheable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Notnearmemcacheable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Rsvd6 : 3;

                            /* Bits[8:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Opcode0 : 10;

                            /* Bits[18:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Opcode1 : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 C6opcode : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for C6 requests */
    UINT32 Noncohopcode : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for non-coh requests */
    UINT32 Isocopcode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* 0 for all requests, 1 for ISOC requests */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRLGLCTR_1_CHA_27_REGISTER;

/**
  Cbo Pmon counters status
**/
#define SKX_MSR_CBOPMONCTRSTATUS_CHA_27 0x00000FB7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCTRSTATUS_CHA_27_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_0_CHA_27 0x00000FB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_0_CHA_27_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_1_CHA_27 0x00000FB9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_1_CHA_27_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_2_CHA_27 0x00000FBA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_2_CHA_27_REGISTER;

/**
  This register is a perfmon counter.  Software can both read it and write it.
**/
#define SKX_MSR_CBOPMONCT_3_CHA_27 0x00000FBB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} SKX_MSR_CBOPMONCT_3_CHA_27_REGISTER;
#endif /* _SKXMSR_h */
