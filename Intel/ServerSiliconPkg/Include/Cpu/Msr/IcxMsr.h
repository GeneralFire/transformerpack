
/** @file
  IcxMsr.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

#ifndef _ICXMSR_h
#define _ICXMSR_h
#include <Base.h>

/**
  Enhanced MCA Thread error injection control
**/
#define ICX_MSR_THREAD_SMI_ERR_INJ_CONTROL 0x0000002B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ifu : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dcu : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_THREAD_SMI_ERR_INJ_CONTROL_REGISTER;

/**
  Enhanced MCA Core error injection control
**/
#define ICX_MSR_CORE_SMI_ERR_INJ_CONTROL 0x0000002C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dtlb : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mlc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CORE_SMI_ERR_INJ_CONTROL_REGISTER;

/**
  Enhanced MCA Uncore error injection control
**/
#define ICX_MSR_UNCORE_SMI_ERR_INJ_CONTROL 0x0000002D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 McaBankId4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId9 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId24 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_UNCORE_SMI_ERR_INJ_CONTROL_REGISTER;

/**
  MSR used to select the mode for the Data Cache Unit (DCU). This MSR is only available when more than one DCU Mode is selectable and is only intended for use in early BIOS before the first transition of the CR0.CD from 1 to 0.
**/
#define ICX_MSR_DCU_MODE_CONTROL 0x00000031

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableDcu16kMode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When read as 0 (default), the DCU Mode is 32-KB
                               8-way without ECC. When read as 1, the BIOS has
                               changed the DCU mode to 16-KB 4-way with ECC. If
                               the DCU Mode is 0 and the first transition of
                               the CR0.CD bit from 1 to 0 has not occurred by
                               either thread in this core, then a write of 1
                               selects the DCU mode as 16-KB 4-way with ECC.
                               After the first write, all further writes are
                               ignored.
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_DCU_MODE_CONTROL_REGISTER;

/**
  Register to disable split locks, which are locked instructions that split a cache line.
**/
#define ICX_MSR_MEMORY_CONTROL 0x00000033

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 29;

                            /* Bits[28:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SplitLockDisable : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If set to 1, a split lock will trigger an #AC
                               fault. If clear to 0, split locks proceed
                               normally (subjected to the "SUPPRESS_SPLIT_LOCK"
                               behavior. If both this bit and
                               SUPPRESS_SPLIT_LOCK are set, then only this bit
                               will be honored (has priority).
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SuppressSplitLock : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If set to 1, disables split locks. If clear to
                               0, enables split locks. Setting this bit will
                               cause split locks to be non-atomic, despite the
                               lock attribute of the instruction.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MEMORY_CONTROL_REGISTER;

/**
  The SOCKET_ID MSR is used to reassign the package-specific portions of the APIC ID.  This MSR is intended only to be used on scalable DP and high-end MP platforms to resolve legacy-mode APIC ID conflicts.
**/
#define ICX_MSR_SOCKET_ID 0x00000039

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PackageId : 11;

                            /* Bits[10:0], Access Type=RO_V, default=None*/

                            /*
                               Holds package ID. This reflects the upper 8 bits
                               of the APIC ID
                            */
    UINT32 Rsvd11 : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SOCKET_ID_REGISTER;

/**
  Contains bits that determine what additional state SMI/RSM must save and restore
  FSCP Crunch - 1 : 32
**/
#define ICX_MSR_SMM_SAVE_CONTROL 0x0000003E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SaveFpState : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* If set, SMI/RSM will save/restore FP state */
    UINT32 Reserved1 : 31;

                            /* Bits[31:1], Access Type=RW, default=0x00000000*/

                            /* Unallocated bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_SAVE_CONTROL_REGISTER;
/**
  new MSR to flush caches
**/
#define ICX_MSR_ADR_CACHE_FLUSH 0x00000056

/**
  Shutdown supression feature
**/
#define ICX_MSR_SUPPRESS_SHUTDOWN 0x00000060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SuppressShutdownAndLogmcaIerr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               suppress shutdown spc cycle and send ierr with
                               logging
                            */
    UINT32 ShutdownLogmcaIerr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* trigger ierr and log errors for shutdown cycle */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SUPPRESS_SHUTDOWN_REGISTER;

/**
  command reg in ACE IP
**/
#define ICX_MSR_ACE_SPI_COMMAND 0x00000062

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Start : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* set to trigger SPI txn */
    UINT32 AddrSize12 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* num of addr bytes */
    UINT32 AddrSize34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* num of addr bytes */
    UINT32 SoftRst : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* soft reset if *code detects a SPI hang */
    UINT32 AddrPhase : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* 1: addr phase present */
    UINT32 Abort : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* abort phase */
    UINT32 FreezeSpi : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* 1:frz present, 0: absent */
    UINT32 DummyPhase : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* 1:present, 0:absent */
    UINT32 DummyCycles : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* num of dummy cycles */
    UINT32 DataPhase : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* 1:present, 0:absent */
    UINT32 ReadWriteb : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* 1: read, 0:write */
    UINT32 Dual : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* SPI dual mode */
    UINT32 Quad : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* SPI quad mode */
    UINT32 TxnDataSize : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* txn data size */
    UINT32 Opcode : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /* 8bit SPI opcode */
    UINT32 Address : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* address */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ACE_SPI_COMMAND_REGISTER;
/**
  command reg in ACE IP
**/
#define ICX_MSR_ACE_SPI_DATA 0x00000063

/**
  status reg in ACE IP
**/
#define ICX_MSR_ACE_SPI_STATUS 0x00000064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Busy : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /* 1:busy, 0:idle */
    UINT32 Error : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /* 1:error, 0: no error */
    UINT32 Empty : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* indicates SPI buffer is empty */
    UINT32 Full : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* indicates SPI buffer is full */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RW, default=0x00000000*/

                            /* data field */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* data field */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ACE_SPI_STATUS_REGISTER;

/**
  config reg in ACE IP
**/
#define ICX_MSR_ACE_SPI_CONFIG 0x00000065

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ClkLow : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /* clk low */
    UINT32 ClkHigh : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000000*/

                            /* clk hi */
    UINT32 Drive : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000000*/

                            /* drive */
    UINT32 Sample : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000000*/

                            /* sample */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RW, default=0x00000000*/

                            /* reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ACE_SPI_CONFIG_REGISTER;

/**
  Used to exit out of PFR VCM. Write only command MSR. Read will #GP
**/
#define ICX_MSR_PFR_EXIT 0x00000066

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* dummy */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PFR_EXIT_REGISTER;
/**
  MSR to provision VCM key hash to CPU
**/
#define ICX_MSR_PFR_VCM_PROVISION 0x00000067

/**
  MSR to read PFR provision status
**/
#define ICX_MSR_PFR_VCM_PROVISION_STATUS 0x00000068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Signature : 16;

                            /* Bits[15:0], Access Type=RW, default=None*/

                            /* PFR signature in CPLD */
    UINT32 PfrEnabled : 1;

                            /* Bits[16:16], Access Type=RW, default=None*/

                            /* PFR enable indication */
    UINT32 CpuProvision : 1;

                            /* Bits[17:17], Access Type=RW, default=None*/

                            /* CPU NVRAM is provisioned */
    UINT32 CpuProvisionLock : 1;

                            /* Bits[18:18], Access Type=RW, default=None*/

                            /* CPU NVRAM is locked */
    UINT32 Rsvd19 : 11;

                            /* Bits[29:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Error : 1;

                            /* Bits[30:30], Access Type=RW, default=None*/

                            /* Error indicatoin */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PFR_VCM_PROVISION_STATUS_REGISTER;

/**
  Holds the error pin status
**/
#define ICX_MSR_IIO_ERRPINSTS 0x00000069

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Err0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               State of ERROR[0] pin (the register value is
                               active high. RW1CS
                            */
    UINT32 Err1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               State of ERROR[1] pin (the register value is
                               active high. RW1CS
                            */
    UINT32 Err2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               State of ERROR[2] pin (the register value is
                               active high. RW1CS
                            */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IIO_ERRPINSTS_REGISTER;

/**
  Register to tune HL configuration
**/
#define ICX_MSR_PREF_TUNING 0x0000006C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of forward hits to detector to trigger
                               fwd prefetching
                            */
    UINT32 Rsvd3 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Number of backward hits to detector to trigger
                               bwd prefetching
                            */
    UINT32 BlockDispatchThreshold : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               When IDIDPTStateMnn1H == 0: Minimum number of
                               available SQ entries, above which OQ block
                               dispatch fires When IDIDPTStateMnn1H > 0 this
                               field is ignored and
                               DPT_BLOCK_DISPATCH_THRESHOLD is used instead
                            */
    UINT32 Rsvd11 : 5;

                            /* Bits[15:11], Access Type=RW, default=0x00000000*/

                            /*
                               No. of MLC Miss SQ entries before spatials are
                               dropped
                            */
    UINT32 DisableDemandThrottling : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Disable Demand Throttling algorithm */
    UINT32 DemandThrottlingOverride : 6;

                            /* Bits[22:17], Access Type=RW, default=0x00000008*/

                            /*
                               No. of demand hits to a detector needed to
                               override throttle state
                            */
    UINT32 DemandThrottlingThreshold : 4;

                            /* Bits[26:23], Access Type=RW, default=0x0000000A*/

                            /*
                               Threshold of demand avg value that causes thread
                               demand throttling
                            */
    UINT32 DptBlockDispatchThreshold : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000002*/

                            /*
                               When IDIDPTStateMnn1H > 0: Minimum number of
                               available SQ entries, above which OQ block
                               dispatch fires When IDIDPTStateMnn1H == 0 this
                               field is ignored and BLOCK_DISPATCH_THRESHOLD is
                               used instead
                            */
    UINT32 MlprefWindowSize : 5;

                            /* Bits[36:32], Access Type=RW, default=0x00000014*/

                            /* MLC window size (unless throttled to half size) */
    UINT32 MlprefHalfWindowThreshold : 5;

                            /* Bits[41:37], Access Type=RW, default=0x0000000F*/

                            /*
                               If number of SQ entries in UNC states is greater
                               than threshold, divide the MLC window by 2
                            */
    UINT32 MlprefBlockThreshold : 5;

                            /* Bits[46:42], Access Type=RW, default=0x0000000E*/

                            /*
                               If number of SQ entries in UNC states is greater
                               than threshold, block MLC prefetches (LLC ones
                               can still dispatch)
                            */
    UINT32 MhlLhlMinDist : 5;

                            /* Bits[51:47], Access Type=RW, default=0x00000008*/

                            /*
                               Minimal distance allowed between HLs, advance
                               LHL if below
                            */
    UINT32 MhlLhlMaxDist : 6;

                            /* Bits[57:52], Access Type=RW, default=0x0000003F*/

                            /*
                               Max distance allowed between HLs, block LHL if
                               reached.
                            */
    UINT32 FarRange : 6;

                            /* Bits[63:58], Access Type=RW, default=0x00000020*/

                            /* Far window range */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PREF_TUNING_REGISTER;

/**
  Register to tune HL configuration
**/
#define ICX_MSR_FEATURE_TUNING_1 0x0000006D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Bi2ifu4FVictimsEn : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Enable BI to IFU for F-State lines */
    UINT32 Enabledbpforf : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Enable DBP for lines in F state */
    UINT32 Rsvd4 : 15;

                            /* Bits[18:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PauseLoopCnt : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000002*/

                            /*
                               Init value for pause loop counter. 00 - no
                               couting. 01 - 6 bit counter. 10 - 7 bit. 11 - 8
                               bit.
                            */
    UINT32 Rsvd21 : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DisableFastgo : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Maintains SNB Legacy behavior for LFB
                               Virtualization - ignore FastGO
                            */
    UINT32 Rsvd28 : 2;

                            /* Bits[29:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Speci2men : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If set, RFO's are stalled and Speculative I2M is
                               allowed
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 3;

                            /* Bits[34:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RfoTrainDisable : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /* Disable MPL training for DCU RFOs and RFOLs */
    UINT32 Rsvd36 : 15;

                            /* Bits[50:36], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DisableLlpref : 1;

                            /* Bits[51:51], Access Type=RW, default=0x00000000*/

                            /* Disable prefetch to LLC */
    UINT32 Rsvd52 : 8;

                            /* Bits[59:52], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DptDisable : 1;

                            /* Bits[60:60], Access Type=RW, default=0x00000000*/

                            /*
                               Forces the Dynamic Prefetch Throttling State to
                               1'b0 (default)
                            */
    UINT32 Rsvd61 : 3;

                            /* Bits[63:61], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FEATURE_TUNING_1_REGISTER;

/**
  MSR to support runtime tuning of CR-QoS feature
**/
#define ICX_MSR_AEP_QOS 0x0000006E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Leakybktsatvalue : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000050*/

                            /* Saturation Value for 2LM Leakybkt Counter */
    UINT32 Leakybktwindowcntr : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000100*/

                            /* Time window cntr Value for 2LM LeakyBkt Cntr */
    UINT32 Threshold : 8;

                            /* Bits[39:32], Access Type=RW, default=0x00000040*/

                            /*
                               Threshold value above which 2LMDDRTThExceeded to
                               CMS is asserted
                            */
    UINT32 LowThreshold : 8;

                            /* Bits[47:40], Access Type=RW, default=0x00000010*/

                            /*
                               Low Threshold below which all distress detection
                               bits are cleared
                            */
    UINT32 Thdisable : 1;

                            /* Bits[48:48], Access Type=RW, default=0x00000000*/

                            /*
                               Bit to defeature 2LMDDRThExceeded assertion to
                               CMS
                            */
    UINT32 Rsvd49 : 15;

                            /* Bits[63:49], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AEP_QOS_REGISTER;

/**
  MSR to indicate directory disable status
**/
#define ICX_MSR_DIR_DIS_STATUS 0x0000006F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DisDirectory : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Disable Directory. Directory should be disabled
                               for single socket configurations. Directory
                               should be enabled for all multi-socket
                               configurations
                            */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_DIR_DIS_STATUS_REGISTER;

/**
  Rd/Wr register to generate or restore Far Memory Keys
**/
#define ICX_MSR_FME_ACTIVATE 0x00000081

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* When set will cause #GP on write. */
    UINT32 FmeEnable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set to enable FME Encryption */
    UINT32 KeySelect : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Select key 0 = new key, 1 = standby restore */
    UINT32 SaveKeyForStandby : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Set to save key for standby */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FME_ACTIVATE_REGISTER;

/**
  MKTME KEYID PARTITIONING
**/
#define ICX_MSR_MKTME_KEYID_PARTITIONING 0x00000087

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 NumMktmeKids : 16;

                            /* Bits[15:0], Access Type=RW, default=None*/

                            /* Number of usable MK-TME KeyIDs */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MKTME_KEYID_PARTITIONING_REGISTER;
/**
  emulated by xucode --> cause pppe exit, described in SNC HSD 1304290485 - HCTIO/SoftCE: SoftCE ISA support
**/
#define ICX_MSR_TIO_PRM_CLEANUP 0x00000092
/**
  emulated by xucode --> cause pppe exit, described in SNC HSD 1304290485 - HCTIO/SoftCE: SoftCE ISA support
**/
#define ICX_MSR_TIO_COPY_ENCRYPT 0x00000093

/**
  Address Match Range Register - Physical Mask Control Register
**/
#define ICX_MSR_TIORR_PHYSBASE 0x00000096

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the TIORR register for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the TIORR register for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TIORR_PHYSBASE_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register
**/
#define ICX_MSR_TIORR_PHYSMASK 0x00000097

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RO_V, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RO_V, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RO_V, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RO_V, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RO_V, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Valid : 1;

                            /* Bits[11:11], Access Type=RO_V, default=0x00000000*/

                            /* valid bit for the AMRR */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TIORR_PHYSMASK_REGISTER;

/**
  MSR to expose the MCHECK error code to BIOS
**/
#define ICX_MSR_SGX_MCU_ERRORCODE 0x000000A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McheckErrorCode : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* MCHECK error code from MCHECK-ucode API */
    UINT32 Rsvd16 : 15;

                            /* Bits[30:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PatchRevIdStatusPppeLoadFail : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               per thread bit to indicate partial or full
                               success
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SGX_MCU_ERRORCODE_REGISTER;
/**
  SGX PRID values
**/
#define ICX_MSR_PRID_0 0x000000A1
/**
  SGX PRID values
**/
#define ICX_MSR_PRID_1 0x000000A2

/**
  MSR to opt in to SGX and opt out of advanceed RAS features
**/
#define ICX_MSR_SGX_RAS 0x000000A3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Optin : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* optin bit */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SGX_RAS_REGISTER;

/**
  SGX QoS MSR
**/
#define ICX_MSR_BIOS_PKG_CONFIG 0x000000A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Lock bit */
    UINT32 Enable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Lock bit */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_PKG_CONFIG_REGISTER;

/**
  FIT BIOS and ACM error type and code
**/
#define ICX_MSR_FIT_BIOS_ERROR 0x000000A5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ErrorCode : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* error code optype */
    UINT32 EntryType : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* entry type optype */
    UINT32 FitPatchEntry : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* indication whether patch entry exists in FIT */
    UINT32 Rsvd17 : 15;

                            /* Bits[31:17], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Rsvd32 : 31;

                            /* Bits[62:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /* Lock bit - set when FIT error is written to FSCP */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FIT_BIOS_ERROR_REGISTER;

/**
  Override MPX Fuse.
**/
#define ICX_MSR_MPX_FUSE_OVERRIDE 0x000000A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MpxEnabled : 1;

                            /* Bits[0:0], Access Type=RO_V, default=None*/

                            /* MPX Enable */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO_V, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO_V, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MPX_FUSE_OVERRIDE_REGISTER;

/**
  Virtual MSR to disable AVX instructions from BIOS
**/
#define ICX_MSR_BIOS_AVX_DIS 0x000000AF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 AvxDis : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* disable AVX/2/3 instructions */
    UINT32 Avx3Dis : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* disable AVX3 instructions */
    UINT32 Reserved2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_AVX_DIS_REGISTER;
/**
  vMSRs for power mgmt
**/
#define ICX_MSR_VMSR_U2P_0 0x000000B0
/**
  vMSRs for power mgmt
**/
#define ICX_MSR_VMSR_U2P_1 0x000000B1
/**
  vMSRs for power mgmt
**/
#define ICX_MSR_VMSR_U2P_2 0x000000B2
/**
  vMSRs for power mgmt
**/
#define ICX_MSR_VMSR_U2P_3 0x000000B3

/**
  This register contains read-only package-level ratio information
**/
#define ICX_MSR_PLATFORM_INFO 0x000000CE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 8;

                            /* Bits[7:0], Access Type=RWS, default=0x00000000*/

                            /* Reserved */
    UINT32 MaxNonTurboLimRatio : 8;

                            /* Bits[15:8], Access Type=RWS, default=0x00000000*/

                            /* The Maximum Non-Turbo Ratio */
    UINT32 SmmSaveCap : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000001*/

                            /*
                               When set to '1' indicates this feature exists
                               and is configured by SMM_SAVE_CONTROL
                            */
    UINT32 Rsvd17 : 6;

                            /* Bits[22:17], Access Type=RWS, default=0x00000000*/

                            /* Reserved */
    UINT32 PpinCap : 1;

                            /* Bits[23:23], Access Type=RWS, default=0x00000000*/

                            /*
                               When set to 1, indicates that this part supports
                               the Protected Processor Inventory Number (PPIN)
                               feature.
                            */
    UINT32 OcvoltOvrdAvail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               0b Indicates that the part does not support
                               Voltage override overclocking. 1b Indicates that
                               the part supports Voltage override overclocking.
                            */
    UINT32 FivrRfiTuningAvail : 1;

                            /* Bits[25:25], Access Type=RWS, default=0x00000000*/

                            /* FIVR RFI Tuning Support */
    UINT32 Dcu16kModeAvail : 1;

                            /* Bits[26:26], Access Type=RWS, default=0x00000000*/

                            /*
                               0b Indicates that the part does not support the
                               16K DCU mode. 1b Indicates that the part
                               supports 16K DCU mode.
                            */
    UINT32 SamplePart : 1;

                            /* Bits[27:27], Access Type=RWS, default=0x00000000*/

                            /*
                               A value of 1 indicates the processor is a
                               preproduction sample and a property of Intel, a
                               value of 0 indicates the part is intended for
                               production.
                            */
    UINT32 PrgTurboRatioEn : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Programmable Turbo Ratios per number of Active
                               Cores 0 = Programming Not Allowed 1 =
                               Programming Allowed
                            */
    UINT32 PrgTdpLimEn : 1;

                            /* Bits[29:29], Access Type=RWS, default=0x00000001*/

                            /*
                               Programmable TDP Limits for Turbo Mode. 0 =
                               Programming Not Allowed 1 = Programming Allowed
                            */
    UINT32 PrgTjOffsetEn : 1;

                            /* Bits[30:30], Access Type=RWS, default=0x00000001*/

                            /*
                               Programmable TJ Offset Enable. 0 = Programming
                               Not Allowed 1 = Programming Allowed
                            */
    UINT32 CpuidFaultingEn : 1;

                            /* Bits[31:31], Access Type=RWS, default=0x00000001*/

                            /*
                               When set to 1 indicates that the processor
                               supports raising a #GP if CPUID is executed when
                               not in SMM and the CPL > 0. When this bit is
                               set, it indicates that MISC_FEATURE_ENABLES[0]
                               can be written by a VMM.
                            */
    UINT32 LpmSupport : 1;

                            /* Bits[32:32], Access Type=RWS, default=0x00000000*/

                            /*
                               0 - Low Power Mode not Supported 1 - Low Power
                               Mode Supported
                            */
    UINT32 ConfigTdpLevels : 2;

                            /* Bits[34:33], Access Type=RWS, default=0x00000000*/

                            /*
                               Configurable TDP Levels 00 Config TDP not
                               supported 01 One additional TDP level supported
                               10 Two additional TDP levels supported 11
                               Reserved
                            */
    UINT32 PfatEnable : 1;

                            /* Bits[35:35], Access Type=RWS, default=0x00000000*/

                            /*
                               BIOS GUARD (PFAT) Enable. 0 = PFAT is disabled 1
                               = PFAT is enabled
                            */
    UINT32 Peg2dmidisEn : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000001*/

                            /*
                               0 = PEG2DMIDIS is disabled 1 = PEG2DMIDIS is
                               enabled
                            */
    UINT32 TimedMwaitEnable : 1;

                            /* Bits[37:37], Access Type=RWS, default=0x00000000*/

                            /*
                               Timed MWAIT Enable. 0 = Timed MWAIT is disabled
                               1 = Timed MWAIT is enabled
                            */
    UINT32 AsaEn : 1;

                            /* Bits[38:38], Access Type=RWS, default=0x00000001*/

                            /*
                               ASA Enable. 0 = ASA is disabled 1 = ASA is
                               enabled
                            */
    UINT32 Rsvd39 : 1;

                            /* Bits[39:39], Access Type=RWS, default=0x00000000*/

                            /* Reserved */
    UINT32 MaxEfficiencyRatio : 8;

                            /* Bits[47:40], Access Type=RWS, default=0x00000000*/

                            /*
                               Maximum Efficienty Ratio. This is given in units
                               of 100 MHz.
                            */
    UINT32 MinOperatingRatio : 8;

                            /* Bits[55:48], Access Type=RW, default=0x00000008*/

                            /* Minimum Supported Ratio in units of 100MHz */
    UINT32 PushpatchEn : 1;

                            /* Bits[56:56], Access Type=RWS, default=0x00000000*/

                            /*
                               The value of this bit is the INVERTED value of
                               FUSE_PUSH_PATCH_DIS
                            */
    UINT32 EdramEnable : 1;

                            /* Bits[57:57], Access Type=RWS, default=0x00000000*/

                            /*
                               Indicates to BIOS that memory-side ACPI tables
                               can be used
                            */
    UINT32 Sxp2lmEnable : 1;

                            /* Bits[58:58], Access Type=RWS, default=0x00000000*/

                            /*
                               Indicates to BIOS that the FME_ACTIVATE MSR can
                               be setup Indicates to BIOS that the FZM
                               functionality can be enabled
                            */
    UINT32 SmmSupovrStateLockEnable : 1;

                            /* Bits[59:59], Access Type=RWS, default=0x00000001*/

                            /*
                               Indicates to BIOS that the SMM_SUPOVR_STATE_LOCK
                               MSR can be setup. This bit is unconditionally
                               set for SoCs that support SNC
                            */
    UINT32 TioEnable : 1;

                            /* Bits[60:60], Access Type=RWS, default=0x00000000*/

                            /*
                               Indicates to BIOS that the Trusted IO (TIO) MSRs
                               can be accessed Indicates to BIOS that the
                               Trusted IO (TIO) functionality can be enabled
                               The value of this bit is the same as FUSE_TIO
                            */
    UINT32 Rsvd61 : 3;

                            /* Bits[63:61], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PLATFORM_INFO_REGISTER;

/**
  SoftSKU SMM access to LB regs
**/
#define ICX_MSR_SSKU_SMM_ADDR 0x000000D2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* different cmds for ssku */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SSKU_SMM_ADDR_REGISTER;

/**
  SoftSKU SMM access to LB regs
**/
#define ICX_MSR_SSKU_SMM_DATA 0x000000D3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* different cmds for ssku */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SSKU_SMM_DATA_REGISTER;
/**
  SoftSKU enforcement MSR
**/
#define ICX_MSR_SSKU_ENFORCE 0x000000D4
/**
  Software PAIR weight override
**/
#define ICX_MSR_PAIR_WEIGHT_OVERRIDE 0x00000102
/**
  Pair package level thread participation
**/
#define ICX_MSR_PAIR_PKG_THREAD_PARTICIPATION 0x00000103
/**
  Register to specify a thread's inclusion or exclusion in Power Aware Interrupt Routing
**/
#define ICX_MSR_PAIR_THREAD_PARTICIPATION 0x00000104

/**
  send to Sleep MSR
**/
#define ICX_MSR_PFAT_GT_SLEEP_CMDSTS 0x00000118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MailboxInternalPcodeKeepGtRc6 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               MAILBOX_INTERNAL_PCODE_KEEP_GT_RC6_DISABLE (0x0)
                               or MAILBOX_INTERNAL_PCODE_KEEP_GT_RC6_ENABLE
                               (0x1)
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PFAT_GT_SLEEP_CMDSTS_REGISTER;

/**
  Read bits 23:16 of uncore SCP (storage for this 8b MSR)
**/
#define ICX_MSR_BIOS_INFO_FLAGS 0x0000011F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 BiosInfoFlagsData : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS_INFO_FLAGS_DATA only 1 defined bit so far,
                               but want to have the flexibility to use other 7
                               bits w/o patching
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_INFO_FLAGS_REGISTER;

/**
  This is a read/write MSR that will control the ucode emulation of the PM_TMR.  BIOS will program this register.
**/
#define ICX_MSR_BIOS_UCODE_PM_TMR_EMULATION_CFG 0x00000121

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EmulatedIoPort : 16;

                            /* Bits[15:0], Access Type=RW, default=None*/

                            /*
                               I/O port which ucode will intercept if the valid
                               bit is set. This port is the PM_TMR
                            */
    UINT32 Valid : 1;

                            /* Bits[16:16], Access Type=RW, default=None*/

                            /*
                               Indication if this configuration is valid. If
                               this isn't valid, then the port in
                               EMULATED_IO_PORT won't be intercepted. BIOS must
                               set this bit to enable PM_TMR emulation
                            */
    UINT32 Rsvd17 : 3;

                            /* Bits[19:17], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 RspDelayLoopCount : 12;

                            /* Bits[31:20], Access Type=RW, default=None*/

                            /*
                               Number of PAUSE-like delay loops that should be
                               completed before returning the response. This
                               will allow for better timing emulation of ACPI
                               timer response, which was causing issues in
                               BIOS.
                            */
    UINT32 CorrectionFactor : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /*
                               Factor to use to correct calculation of PM_TMR
                               (against TSC[CTC])
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_UCODE_PM_TMR_EMULATION_CFG_REGISTER;
/**
  This RO MSR will be used to read the Ubox MMCFG_RULE_CFG list
**/
#define ICX_MSR_MMCFG_RULE_CFG 0x00000129
/**
  This RO MSR will be used to read the Ubox MMCFG_RULE_TARGET_LIST
**/
#define ICX_MSR_MMCFG_RULE_TARGET_LIST 0x0000012A

/**
  An MSR for communicating basic policy information from the Anchor Cove ACM to early BIOS.
  Things like executing in NEM, thread protection enabled etc., will be communicated.
**/
#define ICX_MSR_ANC_SACM_INFO 0x0000013A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SacmData : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               Anchor Cove boot policy information populated by
                               the AnC StartupACM
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 AnchorCoveEnFuse : 1;

                            /* Bits[32:32], Access Type=RW, default=None*/

                            /*
                               Read-only bit to reflect the Anchor Cove enable
                               fuse
                            */
    UINT32 Pbe : 1;

                            /* Bits[33:33], Access Type=RW, default=None*/

                            /*
                               Read-only bit to reflect the PCH Protect BIOS
                               Environment bit
                            */
    UINT32 LtSxEnFuse : 1;

                            /* Bits[34:34], Access Type=RW, default=None*/

                            /* Read-only bit to reflect the LT-SX enable fuse */
    UINT32 NoResetSecretsProt : 1;

                            /* Bits[35:35], Access Type=RW, default=None*/

                            /*
                               Read-only bit to reflect no reset secrets
                               protection
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ANC_SACM_INFO_REGISTER;

/**
  SMM-only MSR which allows locking of various states while in SMM mode
**/
#define ICX_MSR_SMM_SUPOVR_STATE_LOCK 0x00000141

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PagingStates : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set, prevents changing various paging state
                               bits (CR0,CR3,CR4,EFER), and prevents task
                               switches
                            */
    UINT32 Smbase : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* When set, prevents RSM(SMI) from updating SMBASE */
    UINT32 Ia32SmmMonitorCtlMsr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set, prevents WRMSR to IA32_SMM_MONITOR_CTL
                               (aka MSEG) MSR
                            */
    UINT32 Reserved3 : 29;

                            /* Bits[31:3], Access Type=RW, default=0x00000000*/

                            /* Reserved for future usage */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_SUPOVR_STATE_LOCK_REGISTER;

/**
  BIOS Done register for CNL issue 1351547
  - Bit 0 (R/W): ENABLE_IA_UNTRUSTED
  o Cleared only by reset (cold/warm).
  o A change from 0->1 will increment BIOS_DONE_COUNTER in the SoC
  o Writes to the bit will be ignored if the EAX[0] is 0
  - Bit 1 (R): SOC_BIOS_DONE
  o Returns '1 if all available threads set their ENABLE_IA_UNTRUSTED.
  o Writes will be silently dropped.
  - Bits 31:2: Reserved - write '1 results in #GP.
**/
#define ICX_MSR_BIOS_DONE 0x00000151

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableIaUntrusted : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               o Cleared only by reset (cold/warm). o A change
                               from 0->1 will increment BIOS_DONE_COUNTER in
                               the SoC o Writes to the bit will be ignored if
                               the EAX[0] is 0
                            */
    UINT32 SocBiosDone : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000000*/

                            /*
                               o Cleared only by reset (cold/warm). o A change
                               from 0->1 will increment BIOS_DONE_COUNTER in
                               the SoC o Writes to the bit will be ignored if
                               the EAX[0] is 0
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_DONE_REGISTER;

/**
  SNC_CONFIG_BASE register decription
**/
#define ICX_MSR_SNC_CONFIG 0x00000152

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SncEnable : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /* SNC Enable bit */
    UINT32 SncIndicationEnable : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /* SNC Enable bit */
    UINT32 NumberOfClusters : 2;

                            /* Bits[3:2], Access Type=RW_V, default=0x00000000*/

                            /* Number Of Clusters */
    UINT32 Cluster1Base : 6;

                            /* Bits[9:4], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 2 Base */
    UINT32 Cluster2Base : 6;

                            /* Bits[15:10], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 3 Base */
    UINT32 Cluster3Base : 6;

                            /* Bits[21:16], Access Type=RW_V, default=0x00000000*/

                            /* Cluster 4 Base */
    UINT32 Rsvd22 : 6;

                            /* Bits[27:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SncLock : 1;

                            /* Bits[28:28], Access Type=RW_V, default=0x00000000*/

                            /*
                               Due to SKL B0 freeze this late arrving bit is
                               implemented in
                               FSCP_CR_MISC_FEATURE_ENABLES[SNC_LOCK]
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SNC_CONFIG_REGISTER;

/**
  Core SMI Error Source
**/
#define ICX_MSR_THREAD_SMI_ERR_SRC 0x00000158

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ifu : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dcu : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_THREAD_SMI_ERR_SRC_REGISTER;

/**
  SNC range upper 6 bits per range register
**/
#define ICX_MSR_SNC_UPPER_BASE 0x00000159

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 UpperBase0 : 6;

                            /* Bits[5:0], Access Type=RW_V, default=0x00000000*/

                            /* Base Address [51:46] for 1st cluster */
    UINT32 UpperBase1 : 6;

                            /* Bits[11:6], Access Type=RW_V, default=0x00000000*/

                            /* Base Address [51:46] for 2nd cluster */
    UINT32 UpperBase2 : 6;

                            /* Bits[17:12], Access Type=RW_V, default=0x00000000*/

                            /* Base Address [51:46] for 3rd cluster */
    UINT32 UpperBase3 : 6;

                            /* Bits[23:18], Access Type=RW_V, default=0x00000000*/

                            /* Base Address [51:46] for 4th cluster */
    UINT32 UpperBase4 : 6;

                            /* Bits[29:24], Access Type=RW_V, default=0x00000000*/

                            /* Base Address [51:46] for 5th cluster */
    UINT32 Rsvd30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SNC_UPPER_BASE_REGISTER;

/**
  Special uncore usage msr, work in PFAT or in SMM BIOS flash
**/
#define ICX_MSR_SPCL_UNCORE_USAGE 0x0000015B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SPCL_UNCORE_USAGE_REGISTER;

/**
  Read-only MSR that specifies the maximum number of memory controllers on the platform capable of supporting memory persistence
**/
#define ICX_MSR_PERMEM_CONFIG_INFO 0x0000015C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ControllerCount : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               maximum number of memory controllers on the
                               platform capable of supporting memory
                               persistence
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERMEM_CONFIG_INFO_REGISTER;

/**
  Index into the list of persistent memory addresses which is accessed when the PERMEM_CTRLR_ID MSR is read/written
**/
#define ICX_MSR_PERMEM_CTRLR_INDEX 0x0000015D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ControllerIndex : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /* Index into persistent memory address list */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 31;

                            /* Bits[62:32], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[63:63], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERMEM_CTRLR_INDEX_REGISTER;

/**
  Read-only MSR that specifies the maximum number of memory controllers on the platform capable of supporting memory persistence
**/
#define ICX_MSR_PERMEM_CTRLR_ID 0x0000015E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 ControllerIdentifier0 : 26;

                            /* Bits[31:6], Access Type=RW, default=None*/

                            /*
                               memory address that uniquely identifies a
                               persistent memory controller, whose index in
                               list is specified by PERMEM_CTRLR_INDEX
                            */
    UINT32 ControllerIdentifier1 : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /*
                               memory address that uniquely identifies a
                               persistent memory controller, whose index in
                               list is specified by PERMEM_CTRLR_INDEX
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERMEM_CTRLR_ID_REGISTER;

/**
  Core SMI Error Source
**/
#define ICX_MSR_CORE_SMI_ERR_SRC 0x0000017C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Dtlb : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Mlc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CORE_SMI_ERR_SRC_REGISTER;

/**
  Uncore SMI Error Source
**/
#define ICX_MSR_UNCORE_SMI_ERR_SRC 0x0000017E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 McaBankId4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId9 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId24 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 McaBankId31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_UNCORE_SMI_ERR_SRC_REGISTER;

/**
  A non-architectural, package-scoped MSR intended for use by BIOS. ERROR_CONTROL[4] is a r/w bit that defeatures CMCI.
  Storage for this bit is in the UNCORE_SCP_MISC2_CREG[4]. The bit will be saved and restored in C7+ states.
  The reset value for the bit is 0. It will not survive warm reset.
  When MSR 0x17f bit 4 is set, two actions will happen:
  1. Rdmsr to MCG_CAP will have bit 10 cleared to 0.
  2. Wrmsr to MCi_MISC2 registers will clear bits[31:0] in all modes.
**/
#define ICX_MSR_ERROR_CONTROL 0x0000017F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CmciDisable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* When set will disable CMCI signalling */
    UINT32 Rsvd5 : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 LlcEwbSraoPromote : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               For LLC EWB errors, allows EWB errors to be
                               promoted to SRAO from UCNA
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ERROR_CONTROL_REGISTER;

/**
  Legacy register holding temperature related constants for Platform use.
**/
#define ICX_MSR_TEMPERATURE_TARGET 0x000001A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TccOffsetTimeWindow : 7;

                            /* Bits[6:0], Access Type=RW_L, default=0x00000000*/

                            /* Describes the RATL averaging time window */
    UINT32 TccOffsetClampingBit : 1;

                            /* Bits[7:7], Access Type=RW_L, default=0x00000000*/

                            /* When enabled will allow RATL throttling below P1 */
    UINT32 FanTempTargetOfst : 8;

                            /* Bits[15:8], Access Type=RW_L, default=0x00000000*/

                            /*
                               Fan Temperature Target Offset (a.k.a. T-Control)
                               indicates the relative offset from the Thermal
                               Monitor Trip Temperature at which fans should be
                               engaged.
                            */
    UINT32 RefTemp : 8;

                            /* Bits[23:16], Access Type=RW_L, default=0x00000000*/

                            /*
                               This field indicates the maximum junction
                               temperature, also referred to as the Throttle
                               Temperature, TCC Activation Temperature or
                               Prochot Temperature. This is the temperature at
                               which the Adaptive Thermal Monitor is activated.
                            */
    UINT32 TjMaxTccOffset : 6;

                            /* Bits[29:24], Access Type=RW_L, default=0x00000000*/

                            /*
                               Temperature offset in degrees (C) from the TJ
                               Max. Used for throttling temperature. Will not
                               impact temperature reading. If offset is allowed
                               and set - the throttle will occur and reported
                               at lower then Tj_max.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Locked : 1;

                            /* Bits[31:31], Access Type=RW_KL, default=0x00000000*/

                            /*
                               When set, this entire register becomes read-
                               only.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TEMPERATURE_TARGET_REGISTER;

/**
  Miscellaneous Feature Control Register
**/
#define ICX_MSR_MISC_FEATURE_CONTROL 0x000001A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MlcStreamerPrefetchDisable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Set to disable MLC streamer prefetcher. */
    UINT32 MlcSpatialPrefetchDisable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set to disable MLC spatial prefetcher. */
    UINT32 DcuStreamerPrefetchDisable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Set to disable DCU streamer prefetcher. */
    UINT32 DcuIpPrefetchDisable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Set to disable DCU IP prefetcher. */
    UINT32 Rsvd4 : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Rsvd6 : 5;

                            /* Bits[10:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 DisableThreeStrikeCnt : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Prevent the Three Strike Counter from
                               incrementing
                            */
    UINT32 Rsvd12 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MISC_FEATURE_CONTROL_REGISTER;

/**
  Offcore Response Event Select Register
**/
#define ICX_MSR_OFFCORE_RSP_0 0x000001A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reqtype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Request Type: MSR Bit 0 = Demand Data Rd = DCU
                               reads (includes partials) MSR Bit 1 = Demand RFO
                               = DCU RFOs MSR Bit 2 = Demand Ifetch = IFU
                               Fetches MSR Bit 3 = Writeback = Core modified WB
                               MSR Bit 4 = PF Data Rd = MPL Reads MSR Bit 5 =
                               PF RFO = MPL RFOs MSR Bit 6 = PF Ifetch = MPL
                               Fetches MSR Bit 7 = MLC prefetch to LLC - Load
                               (exclude LRUhints) MSR Bit 8 = MLC prefetch to
                               LLC - RFO MSR Bit 9 = MLC prefetch to LLC - Code
                               MSR Bit 10 = L1 Prefetch MSR Bit 11 = Write
                               Combining MSR Bit 12 = Core non-modified WB MSR
                               Bit 13 = LLCpref of load/code/RFO MSR Bit 14 =
                               Reserved MSR Bit 15 = Other
                            */
    UINT32 Any : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Account for any snoop response from Uncore. */
    UINT32 NoSupplierDetails : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* No Supplier Details. */
    UINT32 L3HitMState : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* L3 Hit M-State. */
    UINT32 L3HitEState : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* L3 Hit E-State. */
    UINT32 L3HitSState : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* L3 Hit S-State. */
    UINT32 L3HitFState : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* L3 Hit F-State. */
    UINT32 L4HitLocalNode : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* L4 Hit Local Node. */
    UINT32 L4HitRemote0hop : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 0 Hop */
    UINT32 L4HitRemote1hop : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 1 Hop */
    UINT32 L4HitRemote2hop : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 2 Hop. */
    UINT32 LlcMissLocalNode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Local Node. */
    UINT32 LlcMissRemote0hop : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 0 Hop. */
    UINT32 LlcMissRemote1hop : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 1 Hop. */
    UINT32 LlcMissRemote2hop : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 2 or more Hop. */
    UINT32 SplHit : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* SPL Hit */
    UINT32 None : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* No details as to Snoop-related info. */
    UINT32 NotNeeded : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 Miss : 1;

                            /* Bits[33:33], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 HitNoFwd : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it Hits in at least one
                               snooped cache. Hit denotes a cache-line was
                               valid before snoop effect
                            */
    UINT32 HitWithFwd : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and data was Forwarded from a
                               remote socket.
                            */
    UINT32 Hitm : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it HitMed in local or
                               remote cache. HitM denotes a cache-line was
                               modified before snoop effect.
                            */
    UINT32 NonDram : 1;

                            /* Bits[37:37], Access Type=RW, default=0x00000000*/

                            /* Target was non-DRAM system address. */
    UINT32 Spare : 3;

                            /* Bits[40:38], Access Type=RW, default=0x00000000*/

                            /* Reserved. */
    UINT32 Rsvd41 : 23;

                            /* Bits[63:41], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_OFFCORE_RSP_0_REGISTER;

/**
  Offcore Response Event Select Register
**/
#define ICX_MSR_OFFCORE_RSP_1 0x000001A7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reqtype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Request Type: MSR Bit 0 = Demand Data Rd = DCU
                               reads (includes partials) MSR Bit 1 = Demand RFO
                               = DCU RFOs MSR Bit 2 = Demand Ifetch = IFU
                               Fetches MSR Bit 3 = Writeback = Core modified WB
                               MSR Bit 4 = PF Data Rd = MPL Reads MSR Bit 5 =
                               PF RFO = MPL RFOs MSR Bit 6 = PF Ifetch = MPL
                               Fetches MSR Bit 7 = MLC prefetch to LLC - Load
                               (exclude LRUhints) MSR Bit 8 = MLC prefetch to
                               LLC - RFO MSR Bit 9 = MLC prefetch to LLC - Code
                               MSR Bit 10 = L1 Prefetch MSR Bit 11 = Write
                               Combining MSR Bit 12 = Core non-modified WB MSR
                               Bit 13 = LLCpref of load/code/RFO MSR Bit 14 =
                               Reserved MSR Bit 15 = Other
                            */
    UINT32 Any : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Account for any snoop response from Uncore. */
    UINT32 NoSupplierDetails : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* No Supplier Details. */
    UINT32 L3HitMState : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* L3 Hit M-State. */
    UINT32 L3HitEState : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* L3 Hit E-State. */
    UINT32 L3HitSState : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* L3 Hit S-State. */
    UINT32 L3HitFState : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* L3 Hit F-State. */
    UINT32 L4HitLocalNode : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* L4 Hit Local Node. */
    UINT32 L4HitRemote0hop : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 0 Hop */
    UINT32 L4HitRemote1hop : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 1 Hop */
    UINT32 L4HitRemote2hop : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* L4 Hit 2 Hop. */
    UINT32 LlcMissLocalNode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Local Node. */
    UINT32 LlcMissRemote0hop : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 0 Hop. */
    UINT32 LlcMissRemote1hop : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 1 Hop. */
    UINT32 LlcMissRemote2hop : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* LLC Miss Remote 2 or more Hop. */
    UINT32 SplHit : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* SPL Hit */
    UINT32 None : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* No details as to Snoop-related info. */
    UINT32 NotNeeded : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 Miss : 1;

                            /* Bits[33:33], Access Type=RW, default=0x00000000*/

                            /* No snoop was neeeded to satisfy the request. */
    UINT32 HitNoFwd : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it Hits in at least one
                               snooped cache. Hit denotes a cache-line was
                               valid before snoop effect
                            */
    UINT32 HitWithFwd : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and data was Forwarded from a
                               remote socket.
                            */
    UINT32 Hitm : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000000*/

                            /*
                               A snoop was needed and it HitMed in local or
                               remote cache. HitM denotes a cache-line was
                               modified before snoop effect.
                            */
    UINT32 NonDram : 1;

                            /* Bits[37:37], Access Type=RW, default=0x00000000*/

                            /* Target was non-DRAM system address. */
    UINT32 Spare : 3;

                            /* Bits[40:38], Access Type=RW, default=0x00000000*/

                            /* Reserved. */
    UINT32 Rsvd41 : 23;

                            /* Bits[63:41], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_OFFCORE_RSP_1_REGISTER;

/**
  This MSR indicates the factory configured values for of 1-core, 2-core, 3-core and 4-core turbo ratio limits for all processors and also allows configuration of those values on parts with PLATFORM_INFO MSR 0CEh[28]==1.
**/
#define ICX_MSR_TURBO_RATIO_LIMIT 0x000001AD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MaxTurbo1Core : 8;

                            /* Bits[7:0], Access Type=RW_L, default=0x00000000*/

                            /* Maximum turbo ratio limit with 1 core active. */
    UINT32 MaxTurbo2Cores : 8;

                            /* Bits[15:8], Access Type=RW_L, default=0x00000000*/

                            /* Maximum turbo ratio limit with 2 cores active. */
    UINT32 MaxTurbo3Cores : 8;

                            /* Bits[23:16], Access Type=RW_L, default=0x00000000*/

                            /* Maximum turbo ratio limit with 3 cores active. */
    UINT32 MaxTurbo4Cores : 8;

                            /* Bits[31:24], Access Type=RW_L, default=0x00000000*/

                            /* Maximum turbo ratio limit with 4 cores active. */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TURBO_RATIO_LIMIT_REGISTER;

/**
  Current Logical Processor PM Meta Data and CTC data
**/
#define ICX_MSR_HW_GET_LP_PM_META_DATA 0x000001C2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LpId : 10;

                            /* Bits[9:0], Access Type=RO_V, default=None*/

                            /* LP ID */
    UINT32 Rsvd10 : 22;

                            /* Bits[31:10], Access Type=RO_V, default=None*/

                            /* Reserved */
    UINT32 AbsoluteTimeUponRead : 24;

                            /* Bits[55:32], Access Type=RO_V, default=None*/

                            /* Absolute time upon read */
    UINT32 Rsvd56 : 8;

                            /* Bits[63:56], Access Type=RO_V, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_HW_GET_LP_PM_META_DATA_REGISTER;

/**
  Deliver the LP PM Meta Data into the H/W
**/
#define ICX_MSR_HW_SET_LP_PM_META_DATA 0x000001C3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SetPmMetaData0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /* Set PM Meta Data */
    UINT32 SetPmMetaData1 : 24;

                            /* Bits[55:32], Access Type=RO_V, default=None*/

                            /* Set PM Meta Data */
    UINT32 OsScenario : 4;

                            /* Bits[59:56], Access Type=RO_V, default=None*/

                            /* OS Scenario */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO_V, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_HW_SET_LP_PM_META_DATA_REGISTER;

/**
  NHM creg to filter LBR writes
**/
#define ICX_MSR_LBR_SELECT 0x000001C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CplEq0 : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* filter out ring 0 branches */
    UINT32 CplNeq0 : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* filter out non-ring 0 branches */
    UINT32 Jcc : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* filter out taken conditional branches */
    UINT32 NearRelCall : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /* filter out near relative calls */
    UINT32 NearIndirectCall : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /* filter out near indirect calls */
    UINT32 NearRet : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* filter out near returns */
    UINT32 NearIndirectJmp : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* filter out near unconditional indirect jumps */
    UINT32 NearRelJmp : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* filter out near unconditional relative branches */
    UINT32 FarBranch : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* filter out far branches */
    UINT32 CallStack : 1;

                            /* Bits[9:9], Access Type=RW, default=None*/

                            /* enable LBR to only collect calls */
    UINT32 Rsvd10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_SELECT_REGISTER;

/**
  LBR creg that holds the TOS value
**/
#define ICX_MSR_LBR_TOS 0x000001C9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Tos : 5;

                            /* Bits[4:0], Access Type=RW_V, default=None*/

                            /* LBR TOS */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TOS_REGISTER;

/**
  LAST_BRANCH LBR MSR that holds non-IP information
**/
#define ICX_MSR_LAST_BRANCH_INFO 0x000001DA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RO_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RO_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RO_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RO_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_BRANCH_INFO_REGISTER;

/**
  Top of LBR Stack
**/
#define ICX_MSR_LAST_BRANCH_FROM_IP 0x000001DB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /* FROM LBR at Top of stack */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RO_V, default=None*/

                            /* FROM LBR at Top of stack */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_BRANCH_FROM_IP_REGISTER;

/**
  Top of LBR Stack
**/
#define ICX_MSR_LAST_BRANCH_TO_IP 0x000001DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=None*/

                            /* TO LBR at top of stack */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RO_V, default=None*/

                            /* TO LBR at top of stack */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_BRANCH_TO_IP_REGISTER;

/**
  Last Exeception Record
**/
#define ICX_MSR_LAST_INT_FROM_IP 0x000001DD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LoData : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* low FROM addr of Last Exeception Record */
    UINT32 HiData : 25;

                            /* Bits[56:32], Access Type=RW, default=None*/

                            /* high FROM addr of Last Exeception Record */
    UINT32 CycleCount : 3;

                            /* Bits[59:57], Access Type=RO_V, default=None*/

                            /* 3 MSBs of the cycle counter */
    UINT32 CycCtrMode : 1;

                            /* Bits[60:60], Access Type=RO_V, default=None*/

                            /* cycle counter mode */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW, default=None*/

                            /* TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW, default=None*/

                            /* ROB is in TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW, default=None*/

                            /* MBr was mispredicted */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_INT_FROM_IP_REGISTER;

/**
  Last Exeception Record
**/
#define ICX_MSR_LAST_INT_TO_IP 0x000001DE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LoData : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* low TO addr of Last Exeception Record */
    UINT32 HiData : 25;

                            /* Bits[56:32], Access Type=RW, default=None*/

                            /*
                               high TO addr of Last Exeception Record. If VAPA
                               is fuse-disabled, then bits [56:48] are also
                               part of the CYCLE_COUNT
                            */
    UINT32 CycleCount : 7;

                            /* Bits[63:57], Access Type=RW, default=None*/

                            /* Elapsed cycle counter from previous branch */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_INT_TO_IP_REGISTER;

/**
  LER MSR that holds non-IP information
**/
#define ICX_MSR_LAST_INT_INFO 0x000001E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LAST_INT_INFO_REGISTER;

/**
  Register used to enable customer specific features
**/
#define ICX_MSR_CUSTOMER_SPECIFIC_FEATURE_ENABLE 0x000001E2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* RSVD */
    UINT32 UserLevelMwaitEnable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Enable bit for user-level mwait */
    UINT32 RsvdUpper2 : 30;

                            /* Bits[31:2], Access Type=RW, default=0x00000000*/

                            /* RSVD */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CUSTOMER_SPECIFIC_FEATURE_ENABLE_REGISTER;

/**
  User-level Interrupts Vector
**/
#define ICX_MSR_ULI_VECTOR_INFO 0x000001E5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MatchVector : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Interrupt vector to match on to provide ULI
                               handling
                            */
    UINT32 Enable : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Enable bit for ULI handling */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ULI_VECTOR_INFO_REGISTER;
/**
  User-level Interrupts Target RIP
**/
#define ICX_MSR_ULI_TARGET_RIP 0x000001E7

/**
  Virtual MSR to will write data to an Crash Log configuration
  CR address is taken from CORE_CRASHLOG_CONTROL
  writing and reading CDDIS - CrashLog_Disable
**/
#define ICX_MSR_CRASHLOG_CONTROL 0x000001F1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cddis : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /*
                               CrashDump_Disable - If set, indicates that Crash
                               Dump is disabled. Default value will come from
                               the CORE_CRASHLOG_DIS fuse.
                            */
    UINT32 Reserved1 : 31;

                            /* Bits[31:1], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CRASHLOG_CONTROL_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Mask Control Register
**/
#define ICX_MSR_PRMRR_MASK 0x000001F5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 9;

                            /* Bits[8:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, PRMRR is in assist-mode - else in page
                               abort-mode (defeature only)
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the PRMRR */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the PRMRR */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR MASK bits */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR MASK bits */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_MASK_REGISTER;

/**
  Valid PRMRR configurations
**/
#define ICX_MSR_PRMRR_VALID_CONFIG 0x000001FB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Config1m : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* 1M supported MEE size */
    UINT32 Config2m : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* 2M supported MEE size */
    UINT32 Rsvd2 : 3;

                            /* Bits[4:2], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 Config32m : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* 32M supported MEE size */
    UINT32 Config64m : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* 64M supported MEE size */
    UINT32 Config128m : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* 128M supported MEE size */
    UINT32 Config256m : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* 256M supported MEE size */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RW, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_VALID_CONFIG_REGISTER;

/**
  Written by UCODE as part of the Power_CTL MSR.
  PCODE will sample this register at slow loop.
**/
#define ICX_MSR_POWER_CTL1 0x000001FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableBidirProchot : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Used to enable or disable the response to
                               PROCHOT# input. When set/enabled, platform can
                               force CPU to throttle to a lower power condition
                               such as Pn/Pm by asserting prochot#. When
                               clear/disabled (default), CPU ignores the status
                               of the prochot input signal.
                            */
    UINT32 C1eEnable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Used to enable C1E behavior on every C1 entry
                               (even if MWAIT C1E substate bit was not set or
                               when using HLT). When this package-visible bit
                               is set, it will cause CPU to switch to minimum
                               GV point when all cores have entered C1.
                               Frequency will switch immediately, followed by
                               gradual voltage switching (GV3 style).
                            */
    UINT32 SapmImcC2Policy : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               This bit determines if self-refresh activation
                               is allowed when entering Package C2 State. If it
                               is set to 0b, PCODE will keep the FORCE_SR_OFF
                               bit asserted in Package C2 State and allow its
                               negation according to the defined latency
                               negotiations with the PCH and Display Engine in
                               Package C3 and deeper states. Otherwise, self-
                               rfresh is allowed in Package C2 State.
                            */
    UINT32 FastBrkSnpEn : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               This bit controls the VID swing rate for the
                               OTHER_SNP_WAKE events that are detected by the
                               iMPH. This is the event that is detected by the
                               iMPH when a non-DMI snoopable request is
                               observed while UCLK domain is not functional. 0b
                               Use slow VID swing rate 1b Use fast VID swing
                               rate
                            */
    UINT32 FastBrkIntEn : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Reserved, not in use */
    UINT32 Rsvd5 : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PholdCstPreventionInit : 11;

                            /* Bits[16:6], Access Type=RW, default=0x00000001*/

                            /* Reserved, not in use */
    UINT32 PholdSrDisable : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Reserved, not in use */
    UINT32 PwrPerfPltfrmOvr : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[PWR_PERF_PLTFRM_OVR].
                            */
    UINT32 EeTurboDisable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[EE_TURBO_DISABLE].
                            */
    UINT32 RthDisable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[RTH_DISABLE]
                            */
    UINT32 DisProchotOut : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /* Prochot output disable */
    UINT32 ProchotResponse : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* Prochhot Configurable Response Enable */
    UINT32 ProchotLock : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, locks bits 0, 21, 22 and 23 of
                               this MSR. Once set, a reset is required to clear
                               this bit.
                            */
    UINT32 VrThermAlertDisable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, disables the VR_THERMAL_ALERT
                               signaling.
                            */
    UINT32 DisableRingEe : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[DISABLE_RING_EE]
                            */
    UINT32 DisableSaOptimization : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[DISABLE_SA_OPTIMIZATION]
                            */
    UINT32 DisableOok : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[DISABLE_OOK]
                            */
    UINT32 DisableAutonomous : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[DISABLE_AUTONOMOUS]
                            */
    UINT32 Rsvd29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CstatePrewakeDisable : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Ucode needs to copy this value to/from
                               POWER_CTL_MSR[CSTATE_PREWAKE_DISABLE].
                            */
    UINT32 ThermRsvdEn : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Thermal rsvd bit */
    UINT32 PwrPerfTuningDisableSapmCtrl : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether power perf tuning
                               algorithm controls SAPM entities
                            */
    UINT32 PwrPerfTuningEnableDynSwitching : 1;

                            /* Bits[33:33], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether dynamic switching is
                               enabled in power perf tuning algorithm
                            */
    UINT32 PwrPerfTuningCfgMode : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               was PWR_PERF_TUNING_CFG_MODE, change made to
                               match CR_47 definition
                            */
    UINT32 LtrIioDisable : 1;

                            /* Bits[35:35], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether Pcode should poll the IIO
                               for LTR updates
                            */
    UINT32 PchNegDisable : 1;

                            /* Bits[36:36], Access Type=RW, default=0x00000000*/

                            /*
                               Bit indicates whether latency should be
                               negotiated with PCH for PKGC
                            */
    UINT32 Rsvd37 : 27;

                            /* Bits[63:37], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_POWER_CTL1_REGISTER;

/**
  This register is used for generating corrected error interrupts.
  This is a 64 bits register. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_CTL2
  creg_msr_mask: 64'hFFFFFFFABFFF8000
**/
#define ICX_MSR_MC12_CTL2 0x0000028C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Correrrthrhd : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /*
                               Correctable Error Threshold (CorrErrThrhd): When
                               the correctable error count
                               (MCi_STATUS.CorrCount) transitions to being
                               equal to this threshold, a CMCI will be signaled
                               if the CorrErrCmciEn bit is set. Typically used
                               to indicate to OS that a certain amount of
                               corrected errors were observed.
                            */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Cmcien : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Interrupt Enable (CmciEn):
                               Enable CMCI signaling (when 1). Usage model is
                               to generate a CMCI interrupt for OS on corrected
                               or recoverable error. When the corrected error
                               threshold (CorrErrThrhd) is reached a CMCI will
                               be signaled.
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapcmcitocsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupt to
                               Correctable SM Interrupt (MapCmciToCsmi): If set
                               then any correctable machine check interrupt
                               will be transformed into a correctable SM
                               interrupt so BIOS can intercept it.
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapmcetomsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine Check SM
                               Interrupt (MapCmciToCsmi): If set then any
                               machine check error (i.e. a fatal condition
                               signalled to OS) will be transformed into a
                               machine check SM interrupt so BIOS can intercept
                               it.
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC12_CTL2_REGISTER;

/**
  IMCx_CR_MCx_CTL2 is responsible for enabling and controlling the CMCI mechanism and the correctable threshold value. (described in section 2.2.1 of the MCA HAS).
**/
#define ICX_MSR_IMC0_MC_CTL2 0x0000028D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CorErrCntTh : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /* Corrected error count threshold. */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CmciEn : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MapCmciToCsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupts to
                               Correctable SM Interrupts
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 MapMceToMsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine check SM
                               Interrupts
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IMC0_MC_CTL2_REGISTER;

/**
  This register is used for generating corrected error interrupts.
  This is a 64 bits register. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_CTL2
  creg_msr_mask: 64'hFFFFFFFABFFF8000
**/
#define ICX_MSR_MC16_CTL2 0x00000290

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Correrrthrhd : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /*
                               Correctable Error Threshold (CorrErrThrhd): When
                               the correctable error count
                               (MCi_STATUS.CorrCount) transitions to being
                               equal to this threshold, a CMCI will be signaled
                               if the CorrErrCmciEn bit is set. Typically used
                               to indicate to OS that a certain amount of
                               corrected errors were observed.
                            */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Cmcien : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Interrupt Enable (CmciEn):
                               Enable CMCI signaling (when 1). Usage model is
                               to generate a CMCI interrupt for OS on corrected
                               or recoverable error. When the corrected error
                               threshold (CorrErrThrhd) is reached a CMCI will
                               be signaled.
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapcmcitocsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupt to
                               Correctable SM Interrupt (MapCmciToCsmi): If set
                               then any correctable machine check interrupt
                               will be transformed into a correctable SM
                               interrupt so BIOS can intercept it.
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapmcetomsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine Check SM
                               Interrupt (MapCmciToCsmi): If set then any
                               machine check error (i.e. a fatal condition
                               signalled to OS) will be transformed into a
                               machine check SM interrupt so BIOS can intercept
                               it.
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC16_CTL2_REGISTER;

/**
  This register is used for generating corrected error interrupts.
  This is a 64 bits register. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_CTL2
  creg_msr_mask: 64'hFFFFFFFABFFF8000
**/
#define ICX_MSR_MC20_CTL2 0x00000294

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Correrrthrhd : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /*
                               Correctable Error Threshold (CorrErrThrhd): When
                               the correctable error count
                               (MCi_STATUS.CorrCount) transitions to being
                               equal to this threshold, a CMCI will be signaled
                               if the CorrErrCmciEn bit is set. Typically used
                               to indicate to OS that a certain amount of
                               corrected errors were observed.
                            */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Cmcien : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Interrupt Enable (CmciEn):
                               Enable CMCI signaling (when 1). Usage model is
                               to generate a CMCI interrupt for OS on corrected
                               or recoverable error. When the corrected error
                               threshold (CorrErrThrhd) is reached a CMCI will
                               be signaled.
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapcmcitocsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupt to
                               Correctable SM Interrupt (MapCmciToCsmi): If set
                               then any correctable machine check interrupt
                               will be transformed into a correctable SM
                               interrupt so BIOS can intercept it.
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapmcetomsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine Check SM
                               Interrupt (MapCmciToCsmi): If set then any
                               machine check error (i.e. a fatal condition
                               signalled to OS) will be transformed into a
                               machine check SM interrupt so BIOS can intercept
                               it.
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC20_CTL2_REGISTER;

/**
  This register is used for generating corrected error interrupts.
  This is a 64 bits register. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_CTL2
  creg_msr_mask: 64'hFFFFFFFABFFF8000
**/
#define ICX_MSR_MC24_CTL2 0x00000298

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Correrrthrhd : 15;

                            /* Bits[14:0], Access Type=RWS, default=0x00000000*/

                            /*
                               Correctable Error Threshold (CorrErrThrhd): When
                               the correctable error count
                               (MCi_STATUS.CorrCount) transitions to being
                               equal to this threshold, a CMCI will be signaled
                               if the CorrErrCmciEn bit is set. Typically used
                               to indicate to OS that a certain amount of
                               corrected errors were observed.
                            */
    UINT32 Rsvd15 : 15;

                            /* Bits[29:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Cmcien : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Corrected Error Interrupt Enable (CmciEn):
                               Enable CMCI signaling (when 1). Usage model is
                               to generate a CMCI interrupt for OS on corrected
                               or recoverable error. When the corrected error
                               threshold (CorrErrThrhd) is reached a CMCI will
                               be signaled.
                            */
    UINT32 Rsvd31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapcmcitocsmi : 1;

                            /* Bits[32:32], Access Type=RW, default=0x00000000*/

                            /*
                               Map Correctable Machine Check Interrupt to
                               Correctable SM Interrupt (MapCmciToCsmi): If set
                               then any correctable machine check interrupt
                               will be transformed into a correctable SM
                               interrupt so BIOS can intercept it.
                            */
    UINT32 Rsvd33 : 1;

                            /* Bits[33:33], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mapmcetomsmi : 1;

                            /* Bits[34:34], Access Type=RW, default=0x00000000*/

                            /*
                               Map Machine Check Errors to Machine Check SM
                               Interrupt (MapCmciToCsmi): If set then any
                               machine check error (i.e. a fatal condition
                               signalled to OS) will be transformed into a
                               machine check SM interrupt so BIOS can intercept
                               it.
                            */
    UINT32 Rsvd35 : 29;

                            /* Bits[63:35], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC24_CTL2_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_0 0x000002A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_0_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_1 0x000002A1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_1_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_2 0x000002A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_2_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_3 0x000002A3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_3_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_4 0x000002A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_4_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_5 0x000002A5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_5_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_6 0x000002A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_6_REGISTER;

/**
  Processor Reserved Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_PRMRR_BASE_7 0x000002A7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE MemType */
    UINT32 Configured : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* PRMRR BASE Configured */
    UINT32 Rsvd4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* PRMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRMRR_BASE_7_REGISTER;

/**
  ACM Only MSR for EDRAM management
**/
#define ICX_MSR_EDRAM_ACM 0x000002E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ForceEdramDisabled : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 EdramIsDisabled : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /* eDRAM is disabled as a result of force disable */
    UINT32 EdramExists : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*  */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EDRAM_ACM_REGISTER;
/**
  This is uncore SCP. RO MSR to provide 128 bits of external entropy used for key derivation.
**/
#define ICX_MSR_SE_EPOCH_0 0x00000300
/**
  This is uncore SCP. RO MSR to provide 128 bits of external entropy used for key derivation.
**/
#define ICX_MSR_SE_EPOCH_1 0x00000301

/**
  MSR to read and update SGX SVN by BIOS
**/
#define ICX_MSR_BIOS_SE_SVN 0x00000302

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Reserved0 : 16;

                            /* Bits[15:0], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 SinitSeSvn : 8;

                            /* Bits[23:16], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 ScleanSeSvn : 8;

                            /* Bits[31:24], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 AncSeSvn : 8;

                            /* Bits[39:32], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 PfatSeSvn : 8;

                            /* Bits[47:40], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved48 : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_BIOS_SE_SVN_REGISTER;
/**
  BOOT MSR for communicating boot protocol to MCHECK uses NcuScratchpad26
**/
#define ICX_MSR_MCHECK_BOOT_SCENARIO 0x00000304

/**
  The ROP_DETECT_CTRL is used to enable ROP detection, enable PMI exceptions
  on ROP detect, set ROP window size, determine counting method for ROP window, and
  determine if trip is due to both counting conditions being met.
**/
#define ICX_MSR_ROP_DETECT_CTRL 0x00000350

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnRopDetect : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Global enable for ROP Detect counting. */
    UINT32 EnRopExcept : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Signal ROP Event as a PMI event. (1st generation
                               soln.)
                            */
    UINT32 EnRopLbrFrz : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Enable LBR freeze on ROP threshold trip. */
    UINT32 RopGuestDisable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, ROP detection, event triggering
                               and LBR freeze actions are disabled when
                               operating at VMX non-root operation.
                            */
    UINT32 Rsvd4 : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /* Reserved bits. */
    UINT32 RopWindowSize : 10;

                            /* Bits[17:8], Access Type=RW, default=0x00000000*/

                            /*
                               ROP window size. Default is 1023. Legal range is
                               8 - 1023.
                            */
    UINT32 Rsvd18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 WindowCntSel : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               Window count select. Options are: 00 -
                               Instructions retired. 01 - Branches retired. 10
                               - Return instructions retired. 11 - Indirect
                               branches retired.
                            */
    UINT32 CntAndMode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, then threshold trip occurs only
                               if both enabled counter threshold conditions are
                               true. When set to 0, then threshold trip occurs
                               if either counter conditions are true. If a
                               counter is not enabled then it does not factor
                               into the AND logic.
                            */
    UINT32 EnRopEventFilter : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Global enable for ROP Event filtering. */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_DETECT_CTRL_REGISTER;

/**
  ROP detect status - threshold tripped, which counter tripped, and tripping count.
**/
#define ICX_MSR_ROP_DETECT_STATUS 0x00000351

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ropevent : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               A ROP event was detected. No further logging is
                               performed until event is cleared.
                            */
    UINT32 Roplbrsvalid : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000000*/

                            /*
                               Bit is set to 1 is LBR state is valid for
                               sampling by ROP monitoring s/w agent.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ropcntrhit0 : 1;

                            /* Bits[8:8], Access Type=RO_V, default=0x00000000*/

                            /* ROP Counter 0 caused threshold trip (in bit 0). */
    UINT32 Ropcntrhit1 : 1;

                            /* Bits[9:9], Access Type=RO_V, default=0x00000000*/

                            /* ROP Counter 1 caused threshold trip (in bit 0). */
    UINT32 Rsvd10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ropwindowcount : 10;

                            /* Bits[25:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               ROP Window Count. This is the current value of
                               the window to be written - not the size of the
                               window. To be written on context switch. Since
                               1024 is allowed window size, we will keep upper
                               6 bits reserved.
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ropcount0 : 8;

                            /* Bits[39:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               ROP Count. Measured count over the last window
                               period for Counter 0.
                            */
    UINT32 Ropcount1 : 8;

                            /* Bits[47:40], Access Type=RW_V, default=0x00000000*/

                            /*
                               ROP Count. Measured count over the last window
                               period for Counter 1.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_DETECT_STATUS_REGISTER;

/**
  ROP Detect Capabilities
**/
#define ICX_MSR_ROP_DETECT_CAPABILITIES 0x00000352

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RopDetect : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1 - ROP Heuristics Detection is supported 0 -
                               ROP Heuristics Detection is not supported This
                               bit reflects the value of ROP_DETECT_FUSE_ENABLE
                               fuse - Same as #GP check, therefor = 1 in ICL.
                            */
    UINT32 RopEventFiltering : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               1 - ROP Event Filtering is supported 0 - ROP
                               Event Filtering is not supported = 1 in ICL
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RopCounterNumber : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000002*/

                            /*
                               Number of supported ROP counters
                               (ROP_COUNTER_CONFIG_i MSRs) = 2 in ICL
                            */
    UINT32 RopFiltersNumber : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000001*/

                            /*
                               Number of supported ROP event filters
                               (ROP_EVENT_FILTERx MSRs) = 1 in ICL
                            */
    UINT32 Rsvd16 : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RopFilterSupported : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               Bitmask of supported ROP event filers. Each bit
                               of FilterTypesSupported filed corresponds to a
                               specific ROP event filter: 16 (Stack Pivoting
                               Detection), 17-23 reserved = '00000001 in ICL
                               (only "Stack Pivoting Detection" filter
                               supported)
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_DETECT_CAPABILITIES_REGISTER;

/**
  ROP counter enables plus select for which events to count, counter
  trip threshold, select for counting all events selected or only mispredicted
  events.
**/
#define ICX_MSR_ROP_COUNTER_CONFIG_0 0x00000354

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RopCntrEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable ROP Counter 0. */
    UINT32 RopCntrEvSel : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /*
                               ROP counter event select. Legal combinations
                               are: 0 - RET 1 - RET - Call bias 2 - RET
                               mispredicts (at retirement) 3 - Branch
                               mispredicts (at retirement) 4 - Indirect branch
                               mispredicts (at front-end) 5 - Far branch
                               instructions (at retirement) 6 - 127 - reserved
                            */
    UINT32 RopCntrThreshold : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /*
                               ROP Threshold trip count. Legal values are 0 -
                               127.
                            */
    UINT32 MispredEventCnt : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Mispredict counting behavior: 0 - all
                               mispredicts are counted in a window. 1 -
                               consecutive mispredicts are counted in a window.
                               (i.e. correctly predicted event clears the
                               count.) when operating at VMX non-root
                               operation.
                            */
    UINT32 Rsvd16 : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RopFilterEnable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               ROP filter enable for this ROP counter: 0 - No
                               additional ROP event filter is enabled for this
                               ROP counter 1 - Filter 0 is enabled for this ROP
                               counter (defined by ROP_EVENT_FILTER0)
                            */
    UINT32 Rsvd25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_COUNTER_CONFIG_0_REGISTER;

/**
  ROP counter enables plus select for which events to count, counter
  trip threshold, select for counting all events selected or only mispredicted
  events.
**/
#define ICX_MSR_ROP_COUNTER_CONFIG_1 0x00000355

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RopCntrEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable ROP Counter 1. */
    UINT32 RopCntrEvSel : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /*
                               ROP counter event select. Legal combinations
                               are: 0 - RET 1 - RET - Call bias 2 - RET
                               mispredicts (at retirement) 3 - Branch
                               mispredicts (at retirement) 4 - Indirect branch
                               mispredicts (at front-end) 5 - Far branch
                               instructions (at retirement) 6 - 127 - reserved
                            */
    UINT32 RopCntrThreshold : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /*
                               ROP Threshold trip count. Legal values are 0 -
                               127.
                            */
    UINT32 MispredEventCnt : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Mispredict counting behavior: 0 - all
                               mispredicts are counted in a window. 1 -
                               consecutive mispredicts are counted in a window.
                               (i.e. correctly predicted event clears the
                               count.) when operating at VMX non-root
                               operation.
                            */
    UINT32 Rsvd16 : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RopFilterEnable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               ROP filter enable for this ROP counter: 0 - No
                               additional ROP event filter is enabled for this
                               ROP counter 1 - Filter 0 is enabled for this ROP
                               counter (defined by ROP_EVENT_FILTER0)
                            */
    UINT32 Rsvd25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_COUNTER_CONFIG_1_REGISTER;

/**
  ROP event filter 0
**/
#define ICX_MSR_ROP_EVENT_FILTER0 0x00000360

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RopFilterType : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Type of additional ROP event filtering
                               configured 0000 - No ROP event filter is
                               configured 0001 - "Stack Pivoting Detection"
                               Heuristic
                            */
    UINT32 RopFilterHit : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               0 - Filter didn't detect ROP condition 1 -
                               Filter detected ROP condition
                            */
    UINT32 Rsvd5 : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RopStackBase0 : 24;

                            /* Bits[31:8], Access Type=RW, default=0x00000000*/

                            /*
                               Defines 256 byte aligned linear address of the
                               base of the stack range.
                            */
    UINT32 RopStackBase1 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /*
                               Defines 256 byte aligned linear address of the
                               base of the stack range.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ROP_EVENT_FILTER0_REGISTER;
/**
  ROP event filter 0 Data
**/
#define ICX_MSR_ROP_EVENT_FILTER0_DATA 0x00000361

/**
  This MSR displays the programming status of all the PerfMon counters.
  It is a per logical processor read-only MSR used to observe the ?in-use? status of all the counters at once.
  It is made architectural starting Skylake called IA32_PERF_GLOBAL_INUSE (MSR address 0x392)
**/
#define ICX_MSR_EMON_PERF_RES_PROGRAMMED 0x00000392

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnabledGenCntr : 8;

                            /* Bits[7:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               Counter is in-use for General Counters 7, 6, 5,
                               4, 3, 2 ,1, 0 respectively. A '1 indicates the
                               counter is in-use, that is the corresponding
                               CORE_CR_PERMON_EVNTSEL_CNTrX.EVENT_SELECT[7:0]
                               is non zero
                            */
    UINT32 Rsvd8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 EnabledFixedCntr : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               Counter is in-use for Fixed Counters 3, 2 ,1, 0
                               respectively. A '1 indicates the counter is in-
                               use, that is its corresponding
                               ROB1_CR_EMON_FIXED_CTR_CTRL.en_ctrX[1:0] is non
                               zero
                               CORE_CR_PERMON_EVNTSEL_CNTR.EVENT_SELECT[7:0] is
                               non zero
                            */
    UINT32 Rsvd36 : 27;

                            /* Bits[62:36], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pmi : 1;

                            /* Bits[63:63], Access Type=RO_V, default=0x00000000*/

                            /* PMI. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EMON_PERF_RES_PROGRAMMED_REGISTER;

/**
  Holds global control fields for the NCU PMON counters for IDP 0.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define ICX_MSR_PERF_CTL 0x000003B5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Thread-ID format is given as follows: [0:0]
                               T0 or T1. For GT Core this bit must be 0. [3:1]
                               Core ID. When "TID Filter Enable" is clear in
                               the Counter Control register, then the specified
                               counter will count all events. Thread-ID value
                               of 0xE is reserved for non-associated requests
                               like LLC victims and External Snoops.
                            */
    UINT32 Gtid : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When this field is set (!=0) and TID Filter
                               Enable is set, only GT events will be count.
                               When this bit unset (==0) the filtering will be
                               according to threadid field.
                            */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_CTL_REGISTER;

/**
  Precise Performance Monitoring (PPMON) Event Control.  This register is read-write.
**/
#define ICX_MSR_PEBS_FRONTEND 0x000003F7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EventId : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Choose which event to monitor (ie. 1: L1_IMISS,
                               2: MLC_MISS, 3: ITLB_MISS, 4: STLB_MISS, 5:
                               DSB_MISS, 6: IDQ_READ_BUBBLES)
                            */
    UINT32 Rsvd3 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 CriticalFilter : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When asserted, cycles occurring while IDQ is
                               empty are filtered, otherwise they are
                               monitored.
                            */
    UINT32 Rsvd5 : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 FeLatency : 12;

                            /* Bits[19:8], Access Type=RW, default=0x00000008*/

                            /*
                               Number of consecutive cycles not having less
                               than FE_THRESHOLD bubbles which must occur
                               before logging the event.
                            */
    UINT32 FeThreshold : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Number of delivery bubbles (or more) of cycles
                               to count. If number of delivery bubbles is
                               greater than or equal to this field, then count
                               it.
                            */
    UINT32 Rsvd23 : 9;

                            /* Bits[31:23], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PEBS_FRONTEND_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_PKG_C3_RESIDENCY_COUNTER 0x000003F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C3_RESIDENCY_COUNTER_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_PKG_C6_RESIDENCY_COUNTER 0x000003F9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C6_RESIDENCY_COUNTER_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_PKG_C7_RESIDENCY_COUNTER 0x000003FA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C7_RESIDENCY_COUNTER_REGISTER;

/**
  Time spent in the Core C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_CC3_RCNTR 0x000003FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=None*/

                            /* Data */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=None*/

                            /* Data */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CC3_RCNTR_REGISTER;

/**
  Time spent in the Core C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_CORE_C7_RESIDENCY_COUNTER 0x000003FE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CORE_C7_RESIDENCY_COUNTER_REGISTER;

/**
  Intel UPI MC STATUS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC5_STATUS 0x00000415

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McacodLl : 2;

                            /* Bits[1:0], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error LL */
    UINT32 McacodIi : 2;

                            /* Bits[3:2], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error II */
    UINT32 McacodRrrr : 4;

                            /* Bits[7:4], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodT : 1;

                            /* Bits[8:8], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodPp : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Int Error PPP */
    UINT32 McacodInt : 1;

                            /* Bits[11:11], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Interconnect Error */
    UINT32 McacodRsvd : 4;

                            /* Bits[15:12], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 MscodCode : 6;

                            /* Bits[21:16], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Error Code */
    UINT32 MscodSpare : 10;

                            /* Bits[31:22], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD SPARE */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /* Other Info */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Count 15-bit counter which is
                               incremented on every corrected error. MSB (bit
                               15) is a sticky overflow bit.
                            */
    UINT32 CorrErrStsInd : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*  */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Processor Context Corrupt Flag Bit set on all
                               uncorrectable errors
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /* Address Valid in KTI_MC_AD */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /* KTI_MC_MISC valid flag. */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Enable Flag Set by hardware when MCA
                               (uncorrectable) is signaled.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Uncorrected Set for error which was not
                               corrected.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /* MCA Overflow Flag Set on all second error cases */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Set by hardware when an uncorrectable or
                               correctable error is logged.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC5_STATUS_REGISTER;

/**
  Intel UPI MC ADDRESS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC5_ADDR 0x00000416

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Address4560 : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Address4561 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC5_ADDR_REGISTER;

/**
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC5_MISC 0x00000417

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FlitHdr : 20;

                            /* Bits[19:0], Access Type=RWS_V, default=0x00000000*/

                            /* HDR bits captured */
    UINT32 SyndromeOrL0cbadlanes0 : 12;

                            /* Bits[31:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 SyndromeOrL0cbadlanes1 : 4;

                            /* Bits[35:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 IllegalFlitField : 1;

                            /* Bits[36:36], Access Type=RWS_V, default=0x00000000*/

                            /*
                               For Unexpected Flit Errors this bit is set if
                               unsupported error was cause by bits not captured
                               in Flit_HDR fields.
                            */
    UINT32 PhyState : 3;

                            /* Bits[39:37], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Link State from Physical Layer on error used for
                               isolating lane in CRC error cases
                            */
    UINT32 RxLaneReversal : 1;

                            /* Bits[40:40], Access Type=RWS_V, default=0x00000000*/

                            /* Indicates if physical layer Rx is reversed */
    UINT32 Rsvd41 : 1;

                            /* Bits[41:41], Access Type=RWS, default=0x00000000*/

                            /*
                               Unset by hardware. Placeholder bit in case h/w
                               finds reason to add a HDR_Valid
                            */
    UINT32 Nerr : 12;

                            /* Bits[53:42], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures the Next Error, which is any later
                               error which occurred after the primary error was
                               logged (in mscod_code).
                            */
    UINT32 CorErr : 10;

                            /* Bits[63:54], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Correctable Errors, indicating all
                               correctable error cases that have occurred since
                               last cleared.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC5_MISC_REGISTER;

/**
  Intel UPI MC STATUS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC7_STATUS 0x0000041D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McacodLl : 2;

                            /* Bits[1:0], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error LL */
    UINT32 McacodIi : 2;

                            /* Bits[3:2], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error II */
    UINT32 McacodRrrr : 4;

                            /* Bits[7:4], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodT : 1;

                            /* Bits[8:8], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodPp : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Int Error PPP */
    UINT32 McacodInt : 1;

                            /* Bits[11:11], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Interconnect Error */
    UINT32 McacodRsvd : 4;

                            /* Bits[15:12], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 MscodCode : 6;

                            /* Bits[21:16], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Error Code */
    UINT32 MscodSpare : 10;

                            /* Bits[31:22], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD SPARE */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /* Other Info */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Count 15-bit counter which is
                               incremented on every corrected error. MSB (bit
                               15) is a sticky overflow bit.
                            */
    UINT32 CorrErrStsInd : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*  */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Processor Context Corrupt Flag Bit set on all
                               uncorrectable errors
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /* Address Valid in KTI_MC_AD */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /* KTI_MC_MISC valid flag. */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Enable Flag Set by hardware when MCA
                               (uncorrectable) is signaled.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Uncorrected Set for error which was not
                               corrected.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /* MCA Overflow Flag Set on all second error cases */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Set by hardware when an uncorrectable or
                               correctable error is logged.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC7_STATUS_REGISTER;

/**
  Intel UPI MC ADDRESS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC7_ADDR 0x0000041E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Address4560 : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Address4561 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC7_ADDR_REGISTER;

/**
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC7_MISC 0x0000041F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FlitHdr : 20;

                            /* Bits[19:0], Access Type=RWS_V, default=0x00000000*/

                            /* HDR bits captured */
    UINT32 SyndromeOrL0cbadlanes0 : 12;

                            /* Bits[31:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 SyndromeOrL0cbadlanes1 : 4;

                            /* Bits[35:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 IllegalFlitField : 1;

                            /* Bits[36:36], Access Type=RWS_V, default=0x00000000*/

                            /*
                               For Unexpected Flit Errors this bit is set if
                               unsupported error was cause by bits not captured
                               in Flit_HDR fields.
                            */
    UINT32 PhyState : 3;

                            /* Bits[39:37], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Link State from Physical Layer on error used for
                               isolating lane in CRC error cases
                            */
    UINT32 RxLaneReversal : 1;

                            /* Bits[40:40], Access Type=RWS_V, default=0x00000000*/

                            /* Indicates if physical layer Rx is reversed */
    UINT32 Rsvd41 : 1;

                            /* Bits[41:41], Access Type=RWS, default=0x00000000*/

                            /*
                               Unset by hardware. Placeholder bit in case h/w
                               finds reason to add a HDR_Valid
                            */
    UINT32 Nerr : 12;

                            /* Bits[53:42], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures the Next Error, which is any later
                               error which occurred after the primary error was
                               logged (in mscod_code).
                            */
    UINT32 CorErr : 10;

                            /* Bits[63:54], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Correctable Errors, indicating all
                               correctable error cases that have occurred since
                               last cleared.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC7_MISC_REGISTER;

/**
  Intel UPI MC STATUS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC8_STATUS 0x00000421

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 McacodLl : 2;

                            /* Bits[1:0], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error LL */
    UINT32 McacodIi : 2;

                            /* Bits[3:2], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Bus Interconnect Error II */
    UINT32 McacodRrrr : 4;

                            /* Bits[7:4], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodT : 1;

                            /* Bits[8:8], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 McacodPp : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Int Error PPP */
    UINT32 McacodInt : 1;

                            /* Bits[11:11], Access Type=RWS_V, default=0x00000000*/

                            /* MCACOD - Bus Interconnect Error */
    UINT32 McacodRsvd : 4;

                            /* Bits[15:12], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 MscodCode : 6;

                            /* Bits[21:16], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD Error Code */
    UINT32 MscodSpare : 10;

                            /* Bits[31:22], Access Type=RWS_V, default=0x00000000*/

                            /* MSCOD SPARE */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /* Other Info */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Count 15-bit counter which is
                               incremented on every corrected error. MSB (bit
                               15) is a sticky overflow bit.
                            */
    UINT32 CorrErrStsInd : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*  */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Processor Context Corrupt Flag Bit set on all
                               uncorrectable errors
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /* Address Valid in KTI_MC_AD */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /* KTI_MC_MISC valid flag. */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Enable Flag Set by hardware when MCA
                               (uncorrectable) is signaled.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error Uncorrected Set for error which was not
                               corrected.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /* MCA Overflow Flag Set on all second error cases */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Set by hardware when an uncorrectable or
                               correctable error is logged.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC8_STATUS_REGISTER;

/**
  Intel UPI MC ADDRESS Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC8_ADDR 0x00000422

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 6;

                            /* Bits[5:0], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */
    UINT32 Address4560 : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Address4561 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Tx Address 45 to 6 Note: this is only applicable
                               if KTI_MC_ST.addrv=1. If both flit slot0 and
                               slot1 hit a Tx address parity error on the same
                               cycle, slot0 is logged here.
                            */
    UINT32 Rsvd46 : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /* Field never set by hardware */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC8_ADDR_REGISTER;

/**
  Intel UPI Agents 0, 1, and 2 are assigned Machine Check Banks 5, 12, and 19, respectively.
**/
#define ICX_MSR_MC8_MISC 0x00000423

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FlitHdr : 20;

                            /* Bits[19:0], Access Type=RWS_V, default=0x00000000*/

                            /* HDR bits captured */
    UINT32 SyndromeOrL0cbadlanes0 : 12;

                            /* Bits[31:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 SyndromeOrL0cbadlanes1 : 4;

                            /* Bits[35:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Syndrome for CRC check, or in L0c error
                               captures 8-bit vector of bad lanes.
                            */
    UINT32 IllegalFlitField : 1;

                            /* Bits[36:36], Access Type=RWS_V, default=0x00000000*/

                            /*
                               For Unexpected Flit Errors this bit is set if
                               unsupported error was cause by bits not captured
                               in Flit_HDR fields.
                            */
    UINT32 PhyState : 3;

                            /* Bits[39:37], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Link State from Physical Layer on error used for
                               isolating lane in CRC error cases
                            */
    UINT32 RxLaneReversal : 1;

                            /* Bits[40:40], Access Type=RWS_V, default=0x00000000*/

                            /* Indicates if physical layer Rx is reversed */
    UINT32 Rsvd41 : 1;

                            /* Bits[41:41], Access Type=RWS, default=0x00000000*/

                            /*
                               Unset by hardware. Placeholder bit in case h/w
                               finds reason to add a HDR_Valid
                            */
    UINT32 Nerr : 12;

                            /* Bits[53:42], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures the Next Error, which is any later
                               error which occurred after the primary error was
                               logged (in mscod_code).
                            */
    UINT32 CorErr : 10;

                            /* Bits[63:54], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Captures Correctable Errors, indicating all
                               correctable error cases that have occurred since
                               last cleared.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC8_MISC_REGISTER;

/**
  The MCi MSR is a 64 bit register and contains information related to a machine check error if its
  VAL (valid) flag is set. Software is responsible for clearing the MC5_STATUS register by writing it with all
  0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the
  combination of WRMSR microcode and the CregPLA features. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_STATUS
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC12_STATUS 0x00000431

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0000 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:7] = 0000 0010 0: Near-Memory Cache
                               controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory simultaneously encounter an error of the
                               same severity for a transaction then the channel
                               number logged here is the 1st level channel.
                            */
    UINT32 Mscoddatarderr : 1;

                            /* Bits[16:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for read error (MscodDataRdErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC read
                               data error logged; 1: Error logged is an MC read
                               data error. In this implementation, 'Read'
                               refers to one of {MemSpecRd, MemRd, MemRdData,
                               MemRdXtoI/S/A, MemInv*}.
                            */
    UINT32 Rsvd17 : 1;

                            /* Bits[17:17], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Mscodptlwrerr : 1;

                            /* Bits[18:18], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for partial write error
                               (MscodPtlWrErr): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected. 0:
                               No MC partial write data error logged; 1: Error
                               logged is an MC partial write data error. In
                               this implementation, 'partial write' refers to
                               one of {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The
                               error is detected on the read data of the
                               partial write command.
                            */
    UINT32 Mscodfullwrerr : 1;

                            /* Bits[19:19], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for full write error (MscodFullWrErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC full
                               write data error logged; 1: Error logged is a
                               full write data error. Here, the term 'full
                               write' refers to one of {MemWr_I/S/A,
                               MemWrNI_I/S/A, MemWrFlush}. In case of
                               MemWrFlush, the ADDRV bit will not get set
                               because there is no relevant physical memory
                               address associated with this command. In SKX,
                               this bit will never be set as all full writes
                               are posted to the memory controller channel. Any
                               'full write' errors would get logged in the
                               memory channel controller Machine Check banks
                               instead of here.
                            */
    UINT32 Mscodbgferr : 1;

                            /* Bits[20:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for clock domains crossing error
                               (MscodBgfErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: No MC
                               cross-clock-domains buffer error logged; 1:
                               Logged an M2M clock-domain-crossing buffer (BGF)
                               error. This is a fatal error type.
                            */
    UINT32 Mscodtimeout : 1;

                            /* Bits[21:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for time out (MscodTimeout): Specifies
                               a model specific error code that uniquely
                               identifies the machine check error condition
                               that has been detected. 0: No M2M time-out
                               logged; 1: Error logged is an M2M time out. This
                               is a fatal error type.
                            */
    UINT32 Mscodparerr : 1;

                            /* Bits[22:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for M2M tracker parity error
                               (MscodParErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: An
                               M2M tracker parity error logged; 1: Error logged
                               is an M2M tracker parity error. This is a fatal
                               error type.
                            */
    UINT32 Mscodbucket1err : 1;

                            /* Bits[23:23], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Bucket1 errors (MscodBucket1Err):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No Bucket1
                               error logged; 1: Error logged is a Bucket1
                               error. This is a fatal error type. Bucket1
                               contains credit and buffer underflows and
                               overflows.
                            */
    UINT32 Mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 Mscodmiscerrs : 6;

                            /* Bits[31:26], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Miscellaneous errors
                               (MscodMiscErrs): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected.
                               For each bit in this bitvector: 0: No Misc error
                               logged; 1: Error logged is a Misc error. This
                               bitfield is unused in SKX.
                            */
    UINT32 Otherinfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this particular implementation,
                               no information is revealed in this field.
                            */
    UINT32 Corrcount : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events (except when
                               CfgMcaCountOnFailover=1), nor recoverable events
                               are counted. This count value will continue
                               being incremented until cleared by software. The
                               most significant bit, 52, is a sticky count
                               overflow bit.
                            */
    UINT32 Corrstatus : 2;

                            /* Bits[54:53], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC12_STATUS_REGISTER;

/**
  The MCi_ADDR MSR is a 64 bit register and contains the address of the memory location that
  produced the machine check error if the ADDRV flag in the MCi_STATUS register is set.
  If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be zero and,
  the MCi_ADDR value will be meaningless. The address returned is a full physical address. The upper address bits
  of this register (beyond the address size supported) are reserved for future address expansion and should
  always be set to zero by the HW. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_ADDR
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC12_ADDR 0x00000432

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvdlo0 : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */
    UINT32 Lophyaddr : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of a cache line.
                            */
    UINT32 Hiphyaddr : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 14 bits of physical
                               address [45:32] of the cache line.
                            */
    UINT32 Rsvdhi46 : 18;

                            /* Bits[63:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC12_ADDR_REGISTER;

/**
  This register is used for storing MCA miscellaneous information. Some of the errors are architectural errors,
  other errors are not.
  creg_msr_symbol: MCi_MISC
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC12_MISC 0x00000433

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addrlsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 Addrmode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 Rsvd9 : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Errortype : 10;

                            /* Bits[20:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:8]: reserved. bit7: NM$ data-only-ECC-
                               uncorrectable: Might (or not) have corrected
                               this by data supplied from FM. PCC/UC tells what
                               end-result is, whether corrected from FM or not.
                               bit6: NM$ ECC-uncorrectable fatal: persistently
                               uncorrectable meta-data or data (latter case:
                               uncorr even after reloading from FM). No good
                               data was recovered. This is a fatal condition
                               (not recoverable). bit5: Txn caused permanent
                               hardware channel failover during mirroring.
                               bit4: Scrub check rd returned uncorrected data
                               (ECC correction is enabled during scrub check
                               rd); bit3: Scrub check rd returned good data
                               (note that ECC correction is enabled during
                               scrub check rd); bit2: Txn could not be
                               corrected by ECC; bit1: Txn had an ECC corrected
                               error (corrected by ECC during retry); bit0: Txn
                               had a transient error (corrected by retry
                               without ECC). It is possible for multiple bits
                               to be set in this bitvector. For 2LM, the case
                               of bit2 set and yet corrected error is signalled
                               (PCC=0, UC=0) represents a NMcache location that
                               could not be corrected, yet the FM stored data
                               saved the day.
                            */
    UINT32 Trkid : 9;

                            /* Bits[29:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = htid within that channel.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Smiopcode0 : 1;

                            /* Bits[31:31], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smiopcode1 : 3;

                            /* Bits[34:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smimsgclass : 3;

                            /* Bits[37:35], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Message Class (SmiMsgClass): The logged
                               transaction's message class. The expectation is
                               to only see following values: 0: Request message
                               class. 5: Write-back message class.
                            */
    UINT32 Smiad : 1;

                            /* Bits[38:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI AD message (SmiAD): The logged transaction
                               came in on AD. 0: txn from BL. 1: txn from AD.
                            */
    UINT32 Mccmdvld : 1;

                            /* Bits[39:39], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so don't interpret McCmd fields.
                               1: McCmd logged; can interpret McCmd fields.
                            */
    UINT32 Mccmdopcode : 6;

                            /* Bits[45:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL. See MC_REQ_TYPE_ in mc.vh file.
                            */
    UINT32 Mccmdmemregion : 4;

                            /* Bits[49:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. {cacheable, persistent}
                               encoding: 0 = 1LM DDR4 access, 1 = DDRT access,
                               2 = DDR4 NM cache access (non-Pmem), 3 = DDR4 NM
                               cache access for Pmem.
                            */
    UINT32 Mccmdchnl : 2;

                            /* Bits[51:50], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 Rsvd52 : 5;

                            /* Bits[56:52], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Mccmdmirrregion : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 Mccmdmirrsec : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 Mccmdmirrfo : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 Dataerrorchunk : 2;

                            /* Bits[61:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Chunk containing Data Error (DataErrorChunk):
                               Cache line half on which the data error occured:
                               00: no data error. 01: a data error signal came
                               on 1st half of cache line (critical chunk). 10:
                               a data error signal came on 2nd half of cache
                               line (non-critical chunk). 11: a data error
                               signal asserted both on 1st and 2nd half of
                               cache line.
                            */
    UINT32 Mirrorcorrerr : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel.
                            */
    UINT32 Mirrorfailover : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies a non-
                               ECC-correctable error, and not correctable by
                               mirror scrub on a channel. In this context
                               mirror failover is defined as the scrub check
                               read (after scrub wr) still had a non-ECC-
                               correctable error. In case of HW permanent
                               failover, as soon as one such failover event
                               happens, permanent failover i.e. taking out a
                               complete (failed) channel takes place.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC12_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC13_CTL 0x00000434

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC13_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC13_STATUS 0x00000435

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC13_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_IMC0_MC_ADDR 0x00000436

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IMC0_MC_ADDR_REGISTER;

/**
  The MCiMISC MSR contains additional micro-architecture specific information describing the machine check error if the MISCV flag in the MCiSTATUS register is set. It is also possible to use the Other Info field in the MCiSTATUS register for the same type of model specific error reporting
**/
#define ICX_MSR_IMC0_MC_MISC 0x00000437

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RecErrLsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the LSB of the recoverable address
                               (this may differ from unit to unit). This tells
                               the OS to ignore bits from LSB-1:0
                            */
    UINT32 AddrMode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               defines the type of address captured in the
                               MC5ADDR MSR. Set by hardware, Clear by
                               programming. 000: Segment Offset 001: Linear
                               Address 010: Physical (system) Address 011:
                               Memory Address 111: Generic
                            */
    UINT32 ExtraErrInfo0 : 23;

                            /* Bits[31:9], Access Type=RWS_V, default=0x00000000*/

                            /*  */
    UINT32 ExtraErrInfo1 : 32;

                            /* Bits[63:32], Access Type=RWS_V, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IMC0_MC_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC14_CTL 0x00000438

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC14_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC14_STATUS 0x00000439

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC14_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC14_ADDR 0x0000043A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC14_ADDR_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC15_CTL 0x0000043C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC15_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC15_STATUS 0x0000043D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC15_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC15_ADDR 0x0000043E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC15_ADDR_REGISTER;

/**
  EDRAM 0 Machine Check Architecture Miscellaneous MSR.
**/
#define ICX_MSR_MC15_MISC 0x0000043F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ErrorAddress : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This field contains the address of uncorrected
                               error seen in the PCU/VCU. It is updated on an
                               uncorrectable error. To maintain e-MCA support
                               this register must be writable.
                            */
    UINT32 CorrectedErrorCount : 8;

                            /* Bits[23:16], Access Type=RWS_V, default=0x00000000*/

                            /* Corrected Error Count */
    UINT32 EnhMcaAvail0 : 8;

                            /* Bits[31:24], Access Type=RWS_V, default=0x00000000*/

                            /* Available when enhanced MCA is in use */
    UINT32 EnhMcaAvail1 : 32;

                            /* Bits[63:32], Access Type=RWS_V, default=0x00000000*/

                            /* Available when enhanced MCA is in use */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC15_MISC_REGISTER;

/**
  The MCi MSR is a 64 bit register and contains information related to a machine check error if its
  VAL (valid) flag is set. Software is responsible for clearing the MC5_STATUS register by writing it with all
  0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the
  combination of WRMSR microcode and the CregPLA features. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_STATUS
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC16_STATUS 0x00000441

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0000 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:7] = 0000 0010 0: Near-Memory Cache
                               controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory simultaneously encounter an error of the
                               same severity for a transaction then the channel
                               number logged here is the 1st level channel.
                            */
    UINT32 Mscoddatarderr : 1;

                            /* Bits[16:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for read error (MscodDataRdErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC read
                               data error logged; 1: Error logged is an MC read
                               data error. In this implementation, 'Read'
                               refers to one of {MemSpecRd, MemRd, MemRdData,
                               MemRdXtoI/S/A, MemInv*}.
                            */
    UINT32 Rsvd17 : 1;

                            /* Bits[17:17], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Mscodptlwrerr : 1;

                            /* Bits[18:18], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for partial write error
                               (MscodPtlWrErr): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected. 0:
                               No MC partial write data error logged; 1: Error
                               logged is an MC partial write data error. In
                               this implementation, 'partial write' refers to
                               one of {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The
                               error is detected on the read data of the
                               partial write command.
                            */
    UINT32 Mscodfullwrerr : 1;

                            /* Bits[19:19], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for full write error (MscodFullWrErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC full
                               write data error logged; 1: Error logged is a
                               full write data error. Here, the term 'full
                               write' refers to one of {MemWr_I/S/A,
                               MemWrNI_I/S/A, MemWrFlush}. In case of
                               MemWrFlush, the ADDRV bit will not get set
                               because there is no relevant physical memory
                               address associated with this command. In SKX,
                               this bit will never be set as all full writes
                               are posted to the memory controller channel. Any
                               'full write' errors would get logged in the
                               memory channel controller Machine Check banks
                               instead of here.
                            */
    UINT32 Mscodbgferr : 1;

                            /* Bits[20:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for clock domains crossing error
                               (MscodBgfErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: No MC
                               cross-clock-domains buffer error logged; 1:
                               Logged an M2M clock-domain-crossing buffer (BGF)
                               error. This is a fatal error type.
                            */
    UINT32 Mscodtimeout : 1;

                            /* Bits[21:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for time out (MscodTimeout): Specifies
                               a model specific error code that uniquely
                               identifies the machine check error condition
                               that has been detected. 0: No M2M time-out
                               logged; 1: Error logged is an M2M time out. This
                               is a fatal error type.
                            */
    UINT32 Mscodparerr : 1;

                            /* Bits[22:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for M2M tracker parity error
                               (MscodParErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: An
                               M2M tracker parity error logged; 1: Error logged
                               is an M2M tracker parity error. This is a fatal
                               error type.
                            */
    UINT32 Mscodbucket1err : 1;

                            /* Bits[23:23], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Bucket1 errors (MscodBucket1Err):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No Bucket1
                               error logged; 1: Error logged is a Bucket1
                               error. This is a fatal error type. Bucket1
                               contains credit and buffer underflows and
                               overflows.
                            */
    UINT32 Mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 Mscodmiscerrs : 6;

                            /* Bits[31:26], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Miscellaneous errors
                               (MscodMiscErrs): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected.
                               For each bit in this bitvector: 0: No Misc error
                               logged; 1: Error logged is a Misc error. This
                               bitfield is unused in SKX.
                            */
    UINT32 Otherinfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this particular implementation,
                               no information is revealed in this field.
                            */
    UINT32 Corrcount : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events (except when
                               CfgMcaCountOnFailover=1), nor recoverable events
                               are counted. This count value will continue
                               being incremented until cleared by software. The
                               most significant bit, 52, is a sticky count
                               overflow bit.
                            */
    UINT32 Corrstatus : 2;

                            /* Bits[54:53], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC16_STATUS_REGISTER;

/**
  The MCi_ADDR MSR is a 64 bit register and contains the address of the memory location that
  produced the machine check error if the ADDRV flag in the MCi_STATUS register is set.
  If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be zero and,
  the MCi_ADDR value will be meaningless. The address returned is a full physical address. The upper address bits
  of this register (beyond the address size supported) are reserved for future address expansion and should
  always be set to zero by the HW. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_ADDR
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC16_ADDR 0x00000442

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvdlo0 : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */
    UINT32 Lophyaddr : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of a cache line.
                            */
    UINT32 Hiphyaddr : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 14 bits of physical
                               address [45:32] of the cache line.
                            */
    UINT32 Rsvdhi46 : 18;

                            /* Bits[63:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC16_ADDR_REGISTER;

/**
  This register is used for storing MCA miscellaneous information. Some of the errors are architectural errors,
  other errors are not.
  creg_msr_symbol: MCi_MISC
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC16_MISC 0x00000443

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addrlsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 Addrmode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 Rsvd9 : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Errortype : 10;

                            /* Bits[20:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:8]: reserved. bit7: NM$ data-only-ECC-
                               uncorrectable: Might (or not) have corrected
                               this by data supplied from FM. PCC/UC tells what
                               end-result is, whether corrected from FM or not.
                               bit6: NM$ ECC-uncorrectable fatal: persistently
                               uncorrectable meta-data or data (latter case:
                               uncorr even after reloading from FM). No good
                               data was recovered. This is a fatal condition
                               (not recoverable). bit5: Txn caused permanent
                               hardware channel failover during mirroring.
                               bit4: Scrub check rd returned uncorrected data
                               (ECC correction is enabled during scrub check
                               rd); bit3: Scrub check rd returned good data
                               (note that ECC correction is enabled during
                               scrub check rd); bit2: Txn could not be
                               corrected by ECC; bit1: Txn had an ECC corrected
                               error (corrected by ECC during retry); bit0: Txn
                               had a transient error (corrected by retry
                               without ECC). It is possible for multiple bits
                               to be set in this bitvector. For 2LM, the case
                               of bit2 set and yet corrected error is signalled
                               (PCC=0, UC=0) represents a NMcache location that
                               could not be corrected, yet the FM stored data
                               saved the day.
                            */
    UINT32 Trkid : 9;

                            /* Bits[29:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = htid within that channel.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Smiopcode0 : 1;

                            /* Bits[31:31], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smiopcode1 : 3;

                            /* Bits[34:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smimsgclass : 3;

                            /* Bits[37:35], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Message Class (SmiMsgClass): The logged
                               transaction's message class. The expectation is
                               to only see following values: 0: Request message
                               class. 5: Write-back message class.
                            */
    UINT32 Smiad : 1;

                            /* Bits[38:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI AD message (SmiAD): The logged transaction
                               came in on AD. 0: txn from BL. 1: txn from AD.
                            */
    UINT32 Mccmdvld : 1;

                            /* Bits[39:39], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so don't interpret McCmd fields.
                               1: McCmd logged; can interpret McCmd fields.
                            */
    UINT32 Mccmdopcode : 6;

                            /* Bits[45:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL. See MC_REQ_TYPE_ in mc.vh file.
                            */
    UINT32 Mccmdmemregion : 4;

                            /* Bits[49:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. {cacheable, persistent}
                               encoding: 0 = 1LM DDR4 access, 1 = DDRT access,
                               2 = DDR4 NM cache access (non-Pmem), 3 = DDR4 NM
                               cache access for Pmem.
                            */
    UINT32 Mccmdchnl : 2;

                            /* Bits[51:50], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 Rsvd52 : 5;

                            /* Bits[56:52], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Mccmdmirrregion : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 Mccmdmirrsec : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 Mccmdmirrfo : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 Dataerrorchunk : 2;

                            /* Bits[61:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Chunk containing Data Error (DataErrorChunk):
                               Cache line half on which the data error occured:
                               00: no data error. 01: a data error signal came
                               on 1st half of cache line (critical chunk). 10:
                               a data error signal came on 2nd half of cache
                               line (non-critical chunk). 11: a data error
                               signal asserted both on 1st and 2nd half of
                               cache line.
                            */
    UINT32 Mirrorcorrerr : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel.
                            */
    UINT32 Mirrorfailover : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies a non-
                               ECC-correctable error, and not correctable by
                               mirror scrub on a channel. In this context
                               mirror failover is defined as the scrub check
                               read (after scrub wr) still had a non-ECC-
                               correctable error. In case of HW permanent
                               failover, as soon as one such failover event
                               happens, permanent failover i.e. taking out a
                               complete (failed) channel takes place.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC16_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC17_CTL 0x00000444

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC17_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC17_STATUS 0x00000445

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC17_STATUS_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC18_CTL 0x00000448

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC18_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC18_STATUS 0x00000449

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC18_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC18_ADDR 0x0000044A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC18_ADDR_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC19_CTL 0x0000044C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC19_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC19_STATUS 0x0000044D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC19_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC19_ADDR 0x0000044E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC19_ADDR_REGISTER;

/**
  The MCi MSR is a 64 bit register and contains information related to a machine check error if its
  VAL (valid) flag is set. Software is responsible for clearing the MC5_STATUS register by writing it with all
  0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the
  combination of WRMSR microcode and the CregPLA features. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_STATUS
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC20_STATUS 0x00000451

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0000 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:7] = 0000 0010 0: Near-Memory Cache
                               controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory simultaneously encounter an error of the
                               same severity for a transaction then the channel
                               number logged here is the 1st level channel.
                            */
    UINT32 Mscoddatarderr : 1;

                            /* Bits[16:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for read error (MscodDataRdErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC read
                               data error logged; 1: Error logged is an MC read
                               data error. In this implementation, 'Read'
                               refers to one of {MemSpecRd, MemRd, MemRdData,
                               MemRdXtoI/S/A, MemInv*}.
                            */
    UINT32 Rsvd17 : 1;

                            /* Bits[17:17], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Mscodptlwrerr : 1;

                            /* Bits[18:18], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for partial write error
                               (MscodPtlWrErr): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected. 0:
                               No MC partial write data error logged; 1: Error
                               logged is an MC partial write data error. In
                               this implementation, 'partial write' refers to
                               one of {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The
                               error is detected on the read data of the
                               partial write command.
                            */
    UINT32 Mscodfullwrerr : 1;

                            /* Bits[19:19], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for full write error (MscodFullWrErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC full
                               write data error logged; 1: Error logged is a
                               full write data error. Here, the term 'full
                               write' refers to one of {MemWr_I/S/A,
                               MemWrNI_I/S/A, MemWrFlush}. In case of
                               MemWrFlush, the ADDRV bit will not get set
                               because there is no relevant physical memory
                               address associated with this command. In SKX,
                               this bit will never be set as all full writes
                               are posted to the memory controller channel. Any
                               'full write' errors would get logged in the
                               memory channel controller Machine Check banks
                               instead of here.
                            */
    UINT32 Mscodbgferr : 1;

                            /* Bits[20:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for clock domains crossing error
                               (MscodBgfErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: No MC
                               cross-clock-domains buffer error logged; 1:
                               Logged an M2M clock-domain-crossing buffer (BGF)
                               error. This is a fatal error type.
                            */
    UINT32 Mscodtimeout : 1;

                            /* Bits[21:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for time out (MscodTimeout): Specifies
                               a model specific error code that uniquely
                               identifies the machine check error condition
                               that has been detected. 0: No M2M time-out
                               logged; 1: Error logged is an M2M time out. This
                               is a fatal error type.
                            */
    UINT32 Mscodparerr : 1;

                            /* Bits[22:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for M2M tracker parity error
                               (MscodParErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: An
                               M2M tracker parity error logged; 1: Error logged
                               is an M2M tracker parity error. This is a fatal
                               error type.
                            */
    UINT32 Mscodbucket1err : 1;

                            /* Bits[23:23], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Bucket1 errors (MscodBucket1Err):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No Bucket1
                               error logged; 1: Error logged is a Bucket1
                               error. This is a fatal error type. Bucket1
                               contains credit and buffer underflows and
                               overflows.
                            */
    UINT32 Mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 Mscodmiscerrs : 6;

                            /* Bits[31:26], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Miscellaneous errors
                               (MscodMiscErrs): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected.
                               For each bit in this bitvector: 0: No Misc error
                               logged; 1: Error logged is a Misc error. This
                               bitfield is unused in SKX.
                            */
    UINT32 Otherinfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this particular implementation,
                               no information is revealed in this field.
                            */
    UINT32 Corrcount : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events (except when
                               CfgMcaCountOnFailover=1), nor recoverable events
                               are counted. This count value will continue
                               being incremented until cleared by software. The
                               most significant bit, 52, is a sticky count
                               overflow bit.
                            */
    UINT32 Corrstatus : 2;

                            /* Bits[54:53], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC20_STATUS_REGISTER;

/**
  The MCi_ADDR MSR is a 64 bit register and contains the address of the memory location that
  produced the machine check error if the ADDRV flag in the MCi_STATUS register is set.
  If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be zero and,
  the MCi_ADDR value will be meaningless. The address returned is a full physical address. The upper address bits
  of this register (beyond the address size supported) are reserved for future address expansion and should
  always be set to zero by the HW. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_ADDR
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC20_ADDR 0x00000452

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvdlo0 : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */
    UINT32 Lophyaddr : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of a cache line.
                            */
    UINT32 Hiphyaddr : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 14 bits of physical
                               address [45:32] of the cache line.
                            */
    UINT32 Rsvdhi46 : 18;

                            /* Bits[63:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC20_ADDR_REGISTER;

/**
  This register is used for storing MCA miscellaneous information. Some of the errors are architectural errors,
  other errors are not.
  creg_msr_symbol: MCi_MISC
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC20_MISC 0x00000453

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addrlsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 Addrmode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 Rsvd9 : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Errortype : 10;

                            /* Bits[20:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:8]: reserved. bit7: NM$ data-only-ECC-
                               uncorrectable: Might (or not) have corrected
                               this by data supplied from FM. PCC/UC tells what
                               end-result is, whether corrected from FM or not.
                               bit6: NM$ ECC-uncorrectable fatal: persistently
                               uncorrectable meta-data or data (latter case:
                               uncorr even after reloading from FM). No good
                               data was recovered. This is a fatal condition
                               (not recoverable). bit5: Txn caused permanent
                               hardware channel failover during mirroring.
                               bit4: Scrub check rd returned uncorrected data
                               (ECC correction is enabled during scrub check
                               rd); bit3: Scrub check rd returned good data
                               (note that ECC correction is enabled during
                               scrub check rd); bit2: Txn could not be
                               corrected by ECC; bit1: Txn had an ECC corrected
                               error (corrected by ECC during retry); bit0: Txn
                               had a transient error (corrected by retry
                               without ECC). It is possible for multiple bits
                               to be set in this bitvector. For 2LM, the case
                               of bit2 set and yet corrected error is signalled
                               (PCC=0, UC=0) represents a NMcache location that
                               could not be corrected, yet the FM stored data
                               saved the day.
                            */
    UINT32 Trkid : 9;

                            /* Bits[29:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = htid within that channel.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Smiopcode0 : 1;

                            /* Bits[31:31], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smiopcode1 : 3;

                            /* Bits[34:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smimsgclass : 3;

                            /* Bits[37:35], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Message Class (SmiMsgClass): The logged
                               transaction's message class. The expectation is
                               to only see following values: 0: Request message
                               class. 5: Write-back message class.
                            */
    UINT32 Smiad : 1;

                            /* Bits[38:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI AD message (SmiAD): The logged transaction
                               came in on AD. 0: txn from BL. 1: txn from AD.
                            */
    UINT32 Mccmdvld : 1;

                            /* Bits[39:39], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so don't interpret McCmd fields.
                               1: McCmd logged; can interpret McCmd fields.
                            */
    UINT32 Mccmdopcode : 6;

                            /* Bits[45:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL. See MC_REQ_TYPE_ in mc.vh file.
                            */
    UINT32 Mccmdmemregion : 4;

                            /* Bits[49:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. {cacheable, persistent}
                               encoding: 0 = 1LM DDR4 access, 1 = DDRT access,
                               2 = DDR4 NM cache access (non-Pmem), 3 = DDR4 NM
                               cache access for Pmem.
                            */
    UINT32 Mccmdchnl : 2;

                            /* Bits[51:50], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 Rsvd52 : 5;

                            /* Bits[56:52], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Mccmdmirrregion : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 Mccmdmirrsec : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 Mccmdmirrfo : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 Dataerrorchunk : 2;

                            /* Bits[61:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Chunk containing Data Error (DataErrorChunk):
                               Cache line half on which the data error occured:
                               00: no data error. 01: a data error signal came
                               on 1st half of cache line (critical chunk). 10:
                               a data error signal came on 2nd half of cache
                               line (non-critical chunk). 11: a data error
                               signal asserted both on 1st and 2nd half of
                               cache line.
                            */
    UINT32 Mirrorcorrerr : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel.
                            */
    UINT32 Mirrorfailover : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies a non-
                               ECC-correctable error, and not correctable by
                               mirror scrub on a channel. In this context
                               mirror failover is defined as the scrub check
                               read (after scrub wr) still had a non-ECC-
                               correctable error. In case of HW permanent
                               failover, as soon as one such failover event
                               happens, permanent failover i.e. taking out a
                               complete (failed) channel takes place.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC20_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC21_CTL 0x00000454

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC21_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC21_STATUS 0x00000455

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC21_STATUS_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC22_CTL 0x00000458

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC22_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC22_STATUS 0x00000459

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC22_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC22_ADDR 0x0000045A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC22_ADDR_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC23_CTL 0x0000045C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC23_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC23_STATUS 0x0000045D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC23_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC23_ADDR 0x0000045E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC23_ADDR_REGISTER;

/**
  The MCi MSR is a 64 bit register and contains information related to a machine check error if its
  VAL (valid) flag is set. Software is responsible for clearing the MC5_STATUS register by writing it with all
  0's. Writing 1's to this register will cause a general protection fault to be generated. This is enforced by the
  combination of WRMSR microcode and the CregPLA features. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_STATUS
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC24_STATUS 0x00000461

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0000 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:7] = 0000 0010 0: Near-Memory Cache
                               controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory simultaneously encounter an error of the
                               same severity for a transaction then the channel
                               number logged here is the 1st level channel.
                            */
    UINT32 Mscoddatarderr : 1;

                            /* Bits[16:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for read error (MscodDataRdErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC read
                               data error logged; 1: Error logged is an MC read
                               data error. In this implementation, 'Read'
                               refers to one of {MemSpecRd, MemRd, MemRdData,
                               MemRdXtoI/S/A, MemInv*}.
                            */
    UINT32 Rsvd17 : 1;

                            /* Bits[17:17], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Mscodptlwrerr : 1;

                            /* Bits[18:18], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for partial write error
                               (MscodPtlWrErr): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected. 0:
                               No MC partial write data error logged; 1: Error
                               logged is an MC partial write data error. In
                               this implementation, 'partial write' refers to
                               one of {MemWrPtl_I/S/A, MemWrPtlNI_I/S/A}. The
                               error is detected on the read data of the
                               partial write command.
                            */
    UINT32 Mscodfullwrerr : 1;

                            /* Bits[19:19], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for full write error (MscodFullWrErr):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No MC full
                               write data error logged; 1: Error logged is a
                               full write data error. Here, the term 'full
                               write' refers to one of {MemWr_I/S/A,
                               MemWrNI_I/S/A, MemWrFlush}. In case of
                               MemWrFlush, the ADDRV bit will not get set
                               because there is no relevant physical memory
                               address associated with this command. In SKX,
                               this bit will never be set as all full writes
                               are posted to the memory controller channel. Any
                               'full write' errors would get logged in the
                               memory channel controller Machine Check banks
                               instead of here.
                            */
    UINT32 Mscodbgferr : 1;

                            /* Bits[20:20], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for clock domains crossing error
                               (MscodBgfErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: No MC
                               cross-clock-domains buffer error logged; 1:
                               Logged an M2M clock-domain-crossing buffer (BGF)
                               error. This is a fatal error type.
                            */
    UINT32 Mscodtimeout : 1;

                            /* Bits[21:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for time out (MscodTimeout): Specifies
                               a model specific error code that uniquely
                               identifies the machine check error condition
                               that has been detected. 0: No M2M time-out
                               logged; 1: Error logged is an M2M time out. This
                               is a fatal error type.
                            */
    UINT32 Mscodparerr : 1;

                            /* Bits[22:22], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for M2M tracker parity error
                               (MscodParErr): Specifies a model specific error
                               code that uniquely identifies the machine check
                               error condition that has been detected. 0: An
                               M2M tracker parity error logged; 1: Error logged
                               is an M2M tracker parity error. This is a fatal
                               error type.
                            */
    UINT32 Mscodbucket1err : 1;

                            /* Bits[23:23], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Bucket1 errors (MscodBucket1Err):
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No Bucket1
                               error logged; 1: Error logged is a Bucket1
                               error. This is a fatal error type. Bucket1
                               contains credit and buffer underflows and
                               overflows.
                            */
    UINT32 Mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 Mscodmiscerrs : 6;

                            /* Bits[31:26], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MSCOD bit for Miscellaneous errors
                               (MscodMiscErrs): Specifies a model specific
                               error code that uniquely identifies the machine
                               check error condition that has been detected.
                               For each bit in this bitvector: 0: No Misc error
                               logged; 1: Error logged is a Misc error. This
                               bitfield is unused in SKX.
                            */
    UINT32 Otherinfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this particular implementation,
                               no information is revealed in this field.
                            */
    UINT32 Corrcount : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events (except when
                               CfgMcaCountOnFailover=1), nor recoverable events
                               are counted. This count value will continue
                               being incremented until cleared by software. The
                               most significant bit, 52, is a sticky count
                               overflow bit.
                            */
    UINT32 Corrstatus : 2;

                            /* Bits[54:53], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC24_STATUS_REGISTER;

/**
  The MCi_ADDR MSR is a 64 bit register and contains the address of the memory location that
  produced the machine check error if the ADDRV flag in the MCi_STATUS register is set.
  If there is no meaningful address value for the corresponding MC Error, the ADDRV flag will be zero and,
  the MCi_ADDR value will be meaningless. The address returned is a full physical address. The upper address bits
  of this register (beyond the address size supported) are reserved for future address expansion and should
  always be set to zero by the HW. Refer to the MCA HAS for details.
  x86_architectural: true
  creg_msr_symbol: MCi_ADDR
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC24_ADDR 0x00000462

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvdlo0 : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */
    UINT32 Lophyaddr : 26;

                            /* Bits[31:6], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of a cache line.
                            */
    UINT32 Hiphyaddr : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 14 bits of physical
                               address [45:32] of the cache line.
                            */
    UINT32 Rsvdhi46 : 18;

                            /* Bits[63:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Reserved for future address expansion and should
                               always be set to zero by the HW.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC24_ADDR_REGISTER;

/**
  This register is used for storing MCA miscellaneous information. Some of the errors are architectural errors,
  other errors are not.
  creg_msr_symbol: MCi_MISC
  creg_msr_mask: 64'hFFFFFFFFFFFFFFFF
**/
#define ICX_MSR_MC24_MISC 0x00000463

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Addrlsb : 6;

                            /* Bits[5:0], Access Type=RWS_V, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 Addrmode : 3;

                            /* Bits[8:6], Access Type=RWS_V, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 Rsvd9 : 2;

                            /* Bits[10:9], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Errortype : 10;

                            /* Bits[20:11], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:8]: reserved. bit7: NM$ data-only-ECC-
                               uncorrectable: Might (or not) have corrected
                               this by data supplied from FM. PCC/UC tells what
                               end-result is, whether corrected from FM or not.
                               bit6: NM$ ECC-uncorrectable fatal: persistently
                               uncorrectable meta-data or data (latter case:
                               uncorr even after reloading from FM). No good
                               data was recovered. This is a fatal condition
                               (not recoverable). bit5: Txn caused permanent
                               hardware channel failover during mirroring.
                               bit4: Scrub check rd returned uncorrected data
                               (ECC correction is enabled during scrub check
                               rd); bit3: Scrub check rd returned good data
                               (note that ECC correction is enabled during
                               scrub check rd); bit2: Txn could not be
                               corrected by ECC; bit1: Txn had an ECC corrected
                               error (corrected by ECC during retry); bit0: Txn
                               had a transient error (corrected by retry
                               without ECC). It is possible for multiple bits
                               to be set in this bitvector. For 2LM, the case
                               of bit2 set and yet corrected error is signalled
                               (PCC=0, UC=0) represents a NMcache location that
                               could not be corrected, yet the FM stored data
                               saved the day.
                            */
    UINT32 Trkid : 9;

                            /* Bits[29:21], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = htid within that channel.
                            */
    UINT32 Rsvd30 : 1;

                            /* Bits[30:30], Access Type=RWS_V, default=0x00000000*/

                            /* This bit is reserved for future use. */
    UINT32 Smiopcode0 : 1;

                            /* Bits[31:31], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smiopcode1 : 3;

                            /* Bits[34:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 Smimsgclass : 3;

                            /* Bits[37:35], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI Message Class (SmiMsgClass): The logged
                               transaction's message class. The expectation is
                               to only see following values: 0: Request message
                               class. 5: Write-back message class.
                            */
    UINT32 Smiad : 1;

                            /* Bits[38:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               SMI AD message (SmiAD): The logged transaction
                               came in on AD. 0: txn from BL. 1: txn from AD.
                            */
    UINT32 Mccmdvld : 1;

                            /* Bits[39:39], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so don't interpret McCmd fields.
                               1: McCmd logged; can interpret McCmd fields.
                            */
    UINT32 Mccmdopcode : 6;

                            /* Bits[45:40], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL. See MC_REQ_TYPE_ in mc.vh file.
                            */
    UINT32 Mccmdmemregion : 4;

                            /* Bits[49:46], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. {cacheable, persistent}
                               encoding: 0 = 1LM DDR4 access, 1 = DDRT access,
                               2 = DDR4 NM cache access (non-Pmem), 3 = DDR4 NM
                               cache access for Pmem.
                            */
    UINT32 Mccmdchnl : 2;

                            /* Bits[51:50], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 Rsvd52 : 5;

                            /* Bits[56:52], Access Type=RWS_V, default=0x00000000*/

                            /* These bits are reserved for future use. */
    UINT32 Mccmdmirrregion : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 Mccmdmirrsec : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 Mccmdmirrfo : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 Dataerrorchunk : 2;

                            /* Bits[61:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Chunk containing Data Error (DataErrorChunk):
                               Cache line half on which the data error occured:
                               00: no data error. 01: a data error signal came
                               on 1st half of cache line (critical chunk). 10:
                               a data error signal came on 2nd half of cache
                               line (non-critical chunk). 11: a data error
                               signal asserted both on 1st and 2nd half of
                               cache line.
                            */
    UINT32 Mirrorcorrerr : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel.
                            */
    UINT32 Mirrorfailover : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies a non-
                               ECC-correctable error, and not correctable by
                               mirror scrub on a channel. In this context
                               mirror failover is defined as the scrub check
                               read (after scrub wr) still had a non-ECC-
                               correctable error. In case of HW permanent
                               failover, as soon as one such failover event
                               happens, permanent failover i.e. taking out a
                               complete (failed) channel takes place.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC24_MISC_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC25_CTL 0x00000464

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC25_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC25_STATUS 0x00000465

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC25_STATUS_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC26_CTL 0x00000468

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC26_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC26_STATUS 0x00000469

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC26_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC26_ADDR 0x0000046A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC26_ADDR_REGISTER;

/**
  The MCiCTL MSR controls the signalling of machine check exceptions generated by the bank.
**/
#define ICX_MSR_MC27_CTL 0x0000046C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DataSpareErr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data sparing
                               errors.
                            */
    UINT32 DataScrubErr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data scrubbing
                               errors.
                            */
    UINT32 DataWrtErr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for data write errors */
    UINT32 DataByteEnableErr : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for data byte enable
                               errors
                            */
    UINT32 AddrErr : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for address errors */
    UINT32 CorrRdErr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enables exception signalling for normal read
                               errors.
                            */
    UINT32 WdbParErr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WDB parity err */
    UINT32 ApppParErr : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for address path
                               parity protection err
                            */
    UINT32 Mc2lmInvalReqErr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unrecognized
                               request to 2LM controller
                            */
    UINT32 Mc2lmDatToInvalEntErr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for read response to
                               an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmUnexpectedReadrspErr : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for unexpected 2LM
                               read response
                            */
    UINT32 Mc2lmDdr4CmpErr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDR4 completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmDdrtCmpErr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRt completion
                               to an invalid 2LM scoreboard entry
                            */
    UINT32 Mc2lmFifoOvflwErr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for 2LM data or
                               completion FIFO overflow
                            */
    UINT32 VdbParErr : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               enable exception signaling for DDRT WDB parity
                               err
                            */
    UINT32 RpaParErr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for RPA parity err */
    UINT32 WpaParErr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* enable exception signaling for WPA parity err */
    UINT32 DdrtEridUc : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Enable exception signalling for ERID UC Error */
    UINT32 DdrtIntrOverflow : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for interrupt seen
                               from FNV
                            */
    UINT32 DdrtEridFifoOverflow : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for for ERID FIFO
                               overflow error
                            */
    UINT32 DdrtFnvWrCreditError : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Write credit
                               error
                            */
    UINT32 DdrtFnvRdCreditError : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Read credi
                               error
                            */
    UINT32 DdrtSchedError : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtEridPar : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 LinkFail : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for DDRT scheduler
                               error
                            */
    UINT32 DdrtFnvThermal : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exception signalling for FNV Thermal
                               event error
                            */
    UINT32 Rsvd26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC27_CTL_REGISTER;

/**
  The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set.
**/
#define ICX_MSR_MC27_STATUS 0x0000046D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mcacod : 16;

                            /* Bits[15:0], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected
                            */
    UINT32 Mscod : 16;

                            /* Bits[31:16], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected
                            */
    UINT32 OtherInfo : 6;

                            /* Bits[37:32], Access Type=RWS_V, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture.
                            */
    UINT32 CorErrCnt : 15;

                            /* Bits[52:38], Access Type=RWS_V, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 CorErrStat : 2;

                            /* Bits[54:53], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 Ar : 1;

                            /* Bits[55:55], Access Type=RWS_V, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 S : 1;

                            /* Bits[56:56], Access Type=RWS_V, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 Pcc : 1;

                            /* Bits[57:57], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 Addrv : 1;

                            /* Bits[58:58], Access Type=RWS_V, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 Miscv : 1;

                            /* Bits[59:59], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 En : 1;

                            /* Bits[60:60], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 Uc : 1;

                            /* Bits[61:61], Access Type=RWS_V, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 Over : 1;

                            /* Bits[62:62], Access Type=RWS_V, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 Valid : 1;

                            /* Bits[63:63], Access Type=RWS_V, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC27_STATUS_REGISTER;

/**
  The MCiADDR MSR contains the address of the code or data memory location that produced the machine check error if the ADDRV flag in the MCiSTATUS register is set.
**/
#define ICX_MSR_MC27_ADDR 0x0000046E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Address0 : 32;

                            /* Bits[31:0], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 Address1 : 14;

                            /* Bits[45:32], Access Type=RWS_V, default=0x00000000*/

                            /* Address associated with the error. */
    UINT32 UnimplementedUpperAddress : 18;

                            /* Bits[63:46], Access Type=RWS, default=0x00000000*/

                            /*
                               These bits are not implemented in that they will
                               never by set to one due to a detected error.
                               They can be written and read for software
                               testing.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MC27_ADDR_REGISTER;

/**
  SW opt-in for none-broadcast behavior
**/
#define ICX_MSR_MCG_EXE_CTL 0x000004D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lmce : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Local MCE SW opt-in */
    UINT32 Lmsmi : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Local MSMI SW opt-in */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MCG_EXE_CTL_REGISTER;

/**
  This CSR holds enable bits for on-chip storage of SMM and
  Code Access Check Violation features.
**/
#define ICX_MSR_SMM_FEATURE_CONTROL 0x000004E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               If Lock = 1, CPU will drop writes to the
                               register If Lock = 0, CPU will allow update to
                               b[2:0]
                            */
    UINT32 SmmCpuSaveEn : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If 0, SMI/RSM will save/restore state in SMRAM
                               If 1, SMI/RSM will save/restore state from SRAM
                            */
    UINT32 SmmCodeChkEn : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If 1, generate unrecoverable MCHK on code fetch
                               outside SMRRs If 0, do not report any errors for
                               code fetch outside SMRRs
                            */
    UINT32 Rsvd3 : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_FEATURE_CONTROL_REGISTER;

/**
  This register contains bit per logical processor indicating
  whether the logical processor is in the middle of long flow and hence
  will delay servicing of SMI. SMI will be serviced after the long flow
  completes execution.
**/
#define ICX_MSR_SMM_DELAYED 0x000004E2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LogProc : 16;

                            /* Bits[15:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit will be set at the start of the events
                               listed below and cleared at the end of the
                               events. Patch load C6 entry C6 exit WBINVD Ratio
                               Change/Throttle/S1
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_DELAYED_REGISTER;

/**
  This register contains bit per logical processor indicating
  whether the logical processor is in state where SMIs are blocked and hence
  will not be able to service SMI. SMI can be serviced after the logical
  processor exits the state in which SMIs are blocked
**/
#define ICX_MSR_SMM_BLOCKED 0x000004E3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LogProc : 16;

                            /* Bits[15:0], Access Type=RW_V, default=0x0000FFFF*/

                            /*
                               This bit will be set when the logical processor
                               is in the following states Wait For SIPI SENTER
                               Sleep VMX Abort Error Shutdown (Machine check in
                               WFS state)
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_BLOCKED_REGISTER;

/**
  Description: This SMM_ENABLE_MASK and MATCH registers are used to select threads (Logical thread Id's)
  that should be servicing a Targeted SMI. BIOS programs the MASK register to indicate which bits should
  be masked before doing a MATCH check
**/
#define ICX_MSR_SMM_ENABLE_MATCH 0x000004E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ThreadIdMatch : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               Each bit in this field corresponds to a logical
                               thread-id bit. When set, ucode masks the
                               corresponding thread-id bit before checking for
                               a match against the MATCH register during
                               targeted SMIs
                            */
    UINT32 Reserved12 : 20;

                            /* Bits[31:12], Access Type=RO, default=0x00000000*/

                            /* Reserved for future */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_ENABLE_MATCH_REGISTER;

/**
  Description: This SMM_ENABLE_MASK and MATCH registers are used to select threads (Logical thread Id's)
  that should be servicing a Targeted SMI. BIOS programs the MASK register to indicate which bits should
  be masked before doing a MATCH check
**/
#define ICX_MSR_SMM_ENABLE_MASK 0x000004EA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ThreadIdMask : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000FFF*/

                            /*
                               Each bit in this field corresponds to a logical
                               thread-id bit. When set, ucode masks the
                               corresponding thread-id bit before checking for
                               a match against the MATCH register during
                               targeted SMIs
                            */
    UINT32 Reserved12 : 20;

                            /* Bits[31:12], Access Type=RO, default=0x00000000*/

                            /* Reserved for future */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMM_ENABLE_MASK_REGISTER;

/**

**/
#define ICX_MSR_IA32_SE_SVN 0x00000500

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved1 : 15;

                            /* Bits[15:1], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 SinitSeSvn : 8;

                            /* Bits[23:16], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved24 : 8;

                            /* Bits[31:24], Access Type=RO_V, default=None*/

                            /*  */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RO_V, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_SE_SVN_REGISTER;
/**
  emulated by xucode --> cause pppe exit, described in SNC HSD 1304428988 - HCTIO/SoftCE: uArch support for TIO_DEBUG_STATUS MSRs
**/
#define ICX_MSR_TIO_PM_DEBUG_STATUS 0x0000050A

/**
  Extended Page Table Pointer
**/
#define ICX_MSR_EPTP 0x00000510

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* EPT Memory Type */
    UINT32 Rsvd3 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 EptADEnable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* EPT A/D enable */
    UINT32 EptMbeEnable : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit for EPT Mode Based Execution
                               (required also paging is ON in guest)
                            */
    UINT32 Rsvd8 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 Address0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page-Map Level-4/5 Address */
    UINT32 Address1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* Page-Map Level-4/5 Address */
    UINT32 Rsvd52 : 10;

                            /* Bits[61:52], Access Type=RW, default=0x00000000*/

                            /* Reserved bits */
    UINT32 Ept5l : 1;

                            /* Bits[62:62], Access Type=RW, default=0x00000000*/

                            /* Enable 5L EPT */
    UINT32 Enable : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /* EPT enable bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EPTP_REGISTER;

/**
  AET base address. programmed by probe mode software. cmoshe
  Ucode will use it as the address where it will send all PDM messages.
**/
#define ICX_MSR_AET_BASE_ADDRESS 0x00000521

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Valid : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Valid. Ucode will write PDMs only if valid is
                               set
                            */
    UINT32 Rsvd1 : 5;

                            /* Bits[5:1], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Address0 : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /* Base address for AET */
    UINT32 Address1 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Base address for AET */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AET_BASE_ADDRESS_REGISTER;

/**
  Core UARCH_CTL msr
**/
#define ICX_MSR_CORE_UARCH_CTL 0x00000541

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DcuScrubEn : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* L1 scrubbing enable */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CORE_UARCH_CTL_REGISTER;

/**
  PL4 limit. It is Icc limit on some power-delivery board element, mapped into W. It is proactive, instantaneous limit.
**/
#define ICX_MSR_VR_CURRENT_CONFIG 0x00000601

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CurrentLimit : 13;

                            /* Bits[12:0], Access Type=RW_L, default=0x00000000*/

                            /*
                               Current limitation in 0.125 A increments. This
                               field is locked by VR_CURRENT_CONFIG[LOCK]. When
                               the LOCK bit is set to 1b, this field becomes
                               Read Only.
                            */
    UINT32 Rsvd13 : 18;

                            /* Bits[30:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[31:31], Access Type=RWS_KL, default=0x00000000*/

                            /*
                               This bit will lock the CURRENT_LIMIT settings in
                               this register and will also lock this setting.
                               This means that once set to 1b, the
                               CURRENT_LIMIT setting and this bit become Read
                               Only until the next Warm Reset.
                            */
    UINT32 Psi1Threshold : 10;

                            /* Bits[41:32], Access Type=RW, default=0x00000000*/

                            /* Not in use */
    UINT32 Psi2Threshold : 10;

                            /* Bits[51:42], Access Type=RW, default=0x00000000*/

                            /* Not in use */
    UINT32 Psi3Threshold : 10;

                            /* Bits[61:52], Access Type=RW, default=0x00000000*/

                            /* Not in use */
    UINT32 Ps4Enable : 1;

                            /* Bits[62:62], Access Type=RW, default=0x00000000*/

                            /* Not in use */
    UINT32 Reserved63 : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_VR_CURRENT_CONFIG_REGISTER;

/**
  Input voltage regulator configuration parameters.
**/
#define ICX_MSR_VR_MISC_CONFIG 0x00000603

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DynamicLoadLineR : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000036*/

                            /*
                               The Dynamic load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 IdleLoadLineR : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000036*/

                            /*
                               The Idle load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 LeakLoadLineR : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000036*/

                            /*
                               The Leakage load line value in 10/256 mOhm
                               increments. Values range from 0 mOhm to 10 mOhm.
                            */
    UINT32 MinVid : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Used to constrain the CPU's minimum voltage
                               during package C6/C7 C-states. The default
                               setting of 0x00 will result in full CPU control
                               over the minimum VID. VID resolution is 10mV /
                               LSB. This is internally clipped by fuses to the
                               C6/C7 voltage.
                            */
    UINT32 IoutOffset : 8;

                            /* Bits[39:32], Access Type=RW, default=0x00000000*/

                            /*
                               Signed offset added to VR dIout readings for
                               correction. 2s-complement signed number
                               expressed as a fraction of the IccMax of the VR.
                               Format: S8.-4.11 (8bits, floating point shifted
                               by 4 points). Precision: 0.049% (1/2^11) Range:
                               +/-6.25% of IccMax of the VR. Allowable range
                               may be clipped by processor on a per-SKU basis.
                            */
    UINT32 IoutSlope : 10;

                            /* Bits[49:40], Access Type=RW, default=0x00000200*/

                            /*
                               This is a slope correction for VR dIout readings
                               for postitive/negative correction. This scalar
                               is applied to every dIout reading before it is
                               consumed by the CPU. This scalar represents a
                               1.x number in U10.1.9 format (0.0 to 2.0 scalar
                               in ~0.19% increments)
                            */
    UINT32 IdleExitRampRate : 1;

                            /* Bits[50:50], Access Type=RW, default=0x00000001*/

                            /*
                               Controls the VR ramp rate on package C-state
                               wake events. 1 == fast, 0 == slow. Note that
                               fast will only apply to the Fast Ramp Voltage in
                               VR_MISC_CONFIG2[7:0]
                            */
    UINT32 IdleEntryRampRate : 1;

                            /* Bits[51:51], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the VR ramp rate on package C-state
                               entry events. 1 == fast, 0 == slow. If Decay is
                               set, it has priority. These are used in package
                               C6/C7/C8/C9/C10.
                            */
    UINT32 IdleEntryDecayEnable : 1;

                            /* Bits[52:52], Access Type=RW, default=0x00000001*/

                            /*
                               Enables decay mode on package C-state entry.
                               Decay mode implies PS2 or deeper. When Decay is
                               enabled, it has priority over the
                               IDLE_ENTRY_RAMP_RATE. These are used in package
                               C6/C7/C8/C9/C10.
                            */
    UINT32 Rsvd53 : 11;

                            /* Bits[63:53], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_VR_MISC_CONFIG_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
**/
#define ICX_MSR_PKG_C2_RESIDENCY_COUNTER 0x0000060D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C2_RESIDENCY_COUNTER_REGISTER;

/**
  Read/write data from/to pcode through internal mailbox
**/
#define ICX_MSR_PL3_CONTROL 0x00000615

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PowerLimit : 15;

                            /* Bits[14:0], Access Type=RW, default=None*/

                            /*
                               PL3 or PAppMax power level. A power reading
                               above this will be interpreted as a violation
                               (in increments of 1/8th Watt, U12.3)
                            */
    UINT32 Enable : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               0 (default)=>Algorithm Disabled; 1=> Algorithm
                               Enabled
                            */
    UINT32 Reserved16 : 1;

                            /* Bits[16:16], Access Type=RW, default=None*/

                            /* Reserved . #GP if used. */
    UINT32 Timewindow : 7;

                            /* Bits[23:17], Access Type=RW, default=None*/

                            /*
                               Duration over which duty cycle control will be
                               maintained. The time is in the tau
                               format(xxYYYYY) in milliseconds
                            */
    UINT32 Dutycyle : 7;

                            /* Bits[30:24], Access Type=RW, default=None*/

                            /*
                               Expressed in percentage(U7.0%). Clipped to a max
                               value of 100%.
                            */
    UINT32 Lock : 1;

                            /* Bits[31:31], Access Type=RW, default=None*/

                            /*
                               0=> Updates to fields allowed; 1=> Interface
                               locked. Ignore any writes
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PL3_CONTROL_REGISTER;

/**
  Allows software to set power limits for
  the DRAM domain and measurement attributes associated with each limit.
**/
#define ICX_MSR_DRAM_PLANE_POWER_LIMIT 0x00000618

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 DramPpPwrLim : 15;

                            /* Bits[14:0], Access Type=RWS_L, default=0x00000000*/

                            /*
                               Power Limit[0] for DDR domain. Units=Watts,
                               Format=11.3, Resolution=0.125W,
                               Range=0-2047.875W.
                            */
    UINT32 PwrLimCtrlEn : 1;

                            /* Bits[15:15], Access Type=RWS_L, default=0x00000000*/

                            /* Power Limit[0] enable bit for DDR domain. */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CtrlTimeWin : 7;

                            /* Bits[23:17], Access Type=RWS_L, default=0x00000000*/

                            /*
                               Power Limit[0] time window Y value, for DDR
                               domain. Actual time_window for RAPL is: (1/1024
                               seconds) * (1+(x/4)) * (2^y)
                            */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 31;

                            /* Bits[62:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PpPwrLimLock : 1;

                            /* Bits[63:63], Access Type=RWS_KL, default=0x00000000*/

                            /*
                               When set, this entire register becomes read-
                               only. This bit will typically be set by BIOS
                               during boot.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_DRAM_PLANE_POWER_LIMIT_REGISTER;

/**
  This register provides additional support for BCLK overclocking
**/
#define ICX_MSR_LCLK_PLL_RATIO 0x0000061E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 LclkRatio : 2;

                            /* Bits[1:0], Access Type=RWS, default=0x00000000*/

                            /*
                               LCLK Ratio 00 - 100 MHz bclk (5:5 mapping) 01 -
                               125 MHz bclk (5:4 mapping) 10 - 166 MHz bclk
                               (5:3 mapping) 11 - 250 MHz bclk (5:2 mapping)
                            */
    UINT32 LcSbSelect : 1;

                            /* Bits[2:2], Access Type=RWS, default=0x00000000*/

                            /*
                               LC vs. SB PLL Selection (0 = LC PLL, 1 = SB
                               PLL). Default 0x0
                            */
    UINT32 LongReset : 1;

                            /* Bits[3:3], Access Type=RWS, default=0x00000000*/

                            /*
                               If set to 1, wait additional timeout before
                               relocking Gen2/Gen3/Lclk PLLs
                            */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LCLK_PLL_RATIO_REGISTER;

/**
  Current Uncore Ratio
**/
#define ICX_MSR_UNCORE_PERF_STATUS 0x00000621

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CurrentClrRatio : 7;

                            /* Bits[6:0], Access Type=RO_V, default=0x00000000*/

                            /*  */
    UINT32 Rsvd7 : 9;

                            /* Bits[15:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 LlcRingVoltage : 16;

                            /* Bits[31:16], Access Type=RO_V, default=0x00000000*/

                            /*
                               Indicates the current operating voltage in 3.13
                               , format i.e. current voltage = float([47:32] /
                               (2^13)).
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_UNCORE_PERF_STATUS_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
  For C2, this value includes any forced or popup time from other states.
  For C3/C6/C7/C8/C9/C10, this value does not include popup periods, but advances even if VR actions are disabled.
**/
#define ICX_MSR_PKG_C8_RESIDENCY_COUNTER 0x00000630

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C8_RESIDENCY_COUNTER_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
  For C2, this value includes any forced or popup time from other states.
  For C3/C6/C7/C8/C9/C10, this value does not include popup periods, but advances even if VR actions are disabled.
**/
#define ICX_MSR_PKG_C9_RESIDENCY_COUNTER 0x00000631

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C9_RESIDENCY_COUNTER_REGISTER;

/**
  Time spent in the Package C-State.  It is given in units compatible to P1 clock frequency (Guaranteed / Maximum Core Non-Turbo Frequency).
  This time will be updated by PCODE only after the C-State exit (the update of this register has lower priority than actually ensuring that the C-State exit occurs).
  For C2, this value includes any forced or popup time from other states.
  For C3/C6/C7/C8/C9/C10, this value does not include popup periods, but advances even if VR actions are disabled.
**/
#define ICX_MSR_PKG_C10_RESIDENCY_COUNTER 0x00000632

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Data1 : 28;

                            /* Bits[59:32], Access Type=RW, default=0x00000000*/

                            /* Counter Value */
    UINT32 Rsvd60 : 4;

                            /* Bits[63:60], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_C10_RESIDENCY_COUNTER_REGISTER;

/**
  The coordinated Package-Additive (above the core) Interrupt Response Time is used for BIOS runtime control.  This setting affects the selected package state.
**/
#define ICX_MSR_C_STATE_LATENCY_CONTROL_3 0x00000633

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Value : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Interrupt Response Time Limit is given in
                               units defined in the Multipler field of this
                               register.
                            */
    UINT32 Multiplier : 3;

                            /* Bits[12:10], Access Type=RW, default=0x00000000*/

                            /*
                               This field indicates the unit of measurement
                               that is defined for the Value field in this
                               register.
                            */
    UINT32 Rsvd13 : 2;

                            /* Bits[14:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Valid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field qualifies the validity of the Value
                               field in this register.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_C_STATE_LATENCY_CONTROL_3_REGISTER;

/**
  The coordinated Package-Additive (above the core) Interrupt Response Time is used for BIOS runtime control.  This setting affects the selected package state.
**/
#define ICX_MSR_C_STATE_LATENCY_CONTROL_4 0x00000634

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Value : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Interrupt Response Time Limit is given in
                               units defined in the Multipler field of this
                               register.
                            */
    UINT32 Multiplier : 3;

                            /* Bits[12:10], Access Type=RW, default=0x00000000*/

                            /*
                               This field indicates the unit of measurement
                               that is defined for the Value field in this
                               register.
                            */
    UINT32 Rsvd13 : 2;

                            /* Bits[14:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Valid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field qualifies the validity of the Value
                               field in this register.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_C_STATE_LATENCY_CONTROL_4_REGISTER;

/**
  The coordinated Package-Additive (above the core) Interrupt Response Time is used for BIOS runtime control.  This setting affects the selected package state.
**/
#define ICX_MSR_C_STATE_LATENCY_CONTROL_5 0x00000635

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Value : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Interrupt Response Time Limit is given in
                               units defined in the Multipler field of this
                               register.
                            */
    UINT32 Multiplier : 3;

                            /* Bits[12:10], Access Type=RW, default=0x00000000*/

                            /*
                               This field indicates the unit of measurement
                               that is defined for the Value field in this
                               register.
                            */
    UINT32 Rsvd13 : 2;

                            /* Bits[14:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Valid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field qualifies the validity of the Value
                               field in this register.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_C_STATE_LATENCY_CONTROL_5_REGISTER;

/**
  Input voltage regulator configuration parameters.
**/
#define ICX_MSR_VR_MISC_CONFIG2 0x00000636

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 FastRampVoltage : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This is the maximum voltage that the CPU can
                               ramp at the fast rate to.
                            */
    UINT32 MinC8Voltage : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Used to constrain the CPU's minimum voltage
                               during package C8 C-state. The default setting
                               of 0x00 will result in full CPU control over the
                               minimum VID. VID resolution is 10mV / LSB. This
                               is internally clipped by fuses to the C8 voltage
                            */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_VR_MISC_CONFIG2_REGISTER;
/**
  Defined for ULT only. Does not exist on HSW/CRW.
  This MSR is used to read out the 24MHz alternative Time Stap Counter. Owner: Jay Schwartz
**/
#define ICX_MSR_COUNTER_24MHZ 0x00000637

/**
  The PRIMARY_PLANE_TURBO_POWER_POLICY and SECONDARY_PLANE_TURBO_POWER_POLICY are used together to balance the power budget betwen the two power planes.
  The power plane with the higher policy will get a higher priority.  The default value will aim to maintain same ratio for IA and GT.
**/
#define ICX_MSR_PRIMARY_PLANE_TURBO_POWER_POLICY 0x0000063A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Priptp : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Priority Level. A higher number implies a higher
                               priority.
                            */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PRIMARY_PLANE_TURBO_POWER_POLICY_REGISTER;
/**
  Memory RAPL performance excursion counter.  This register can report the performance impact of power limiting.
**/
#define ICX_MSR_PRIMARY_PLANE_OVERFLOW_STATUS 0x0000063B

/**
  This register is used by BIOS/OS/Integrated Graphics Driver/CPM Driver to limit the power budget of the Secondary Power Plane.
  The overall package turbo power limitation is controlled by PACKAGE_RAPL_LIMIT.
**/
#define ICX_MSR_SECONDARY_PLANE_TURBO_POWER_LIMIT 0x00000640

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 NonIaPpPwrLim : 15;

                            /* Bits[14:0], Access Type=RW_L, default=0x00000000*/

                            /*
                               This is the power limitation on the Non-IA cores
                               power plane. The unit of measurement is defined
                               in PACKAGE_POWER_SKU_UNIT_MSR[PWR_UNIT].
                            */
    UINT32 PwrLimCtrlEn : 1;

                            /* Bits[15:15], Access Type=RW_L, default=0x00000000*/

                            /*
                               This bit must be set in order to limit the power
                               of the Non-IA cores power plane. 0b Non-IA cores
                               power plane power limitation is disabled 1b Non-
                               IA cores power plane power limitation is enabled
                            */
    UINT32 PpClampLim : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000000*/

                            /*
                               Power Plane Clamping limitation - Allow going
                               below P1. 0b PBM is limited between P1 and P0.
                               1b PBM can go below P1.
                            */
    UINT32 CtrlTimeWin : 7;

                            /* Bits[23:17], Access Type=RW_L, default=0x00000000*/

                            /*
                               x = CTRL_TIME_WIN[23:22] y =
                               CTRL_TIME_WIN[21:17] The timing interval window
                               is Floating Point number given by 1.x *
                               power(2,y). The unit of measurement is defined
                               in PACKAGE_POWER_SKU_UNIT_MSR[TIME_UNIT]. The
                               maximal time window is bounded by
                               PACKAGE_POWER_SKU_MSR[PKG_MAX_WIN]. The minimum
                               time window is 1 unit of measurement (as defined
                               above).
                            */
    UINT32 Rsvd24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SpPwrLimLock : 1;

                            /* Bits[31:31], Access Type=RW_KL, default=0x00000000*/

                            /*
                               When set, all settings in this register are
                               locked and are treated as Read Only.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SECONDARY_PLANE_TURBO_POWER_LIMIT_REGISTER;
/**
  Reports total energy consumed.  The counter will wrap around and continue counting when it reaches its limit.
  The energy status is reported in units which are defined in PACKAGE_POWER_SKU_UNIT_MSR[ENERGY_UNIT].
  SW will read this value and subtract the difference from last value read. The value of this register is updated every 1mSec.
  THIS REGISTER IS DUPLICATED IN THE PCU I/O SPACE, XML CHANGES MUST BE MADE IN BOTH PLACES.
**/
#define ICX_MSR_SECONDARY_PLANE_ENERGY_STATUS 0x00000641

/**
  The PRIMARY_PLANE_TURBO_POWER_POLICY and SECONDARY_PLANE_TURBO_POWER_POLICY are used together to balance the power budget betwen the two power planes.
  The power plane with the higher policy will get a higher priority.  The default value will aim to maintain same ratio for IA and GT.
**/
#define ICX_MSR_SECONDARY_PLANE_TURBO_POWER_POLICY 0x00000642

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Secptp : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000010*/

                            /*
                               Priority Level. A higher number implies a higher
                               priority.
                            */
    UINT32 Rsvd5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SECONDARY_PLANE_TURBO_POWER_POLICY_REGISTER;

/**
  Level 1 configurable TDP settings
**/
#define ICX_MSR_CONFIG_TDP_LEVEL1 0x00000649

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PkgTdp : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power for this TDP level. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT] Similar to
                               PACKAGE_POWER_SKU[PKG_TDP]
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 TdpRatio : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* TDP ratio for config tdp level 1. */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMaxPwr : 15;

                            /* Bits[46:32], Access Type=RW, default=0x00000000*/

                            /*
                               Max pkg power setting allowed for this config
                               TDP level1. Higher values will be clamped down
                               to this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MAX_PWR].
                            */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMinPwr : 15;

                            /* Bits[62:48], Access Type=RW, default=0x00000000*/

                            /*
                               Min pkg power setting allowed for this config
                               TDP level. Lower values will be clamped up to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MIN_PWR].
                            */
    UINT32 Rsvd63 : 1;

                            /* Bits[63:63], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CONFIG_TDP_LEVEL1_REGISTER;

/**
  Level 2 configurable TDP settings
**/
#define ICX_MSR_CONFIG_TDP_LEVEL2 0x0000064A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PkgTdp : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power for this TDP level. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT] Similar to
                               PACKAGE_POWER_SKU[PKG_TDP].
                            */
    UINT32 Rsvd15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 TdpRatio : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* TDP ratio for level 2. */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMaxPwr : 15;

                            /* Bits[46:32], Access Type=RW, default=0x00000000*/

                            /*
                               Max pkg power setting allowed for config TDP
                               level 2. Higher values will be clamped down to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MAX_PWR].
                            */
    UINT32 Rsvd47 : 1;

                            /* Bits[47:47], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PkgMinPwr : 15;

                            /* Bits[62:48], Access Type=RW, default=0x00000000*/

                            /*
                               Min pkg power setting allowed for this config
                               TDP level 2. Lower values will be clamped up to
                               this value. Units defined in
                               PACKAGE_POWER_SKU_MSR[PWR_UNIT]. Similar to
                               PACKAGE_POWER_SKU[PKG_MIN_PWR].
                            */
    UINT32 Rsvd63 : 1;

                            /* Bits[63:63], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CONFIG_TDP_LEVEL2_REGISTER;

/**
  Provides addtional HWP insight when performance limited
**/
#define ICX_MSR_IA_PERF_LIMIT_REASONS2 0x0000064D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*  */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA_PERF_LIMIT_REASONS2_REGISTER;

/**
  Enables tune  options for the  SDC operation.
**/
#define ICX_MSR_PKG_SDC_CONFIG_CONTROL 0x00000652

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SdcCxMonitor : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000002*/

                            /*
                               Controls the PKG_SDC_DEEP_RESIDENCY the Cx
                               threshold that >= counts pkg Cx residency due
                               forced idle Cx event: 0x0 no-counting, 0x1 PC2R
                               only, 0x2 PC3 and deep, 0x3 PC6 and deep, 0x4
                               PC7 and deep. Default=0x0
                            */
    UINT32 SdcMcntCountMethod : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Controls if MCNT will increment or not during
                               SDC forced idle time (default=0 meaning 'tick')
                            */
    UINT32 SdcRespectOsMin : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               As part of eco#5311742 this bit is used for QoS
                               protection. Controls if SDC respects the O/S Min
                               Ratio Request, as provided by HWP or Legacy
                               interface. If this bit is set, SDC will not push
                               the effective average frequency, which takes off
                               time as freq=0 into account, to be lower than
                               O/S Min request.
                            */
    UINT32 SdcMaxForceIdleDurationTime : 6;

                            /* Bits[10:5], Access Type=RW, default=0x00000000*/

                            /*
                               Limits the SDC max duration idle time (50usec
                               units). The default value is 0x0, meaning min
                               SDC duty cycles idle time default value to be
                               set by pcode (e.g. 800usec)
                            */
    UINT32 Spare2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* SPARE2. */
    UINT32 SdcDirectControl : 7;

                            /* Bits[18:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFT FIELD: Overrides the H/W Heuristics with S/W
                               defined SDC control %. The units are 1/ 127
                               (0x7F=100%). A value of 0x0 means that SDC is
                               not requested. SDC due to RAPL power limitation
                               will not be affected by this setting. Default is
                               0x0
                            */
    UINT32 MinActiveTime : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               Limits the forced idle min duration active time
                               (50usec units) starting 100usec as the lowest
                               value. The default value is 0x0, means min SDC
                               duty cycles active time default value to be set
                               by pcode (e.g. 250usec). Default value is 0x0.
                            */
    UINT32 Spare3 : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000000*/

                            /* SPARE3. */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PKG_SDC_CONFIG_CONTROL_REGISTER;

/**
  Contains software threads information for the current ia_thread.
**/
#define ICX_MSR_THREAD_INFO 0x00000654

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ProcessId : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /*
                               S/W Process ID (R/W): monitor the process the
                               current thread belongs to
                            */
    UINT32 ThreadPriority : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /*
                               Thread priority: Lowest - 0, priority - 15:
                               Highest priority
                            */
    UINT32 ThreadProcessType : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Multi-Threaded: 0x1, Process Uses GFX: 0x2,
                               Consumer/Producer: 0x3
                            */
    UINT32 SwThreadId : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* S/W Thread ID (R/W): monitor the current thread */
    UINT32 Spare : 12;

                            /* Bits[63:52], Access Type=RW, default=0x00000000*/

                            /* Spare */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_THREAD_INFO_REGISTER;
/**
  PKG shallow CX cycles Residency Counter.
**/
#define ICX_MSR_PKG_SDC_SHALLOW_RESIDENCY 0x00000655
/**
  PKG Deep CX duty cycles Residency Counter
**/
#define ICX_MSR_PKG_SDC_DEEP_RESIDENCY 0x00000656
/**
  Sum the cycles per number of  active cores
**/
#define ICX_MSR_PKG_IA_C0_ANY_SUM 0x00000658
/**
  C0.Any - Sum the cycles of any active cores.
**/
#define ICX_MSR_PKG_IA_C0_ANY 0x00000659
/**
  Sum the cycles of active GT
**/
#define ICX_MSR_PKG_GT_C0_ANY 0x0000065A
/**
  Sum the cycles of overlap time between any IA cores and GT
**/
#define ICX_MSR_PKG_GT_AND_IA_OVERLAP 0x0000065B

/**
  Platform power limit
**/
#define ICX_MSR_PLATFORM_POWER_LIMIT 0x0000065C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PowerLimit1 : 15;

                            /* Bits[14:0], Access Type=RW_L, default=0x00000000*/

                            /*
                               Average Power limit value which the Platform
                               must not exceed over a time window as specified
                               by Power_Limit_1_TIME field above.
                            */
    UINT32 PowerLimit1En : 1;

                            /* Bits[15:15], Access Type=RW_L, default=0x00000000*/

                            /*
                               When set, enables processor to apply control
                               policies such that the Platform average power
                               does not exceed Power_Limit_1 value over an
                               exponential weighted moving average of the time
                               window.
                            */
    UINT32 CriticalPowerClamp1 : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000000*/

                            /*
                               When set, allows processor to go below the OS
                               requested P States in order to maintain the
                               power below Power_Limit_1 value specified below.
                            */
    UINT32 PowerLimit1Time : 7;

                            /* Bits[23:17], Access Type=RW_L, default=0x0000000A*/

                            /*
                               This indicates the time window over which
                               Power_Limit_1 value should be maintained.
                            */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PowerLimit2 : 15;

                            /* Bits[46:32], Access Type=RW_L, default=0x00000000*/

                            /*
                               Duration Power limit value which the Platform
                               must not exceed. This field is specified in the
                               units as identified by the
                               PALTFORM_POWER_SKU_UNIT (MSR606h).
                            */
    UINT32 PowerLimit2En : 1;

                            /* Bits[47:47], Access Type=RW_L, default=0x00000000*/

                            /*
                               When set, enables processor to apply control
                               policies such that the platform power does not
                               exceed Power_Limit_2 value.
                            */
    UINT32 CriticalPowerClamp2 : 1;

                            /* Bits[48:48], Access Type=RW_L, default=0x00000000*/

                            /*
                               When set, allows processor to go below the OS
                               requested P States in order to maintain the
                               power below Power_Limit_2 value specified below.
                            */
    UINT32 Rsvd49 : 14;

                            /* Bits[62:49], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Lock : 1;

                            /* Bits[63:63], Access Type=RW_KL, default=0x00000000*/

                            /* Locks all other fields. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PLATFORM_POWER_LIMIT_REGISTER;

/**
  DCRA Dirty bits status register
**/
#define ICX_MSR_DISTRIBUTED_STATUS 0x0000065E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cr0 : 1;

                            /* Bits[0:0], Access Type=RO_V, default=0x00000000*/

                            /* CR0 Dirty Bit */
    UINT32 Cr1 : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000000*/

                            /* CR1 Dirty Bit */
    UINT32 Cr2 : 1;

                            /* Bits[2:2], Access Type=RO_V, default=0x00000000*/

                            /* CR2 Dirty Bit */
    UINT32 Cr3 : 1;

                            /* Bits[3:3], Access Type=RO_V, default=0x00000000*/

                            /* CR3 Dirty Bit */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO_V, default=0x00000000*/

                            /* Status CR rsvd Bits */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_DISTRIBUTED_STATUS_REGISTER;

/**
  Fast wrmsr/rdmsr enumeration MSR. This is read-only MSR. Each bit refers to one MSR and indicate if this MSR
  is enabled to be use in FAST_UNCORE_MSRS. Currently , bit 0 refers to IA32_HWP_REQUEST , while bit 1 refers to THREAD_INFO MSR
**/
#define ICX_MSR_FAST_UNCORE_MSRS_CAPABILITY 0x0000065F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MsrsCapability : 4;

                            /* Bits[3:0], Access Type=RO_V, default=None*/

                            /*
                               each bit represents one MSR and holds if this
                               MSR is supported in FAST_UNCORE_MSRS mode
                            */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FAST_UNCORE_MSRS_CAPABILITY_REGISTER;

/**
  LBR MSR that holds the from IP, canonical check for write, see Vol 3A
**/
#define ICX_MSR_LBR_FROM_IP_0 0x00000680

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_0_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_1 0x00000681

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_1_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_2 0x00000682

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_2_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_3 0x00000683

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_3_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_4 0x00000684

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_4_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_5 0x00000685

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_5_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_6 0x00000686

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_6_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_7 0x00000687

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_7_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_8 0x00000688

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_8_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_9 0x00000689

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_9_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_10 0x0000068A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_10_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_11 0x0000068B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_11_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_12 0x0000068C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_12_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_13 0x0000068D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_13_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_14 0x0000068E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_14_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_15 0x0000068F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_15_REGISTER;

/**
  LBR MSR that holds the from IP, canonical check for write, see Vol 3A
**/
#define ICX_MSR_LBR_FROM_IP_16 0x00000690

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_16_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_17 0x00000691

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 16;

                            /* Bits[63:48], Access Type=RO_V, default=None*/

                            /* sign extension of bit 47 */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_17_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_18 0x00000692

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_18_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_19 0x00000693

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_19_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_20 0x00000694

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_20_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_21 0x00000695

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_21_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_22 0x00000696

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_22_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_23 0x00000697

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_23_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_24 0x00000698

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_24_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_25 0x00000699

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_25_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_26 0x0000069A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_26_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_27 0x0000069B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_27_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_28 0x0000069C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_28_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_29 0x0000069D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_29_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_30 0x0000069E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_30_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_FROM_IP_31 0x0000069F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* From IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_FROM_IP_31_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_0 0x000006C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_0_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_1 0x000006C1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_1_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_2 0x000006C2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_2_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_3 0x000006C3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_3_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_4 0x000006C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_4_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_5 0x000006C5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_5_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_6 0x000006C6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_6_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_7 0x000006C7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_7_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_8 0x000006C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_8_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_9 0x000006C9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_9_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_10 0x000006CA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_10_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_11 0x000006CB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_11_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_12 0x000006CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_12_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_13 0x000006CD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_13_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_14 0x000006CE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_14_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_15 0x000006CF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_15_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_16 0x000006D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_16_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_17 0x000006D1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_17_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_18 0x000006D2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_18_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_19 0x000006D3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_19_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_20 0x000006D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_20_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_21 0x000006D5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_21_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_22 0x000006D6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_22_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_23 0x000006D7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_23_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_24 0x000006D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_24_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_25 0x000006D9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_25_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_26 0x000006DA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_26_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_27 0x000006DB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_27_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_28 0x000006DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_28_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_29 0x000006DD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_29_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_30 0x000006DE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_30_REGISTER;

/**
  LBR MSR that holds the from IP
**/
#define ICX_MSR_LBR_TO_IP_31 0x000006DF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Data0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 Data1 : 25;

                            /* Bits[56:32], Access Type=RW_V, default=None*/

                            /* Target IP */
    UINT32 SignExt : 7;

                            /* Bits[63:57], Access Type=RO_V, default=None*/

                            /*
                               sign extension of bit 56 (VAPA fuse-enabled) or
                               bit 47 (VAPA fuse-disabled)
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_TO_IP_31_REGISTER;

/**
  Global PMON
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define ICX_MSR_PERF_GLOBAL_CTRL 0x00000700

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmiselc0 : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc1 : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc2 : 1;

                            /* Bits[2:2], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc3 : 1;

                            /* Bits[3:3], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc4 : 1;

                            /* Bits[4:4], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc5 : 1;

                            /* Bits[5:5], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc6 : 1;

                            /* Bits[6:6], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc7 : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc8 : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc9 : 1;

                            /* Bits[9:9], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc10 : 1;

                            /* Bits[10:10], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc11 : 1;

                            /* Bits[11:11], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc12 : 1;

                            /* Bits[12:12], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc13 : 1;

                            /* Bits[13:13], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc14 : 1;

                            /* Bits[14:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc15 : 1;

                            /* Bits[15:15], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc16 : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc17 : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc18 : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc19 : 1;

                            /* Bits[19:19], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc20 : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc21 : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc22 : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc23 : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc24 : 1;

                            /* Bits[24:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc25 : 1;

                            /* Bits[25:25], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc26 : 1;

                            /* Bits[26:26], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc27 : 1;

                            /* Bits[27:27], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc28 : 1;

                            /* Bits[28:28], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc29 : 1;

                            /* Bits[29:29], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc30 : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc31 : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc32 : 1;

                            /* Bits[32:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc33 : 1;

                            /* Bits[33:33], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc34 : 1;

                            /* Bits[34:34], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc35 : 1;

                            /* Bits[35:35], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc36 : 1;

                            /* Bits[36:36], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc37 : 1;

                            /* Bits[37:37], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc38 : 1;

                            /* Bits[38:38], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc39 : 1;

                            /* Bits[39:39], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc40 : 1;

                            /* Bits[40:40], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc41 : 1;

                            /* Bits[41:41], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc42 : 1;

                            /* Bits[42:42], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc43 : 1;

                            /* Bits[43:43], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Pmiselc44 : 1;

                            /* Bits[44:44], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enables sending the PMI to the respective core.
                               If WakeOnPMI is '1' a wake request is sent to
                               any sleeping core within the mask prior to
                               sending the event. Otherwise, the PMON event is
                               sent to all waken cores within the mask. The PMI
                               event is sent as a set of un-cast messages to
                               the targ 0 - Don't send event to the core
                               (default) 1 - Send event to the core
                            */
    UINT32 Rsvd45 : 14;

                            /* Bits[58:45], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Resetcntrs : 1;

                            /* Bits[59:59], Access Type=WO, default=0x00000000*/

                            /*
                               ResetCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be frozen. 0 : No
                               effect 1 : Reset all the perfmon counters
                            */
    UINT32 Pmiovfenubp : 1;

                            /* Bits[60:60], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable the generation of uBP event when set. 0 -
                               Does not assert uBP event with the PMI Overflow.
                               1 - Assert uBP event with the PMI Overflow is
                               set.
                            */
    UINT32 Unfrzcountr : 1;

                            /* Bits[61:61], Access Type=WO, default=0x00000000*/

                            /*
                               UnfreezCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be unfrozen. 0 :
                               No effect 1 : Unfreeze all the perfmon counters,
                               start counting
                            */
    UINT32 Wkonpmi : 1;

                            /* Bits[62:62], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit determines whether PMI event is sent to
                               waken cores only or is broadcast to all cores
                               after waking up any sleeping core. 0 : Avoid
                               waking a core for PMI event - send event to
                               waken cores only. 1 : Wake any sleeping core and
                               send PMI event to all cores
                            */
    UINT32 Frzcountr : 1;

                            /* Bits[63:63], Access Type=WO, default=0x00000000*/

                            /*
                               FreezCounter : This bit, when asserted, cause
                               all of the global enables for the UnCore PerfMon
                               Counters and fixed counters to be frozen. 0 : No
                               effect 1 : Freeze all the perfmon counters, stop
                               counting
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_GLOBAL_CTRL_REGISTER;

/**
  This is MSR that shows to user configuration of uncore PMON's. In this particular case it shows the number of Cbo PMON banks
**/
#define ICX_MSR_PMON_CONFIG 0x00000702

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Numofcbopmon : 6;

                            /* Bits[5:0], Access Type=RWS, default=0x00000008*/

                            /*  */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PMON_CONFIG_REGISTER;

/**
  Uncore fixed counter control
**/
#define ICX_MSR_FIXED_PERF_CTR_CTRL 0x00000703

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 20;

                            /* Bits[19:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable generation of Overflow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Rsvd23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FIXED_PERF_CTR_CTRL_REGISTER;

/**
  Uncore fixed counter
**/
#define ICX_MSR_FIXED_PERF_CTR 0x00000704

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_FIXED_PERF_CTR_REGISTER;

/**
  Controls the operation of the the PMON Counter 1 in IDP 0.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define ICX_MSR_PERF_EVT_SEL_0 0x00000705

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               a selector for measured signals Details of
                               events are TBD
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               A set of qualifiers defined for each of the
                               events. Details for the counter are TBD.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Enubp : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the generation of micro-breakpoint event
                               on event occurrence. 0b Do not assert micro-
                               breakpoint on event occurrence 1b Assert micro-
                               breakpoint on event occurrence
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable generation of Overfolow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. This
                               bit effectively increases the address space for
                               event selection. NOTE: Microcode will cause a GP
                               fault when the programmer attempts to enable an
                               internal event from a locked part. The UnCore
                               PerfMon hardware does not handle the security of
                               the internal events.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the event for counting purposes : 0 :
                               Count when the event is asserted or on it's
                               rising edge 1. : Count when the event is de-
                               asserted or on it's falling edge
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming increment value from event increment
                               bus. The width of this field is determined by
                               the widest event in the iMPH (which is 5 bits
                               for queue occupancy). The result of the
                               comparison is effectiv When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification (i.e. the counter
                               will adevance by the specified increment value).
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_EVT_SEL_0_REGISTER;

/**
  Controls the operation of the the PMON Counte 2 in IDP 0.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define ICX_MSR_PERF_EVT_SEL_1 0x00000706

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               a selector for measured signals Details of
                               events are TBD
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               A set of qualifiers defined for each of the
                               events. Details for the counter are TBD.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Enubp : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the generation of micro-breakpoint event
                               on event occurrence. 0b Do not assert micro-
                               breakpoint on event occurrence 1b Assert micro-
                               breakpoint on event occurrence
                            */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfen : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enable generation of Overfolow indiation when
                               this counter overflows. 0 : PMI Event for this
                               counter is disabled 1 : PMI event is enabled
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. This
                               bit effectively increases the address space for
                               event selection. NOTE: Microcode will cause a GP
                               fault when the programmer attempts to enable an
                               internal event from a locked part. The UnCore
                               PerfMon hardware does not handle the security of
                               the internal events.
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active. 0 : counter is disabled and
                               will not count when global enable is set. 1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the event for counting purposes : 0 :
                               Count when the event is asserted or on it's
                               rising edge 1. : Count when the event is de-
                               asserted or on it's falling edge
                            */
    UINT32 Threshold : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming increment value from event increment
                               bus. The width of this field is determined by
                               the widest event in the iMPH (which is 5 bits
                               for queue occupancy). The result of the
                               comparison is effectivly a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the Invert bit) no
                               matter how wide the original event was.
                            */
    UINT32 Rsvd29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_EVT_SEL_1_REGISTER;

/**
  Holds global control fields for the NCU PMON counters.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCtrClr] is set to 1b.
**/
#define ICX_MSR_PERF_UNIT_CTL 0x00000707

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               The Thread-ID format is given as follows: [0:0]
                               T0 or T1. For GT Core this bit must be 0. [3:1]
                               Core ID. When "TID Filter Enable" is clear in
                               the Counter Control register, then the specified
                               counter will count all events. Thread-ID value
                               of 0xE is reserved for non-associated requests
                               like LLC victims and External Snoops.
                            */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_UNIT_CTL_REGISTER;

/**
  IDP 0 PMON Status register.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define ICX_MSR_PERF_STATUS 0x00000708

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ovfcntr0 : 1;

                            /* Bits[0:0], Access Type=RW1C_FW, default=0x00000000*/

                            /*
                               Indicates overflow Condition on the NCU Counter
                               0. Read 0 - counter didn't overflow 1 - couner
                               overflow occured. Write 0 - ignored
                            */
    UINT32 Ovfcntr1 : 1;

                            /* Bits[1:1], Access Type=RW1C_FW, default=0x00000000*/

                            /*
                               Indicates overflow Condition on the NCU Counter
                               1. Read 0 - counter didn't overflow 1 - couner
                               overflow occured. Write 0 - ignored
                            */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_STATUS_REGISTER;

/**
  IDP 0 PMON Counter 1  data register
  The Fix counter is counting UCLK cycles.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define ICX_MSR_PERF_CTR_0 0x00000709

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 12;

                            /* Bits[43:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd44 : 20;

                            /* Bits[63:44], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_CTR_0_REGISTER;

/**
  IDP 0 PMON Counter 2  data register
  The Fix counter is counting UCLK cycles.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define ICX_MSR_PERF_CTR_1 0x0000070A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Pmonctrdata1 : 12;

                            /* Bits[43:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               Pmon Counter data. The register may be read and
                               written when the counter is stopped.
                            */
    UINT32 Rsvd44 : 20;

                            /* Bits[63:44], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_CTR_1_REGISTER;

/**
  Ubox local PMON mask for NCDEC events
**/
#define ICX_MSR_NCU_PMON_MASK_CTL0 0x0000070B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask : 25;

                            /* Bits[24:0], Access Type=RWS, default=0x00000000*/

                            /*
                               event mask bit per ring message decode [ 0]
                               PMON_NCDEC_MASK_NCB_Int_CBO_IIO [ 1]
                               PMON_NCDEC_MASK_NCB_Int_UBX_QPI [ 2]
                               PMON_NCDEC_MASK_NCB_P2PB_IIO [ 3]
                               PMON_NCDEC_MASK_NCB_P2PB_CBO_UBX_QPI [ 4]
                               PMON_NCDEC_MASK_NCB_VLW_IIO_CBO [ 5]
                               PMON_NCDEC_MASK_NCB_VLW_UBX_QPI [ 6]
                               PMON_NCDEC_MASK_NCB_EOI_CBO [ 7]
                               PMON_NCDEC_MASK_NCB_EOI_UBX_QPI [ 8]
                               PMON_NCDEC_MASK_NCB_EOI_IIO [ 9]
                               PMON_NCDEC_MASK_NCB_STARTREQ234 [10]
                               PMON_NCDEC_MASK_NCB_PMREQ [11]
                               PMON_NCDEC_MASK_NCB_RSVD [12]
                               PMON_NCDEC_MASK_NCS_CfgRd_Wr [13]
                               PMON_NCDEC_MASK_NCS_IORd_Wr [14]
                               PMON_NCDEC_MASK_NCS_LTRd [15]
                               PMON_NCDEC_MASK_NCS_LTWr_IIO_CBO [16]
                               PMON_NCDEC_MASK_NCS_LTWr_UBX_QPI [17]
                               PMON_NCDEC_MASK_NCS_FERR [18]
                               PMON_NCDEC_MASK_NCS_RSVD [19]
                               PMON_NCDEC_MASK_NCS_SHUTDOWN_CBO [20]
                               PMON_NCDEC_MASK_NCS_LOCKS_UNLOCK_CBO_IIO [21]
                               PMON_NCDEC_MASK_NCS_LOCKS_UNLOCK_UBX_QPI [22]
                               PMON_NCDEC_MASK_NCS_STARTREQ1_STOPREQ1234 [23]
                               PMON_NCDEC_MASK_NCS_INVD_WBINVD_CBO_IIO [24]
                               PMON_NCDEC_MASK_NCS_INVD_WBINVD_UBX_QPI
                            */
    UINT32 Rsvd25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_NCU_PMON_MASK_CTL0_REGISTER;

/**
  Ubox local PMON mask for NCDEC events for subunit target
**/
#define ICX_MSR_NCU_PMON_MASK_CTL1 0x0000070C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask : 12;

                            /* Bits[11:0], Access Type=RWS, default=0x00000000*/

                            /*
                               event mask bit per sub unit target [ 0] GLOB_INT
                               [ 1] PMREQ [ 2] RACU [ 3] NCEVENT [ 4] NCLOCK [
                               5] GLOB_LOCK [ 6] MAST_LOCK [ 7] NCS_SPEC [ 8]
                               NCB_SPEC [ 9] GLOB_EOI [10] NCEOI [11] DROP
                            */
    UINT32 AddrMask : 16;

                            /* Bits[27:12], Access Type=RWS, default=0x00000000*/

                            /* Register address mask for addr[15:0] */
    UINT32 Rsvd28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_NCU_PMON_MASK_CTL1_REGISTER;

/**
  Address offset match value for Ubox match/mask. Will compare bits that are not masked
**/
#define ICX_MSR_NCU_PMON_MATCH_ADDR 0x0000070D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 AddrMatch : 16;

                            /* Bits[15:0], Access Type=RWS, default=0x00000000*/

                            /* Address offset to match */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_NCU_PMON_MATCH_ADDR_REGISTER;

/**
  PMON Global Status register.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define ICX_MSR_PERF_GLOBAL_STATUS 0x0000070E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Fixctrovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates that an overflow event occured on the
                               Fix Event. read 0 - No overflow detected 1 -
                               Event overflow event was detected (sticky) Write
                               0 - Ignore 1 - Clear this bit
                            */
    UINT32 Ncuctrovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /*
                               Indicates that an overflow event occured on the
                               NCU and IMPH Event. read 0 - No overflow
                               detected 1 - Event overflow event was detected
                               (sticky) Write 0 - Ignore 1 - Clear this bit
                            */
    UINT32 Pcuovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware to indicate that an overflow
                               happened in the PCU
                            */
    UINT32 Cbo0ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 0 */
    UINT32 Cbo1ovf : 1;

                            /* Bits[4:4], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 1 */
    UINT32 Cbo2ovf : 1;

                            /* Bits[5:5], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 2 */
    UINT32 Cbo3ovf : 1;

                            /* Bits[6:6], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 3 */
    UINT32 Cbo4ovf : 1;

                            /* Bits[7:7], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 4 */
    UINT32 Cbo5ovf : 1;

                            /* Bits[8:8], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 5 */
    UINT32 Cbo6ovf : 1;

                            /* Bits[9:9], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 6 */
    UINT32 Cbo7ovf : 1;

                            /* Bits[10:10], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 7 */
    UINT32 Cbo8ovf : 1;

                            /* Bits[11:11], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 8 */
    UINT32 Cbo9ovf : 1;

                            /* Bits[12:12], Access Type=RW1C, default=0x00000000*/

                            /* Set by hardware when an overflow occurs in CBo 9 */
    UINT32 Cbo10ovf : 1;

                            /* Bits[13:13], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               10
                            */
    UINT32 Cbo11ovf : 1;

                            /* Bits[14:14], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               11
                            */
    UINT32 Cbo12ovf : 1;

                            /* Bits[15:15], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               15
                            */
    UINT32 Cbo13ovf : 1;

                            /* Bits[16:16], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               16
                            */
    UINT32 Cbo14ovf : 1;

                            /* Bits[17:17], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo15ovf : 1;

                            /* Bits[18:18], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo16ovf : 1;

                            /* Bits[19:19], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo17ovf : 1;

                            /* Bits[20:20], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               17
                            */
    UINT32 Cbo18ovf : 1;

                            /* Bits[21:21], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               18
                            */
    UINT32 Cbo19ovf : 1;

                            /* Bits[22:22], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               19
                            */
    UINT32 Cbo20ovf : 1;

                            /* Bits[23:23], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               20
                            */
    UINT32 Cbo21ovf : 1;

                            /* Bits[24:24], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               21
                            */
    UINT32 Cbo22ovf : 1;

                            /* Bits[25:25], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               22
                            */
    UINT32 Cbo23ovf : 1;

                            /* Bits[26:26], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               23
                            */
    UINT32 Cbo24ovf : 1;

                            /* Bits[27:27], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               24
                            */
    UINT32 Cbo25ovf : 1;

                            /* Bits[28:28], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               25
                            */
    UINT32 Cbo26ovf : 1;

                            /* Bits[29:29], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               26
                            */
    UINT32 Cbo27ovf : 1;

                            /* Bits[30:30], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               27
                            */
    UINT32 Cbo33to28ovf0 : 1;

                            /* Bits[31:31], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               28 to 33
                            */
    UINT32 Cbo33to28ovf1 : 5;

                            /* Bits[36:32], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in CBo
                               28 to 33
                            */
    UINT32 Rsvd37 : 2;

                            /* Bits[38:37], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Imc0ovf : 1;

                            /* Bits[39:39], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in the
                               memory controller 0
                            */
    UINT32 Imc1ovf : 1;

                            /* Bits[40:40], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in the
                               memory controller 1
                            */
    UINT32 Kti00ag0ovf : 1;

                            /* Bits[41:41], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI00
                               Agent
                            */
    UINT32 Kti00ag1ovf : 1;

                            /* Bits[42:42], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI00
                               Agent
                            */
    UINT32 Kti40ovf : 1;

                            /* Bits[43:43], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in KTI40
                               Agent
                            */
    UINT32 Rsvd44 : 2;

                            /* Bits[45:44], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 M3kti0ovf : 1;

                            /* Bits[46:46], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in
                               M3UPI0
                            */
    UINT32 M3kti1ovf : 1;

                            /* Bits[47:47], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when an overflow occurs in
                               M3UPI1
                            */
    UINT32 Rsvd48 : 3;

                            /* Bits[50:48], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 M2pcie0ovf : 1;

                            /* Bits[51:51], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe0
                            */
    UINT32 M2pcie1ovf : 1;

                            /* Bits[52:52], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe1
                            */
    UINT32 M2pcie2ovf : 1;

                            /* Bits[53:53], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe2
                            */
    UINT32 M2pcie3ovf : 1;

                            /* Bits[54:54], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe3
                            */
    UINT32 M2pcie4ovf : 1;

                            /* Bits[55:55], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2PCIe4
                            */
    UINT32 Iio0ovf : 1;

                            /* Bits[56:56], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO0(CBDMA)
                            */
    UINT32 Iio1ovf : 1;

                            /* Bits[57:57], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO1
                            */
    UINT32 Iio2ovf : 1;

                            /* Bits[58:58], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO2
                            */
    UINT32 Iio3ovf : 1;

                            /* Bits[59:59], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in IIO3
                            */
    UINT32 Mcplink0ovf : 1;

                            /* Bits[60:60], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in MCPLink0
                            */
    UINT32 Mcplink1ovf : 1;

                            /* Bits[61:61], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in MCPLink1
                            */
    UINT32 M2mem0ovf : 1;

                            /* Bits[62:62], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2MEM0. Independent from iMC as they are in
                               different clock domains
                            */
    UINT32 M2mem1ovf : 1;

                            /* Bits[63:63], Access Type=RW1C, default=0x00000000*/

                            /*
                               Set by hardware when a counter overflow occurs
                               in M2MEM1. Independent from iMC as they are in
                               different clock domains
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_GLOBAL_STATUS_REGISTER;
/**
  PMON Global Status register.
  All fields in this reigster must be reset when LT_CONTROL_MSR[LTPmonCntClr] is set to 1b.
**/
#define ICX_MSR_NCUPMONGLSTS1 0x0000070F

/**

**/
#define ICX_MSR_PMON_UNIT_CTRL 0x00000710

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PMON_UNIT_CTRL_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_SEL_0 0x00000711

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Filtermask : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThreadID filter enable. This is only used by
                               Cbo. For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               overflow enabled, tehn a signal will be
                               transmitted to the Ubox
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal the events selected by the event
                               select, unit mask, and internal if this bit is
                               set to 1 but the Unit Control Registers have
                               determined that counting is disabled, then the
                               counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 - "greater than or equal to"
                               comparison on the threshhold compare 1 - "less
                               than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_SEL_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_SEL_1 0x00000712

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Filtermask : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThreadID filter enable. This is only used by
                               Cbo. For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               overflow enabled, tehn a signal will be
                               transmitted to the Ubox
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal the events selected by the event
                               select, unit mask, and internal if this bit is
                               set to 1 but the Unit Control Registers have
                               determined that counting is disabled, then the
                               counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 - "greater than or equal to"
                               comparison on the threshhold compare 1 - "less
                               than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_SEL_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_SEL_2 0x00000713

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Filtermask : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThreadID filter enable. This is only used by
                               Cbo. For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               overflow enabled, tehn a signal will be
                               transmitted to the Ubox
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal the events selected by the event
                               select, unit mask, and internal if this bit is
                               set to 1 but the Unit Control Registers have
                               determined that counting is disabled, then the
                               counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 - "greater than or equal to"
                               comparison on the threshhold compare 1 - "less
                               than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_SEL_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_SEL_3 0x00000714

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Filtermask : 7;

                            /* Bits[6:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               Perfmon HAS and the individual unit HAS
                               documents.
                            */
    UINT32 Useoccupancy : 1;

                            /* Bits[7:7], Access Type=RW_V, default=0x00000000*/

                            /*
                               When enabled, this will pass the output of the
                               occupancy block through to the counter
                               (dependent on the event occuring). See the HAS
                               for more details.
                            */
    UINT32 Rsvd8 : 6;

                            /* Bits[13:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Occselect : 2;

                            /* Bits[15:14], Access Type=RW_V, default=0x00000000*/

                            /*
                               Select which of the four occupancy counters to
                               use. 00 - Threads in C0 01 - Cores in C0 10 -
                               Cores in C3 11 - Cores in C6
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L0s mode in Intel UPI. By using
                               edge detect, one can count the number of times
                               that we entered L0s mode (by detecting the
                               rising edge). Edge detect only works in
                               conjunction with threshholding. This is true
                               even for events that can only increment by 1 in
                               a given cycle (like the L0s example above). In
                               this case, one should set a threshhold of 1. One
                               can also use Edge Detect with queue occupancy
                               events. For example, if one wanted to count the
                               number of times when the TOR occupancy was
                               larger than 5, one would selet the TOR occupancy
                               event with a threshold of 5 and set the Edge
                               Detect bit. Edge detect can also be used with
                               the invert. This is generally not particularly
                               useful, as the count of falling edges compared
                               to rising edges will always on differ by 1.
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               ThreadID filter enable. This is only used by
                               Cbo. For other units it is Reserved.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               overflow enabled, tehn a signal will be
                               transmitted to the Ubox
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are events that are only
                               accessible on unlocked parts. One can basically
                               think of the internal bit as an extension of the
                               event select bits [7:0], as it allows the use to
                               gain access to additional events. It will not be
                               possible to use these events on locked parts.
                               For perfmons that exist in MSR space, the MSR
                               write mask is set on this bit, and the ucode
                               handler will trigger a GP fault if one attempts
                               to write to these bits. Writing to these bits is
                               controlled in other ways in the other units.
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal the events selected by the event
                               select, unit mask, and internal if this bit is
                               set to 1 but the Unit Control Registers have
                               determined that counting is disabled, then the
                               counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the 'invert' bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */
    UINT32 Occinvert : 1;

                            /* Bits[30:30], Access Type=RW_V, default=0x00000000*/

                            /*
                               Invert the output of the occupancy threshhold
                               comparison logic. 0 - "greater than or equal to"
                               comparison on the threshhold compare 1 - "less
                               than" comparison on the threshhold compare
                            */
    UINT32 Occedgedetect : 1;

                            /* Bits[31:31], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enable edge detection on the output of the
                               occupancy threshhold comparison. When enabled
                               and used with the Threshhold logic, this will
                               provide the ability to track the number of times
                               when an occupancy counter exceed or was equal to
                               the value in the threshhold. When used with
                               OccInvert, this will track the number of times
                               when the value dropped below the threshhold.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_SEL_3_REGISTER;
/**

**/
#define ICX_MSR_PERF_PCU_FILTER 0x00000715

/**

**/
#define ICX_MSR_PERF_UNIT_STATUS 0x00000716

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counteroverflowbitmask : 7;

                            /* Bits[6:0], Access Type=RW1C, default=0x00000000*/

                            /*
                               This bitmask that specifies which counter(or
                               counters have overflowed. If the unit has a
                               fixed counter, it's corresponding bitmask will
                               be stored at position 0.
                            */
    UINT32 Rsvd7 : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_UNIT_STATUS_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_CTR_0 0x00000717

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_CTR_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_CTR_1 0x00000718

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_CTR_2 0x00000719

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_CTR_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PCU_EVT_CTR_3 0x0000071A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PCU_EVT_CTR_3_REGISTER;

/**
  Contains enable bits for HWP feature
**/
#define ICX_MSR_IA32_PM_ENABLE 0x00000770

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 HwpEnable : 1;

                            /* Bits[0:0], Access Type=RW_KL, default=0x00000000*/

                            /*
                               Set (1) to enable the HWP performance control
                               interface. ucode makes sure this is sticky,
                               meaning it will only write 1, never write 0.
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_PM_ENABLE_REGISTER;

/**
  Contains fields describing the performance and window time borders in which HWP works.
**/
#define ICX_MSR_IA32_HWP_CAPABILITIES 0x00000771

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 HighestPerformance : 8;

                            /* Bits[7:0], Access Type=RW_L, default=0x00000000*/

                            /*
                               Value for the max non-guaranteed performance
                               level (aka max turbo).
                            */
    UINT32 GuaranteedPerformance : 8;

                            /* Bits[15:8], Access Type=RW_L, default=0x00000001*/

                            /*
                               Current value for the guaranteed performance
                               level. Will change dynamically as a result of
                               internal or external constraints (e.g.
                               thermal/power limit). Reset value set to P1 fuse
                               was done by Dan Levy with Eli Weissman and
                               Michael Mishaeli
                            */
    UINT32 MostEfficientPerformance : 8;

                            /* Bits[23:16], Access Type=RW_L, default=0x00000000*/

                            /*
                               Value of the most efficient performance level
                               (aka minVCC level).
                            */
    UINT32 LowestLinearPerformance : 8;

                            /* Bits[31:24], Access Type=RW_L, default=0x00000001*/

                            /*
                               Value of the lowest performance level (aka Pn at
                               max throttling).
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_HWP_CAPABILITIES_REGISTER;

/**
  Contains bits describing the current status of HWP feature work process
**/
#define ICX_MSR_IA32_HWP_INTERRUPT 0x00000773

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ChangeToGuaranteed : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set (1), an HWP Interrupt will be generated
                               whenever a change to the Guaranteed Performance
                               occurs. Default = interrupt disabled (0).
                            */
    UINT32 ExcursionToMinimum : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When set (1), an HWP Interrupt will be generated
                               whenever HW is unable to meet the Minimum
                               Performance. Default = interrupt disabled (0).
                            */
    UINT32 ChangeToHighest : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set (1), an HWP Interrupt will be generated
                               whenever a change to the Highest Performance
                               occurs. Default = interrupt disabled (0).
                            */
    UINT32 PeciOverride : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set(1), an HWP interrupt will be generated
                               whenever a management controller supersedes one
                               or more of the OS control hints (min, max, EPP)
                               specified in IA32_HWP_REQUEST or
                               IA32_HWP_REQUEST_PKG
                            */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_HWP_INTERRUPT_REGISTER;

/**
  FIXME - update virtual MSR. Hardware Pstate requested performance and time window parameters. should i remove? need to be changed to virtual.
**/
#define ICX_MSR_HWP_REQUEST 0x00000774

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MinimumPerformance : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000001*/

                            /*
                               Used as a hint to the H/W. The OS sets the
                               minimum performance level to achieve the
                               required QOS. Excursion below this level is
                               possible due to physical or algorithmic
                               constraints. reset value is identical to
                               IA32_HWP_CAPABILITIES.LOWEST_LINEAR_PERFORMANCE
                            */
    UINT32 MaximumPerformance : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000FF*/

                            /*
                               The OS sets this field to limit the maximum
                               performance over the Activity Window that is
                               expected to be supplied by the H/W. Excursions
                               above this limit are possible due H/W
                               coordination between the IA core and other SoC's
                               components.
                            */
    UINT32 DesiredPerformance : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               RW (default = 0) When set to zero, HW autonomous
                               selection determines the performance target.
                               When set to a non-zero value, in the range of
                               Lowest Performance to Highest Performance
                               (IA32_HWP_CAPABILITIES), conveys an explicit
                               performance request hint to the hardware;
                               effectively disabling HW Autonomous selection.
                               The Desired Performance input is non-
                               constraining in terms of Performance and Energy
                               Efficiency optimizations, which are
                               independently controlled.
                            */
    UINT32 EnergyPerformancePreference : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000080*/

                            /*  */
    UINT32 ActivityWindow : 10;

                            /* Bits[41:32], Access Type=RW, default=0x00000000*/

                            /*
                               Used as a hint to the H/W. OS writes a time
                               value (100us) to this field to indicate a moving
                               utilization sensitivity window. Combined with
                               the Desired Performance input, influences the
                               rate of performance increase / decrease.
                            */
    UINT32 PackageControl : 1;

                            /* Bits[42:42], Access Type=RW, default=0x00000000*/

                            /*
                               When set causes thread IA32_HWP_REQUEST control
                               inputs to be derived from IA32_HWP_REQUEST_PKG
                            */
    UINT32 Rsvd43 : 16;

                            /* Bits[58:43], Access Type=RO, default=0x00000000*/

                            /* Reserved Bits */
    UINT32 ActivityWindowsValid : 1;

                            /* Bits[59:59], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1 means that if the package control bit
                               is set, takes active windows value from this MSR
                            */
    UINT32 EppValid : 1;

                            /* Bits[60:60], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1 means that if the package control bit
                               is set, takes EPP value from the the this MSR
                            */
    UINT32 DesiredValid : 1;

                            /* Bits[61:61], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1 means that if the package control bit
                               is set, takes Desired Performance value from the
                               the this MSR
                            */
    UINT32 MaximumValid : 1;

                            /* Bits[62:62], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1 means that if the package control bit
                               is set, takes Maximum Performance value from the
                               the this MSR
                            */
    UINT32 MinimumValid : 1;

                            /* Bits[63:63], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1 means that if the package control bit
                               is set, takes Minimum Performance value from the
                               the this MSR
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_HWP_REQUEST_REGISTER;

/**
  Contains bits describing the current status of HWP feature work process
**/
#define ICX_MSR_IA32_HWP_STATUS 0x00000777

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ChangeToGuaranteed : 1;

                            /* Bits[0:0], Access Type=RW0C_FW, default=0x00000000*/

                            /*
                               If set (1), a change to Guaranteed Performance
                               has occurred. SW should query
                               IA32_HWP_CAPABILITIES to ascertain the new
                               Guaranteed Performance value.
                            */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ExcursionToMinimum : 1;

                            /* Bits[2:2], Access Type=RW0C_FW, default=0x00000000*/

                            /*
                               If set (1), an excursion to Minimum Performance
                               has occurred.
                            */
    UINT32 HighestChange : 1;

                            /* Bits[3:3], Access Type=RW0C_FW, default=0x00000000*/

                            /*
                               If set (1), a change to Highest Performance has
                               occurred. SW should query IA32_HWP_CAPABILITIES
                               to ascertain the new Highest Performance value.
                               SW must clear this bit by writing a zero (0).
                            */
    UINT32 PeciOverrideEnter : 1;

                            /* Bits[4:4], Access Type=RW0C_FW, default=0x00000000*/

                            /*
                               If set (1), a management controller has started
                               a PECI override of one or more OS control hints
                               (min, max, EPP) specified in IA32_HWP_REQUEST or
                               IA32_HWP_REQUEST_PKG. SW must clear this bit
                            */
    UINT32 PeciOverrideExit : 1;

                            /* Bits[5:5], Access Type=RW0C_FW, default=0x00000000*/

                            /*
                               If set (1), a management controller has stopped
                               a PECI override of all OS control hints (min,
                               max, EPP) specified in IA32_HWP_REQUEST or
                               IA32_HWP_REQUEST_PKG. SW must clear this bit by
                               writing a zero (0).
                            */
    UINT32 Rsvd6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_HWP_STATUS_REGISTER;
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_0 0x00000791
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_2 0x00000794
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_3 0x00000795
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_4 0x00000796
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_5 0x00000797
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_6 0x00000798
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_7 0x00000799
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_8 0x0000079A
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_9 0x0000079B
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_10 0x0000079C
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_11 0x0000079D
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_12 0x0000079E
/**
  Spare Virtual MSRs in uncore Creg PLA
**/
#define ICX_MSR_UNCORE_SPARE_13 0x0000079F

/**
  Holds XSAVE_AREA "triplet" w/ addition of XCompaction vector for the XMODIFIED optimization.
**/
#define ICX_MSR_XRSTOR_INFO 0x00000900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 XsaveAreaCpl : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* The full CPL from the last XRSTOR instruction. */
    UINT32 XsaveAreaVmmHostGuest : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               The VMM Host/Guest state from the last XRSTOR
                               instruction.
                            */
    UINT32 Rsvd3 : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */
    UINT32 XsaveAreaValid : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA valid bit is effectively an
                               address bit of the XSAVE_AREA. Since all
                               XSAVE_AREAs must be 64 byte aligned, setting
                               this bit forces the misalignment so compare of
                               this XSAVE_AREA and the XSAVE_AREA specified in
                               the XSAVE instruction must miscompare. The
                               miscompare will force all xmodified bits to be
                               treated as modified.
                            */
    UINT32 XsaveAreaAddress0 : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA linear address from the last
                               XRSTOR.
                            */
    UINT32 XsaveAreaAddress1 : 25;

                            /* Bits[56:32], Access Type=RW, default=0x00000000*/

                            /*
                               The XSAVE_AREA linear address from the last
                               XRSTOR.
                            */
    UINT32 Rsvd57 : 7;

                            /* Bits[63:57], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XRSTOR_INFO_REGISTER;

/**
  Equivalent to architectural DR6 reg. 16 bit.
  (Mrm roctlregc/roctlregd/{tmpdr6lowSM306L|tmpdr6hiSM306L})
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define ICX_MSR_TMPDR6 0x00000902

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 B0 : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B0 */
    UINT32 B1 : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B1 */
    UINT32 B2 : 1;

                            /* Bits[2:2], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B2 */
    UINT32 B3 : 1;

                            /* Bits[3:3], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6B3 */
    UINT32 Rsvd4 : 9;

                            /* Bits[12:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Bd : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* ROBTMPDR6BD */
    UINT32 Bs : 1;

                            /* Bits[14:14], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6BS */
    UINT32 Bt : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* ROBTMPDR6BT */
    UINT32 Hled : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /* ROBTMPDR6HLED */
    UINT32 EnclaveInterruption : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               Enclave interruption indication. Cleared by HW
                               on retired EOM
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TMPDR6_REGISTER;

/**
  Holds address bits [11:0] of a guest load/store access that hit the AVRR range
  C6NoSave Candidate
  FSCP Crunch:  12:32 Used only 12 bits out of 32
**/
#define ICX_MSR_VMX_VMENTRY_AVRR_TBIT_MAILBOX 0x00000907

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MailboxOffset : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mailbox address bits [11:0] of a guest
                               load/store access that hit the AVRR range
                            */
    UINT32 Reserved12 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Unused */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_VMX_VMENTRY_AVRR_TBIT_MAILBOX_REGISTER;

/**
  Millicode MSR used to control SMM states
  WRMSR will ignore the undefined bits (63:32, 30:1).
  RDMSR will always return 0 in bits 63:32, 30:1.
**/
#define ICX_MSR_XU_SMM_STATE 0x00000908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 InSmm : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting/clearing this bit will set/clear
                               CORE_CR_RR_MODE[IN_SMM] for the current thread
                               (see GQ1_CR_XU_SMM_STATE for uncore). 0 - Not in
                               SMM mode, 1 - In SMM mode
                            */
    UINT32 Rsvd1 : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SmmCodeAccessVioEnable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Tied to the following bits.
                               PMH_CR_RR_MODE[SMM_CODE_RANGE_CHK_EN] and
                               ROB1_CR_MISC_STATE[EIP_LOGGING].
                               Setting/clearing this bit will set/clear
                               PMH_CR_RR_MODE[SMM_CODE_RANGE_CHK_EN] and
                               ROB1_CR_MISC_STATE[EIP_LOGGING]
                            */
    UINT32 Rsvd5 : 16;

                            /* Bits[20:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 PsmiBaseLocked : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               RDMSR only bit to report status of
                               SCP_CR_PSMI_CTRL_PSMI_BASE_LOCKED, ignored on
                               WRMSR
                            */
    UINT32 Rsvd22 : 9;

                            /* Bits[30:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 SmmOutsideVmx : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Setting/clearing this bit will set/clear
                               FSCP_CR_LT_SMM_OPT_OUT_INFO[SMM_OUTSIDE_VMX]
                               (bit31) Indicates/controls opt-in to peer SMM
                               operation
                            */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XU_SMM_STATE_REGISTER;

/**
  This is a Write-Only cmd MSR. A write causes GT to flush outstanding transactions and re-load it's boot context. A Rd will GP Fault.
  With the removal of the GT_CREG_ADDR_DIFFERENTIATOR there is no
  need for this to be virtual
**/
#define ICX_MSR_GT_FLUSH_RELOAD 0x0000090E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 BcldReq : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               GT Boot Context Load Request. Write to this bit
                               will initiate ?Mcheck Complete Routine? (PPPE
                               flow).
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RW, default=0x00000000*/

                            /* reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_GT_FLUSH_RELOAD_REGISTER;

/**
  GT writes a '1 to this bit to acknowledge PPPE range registers are loaded into GT.
**/
#define ICX_MSR_GT_FLUSH_BCLD_ACK 0x0000090F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Ack : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* GT Boot Context Load Ack */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_GT_FLUSH_BCLD_ACK_REGISTER;

/**

**/
#define ICX_MSR_XU_STATUS 0x00000910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 C6DramEnabled : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* C6 DRAM ENABLE FUSE */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 TagecOnly : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 Rsvd3 : 13;

                            /* Bits[15:3], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 Strap : 4;

                            /* Bits[19:16], Access Type=RW, default=None*/

                            /* Straps from PCU_CR_STRAP_SET_DATA2_HIGH.strap */
    UINT32 Rsvd20 : 5;

                            /* Bits[24:20], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 EpcOvDis : 1;

                            /* Bits[25:25], Access Type=RW, default=None*/

                            /* EPC_OV Disable fuse */
    UINT32 Rsvd26 : 5;

                            /* Bits[30:26], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 EdmmDis : 1;

                            /* Bits[31:31], Access Type=RW, default=None*/

                            /* EDMM Disable fuse */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XU_STATUS_REGISTER;

/**
  Holds XSAVE_AREA XCompaction vector for the XMODIFIED optimization.
**/
#define ICX_MSR_XRSTOR_XCOMPACTION_VECTOR 0x00000911

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 XcompactionVector : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit 0 => FP Bit 1 => SSE Bit 2 => GSSE Bit 3 =>
                               PL BNDREGS Bit 4 => PL BNDCFS Bit 5 => KMASK Bit
                               6 => AVX3(15:0) Bit 7 => AVX3(31:16) Bit 8 =>
                               RTIT (reserved - actual bit in IA_XSS) Bit 9 =>
                               PKRU
                            */
    UINT32 Rsvd10 : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000000*/

                            /* Available for use */
    UINT32 XcompInUse : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Save area for XRSTOR_INFO used XCOMPACTION, or
                               VECTOR in this MSR is valid.
                            */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Available for use */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Available for use */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XRSTOR_XCOMPACTION_VECTOR_REGISTER;

/**
  Trusted IO - CAM Filter Info
**/
#define ICX_MSR_XU_TIO_CF_INFO 0x00000912

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Numrows : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               Specifies the number of rows in the CAM Filter
                               table
                            */
    UINT32 Numcols : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Specifies the number of CRs per row in the CAM
                               Filter table
                            */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RO, default=0x00000000*/

                            /*
                               reserved the number of CRs per row in the CAM
                               Filter table
                            */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RO, default=0x00000000*/

                            /*
                               reserved the number of CRs per row in the CAM
                               Filter table
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XU_TIO_CF_INFO_REGISTER;

/**
  APIC Virtualization Range Register - Base address of virtual APIC
**/
#define ICX_MSR_AVRR_BASE 0x00000916

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 11;

                            /* Bits[10:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the AVRR */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* AVRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* AVRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AVRR_BASE_REGISTER;

/**
  The who-am-I register is used by uCode to set up the APIC ID.
  This register is initialized by the PCU according to the socket configuration using the NcuPcuWHOAMI register.
  The who-am-i register returns a thread specific identifier, however some of the fields of this registers are shared between all threads as indicated by the fields description.
**/
#define ICX_MSR_WHO_AM_I 0x00000920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lpid : 3;

                            /* Bits[2:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               3-bit field. UBOX generates contiguous LPIDs for
                               logical procsesors within an IDI agent. CPUs
                               with fewer than 8 logical processors per IDI (eg
                               ICL, ICX) see holes in the WHOAMI space. Ucode
                               handles this as required (plug holes or live
                               with it)
                            */
    UINT32 Moduleid : 13;

                            /* Bits[15:3], Access Type=RO_V, default=0x00000000*/

                            /* Returns the Module Identification number. */
    UINT32 Packageid : 11;

                            /* Bits[26:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               Maps to the socketId straps; Can be programmed
                               (MSR)
                            */
    UINT32 Rsvd27 : 1;

                            /* Bits[27:27], Access Type=RO_V, default=0x00000000*/

                            /* Reserved */
    UINT32 Corenum : 3;

                            /* Bits[30:28], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates how many common APIC ID bits there are
                               in the socket: 000: upto 8 cores 001: upto 16
                               cores 010: upto 32 cores 011: upto 64 cores 100:
                               upto 128 cores 101: upto 256 cores 110: upto 512
                               cores 111: upto 1024 cores This field is used by
                               uCode for correctly handling the number of
                               variable bits in PID field.
                            */
    UINT32 Bsp : 1;

                            /* Bits[31:31], Access Type=RO_V, default=0x00000000*/

                            /*
                               Indicates to the core uCode that this thread
                               should be made the BSP of the socket, .
                               Selection among multi-socket BSP is done by BIOS
                               SW. 0 : this thread should not be set as BSP 1 :
                               this thread should be set as BSP
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_WHO_AM_I_REGISTER;

/**

**/
#define ICX_MSR_RESOLVED_CORES 0x00000921

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CoreMask0 : 32;

                            /* Bits[31:0], Access Type=RWS, default=0x00000000*/

                            /*
                               The resolved IA core mask contains the
                               functional (enabled in SKU) and non-defeatured
                               IA cores. The mask is indexed by logical ID. It
                               is normally contiguous, unless BIOS defeature is
                               activated on a particular core. BSP and APIC IDs
                               will be set by the processor based on this
                               value. This field is determined by FW based on
                               CSR_DESIRED_CORES[CORE_OFF_MASK].
                            */
    UINT32 CoreMask1 : 10;

                            /* Bits[41:32], Access Type=RWS, default=0x00000000*/

                            /*
                               The resolved IA core mask contains the
                               functional (enabled in SKU) and non-defeatured
                               IA cores. The mask is indexed by logical ID. It
                               is normally contiguous, unless BIOS defeature is
                               activated on a particular core. BSP and APIC IDs
                               will be set by the processor based on this
                               value. This field is determined by FW based on
                               CSR_DESIRED_CORES[CORE_OFF_MASK].
                            */
    UINT32 Rsvd42 : 22;

                            /* Bits[63:42], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_RESOLVED_CORES_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_STATUS (lower 32b) and ROB1_CR_PIC_EVENT_STATUS (upper 32b)
**/
#define ICX_MSR_PPPE_EVENT_STATUS 0x00000925

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : INTR */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : MONITOR */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=RO_V, default=0x00000000*/

                            /* Event Status GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=RO_V, default=0x00000000*/

                            /* Event Status GO THREAD */
    UINT32 MceSmi : 1;

                            /* Bits[18:18], Access Type=RO_V, default=0x00000000*/

                            /*
                               When Set indicates SMI is pended due to MCE_CTL
                               setting in core or uncore MCi_Ctl2 register
                            */
    UINT32 CmciSmi : 1;

                            /* Bits[19:19], Access Type=RO_V, default=0x00000000*/

                            /*
                               When Set indicates SMI is pended due to CMCI_CTL
                               setting in core or uncore MCi_Ctl2 register
                            */
    UINT32 MwaitTimerMonitor : 1;

                            /* Bits[20:20], Access Type=RO_V, default=0x00000000*/

                            /* Event Status : MWAIT_TIMER_MONITOR */
    UINT32 Rsvd21 : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Restart micro */
    UINT32 Rsvd34 : 2;

                            /* Bits[35:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CorrectableMc : 1;

                            /* Bits[36:36], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for Machine Check event. set when
                               Parity Error is detected.
                            */
    UINT32 RtitMem : 1;

                            /* Bits[37:37], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for RTIT mem event */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for Core Retirement Detector
                               (CRD) event
                            */
    UINT32 Rop : 1;

                            /* Bits[45:45], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for ROP event */
    UINT32 Reserved46 : 1;

                            /* Bits[46:46], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for RESERVED event */
    UINT32 RtitFlush : 1;

                            /* Bits[47:47], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for RTIT flush event */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for NMIP */
    UINT32 TxAbortMisspec : 1;

                            /* Bits[49:49], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for TX_ABORT due to MEU
                               Misspeculation
                            */
    UINT32 TxAbortWatchdog : 1;

                            /* Bits[50:50], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for TX_ABORT due to Watchdog Time
                               out
                            */
    UINT32 TxCatastrophicAbort : 1;

                            /* Bits[51:51], Access Type=RO_V, default=0x00000000*/

                            /*
                               Pending status for TX catatrophic abort which is
                               taken as soon as it's posted
                            */
    UINT32 Pebs : 12;

                            /* Bits[63:52], Access Type=RO_V, default=0x00000000*/

                            /* Pending status for PEBS event per counter */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PPPE_EVENT_STATUS_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_SET (lower 32b) and ROB1_CR_PIC_EVENT_SET (upper 32b)
**/
#define ICX_MSR_PPPE_EVENT_SET 0x00000926

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /* Event Set : INTR */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /* used to be A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Event Set : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Event Set : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=WO, default=0x00000000*/

                            /* Event Set : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=WO, default=0x00000000*/

                            /* Event Set : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=WO, default=0x00000000*/

                            /* Event Set : MONITOR */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=WO, default=0x00000000*/

                            /* Event Set : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /* Event Set : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /* Event Set : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=WO, default=0x00000000*/

                            /* Event Set : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=WO, default=0x00000000*/

                            /* Event Set : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=WO, default=0x00000000*/

                            /* Event Set : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=WO, default=0x00000000*/

                            /* Event Set : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=WO, default=0x00000000*/

                            /* Event Set : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=WO, default=0x00000000*/

                            /* Event Set : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /* Event Set GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /* Event Set GO THREAD */
    UINT32 MceSmi : 1;

                            /* Bits[18:18], Access Type=WO, default=0x00000000*/

                            /* Event set MCE_SMI */
    UINT32 CmciSmi : 1;

                            /* Bits[19:19], Access Type=WO, default=0x00000000*/

                            /* Event set CMCI_SMI */
    UINT32 MwaitTimerMonitor : 1;

                            /* Bits[20:20], Access Type=WO, default=0x00000000*/

                            /* Event set : MWAIT_TIMER_MONITOR */
    UINT32 Rsvd21 : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=WO, default=0x00000000*/

                            /* Pending state for Restart micro */
    UINT32 Rsvd34 : 2;

                            /* Bits[35:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CorrectableMc : 1;

                            /* Bits[36:36], Access Type=WO, default=0x00000000*/

                            /*
                               Pending status for Machine Check event. set when
                               Parity Error is detected.
                            */
    UINT32 RtitMem : 1;

                            /* Bits[37:37], Access Type=WO, default=0x00000000*/

                            /* Pending status for RTIT mem event */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=WO, default=0x00000000*/

                            /* Pending state for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=WO, default=0x00000000*/

                            /* Pending state for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=WO, default=0x00000000*/

                            /* Pending state for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=WO, default=0x00000000*/

                            /* Pending state for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=WO, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=WO, default=0x00000000*/

                            /* Pending state for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=WO, default=0x00000000*/

                            /* Set Core Retirement Detector (CRD) pending state */
    UINT32 Rop : 1;

                            /* Bits[45:45], Access Type=WO, default=0x00000000*/

                            /* Pending state for FERR_OVERFLOW event */
    UINT32 Reserved46 : 1;

                            /* Bits[46:46], Access Type=WO, default=0x00000000*/

                            /* Pending status for RESERVED event */
    UINT32 RtitFlush : 1;

                            /* Bits[47:47], Access Type=WO, default=0x00000000*/

                            /* Pending status for RTIT event */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=WO, default=0x00000000*/

                            /* Pending status for NMIP */
    UINT32 TxAbortMisspec : 1;

                            /* Bits[49:49], Access Type=WO, default=0x00000000*/

                            /*
                               Pending status for TX_ABORT due to MEU
                               Misspeculation
                            */
    UINT32 TxAbortWatchdog : 1;

                            /* Bits[50:50], Access Type=WO, default=0x00000000*/

                            /*
                               Pending status for TX_ABORT due to Watchdog Time
                               out
                            */
    UINT32 TxCatastrophicAbort : 1;

                            /* Bits[51:51], Access Type=WO, default=0x00000000*/

                            /*
                               Pending status for TX catatrophic abort which is
                               taken as soon as it's posted
                            */
    UINT32 Pebs : 12;

                            /* Bits[63:52], Access Type=WO, default=0x00000000*/

                            /* Pending status for PEBS event per counter */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PPPE_EVENT_SET_REGISTER;

/**
  Maps to ML3_CR_PIC_EVENT_RESET (lower 32b) and ROB1_CR_PIC_EVENT_RESET (upper 32b)
**/
#define ICX_MSR_PPPE_EVENT_RESET 0x00000927

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Intr : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /* Reset Event INTR */
    UINT32 Rsvd1 : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /* Event Reset : A20M */
    UINT32 Init : 1;

                            /* Bits[2:2], Access Type=WO, default=0x00000000*/

                            /* Event Reset : INIT */
    UINT32 Nmi : 1;

                            /* Bits[3:3], Access Type=WO, default=0x00000000*/

                            /* Event Reset : NMI */
    UINT32 Smi : 1;

                            /* Bits[4:4], Access Type=WO, default=0x00000000*/

                            /* Event Reset : SMI */
    UINT32 Psmi : 1;

                            /* Bits[5:5], Access Type=WO, default=0x00000000*/

                            /* Event Reset : PSMI */
    UINT32 Monitor : 1;

                            /* Bits[6:6], Access Type=WO, default=0x00000000*/

                            /*
                               Event Reset : MONITOR: Doesn't write
                               ML3_CR_PIC_EVENT_RESET_MONITOR but clears the
                               MONITOR FSM with a spcl cycle
                            */
    UINT32 Sipi : 1;

                            /* Bits[7:7], Access Type=WO, default=0x00000000*/

                            /* Event Reset : SIPI */
    UINT32 LtDoorbell : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /* Event Reset : LT_DOORBELL */
    UINT32 VmxTimer : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /* Event Reset : VMX_TIMER */
    UINT32 Preq : 1;

                            /* Bits[10:10], Access Type=WO, default=0x00000000*/

                            /* Event Reset : PREQ */
    UINT32 Mcakind : 1;

                            /* Bits[11:11], Access Type=WO, default=0x00000000*/

                            /* Event Reset : MCAKIND */
    UINT32 CpdEnter : 1;

                            /* Bits[12:12], Access Type=WO, default=0x00000000*/

                            /* Event Reset : CPD_ENTER */
    UINT32 CpdExit : 1;

                            /* Bits[13:13], Access Type=WO, default=0x00000000*/

                            /* Event Reset : CPD_EXIT */
    UINT32 UncoreTrap : 1;

                            /* Bits[14:14], Access Type=WO, default=0x00000000*/

                            /* Event Reset : UNCORE_TRAP */
    UINT32 AsyncMca : 1;

                            /* Bits[15:15], Access Type=WO, default=0x00000000*/

                            /* Event Reset : ASYNC_MCA */
    UINT32 GoCore : 1;

                            /* Bits[16:16], Access Type=WO, default=0x00000000*/

                            /* Event Reset GO CORE */
    UINT32 GoThread : 1;

                            /* Bits[17:17], Access Type=WO, default=0x00000000*/

                            /* Event Reset GO THREAD */
    UINT32 MceSmi : 1;

                            /* Bits[18:18], Access Type=WO, default=0x00000000*/

                            /* Event Reset MCE_SMI */
    UINT32 CmciSmi : 1;

                            /* Bits[19:19], Access Type=WO, default=0x00000000*/

                            /* Event Reset CMCI_SMI */
    UINT32 MwaitTimerMonitor : 1;

                            /* Bits[20:20], Access Type=WO, default=0x00000000*/

                            /* Event Reset : MWAIT_TIMER_MONITOR */
    UINT32 Rsvd21 : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 1;

                            /* Bits[32:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 RestartMicro : 1;

                            /* Bits[33:33], Access Type=WO, default=0x00000000*/

                            /* Pending state for Restart micro */
    UINT32 Rsvd34 : 2;

                            /* Bits[35:34], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 CorrectableMc : 1;

                            /* Bits[36:36], Access Type=WO, default=0x00000000*/

                            /* Clear state correctable mc */
    UINT32 RtitMem : 1;

                            /* Bits[37:37], Access Type=WO, default=0x00000000*/

                            /* Pending status for RTIT memory event */
    UINT32 Monitortrap : 1;

                            /* Bits[38:38], Access Type=WO, default=0x00000000*/

                            /* Pending state for Monitor trap */
    UINT32 Btm : 1;

                            /* Bits[39:39], Access Type=WO, default=0x00000000*/

                            /* Pending state for Branch trace message */
    UINT32 Smc : 1;

                            /* Bits[40:40], Access Type=WO, default=0x00000000*/

                            /* Pending state for SMC */
    UINT32 Virtualnuke : 1;

                            /* Bits[41:41], Access Type=WO, default=0x00000000*/

                            /* Pending state for Virtual Nuke */
    UINT32 PeMicrotrap : 1;

                            /* Bits[42:42], Access Type=WO, default=0x00000000*/

                            /* Pending status for PE microtrap */
    UINT32 UcodeMacrotrap : 1;

                            /* Bits[43:43], Access Type=WO, default=0x00000000*/

                            /* Pending state for Ucode macrotrap */
    UINT32 Crd : 1;

                            /* Bits[44:44], Access Type=WO, default=0x00000000*/

                            /*
                               Clear Core Retirement Detector (CRD) pending
                               state
                            */
    UINT32 Rop : 1;

                            /* Bits[45:45], Access Type=WO, default=0x00000000*/

                            /* Pending state for ROP event */
    UINT32 Reserved46 : 1;

                            /* Bits[46:46], Access Type=WO, default=0x00000000*/

                            /* Clear state for RESERVED event */
    UINT32 RtitFlush : 1;

                            /* Bits[47:47], Access Type=WO, default=0x00000000*/

                            /* Clear state for RTIT event */
    UINT32 Nmip : 1;

                            /* Bits[48:48], Access Type=WO, default=0x00000000*/

                            /* Clear state for NMIP */
    UINT32 TxAbortMisspec : 1;

                            /* Bits[49:49], Access Type=WO, default=0x00000000*/

                            /*
                               Clear state for TX_ABORT due to MEU
                               Misspeculation
                            */
    UINT32 TxAbortWatchdog : 1;

                            /* Bits[50:50], Access Type=WO, default=0x00000000*/

                            /*
                               Clear state for TX_ABORT due to Watchdog Time
                               out
                            */
    UINT32 TxCatastrophicAbort : 1;

                            /* Bits[51:51], Access Type=WO, default=0x00000000*/

                            /*
                               Clear state for TX catatrophic abort which is
                               taken as soon as it's posted
                            */
    UINT32 Pebs : 12;

                            /* Bits[63:52], Access Type=WO, default=0x00000000*/

                            /* Clear state for PEBS event per counter */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PPPE_EVENT_RESET_REGISTER;

/**
  Holds various SMX state
**/
#define ICX_MSR_LT_SMX_STATE 0x00000936

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 IlpFlag : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set during SENTER and SEXIT handshakes for the
                               ILP thread. Also set during ENTERACCS
                            */
    UINT32 SenterFlag : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set by SENTER for all threads, cleared by SEXIT */
    UINT32 AcmodeFlag : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Set while AC mode is active */
    UINT32 ShutdownFlag : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this caues leacy shutdown to morph to
                               LT-shutdown
                            */
    UINT32 AuthenticationBypassFlag : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set to bypass AC-module authentication to speed
                               up validation
                            */
    UINT32 PsmiEnable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Set to enable PSMI events during AC-mode */
    UINT32 CramLoadBypass : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Set to bypass CRAM load */
    UINT32 EnteraccsMacro : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Set during ENTERACCS */
    UINT32 SavedGqDisDca : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Saved value of the GQ DCA Disable bit */
    UINT32 LtAbortFlag : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 FitProcessing : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Set during patch load and startup ACM launch
                               while we're processing the FIT.
                            */
    UINT32 SavedSmrrValid : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Saved value of the SMRR valid bit. Used when
                               unlocking TSEG.
                            */
    UINT32 SavedSmrr2Valid : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Saved value of the SMRR2 valid bit. Used when
                               unlocking TSEG.
                            */
    UINT32 SavedBiosDone : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 PackageBsp : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Thread that will send the JOIN cycle to the
                               chipset (RLP BSP) will also set this bit
                            */
    UINT32 SvSenterEn : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enables extended state saving for SV during
                               SENTER
                            */
    UINT32 CrashCode : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Holds the crash code for LT-shutdown. Written to
                               LSBs of LT_CRASH register. Dont change position
                               without CRASH_ACM_SVN
                            */
    UINT32 CrashCodeValid : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Indicates that the crash code is vaild */
    UINT32 PppeEnabled : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Indicates whether PPPE was enabled prior to AC-
                               mode
                            */
    UINT32 SavedTf : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* Saved value of EFLAGS.TF during SEXIT */
    UINT32 TpmBypass : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* Set to bypass TPM registration during SENTER */
    UINT32 Hotadd : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Reserved26 : 5;

                            /* Bits[30:26], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 LtPatchFlag : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 CrashAcmSvn : 8;

                            /* Bits[39:32], Access Type=RW, default=0x00000000*/

                            /*
                               Used in case of Crash-Code = 16, otherwise
                               zeroed. Should be 16 bits shifted left from the
                               CRASH_CODE field.
                            */
    UINT32 Reserved40 : 24;

                            /* Bits[63:40], Access Type=RW, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LT_SMX_STATE_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define ICX_MSR_XU_RESERVED_20 0x0000093F

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define ICX_MSR_PDPTR_0 0x00000940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PDPTR_0_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define ICX_MSR_PDPTR_1 0x00000941

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PDPTR_1_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define ICX_MSR_PDPTR_2 0x00000942

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PDPTR_2_REGISTER;

/**
  Mode C - Protected Mode PagDir Pointers - 0
**/
#define ICX_MSR_PDPTR_3 0x00000943

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 P : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Page Directory Pointer Entry 0 - P bit */
    UINT32 Rsvd1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache write through */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* CR3 page level cache disable */
    UINT32 Rsvd5 : 7;

                            /* Bits[11:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Pdba1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* Page Directory Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PDPTR_3_REGISTER;

/**

**/
#define ICX_MSR_XU_ALL_CORES_POISON 0x0000094E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 PoisonEn : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 ViralEn : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 RasSgxOptin : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 Rsrvd3 : 29;

                            /* Bits[31:3], Access Type=RW, default=None*/

                            /* reserved */
    UINT32 Rsrvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=None*/

                            /* reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XU_ALL_CORES_POISON_REGISTER;
/**

**/
#define ICX_MSR_XU_OPTIN 0x0000094F

/**
  Each bit is command from xucode for specific action. Not really a register.
**/
#define ICX_MSR_XUCODE_UCODE_COMMAND 0x00000950

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnableEmxrr : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* set EMXRR_enable at PMH_CR_RR_MODE[7] */
    UINT32 UpdateCurrentSeSvn : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Updates CURRENT_SE_SVN */
    UINT32 LockSeSvn : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* Sets and lock R_LAST_PATCH_SVN */
    UINT32 SignalMckindEvent : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /*
                               broadcast the MCKIND to all threads in the
                               package will not be formally checked
                            */
    UINT32 DisablePdrCopy : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /*
                               Set FSCP_CR_TAP_MISC.DISABLE_PDR_COPY per
                               Skylake issue 1350825
                            */
    UINT32 SetSmmDelayed : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /*
                               invoke set_smm_delayed_bit ucode routine per
                               Skylake issue 1351518
                            */
    UINT32 ClearSmmDelayed : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /*
                               invoke clear_smm_delayed_bit ucode routine per
                               Skylake issue 1351518
                            */
    UINT32 Reserved7 : 24;

                            /* Bits[30:7], Access Type=RW, default=None*/

                            /* Reserved */
    UINT32 SetSgxSecureEn : 1;

                            /* Bits[31:31], Access Type=RW, default=None*/

                            /* For mcheck to set sgx_secure_en */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XUCODE_UCODE_COMMAND_REGISTER;

/**
  An uncore register indicating that SE is fully installed. Used by CPUID and preamble need to check the option to cache it for each core
**/
#define ICX_MSR_GLOBAL_SE_ENABLE 0x00000951

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 SeEnable : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* enable bit for this thread */
    UINT32 Lock : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* this acts as global SE disable */
    UINT32 Reserved2 : 30;

                            /* Bits[31:2], Access Type=RW, default=None*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_GLOBAL_SE_ENABLE_REGISTER;

/**
  Enclave Linear Space Range Register - Physical Base Control Register
**/
#define ICX_MSR_ELSRR_BASE 0x00000955

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* ELSRR Base Address */
    UINT32 Base1 : 25;

                            /* Bits[56:32], Access Type=RW, default=0x00000000*/

                            /* ELSRR Base Address */
    UINT32 Rsvd57 : 7;

                            /* Bits[63:57], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ELSRR_BASE_REGISTER;

/**
  Enclave Linear Space Range Register - Physical Mask Control Register
**/
#define ICX_MSR_ELSRR_MASK 0x00000956

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* ELSRR MASK bits */
    UINT32 Mask1 : 25;

                            /* Bits[56:32], Access Type=RW, default=0x00000000*/

                            /* ELSRR MASK bits */
    UINT32 Rsvd57 : 7;

                            /* Bits[63:57], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_ELSRR_MASK_REGISTER;

/**
  TCS Physical Address. Pointer to TCS structure, to be used at ASEX
**/
#define ICX_MSR_TCS_PA 0x00000958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TcsPhysAddr0 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 TcsPhysAddr1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 RsvdB52 : 12;

                            /* Bits[63:52], Access Type=RW, default=0x00000000*/

                            /*  */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_TCS_PA_REGISTER;

/**
  Holds SE Active SECS
**/
#define ICX_MSR_SECS_SID 0x00000959

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 EnclaveMode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* The thread is in Enclave Mode */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ActiveSecs0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* ACTIVE_SECS */
    UINT32 ActiveSecs1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* ACTIVE_SECS */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SECS_SID_REGISTER;
/**
  This is a Read-Only xucode MSR.
**/
#define ICX_MSR_FUSE_KEY1_0 0x00000960
/**
  This is a Read-Only xucode MSR.
**/
#define ICX_MSR_FUSE_KEY1_1 0x00000961

/**
  Millicode Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_EMRR_BASE 0x00000962

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Memtype : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* EMRR BASE MemType */
    UINT32 Rsvd3 : 9;

                            /* Bits[11:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* EMRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EMRR_BASE_REGISTER;

/**
  Millicode Memory Range Register - Physical Mask Control Register
**/
#define ICX_MSR_EMRR_MASK 0x00000963

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 9;

                            /* Bits[8:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, EMRR is in assist-mode - else in page
                               abort-mode (defeature only)
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the EMRR */
    UINT32 Vld : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Enable bit for the EMRR */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMRR MASK bits */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* EMRR MASK bits */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EMRR_MASK_REGISTER;

/**
  Xucode Memory Range Register - Physical Base Control Register
**/
#define ICX_MSR_EMXRR_BASE 0x00000964

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMXRR Base Address */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* EMXRR Base Address */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EMXRR_BASE_REGISTER;

/**
  Xucode Memory Range Register - Physical Mask Control Register
**/
#define ICX_MSR_EMXRR_MASK 0x00000965

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 10;

                            /* Bits[9:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the EMXRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* EMXRR MASK bits */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /* EMXRR MASK bits */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EMXRR_MASK_REGISTER;
/**
  This define is used to reserve some MSR addresses for XuCode. Ucode would have a dedicated handler for these MSRs
**/
#define ICX_MSR_XU_RESERVED_31 0x00000967
/**
  This is uncore SCP. RO MSR to provide 128 bits of external entropy used for key derivation.
**/
#define ICX_MSR_MEE_SETUP 0x0000096A

/**
  MEE init register
**/
#define ICX_MSR_EE_INIT 0x0000096C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Lock : 1;

                            /* Bits[0:0], Access Type=RW_KL, default=0x00000000*/

                            /* Lock bit. */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_EE_INIT_REGISTER;

/**
  Holds XCR0 and XSAVE Compaction Vector (used for XMODIFIED optimization check)
**/
#define ICX_MSR_XCR0 0x0000096D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 X87 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Bit 0 => FP */
    UINT32 Sse : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Bit 1 => SSE */
    UINT32 Gsse : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Bit 2 => GSSE */
    UINT32 PlBndregs : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Bit 3 => PL BNDREGS */
    UINT32 PlBndcfs : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Bit 4 => PL BNDCFS */
    UINT32 Kmask : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Bit 5 => KMASK */
    UINT32 Avx3150 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Bit 6 => AVX3(15:0) */
    UINT32 Avx33116 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Bit 7 => AVX3(31:16) */
    UINT32 RsvdIaXssRtit8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit 8 is reserved because of use as RTIT bit in
                               IA_XSS.
                            */
    UINT32 Pkru : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Bit 9 => Page Protection Keys User. */
    UINT32 Rsvd10 : 22;

                            /* Bits[31:10], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Unused bits. */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_XCR0_REGISTER;
/**
  PCHSGXID 0 exposed in PCH by CSME
**/
#define ICX_MSR_SGX_RDPCHSGXID_0 0x00000970
/**
  PCHSGXID 1 exposed in PCH by CSME
**/
#define ICX_MSR_SGX_RDPCHSGXID_1 0x00000971
/**
  MCHECK XuCode register that holds address of uncore register to be written
**/
#define ICX_MSR_MCHECK_CPU_REGISTER_ADDRESS 0x00000972
/**
  Virtual MSR to will write data to an Uncore CR.
  The write is invoked by MCHECK flow.
  CR address is taken from MSR 0x972
**/
#define ICX_MSR_MCHECK_CPU_REGISTER_DATA 0x00000973
/**
  MSR to read/write ubox LOW TME EPHEMERAL KEY
**/
#define ICX_MSR_BIOS_TME_KEY_0 0x00000992
/**
  MSR to read/write ubox HIGH TME EPHEMERAL KEY
**/
#define ICX_MSR_BIOS_TME_KEY_1 0x00000993
/**
  Virtual MSR to read TME_ACTIVATE[MK_TME_KEYID_BITS] from SoC.
  Write with EDX:EAX == 0 will translate the above value into PMH mask register.
**/
#define ICX_MSR_CORE_MKTME_ACTIVATION 0x000009FF

/**

**/
#define ICX_MSR_STACK0_M2P_PMONUNITCTRL0 0x00000A40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_M2P_CTR_0 0x00000A41

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_M2P_CTR_1 0x00000A42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_M2P_CTR_2 0x00000A43

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_M2P_CTR_3 0x00000A44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK0_M2P_PMONUNITSTATUS0 0x00000A45

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_PMONUNITSTATUS0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_M2P_CTR_CFG_2 0x00000A48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_M2P_CTR_CFG_3 0x00000A49

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK0_IRP_PMONUNITCTRL0 0x00000A4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IRP_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IRP_CTR_0 0x00000A4B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IRP_CTR_1 0x00000A4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_M2P_CTR_CFG_0 0x00000A4D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_M2P_CTR_CFG_1 0x00000A4E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK0_IRP_PMONUNITSTATUS0 0x00000A4F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IRP_PMONUNITSTATUS0_REGISTER;

/**

**/
#define ICX_MSR_STACK0_IO_PMONUNITCTRL0 0x00000A50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IO_CTR_0 0x00000A51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IO_CTR_1 0x00000A52

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IO_CTR_2 0x00000A53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK0_IO_CTR_3 0x00000A54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK0_IO_PMONFRCNTRCLK0 0x00000A55

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_PMONFRCNTRCLK0_REGISTER;

/**

**/
#define ICX_MSR_STACK0_IO_PMONUNITSTATUS0 0x00000A57

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_PMONUNITSTATUS0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_IO_CTR_CFG_0 0x00000A58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_IO_CTR_CFG_1 0x00000A59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_IO_CTR_CFG_2 0x00000A5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK0_IO_CTR_CFG_3 0x00000A5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_IO_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK1_M2P_PMONUNITCTRL1 0x00000A60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_M2P_CTR_0 0x00000A61

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_M2P_CTR_1 0x00000A62

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_M2P_CTR_2 0x00000A63

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_M2P_CTR_3 0x00000A64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK1_M2P_PMONUNITSTATUS1 0x00000A65

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_PMONUNITSTATUS1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_M2P_CTR_CFG_2 0x00000A68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_M2P_CTR_CFG_3 0x00000A69

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK1_IRP_PMONUNITCTRL1 0x00000A6A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IRP_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IRP_CTR_0 0x00000A6B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IRP_CTR_1 0x00000A6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_M2P_CTR_CFG_0 0x00000A6D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_M2P_CTR_CFG_1 0x00000A6E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK1_IRP_PMONUNITSTATUS1 0x00000A6F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IRP_PMONUNITSTATUS1_REGISTER;

/**

**/
#define ICX_MSR_STACK1_IO_PMONUNITCTRL1 0x00000A70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IO_CTR_0 0x00000A71

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IO_CTR_1 0x00000A72

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IO_CTR_2 0x00000A73

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK1_IO_CTR_3 0x00000A74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK1_IO_PMONFRCNTRCLK1 0x00000A75

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_PMONFRCNTRCLK1_REGISTER;

/**

**/
#define ICX_MSR_STACK1_IO_PMONUNITSTATUS1 0x00000A77

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_PMONUNITSTATUS1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_IO_CTR_CFG_0 0x00000A78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_IO_CTR_CFG_1 0x00000A79

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_IO_CTR_CFG_2 0x00000A7A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK1_IO_CTR_CFG_3 0x00000A7B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_IO_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK2_M2P_PMONUNITCTRL2 0x00000A80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_M2P_CTR_0 0x00000A81

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_M2P_CTR_1 0x00000A82

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_M2P_CTR_2 0x00000A83

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_M2P_CTR_3 0x00000A84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK2_M2P_PMONUNITSTATUS2 0x00000A85

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_PMONUNITSTATUS2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_M2P_CTR_CFG_2 0x00000A88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_M2P_CTR_CFG_3 0x00000A89

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK2_IRP_PMONUNITCTRL2 0x00000A8A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IRP_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IRP_CTR_0 0x00000A8B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IRP_CTR_1 0x00000A8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_M2P_CTR_CFG_0 0x00000A8D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_M2P_CTR_CFG_1 0x00000A8E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK2_IRP_PMONUNITSTATUS2 0x00000A8F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IRP_PMONUNITSTATUS2_REGISTER;

/**

**/
#define ICX_MSR_STACK2_IO_PMONUNITCTRL2 0x00000A90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IO_CTR_0 0x00000A91

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IO_CTR_1 0x00000A92

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IO_CTR_2 0x00000A93

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK2_IO_CTR_3 0x00000A94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK2_IO_PMONFRCNTRCLK2 0x00000A95

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_PMONFRCNTRCLK2_REGISTER;

/**

**/
#define ICX_MSR_STACK2_IO_PMONUNITSTATUS2 0x00000A97

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_PMONUNITSTATUS2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_IO_CTR_CFG_0 0x00000A98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_IO_CTR_CFG_1 0x00000A99

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_IO_CTR_CFG_2 0x00000A9A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK2_IO_CTR_CFG_3 0x00000A9B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_IO_CTR_CFG_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_0 0x00000AA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_1 0x00000AA1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_2 0x00000AA2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_3 0x00000AA3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_4 0x00000AA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_5 0x00000AA5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_6 0x00000AA6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_7 0x00000AA7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_8 0x00000AA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_9 0x00000AA9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_10 0x00000AAA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_11 0x00000AAB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_12 0x00000AAC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_13 0x00000AAD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_14 0x00000AAE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK0_TC_PMONFRCNTR_15 0x00000AAF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK0_TC_PMONFRCNTR_15_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_0 0x00000AB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_1 0x00000AB1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_2 0x00000AB2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_3 0x00000AB3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_4 0x00000AB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_5 0x00000AB5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_6 0x00000AB6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_7 0x00000AB7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_8 0x00000AB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_9 0x00000AB9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_10 0x00000ABA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_11 0x00000ABB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_12 0x00000ABC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_13 0x00000ABD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_14 0x00000ABE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK1_TC_PMONFRCNTR_15 0x00000ABF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK1_TC_PMONFRCNTR_15_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_0 0x00000AC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_1 0x00000AC1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_2 0x00000AC2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_3 0x00000AC3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_4 0x00000AC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_5 0x00000AC5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_6 0x00000AC6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_7 0x00000AC7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_8 0x00000AC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_9 0x00000AC9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_10 0x00000ACA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_11 0x00000ACB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_12 0x00000ACC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_13 0x00000ACD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_14 0x00000ACE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK2_TC_PMONFRCNTR_15 0x00000ACF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK2_TC_PMONFRCNTR_15_REGISTER;

/**

**/
#define ICX_MSR_STACK3_M2P_PMONUNITCTRL0 0x00000AD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_M2P_CTR_0 0x00000AD1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_M2P_CTR_1 0x00000AD2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_M2P_CTR_2 0x00000AD3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_M2P_CTR_3 0x00000AD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK3_M2P_PMONUNITSTATUS0 0x00000AD5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_PMONUNITSTATUS0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_M2P_CTR_CFG_2 0x00000AD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_M2P_CTR_CFG_3 0x00000AD9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK3_IRP_PMONUNITCTRL0 0x00000ADA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IRP_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IRP_CTR_0 0x00000ADB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IRP_CTR_1 0x00000ADC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_M2P_CTR_CFG_0 0x00000ADD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_M2P_CTR_CFG_1 0x00000ADE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK3_IRP_PMONUNITSTATUS0 0x00000ADF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IRP_PMONUNITSTATUS0_REGISTER;

/**

**/
#define ICX_MSR_STACK3_IO_PMONUNITCTRL0 0x00000AE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_PMONUNITCTRL0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IO_CTR_0 0x00000AE1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IO_CTR_1 0x00000AE2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IO_CTR_2 0x00000AE3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK3_IO_CTR_3 0x00000AE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK3_IO_PMONFRCNTRCLK0 0x00000AE5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_PMONFRCNTRCLK0_REGISTER;

/**

**/
#define ICX_MSR_STACK3_IO_PMONUNITSTATUS0 0x00000AE7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_PMONUNITSTATUS0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_IO_CTR_CFG_0 0x00000AE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_IO_CTR_CFG_1 0x00000AE9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_IO_CTR_CFG_2 0x00000AEA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK3_IO_CTR_CFG_3 0x00000AEB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_IO_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK4_M2P_PMONUNITCTRL1 0x00000AF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_M2P_CTR_0 0x00000AF1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_M2P_CTR_1 0x00000AF2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_M2P_CTR_2 0x00000AF3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_M2P_CTR_3 0x00000AF4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK4_M2P_PMONUNITSTATUS1 0x00000AF5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_PMONUNITSTATUS1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_M2P_CTR_CFG_2 0x00000AF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_M2P_CTR_CFG_3 0x00000AF9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK4_IRP_PMONUNITCTRL1 0x00000AFA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IRP_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IRP_CTR_0 0x00000AFB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IRP_CTR_1 0x00000AFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_M2P_CTR_CFG_0 0x00000AFD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_M2P_CTR_CFG_1 0x00000AFE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK4_IRP_PMONUNITSTATUS1 0x00000AFF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IRP_PMONUNITSTATUS1_REGISTER;

/**

**/
#define ICX_MSR_STACK4_IO_PMONUNITCTRL1 0x00000B00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_PMONUNITCTRL1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IO_CTR_0 0x00000B01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IO_CTR_1 0x00000B02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IO_CTR_2 0x00000B03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK4_IO_CTR_3 0x00000B04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK4_IO_PMONFRCNTRCLK1 0x00000B05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_PMONFRCNTRCLK1_REGISTER;

/**

**/
#define ICX_MSR_STACK4_IO_PMONUNITSTATUS1 0x00000B07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_PMONUNITSTATUS1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_IO_CTR_CFG_0 0x00000B08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_IO_CTR_CFG_1 0x00000B09

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_IO_CTR_CFG_2 0x00000B0A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK4_IO_CTR_CFG_3 0x00000B0B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_IO_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK5_M2P_PMONUNITCTRL2 0x00000B10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_M2P_CTR_0 0x00000B11

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_M2P_CTR_1 0x00000B12

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_M2P_CTR_2 0x00000B13

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_M2P_CTR_3 0x00000B14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK5_M2P_PMONUNITSTATUS2 0x00000B15

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_PMONUNITSTATUS2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_M2P_CTR_CFG_2 0x00000B18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_M2P_CTR_CFG_3 0x00000B19

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_CFG_3_REGISTER;

/**

**/
#define ICX_MSR_STACK5_IRP_PMONUNITCTRL2 0x00000B1A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IRP_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IRP_CTR_0 0x00000B1B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IRP_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IRP_CTR_1 0x00000B1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IRP_CTR_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_M2P_CTR_CFG_0 0x00000B1D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_M2P_CTR_CFG_1 0x00000B1E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW_V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               Perf counter for which the event select register
                               is associated to be clearedto all 0 when a 1 is
                               written to it. No action is taken when 0 is
                               written. Note since the queue occupancy counters
                               will never drop to 0 , it is possible for the
                               counters to catch up with the real occupancy of
                               the queuein question when the real occupancy
                               drops to 0
                            */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event.
                               Internal events are only accessible on unlocked
                               parts. One can think of an internal bit as an
                               extension of the event select bits 7:0, as it
                               allows theuse to gain access to additional
                               events. For perfmons that exist in teh MSR space
                               , the MSR write mask is set on this bit and teh
                               ucode handler will trigger a GP fault if one
                               attempts to write to these bits. Writing to
                               these bits is controlled in otehr ways in the
                               other units
                            */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 Threshold : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_M2P_CTR_CFG_1_REGISTER;

/**

**/
#define ICX_MSR_STACK5_IRP_PMONUNITSTATUS2 0x00000B1F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IRP_PMONUNITSTATUS2_REGISTER;

/**

**/
#define ICX_MSR_STACK5_IO_PMONUNITCTRL2 0x00000B20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezeenable : 1;

                            /* Bits[16:16], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls what the counters in the unit
                               will do when they receive a freeze signal. When
                               set, the counters will be allowed to freeze.
                               When not set, the counters will ignore the
                               freeze signal. For freeze to be enabled for a
                               given unit, all of the unit control registers
                               must have this bit set.
                            */
    UINT32 Overflowenable : 1;

                            /* Bits[17:17], Access Type=RW_L, default=0x00000001*/

                            /*
                               This bit controls the behavior of counters when
                               they overflow. When set, the system will trigger
                               the overflow handling process throughout the
                               rest of the uncore, potentially triggering a PMI
                               and freezing counters. When it is not set, the
                               counters will simply wrap around and continue to
                               count. For overflow to be enabled for a given
                               unit, all of the unit control registers must
                               have this bit set.
                            */
    UINT32 Rsvd18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_PMONUNITCTRL2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IO_CTR_0 0x00000B21

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_0_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IO_CTR_1 0x00000B22

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_1_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IO_CTR_2 0x00000B23

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_2_REGISTER;

/**
  This register is a perf counter. Software can read it and write it
**/
#define ICX_MSR_STACK5_IO_CTR_3 0x00000B24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Countervalue1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* The value of the counter */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_3_REGISTER;

/**

**/
#define ICX_MSR_STACK5_IO_PMONFRCNTRCLK2 0x00000B25

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /*
                               This register is a perfmon counter. Software can
                               both read it and write it
                            */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_PMONFRCNTRCLK2_REGISTER;

/**

**/
#define ICX_MSR_STACK5_IO_PMONUNITSTATUS2 0x00000B27

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW1C, default=0x00000000*/

                            /* counter 0 overflowed */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW1C, default=0x00000000*/

                            /* counter 1 overflowed */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW1C, default=0x00000000*/

                            /* counter 2 overflowed */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW1C, default=0x00000000*/

                            /* counter 3 overflowed */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_PMONUNITSTATUS2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_IO_CTR_CFG_0 0x00000B28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_CFG_0_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_IO_CTR_CFG_1 0x00000B29

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_CFG_1_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_IO_CTR_CFG_2 0x00000B2A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_CFG_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_STACK5_IO_CTR_CFG_3 0x00000B2B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Eventselect : 8;

                            /* Bits[7:0], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective individual unit performance
                               monitoring documentation.
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bitwise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 Rsvd16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterreset : 1;

                            /* Bits[17:17], Access Type=RW_V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 Edgedetect : 1;

                            /* Bits[18:18], Access Type=RW_V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge).ect only works in conjunction with
                               threshholding. This is true even for events that
                               can only increment by 1 in a given cycle (like
                               the L1 example above). In this case, one should
                               set a threshhold of 1. One can also use Edge
                               Detect with queue occupancy events. For example,
                               if one wanted to count the number of times when
                               the TOR occupancy was larger than 5, one would
                               selet the TOR occupancy event with a threshold
                               of 5 and set the Edge Detect bit. Can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will always on
                               differ by 1.
                            */
    UINT32 Rsvd19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Overflowenable : 1;

                            /* Bits[20:20], Access Type=RW_V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 Rsvd21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Counterenable : 1;

                            /* Bits[22:22], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold event.
                               When set to 1, the comparison that will be done
                               is inverted from the case where this bit is set
                               to 0, i.e., threshold event. The invert bit only
                               works when Threshhold != 0. So, if one would
                               like to invert a non-occupancy event (like LLC
                               Hit), one needs to set the threshhold to 1.
                            */
    UINT32 ResThreshold0 : 8;

                            /* Bits[31:24], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 ResThreshold1 : 4;

                            /* Bits[35:32], Access Type=RW_V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the ITC/OTC is 10 bits
                               (queue occupancy), it is 10 bit wide. The result
                               of the comparison is effectively a 1 bit wide
                               event, i.e., the counter will be incremented by
                               1 when the comparison is true (the type of
                               comparison depends on the setting of the invert
                               bit - see bit 23 below) no matter how wide the
                               original event was. When this field is zero,
                               threshold comparison is disabled and the event
                               is passed without modification.
                            */
    UINT32 Chnlmask : 12;

                            /* Bits[47:36], Access Type=RW, default=0x00000FFF*/

                            /*
                               This one-hot field specifies which PCIE links
                               should be considered when counting PerfMon
                               events. For example, if only bit 1 is set, then
                               only events corresponding to PCIE link 1 will be
                               counted.
                            */
    UINT32 Fcmask : 3;

                            /* Bits[50:48], Access Type=RW, default=0x00000007*/

                            /*
                               This one-hot field specifies which FCs should be
                               considered when counting PerfMon events: Bit 0 -
                               Posted requests Bit 1 - Non-posted requests Bit
                               2 - Completions
                            */
    UINT32 Rsvd51 : 13;

                            /* Bits[63:51], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_IO_CTR_CFG_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_0 0x00000B30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_1 0x00000B31

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_2 0x00000B32

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_3 0x00000B33

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_4 0x00000B34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_5 0x00000B35

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_6 0x00000B36

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_7 0x00000B37

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_8 0x00000B38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_9 0x00000B39

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_10 0x00000B3A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_11 0x00000B3B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_12 0x00000B3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_13 0x00000B3D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_14 0x00000B3E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK3_TC_PMONFRCNTR_15 0x00000B3F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK3_TC_PMONFRCNTR_15_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_0 0x00000B40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_1 0x00000B41

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_2 0x00000B42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_3 0x00000B43

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_4 0x00000B44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_5 0x00000B45

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_6 0x00000B46

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_7 0x00000B47

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_8 0x00000B48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_9 0x00000B49

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_10 0x00000B4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_11 0x00000B4B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_12 0x00000B4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_13 0x00000B4D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_14 0x00000B4E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK4_TC_PMONFRCNTR_15 0x00000B4F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK4_TC_PMONFRCNTR_15_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_0 0x00000B50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_0_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_1 0x00000B51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_1_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_2 0x00000B52

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_2_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_3 0x00000B53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_3_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_4 0x00000B54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_4_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_5 0x00000B55

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_5_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_6 0x00000B56

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_6_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_7 0x00000B57

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_7_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_8 0x00000B58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_8_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_9 0x00000B59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_9_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_10 0x00000B5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_10_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_11 0x00000B5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_11_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_12 0x00000B5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_12_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_13 0x00000B5D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_13_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_14 0x00000B5E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_14_REGISTER;

/**
  This is the foward counter. Software can read and write into it
**/
#define ICX_MSR_STACK5_TC_PMONFRCNTR_15 0x00000B5F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Countervalue0 : 32;

                            /* Bits[31:0], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Countervalue1 : 4;

                            /* Bits[35:32], Access Type=RO_V, default=0x00000000*/

                            /* The current value of the counter */
    UINT32 Rsvd36 : 28;

                            /* Bits[63:36], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_STACK5_TC_PMONFRCNTR_15_REGISTER;

/**
  Available only in SMM. SMRAM copy of CR3 saved by SMI
**/
#define ICX_MSR_SMRAM_CR3 0x00000C01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsv : 3;

                            /* Bits[2:0], Access Type=RW, default=None*/

                            /* Reserved bits, reset value T0 = 3'b0, T1=3'b111 */
    UINT32 Pwt : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /*
                               CR3 page level cache write through, reset value
                               T0 = 0, T1 = 1
                            */
    UINT32 Pcd : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /*
                               CR3 page level cache disable reset value T0 = 0,
                               T1 = 1
                            */
    UINT32 PdptrPdb : 7;

                            /* Bits[11:5], Access Type=RW, default=None*/

                            /*
                               PD Pntr Base, extended range for Mode-C paging,
                               reset val T0 ? 7'h78 : 7'h07
                            */
    UINT32 Pdba0 : 20;

                            /* Bits[31:12], Access Type=RW, default=None*/

                            /*
                               CR3 page directory base address , T0 ? 20'hfffff
                               : 20'hffff0
                            */
    UINT32 Pdba1 : 21;

                            /* Bits[52:32], Access Type=RW, default=None*/

                            /*
                               CR3 page directory base address , T0 ? 20'hfffff
                               : 20'hffff0
                            */
    UINT32 Rsvd53 : 11;

                            /* Bits[63:53], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMRAM_CR3_REGISTER;

/**
  Available only in SMM. SMRAM copy of CR0 saved by SMI
**/
#define ICX_MSR_SMRAM_CR4 0x00000C37

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Vme : 1;

                            /* Bits[0:0], Access Type=RW, default=None*/

                            /* Enables virtual 8086-mode extensions */
    UINT32 Pvi : 1;

                            /* Bits[1:1], Access Type=RW, default=None*/

                            /* Protected-Mode Virtual Interrupts */
    UINT32 Tsd : 1;

                            /* Bits[2:2], Access Type=RW, default=None*/

                            /* Time Stamp Disable */
    UINT32 De : 1;

                            /* Bits[3:3], Access Type=RW, default=None*/

                            /* Debugging Extensions */
    UINT32 Pse : 1;

                            /* Bits[4:4], Access Type=RW, default=None*/

                            /* Page Size Extensions */
    UINT32 Pae : 1;

                            /* Bits[5:5], Access Type=RW, default=None*/

                            /* Physical Address Extension */
    UINT32 Mce : 1;

                            /* Bits[6:6], Access Type=RW, default=None*/

                            /* Machine check Enable */
    UINT32 Pge : 1;

                            /* Bits[7:7], Access Type=RW, default=None*/

                            /* Page Global Enable */
    UINT32 Pce : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /* Performance-monitoring Counter Enable */
    UINT32 Osfxsr : 1;

                            /* Bits[9:9], Access Type=RW, default=None*/

                            /* Enables the fast FXsave and FXrestore */
    UINT32 Xmmexc : 1;

                            /* Bits[10:10], Access Type=RW, default=None*/

                            /* Enables the exceptions for Katmia */
    UINT32 Umip : 1;

                            /* Bits[11:11], Access Type=RW, default=None*/

                            /* UMIP Enable */
    UINT32 Rsvd12 : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 VmxEnable : 1;

                            /* Bits[13:13], Access Type=RW, default=None*/

                            /* Logic 1 indicates that VMX is enabled */
    UINT32 SmxEnable : 1;

                            /* Bits[14:14], Access Type=RW, default=None*/

                            /* Logic 1 indicates that SMX is enabled */
    UINT32 Slc64 : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /* Logic 1 indicates that SLC64 is enabled */
    UINT32 FsGsBase : 1;

                            /* Bits[16:16], Access Type=RW, default=None*/

                            /*
                               Logic 1 indicates that Ring3 Segment Base Access
                               is enabled. This allows reading/writing the
                               FS/GS segment bases through instructions
                               RDFSBASE. WRFSBASE, RDGSBASE or WRGSBASE.
                            */
    UINT32 Pcide : 1;

                            /* Bits[17:17], Access Type=RW, default=None*/

                            /* Logic 1 indicates that PCID is enabled */
    UINT32 Osxsave : 1;

                            /* Bits[18:18], Access Type=RW, default=None*/

                            /* Logic 1 indicates that XSAVE is enabled */
    UINT32 Rsvd19 : 4;

                            /* Bits[22:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 La57 : 1;

                            /* Bits[23:23], Access Type=RW, default=None*/

                            /* Logic 1 indicates that VA of 57 width is enabled */
    UINT32 Rsvd24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_SMRAM_CR4_REGISTER;

/**
  IO QOS cfg
**/
#define ICX_MSR_IO_QOS_CFG 0x00000C83

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 IoQosEnf : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* IIO qos enf enable */
    UINT32 IoQosMon : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* IIO qos mon enable - RSVD in ICX */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IO_QOS_CFG_REGISTER;

/**
  MBA (mem bandwidth alloc) cfg
**/
#define ICX_MSR_MBA_CFG 0x00000C84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 MinMaxDelay : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Min (0) or Max (1) of per-core CLOS delays */
    UINT32 MbaEn : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* MBA hardware ctrlr enable */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MBA_CFG_REGISTER;

/**
  way mask for locked LLC ways. If the hit way intersects this mask, LLC to SF migration is disabled
**/
#define ICX_MSR_L3_PROTECTED_WAYS 0x00000C85

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mask : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /* way mask */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_L3_PROTECTED_WAYS_REGISTER;

/**
  model specific msr to enable maksing of events that MBM counts
**/
#define ICX_MSR_MBM_CFG_3DXP 0x00000C86

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mbmcountnonddrt : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* dram bw included in count */
    UINT32 Mbmcountddrt : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* 3dxp bw included in count */
    UINT32 Rsvd2 : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_MBM_CFG_3DXP_REGISTER;

/**
  Way Mask for IIO accesses (SF and LLC)
**/
#define ICX_MSR_IIO_LLC_WAYS 0x00000C8B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iiocosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000C0000*/

                            /*
                               available LLC/SF way vectors for class of
                               service of IIO (default is top 2 ways)
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IIO_LLC_WAYS_REGISTER;

/**
  uCR: LRU Update values for various opcodes that update the LRU bits.
**/
#define ICX_MSR_QLRU_CONFIG 0x00000C8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Cr0 : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000003*/

                            /* LRU Age Update value for CRd/Monitor on LLC Hit */
    UINT32 Cr1 : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000003*/

                            /*
                               LRU Age Update value for Prefetch Code (to MLC)
                               on LLC Hit
                            */
    UINT32 Cr2 : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000002*/

                            /*
                               LRU Age Update value for Prefetch Code (to LLC)
                               on LLC Hit
                            */
    UINT32 Cr3 : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000002*/

                            /*
                               LRU Age Update value for DRd/RFO/DRdPTE/ItoM on
                               LLC Hit
                            */
    UINT32 Cr4 : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000002*/

                            /*
                               LRU Age Update value for Prefetch data (to MLC)
                               on LLC Hit
                            */
    UINT32 Cr5 : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000002*/

                            /*
                               LRU Age Update value for PrefRFO / PrefData (to
                               LLC) on LLC Hit
                            */
    UINT32 Cr6 : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000003*/

                            /*
                               LRU Age Update value for CRd / Monitor on LLC
                               Miss (Normal Fill)
                            */
    UINT32 Cr7 : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000003*/

                            /*
                               LRU Age Update value for Prefetch Code (to MLC)
                               on LLC Miss (Normal Fill)
                            */
    UINT32 Cr8 : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for Prefetch Code (to LLC)
                               on LLC Miss (Normal Fill)
                            */
    UINT32 Cr9 : 2;

                            /* Bits[19:18], Access Type=RW, default=0x00000002*/

                            /*
                               LRU Age Update value for DRd / RFO / DRdPTE /
                               ItoM on LLC Miss (Normal Fill)
                            */
    UINT32 CrB : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for Prefetch data (to MLC)
                               on LLC Miss (Normal Fill)
                            */
    UINT32 CrD : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for PrefRFO / PrefData (to
                               LLC) on LLC Miss (Normal Fill)
                            */
    UINT32 CrF : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000003*/

                            /*
                               LRU Age Update value for demand read and MLC
                               prefetche on LLC Hit, when the current age is
                               2/3.
                            */
    UINT32 Cr10 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000002*/

                            /* LRU Age update value for IIO requests on LLC Hit */
    UINT32 Cr11 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* LRU Age update for IIO requests on LLC Miss */
    UINT32 Cr12 : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000001*/

                            /* LRU Age update for Writebacks */
    UINT32 Cr13 : 2;

                            /* Bits[33:32], Access Type=RW, default=0x00000003*/

                            /* LRU Age update for WbPushHint */
    UINT32 Rsvd34 : 10;

                            /* Bits[43:34], Access Type=RW, default=0x00000000*/

                            /* LRU Age update for WbPushHint */
    UINT32 Cr6Llc : 2;

                            /* Bits[45:44], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for CRd / Monitor on LLC
                               allocate
                            */
    UINT32 Cr7Llc : 2;

                            /* Bits[47:46], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for Prefetch Code (to MLC)
                               on LLC allocate
                            */
    UINT32 Rsvd48 : 2;

                            /* Bits[49:48], Access Type=RW, default=0x00000001*/

                            /* Reserved */
    UINT32 Cr9Llc : 2;

                            /* Bits[51:50], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for DRd / RFO / DRdPTE /
                               ItoM on LLC Miss (Vulnerable Fill)
                            */
    UINT32 CrBLlc : 2;

                            /* Bits[53:52], Access Type=RW, default=0x00000001*/

                            /*
                               LRU Age Update value for Prefetch data (to MLC)
                               on LLC Miss (Vulnerable Fill)
                            */
    UINT32 Cr14 : 2;

                            /* Bits[55:54], Access Type=RW, default=0x00000000*/

                            /* LRU Age update for CLCleanse */
    UINT32 Cr15 : 2;

                            /* Bits[57:56], Access Type=RW, default=0x00000003*/

                            /* LRU Age update for LLC allocation from SF Victim */
    UINT32 Cr16 : 2;

                            /* Bits[59:58], Access Type=RW, default=0x00000000*/

                            /* LRU Age update for Remote Requests */
    UINT32 Rsvd60 : 2;

                            /* Bits[61:60], Access Type=RW, default=0x00000001*/

                            /* Reserved */
    UINT32 Rsvd62 : 2;

                            /* Bits[63:62], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QLRU_CONFIG_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_0 0x00000C90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_0_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_1 0x00000C91

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_1_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_2 0x00000C92

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_2_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_3 0x00000C93

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_3_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_4 0x00000C94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_4_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_5 0x00000C95

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_5_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_6 0x00000C96

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_6_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_7 0x00000C97

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_7_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_8 0x00000C98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_8_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_9 0x00000C99

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_9_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_10 0x00000C9A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_10_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_11 0x00000C9B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_11_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_12 0x00000C9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_12_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_13 0x00000C9D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_13_REGISTER;

/**
  This MSR is used for Cache enforcement
**/
#define ICX_MSR_COSWAYS_14 0x00000C9E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Iacosways : 20;

                            /* Bits[19:0], Access Type=RW, default=0x000FFFFF*/

                            /*
                               available ways vectors for class of service of
                               IA core
                            */
    UINT32 Rsvd20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_COSWAYS_14_REGISTER;

/**
  If set, RMID will be compared with FinalCHAID = BaseCHA_Cluster + HashCHAID. If not set, RMID will be compared with HashCHAID
**/
#define ICX_MSR_RMID_SNC_DISABLE 0x00000CA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RmidSncDisable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* see desc */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_RMID_SNC_DISABLE_REGISTER;

/**
  Apply correction factor upon data return through the IA32_QM_CTR MSR
**/
#define ICX_MSR_QMC_CNTR_CORRECTION 0x00000CA1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threshold : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* see desc */
    UINT32 CorrectionFactor : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* see desc */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QMC_CNTR_CORRECTION_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_0 0x00000D50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_0_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_1 0x00000D51

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_1_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_2 0x00000D52

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_2_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_3 0x00000D53

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_3_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_4 0x00000D54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_4_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_5 0x00000D55

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_5_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_6 0x00000D56

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_6_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_7 0x00000D57

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_7_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_8 0x00000D58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_8_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_9 0x00000D59

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_9_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_10 0x00000D5A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_10_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_11 0x00000D5B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_11_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_12 0x00000D5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_12_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_13 0x00000D5D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_13_REGISTER;

/**
  This MSR is used for Memory BW enforcement
**/
#define ICX_MSR_QOS_EXT_BW_THRTL_14 0x00000D5E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 RbeEnforcementVal : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* The mem bw thrtl value */
    UINT32 Reserved16 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 Reserved32 : 32;

                            /* Bits[63:32], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_QOS_EXT_BW_THRTL_14_REGISTER;

/**
  Extensible Supervisor State MSR
**/
#define ICX_MSR_IA32_XSS 0x00000DA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Mbz : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Must-Be-Zero */
    UINT32 RtitSupport : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* RTIT X* support */
    UINT32 Mbz2 : 4;

                            /* Bits[12:9], Access Type=RW, default=0x00000000*/

                            /* Must-Be-Zero */
    UINT32 HdcSupport : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* HDC support */
    UINT32 Reserved14 : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /* Reserved for future growth */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_IA32_XSS_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_0 0x00000DC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_0_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_1 0x00000DC1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_1_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_2 0x00000DC2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_2_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_3 0x00000DC3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_3_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_4 0x00000DC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_4_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_5 0x00000DC5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_5_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_6 0x00000DC6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_6_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_7 0x00000DC7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_7_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_8 0x00000DC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_8_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_9 0x00000DC9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_9_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_10 0x00000DCA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_10_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_11 0x00000DCB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_11_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_12 0x00000DCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_12_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_13 0x00000DCD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_13_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_14 0x00000DCE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_14_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_15 0x00000DCF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_15_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_16 0x00000DD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_16_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_17 0x00000DD1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_17_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_18 0x00000DD2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_18_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_19 0x00000DD3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_19_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_20 0x00000DD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_20_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_21 0x00000DD5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_21_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_22 0x00000DD6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_22_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_23 0x00000DD7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_23_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_24 0x00000DD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_24_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_25 0x00000DD9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_25_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_26 0x00000DDA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_26_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_27 0x00000DDB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_27_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_28 0x00000DDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_28_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_29 0x00000DDD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_29_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_30 0x00000DDE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_30_REGISTER;

/**
  LBR MSR that holds non-IP information
**/
#define ICX_MSR_LBR_INFO_31 0x00000DDF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 CycleCount : 16;

                            /* Bits[15:0], Access Type=RW_V, default=None*/

                            /* core-clocks elapsed since last LBR array update */
    UINT32 Rsvd16 : 16;

                            /* Bits[31:16], Access Type=RW_V, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 29;

                            /* Bits[60:32], Access Type=RW_V, default=None*/

                            /* Reserved */
    UINT32 HleAbort : 1;

                            /* Bits[61:61], Access Type=RW_V, default=None*/

                            /* HLE/+ TX Abort occured */
    UINT32 InTx : 1;

                            /* Bits[62:62], Access Type=RW_V, default=None*/

                            /* Executing in HLE/+ TX */
    UINT32 Mispred : 1;

                            /* Bits[63:63], Access Type=RW_V, default=None*/

                            /* Misprediction bit */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_LBR_INFO_31_REGISTER;

/**
  When this bit is written to, the counter configuration registers will be reset. This does not effect the values in the counters. To reset the counters, this bit need only be set by one of the unit control registers
**/
#define ICX_MSR_CBOPMONUNITCTRL 0x00000E00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Resetcounterconfigs : 1;

                            /* Bits[0:0], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. This is a
                               WO register, and writing to this bit will
                               trigger a reset for 1 cycle only.
                            */
    UINT32 Resetcounters : 1;

                            /* Bits[1:1], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset. This is a WO register, and
                               writing to this bit will trigger a reset for 1
                               cycle only.
                            */
    UINT32 Rsvd2 : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Freezecounters : 1;

                            /* Bits[8:8], Access Type=RW_V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting. To freeze the counters, this bit need
                               only be set by one of the unit control
                               registers.
                            */
    UINT32 Rsvd9 : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CBOPMONUNITCTRL_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PERF_EVT_SEL_2 0x00000E03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the event logic unit to detect certain
                               microarchitectural conditions
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Further qualifies the event logic unit selected
                               in the event select field to detect a specific
                               microarchitectural condition.
                            */
    UINT32 Rsvd16 : 2;

                            /* Bits[17:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Indicates whether the counter should assert the
                               PMON_Overflow output from CBo towards NCU. 0:
                               The counter will not assert PMON_Overflow 1: The
                               counter asserts PMON_Overflow upon counter
                               overflow
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. This
                               bit effectively increases the address space for
                               event selection. NOTE: Microcode will cause a GP
                               fault when the programmer attempts to enable an
                               internal event from a locked
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active.0 : counter is disabled and
                               will not count when global enable is set.1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is event-count >=
                               threshold. When set to 1, the comparison that
                               will be done is inverted from the case where
                               this bit is set to 0, i.e., event-count &lt;
                               threshold.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               When Threshold is not zero, the corresponding
                               performance counter increments each cycle if the
                               event count is greater than or equal to the
                               Threshold.
                            */
    UINT32 Rsvd30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_EVT_SEL_2_REGISTER;

/**
  Holds the status information and control the operation of the the PMON Fixed Counter.
**/
#define ICX_MSR_PERF_EVT_SEL_3 0x00000E04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Evslct : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the event logic unit to detect certain
                               microarchitectural conditions
                            */
    UINT32 Unitmask : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Further qualifies the event logic unit selected
                               in the event select field to detect a specific
                               microarchitectural condition.
                            */
    UINT32 Rsvd16 : 2;

                            /* Bits[17:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Edgedet : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counting on event edges (count
                               occurrences) or level (number of clocks the
                               event was high) 0 : level count 1 : Edge count
                            */
    UINT32 Tidfilterenable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Thread-ID format: [0:0] - T0 or T1. N/A for
                               GT/IO Cores [3:1] - Core-ID When 'TID filter
                               enable' is clear; the specified counter will
                               count All events Thread-ID of 0xF is reserved
                               for non-associated requests like: - LLC victims
                               - PMSeq - External snoops
                            */
    UINT32 Ovfenable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Indicates whether the counter should assert the
                               PMON_Overflow output from CBo towards NCU. 0:
                               The counter will not assert PMON_Overflow 1: The
                               counter asserts PMON_Overflow upon counter
                               overflow
                            */
    UINT32 Internal : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This bit needs to be asserted if the event which
                               needs to be selected is an internal event. This
                               bit effectively increases the address space for
                               event selection. NOTE: Microcode will cause a GP
                               fault when the programmer attempts to enable an
                               internal event from a locked
                            */
    UINT32 Counteren : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the counter to count when the global
                               enable is active.0 : counter is disabled and
                               will not count when global enable is set.1 :
                               counter is enabled and will count when global
                               enable is set.
                            */
    UINT32 Invert : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is event-count >=
                               threshold. When set to 1, the comparison that
                               will be done is inverted from the case where
                               this bit is set to 0, i.e., event-count &lt;
                               threshold.
                            */
    UINT32 Threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               When Threshold is not zero, the corresponding
                               performance counter increments each cycle if the
                               event count is greater than or equal to the
                               Threshold.
                            */
    UINT32 Rsvd30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_EVT_SEL_3_REGISTER;

/**
  When this bit is written to, the counter configuration registers will be reset. This does not effect the values in the counters. To reset the counters, this bit need only be set by one of the unit control registers
**/
#define ICX_MSR_CBOPMONCTRLGLCTR 0x00000E05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Threadid : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /* Thread-ID format[2:0] - ThreadId. [8:3] -Core-ID */
    UINT32 Link0 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*  */
    UINT32 Link1 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link2 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Link3 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*  */
    UINT32 Rsvd13 : 4;

                            /* Bits[16:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 State : 10;

                            /* Bits[26:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select the state(s) to monitor in the
                               CBO_CACHE_LOOKUP event (when the STATE submask
                               is selected). Setting multiple bits in this
                               field will allow one to track multiple states.
                               [17] - LLC_I [18] - SF_S [19] - SF_E [20] - SF_H
                               [21] - LLC_S [22] - LLC_E [23] - LLC_M [24] -
                               LLC_F [25] - LLC_D [26] - LLC_P
                            */
    UINT32 Rsvd27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CBOPMONCTRLGLCTR_REGISTER;

/**
  When this bit is written to, the counter configuration registers will be reset. This does not effect the values in the counters. To reset the counters, this bit need only be set by one of the unit control registers
**/
#define ICX_MSR_CBOPMONCTRSTATUS 0x00000E07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Counter0ovf : 1;

                            /* Bits[0:0], Access Type=RW_V, default=0x00000000*/

                            /* counter 1 overflowed. Write 1 to clear */
    UINT32 Counter1ovf : 1;

                            /* Bits[1:1], Access Type=RW_V, default=0x00000000*/

                            /* counter 1 overflowed. Write 1 to clear */
    UINT32 Counter2ovf : 1;

                            /* Bits[2:2], Access Type=RW_V, default=0x00000000*/

                            /* counter 2 overflowed. Write 1 to clear */
    UINT32 Counter3ovf : 1;

                            /* Bits[3:3], Access Type=RW_V, default=0x00000000*/

                            /* counter 3 overflowed. Write 1 to clear */
    UINT32 Rsvd4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_CBOPMONCTRSTATUS_REGISTER;

/**
  PMON Counter 0 data register. Holds the counter value.
**/
#define ICX_MSR_PERF_CTR_2 0x00000E0A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* Pmon Counter data. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* Pmon Counter data. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_CTR_2_REGISTER;

/**
  PMON Counter 0 data register. Holds the counter value.
**/
#define ICX_MSR_PERF_CTR_3 0x00000E0B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Pmonctrdata0 : 32;

                            /* Bits[31:0], Access Type=RW_V, default=0x00000000*/

                            /* Pmon Counter data. */
    UINT32 Pmonctrdata1 : 16;

                            /* Bits[47:32], Access Type=RW_V, default=0x00000000*/

                            /* Pmon Counter data. */
    UINT32 Rsvd48 : 16;

                            /* Bits[63:48], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_PERF_CTR_3_REGISTER;

/**
  Address Match Range Register - Physical Base Control Register for Hidden Lake
**/
#define ICX_MSR_AMRR_BASE_0 0x00000F00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TmeEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable TME masking */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 3 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 3 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_BASE_0_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register for Hidden Lake
**/
#define ICX_MSR_AMRR_MASK_0 0x00000F01

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_MASK_0_REGISTER;

/**
  Address Match Range Register - Physical Base Control Register for PPPE and Hidden Lake
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define ICX_MSR_AMRR_BASE_1 0x00000F02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TmeEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable TME masking */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_BASE_1_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register for PPPE and Hidden Lake
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define ICX_MSR_AMRR_MASK_1 0x00000F03

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_MASK_1_REGISTER;

/**
  Address Match Range Register - Physical Base Control Register for PPPE and Hidden Lake
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define ICX_MSR_AMRR_BASE_2 0x00000F04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TmeEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable TME masking */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_BASE_2_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register for PPPE and Hidden Lake
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!                                                                            !!!
  !!! CAUTION: Adding more bits to this creg or changing the layout of this creg !!!
  !!! will require MSR ucode changes. Talk to MSR ucode owner (rpartha on NHM) if!!!
  !!! you want to make changes to this creg                                      !!!
  !!!                                                                            !!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**/
#define ICX_MSR_AMRR_MASK_2 0x00000F05

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_MASK_2_REGISTER;

/**
  Address Match Range Register - Physical Base Control Register
**/
#define ICX_MSR_AMRR_BASE_3 0x00000F06

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TmeEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable TME masking */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_BASE_3_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register
**/
#define ICX_MSR_AMRR_MASK_3 0x00000F07

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_MASK_3_REGISTER;

/**
  Address Match Range Register - Physical Base Control Register
**/
#define ICX_MSR_AMRR_BASE_4 0x00000F08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 TmeEn : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable TME masking */
    UINT32 Rsvd1 : 11;

                            /* Bits[11:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Base0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Base1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The 4K-aligned platform physical base addresses
                               of the 5 AMRR registers for debugging. These
                               registers are programmed like MTRRs with base
                               and mask. Address matches of an AMRR can be
                               programmed to cause an "assist" or "abort".
                               Assists invoke the address match ucode handler
                               and populate the RR_MATCH_ADDR and
                               RR_MATCH_RESULT CREGs with useful information
                               about the access. Aborts force the memory type
                               to UC and redirect the access to the abort page
                               (causing it to get garbage data from the
                               uncore). See AMRR_MASK bits for more information
                               on how to program. See the PRF register
                               definition for how to resume AMRR assist
                               matches.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_BASE_4_REGISTER;

/**
  Address Match Range Register - Physical Mask Control Register
**/
#define ICX_MSR_AMRR_MASK_4 0x00000F09

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Rsvd0 : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 IgnorePw : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR on a stuffed load will
                               be ignored and will not cause assist nor abort.
                               Only the real PA (on redispatch) can cause an
                               assist if matches.
                            */
    UINT32 PhysegOvrd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting the AMRR with PhySegSupOvr is
                               allowed, and will not cause assist or abort
                            */
    UINT32 ForceWb : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, hitting AMRR legally (see above bit),
                               will also force WB memtype. This is subject to
                               memtype priorities and can be overridden due to
                               higher priority mem types
                            */
    UINT32 Rsvd6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Ifetch : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, allow AMRR assist matches for both
                               I-side and D-side, else assist match D-side
                               only. Pagewalk accesses (stuffed loads and
                               loadpxelocks) always count as D-side. This bit
                               has no effect on abort matches.
                            */
    UINT32 Assist : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If set, AMRR matches to the programmed address
                               will invoke ucode's address match handler. If
                               clear, AMRR matches will "abort" and redirect
                               the access to the abort page and a UC memory
                               type.
                            */
    UINT32 L : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Lock bit for the AMRR */
    UINT32 Rsvd11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Mask0 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Mask1 : 20;

                            /* Bits[51:32], Access Type=RW, default=0x00000000*/

                            /*
                               The mask value used in MTRR-like address
                               matching of platform. Minimum granularity for
                               matches is 4K (aligned), but the ucode handler
                               can use RR_MATCH_ADDR and the resume capability
                               (see the PRF register definition) to achieve
                               narrower checking.
                            */
    UINT32 Rsvd52 : 12;

                            /* Bits[63:52], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_AMRR_MASK_4_REGISTER;
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_CORE_SPECIFIC_13_BIT_SPARE_0 0x00001001
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_CORE_SPECIFIC_13_BIT_SPARE_1 0x00001002
/**
  Spare core MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_CORE_SPECIFIC_13_BIT_SPARE_2 0x00001003
/**
  Spare Thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_THREAD_SPECIFIC_13_BIT_SPARE_0 0x00001004
/**
  Spare Thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_THREAD_SPECIFIC_13_BIT_SPARE_1 0x00001005
/**
  Spare Thread MSRs supported by the cregpla. Ucode (instead of the PLA) will signal #GP on access. CNL issue 1351559
**/
#define ICX_MSR_THREAD_SPECIFIC_13_BIT_SPARE_2 0x00001006

/**
  The operating system enables the hardware guided scheduler interface using new package scoped MSR
**/
#define ICX_MSR_HW_FB_CONFIG 0x000017D1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 Enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               when set to 1 enables HE guided scheduler
                               interface
                            */
    UINT32 Rsvd1 : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 Rsvd32 : 32;

                            /* Bits[63:32], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;

  UINT32 Uint32;
  UINT64 Uint64;

} ICX_MSR_HW_FB_CONFIG_REGISTER;
#endif /* _ICXMSR_h */
