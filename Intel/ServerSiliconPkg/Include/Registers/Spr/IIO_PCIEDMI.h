
/** @file
  IIO_PCIEDMI.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _IIO_PCIEDMI_h
#define _IIO_PCIEDMI_h
#include <Base.h>

/* NECH_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x20000000)                                                      */
/*      SPRB0 (0x20000000)                                                      */
/*      SPRHBM (0x20000000)                                                     */
/*      SPRC0 (0x20000000)                                                      */
/*      SPRMCC (0x20000000)                                                     */
/*      SPRUCC (0x20000000)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Null Extended Capability Header
*/


#define NECH_IIO_PCIEDMI_REG 0x0D020000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               PCI Express Extended Capability ID for the
                               Secondary PCI Express Extended Capability is
                               0019h
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Extended Capability structure or 000h if
                               no other items exist in the linked list of
                               Capabilities. Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} NECH_IIO_PCIEDMI_STRUCT;

/* PCICMD_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000004)                                                      */
/*      SPRB0 (0x10000004)                                                      */
/*      SPRHBM (0x10000004)                                                     */
/*      SPRC0 (0x10000004)                                                      */
/*      SPRMCC (0x10000004)                                                     */
/*      SPRUCC (0x10000004)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls how the device behaves on the primary interface (PCI Express).
*/


#define PCICMD_IIO_PCIEDMI_REG 0x0D010004

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 iose : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0 - Respond to all I/O Requests on the primary
                               interface with an Unsupported Request
                               Completion. Forward all I/O transactions from
                               the secondary interface to the primary interface
                               (if supported). 1 - Enable forwarding of I/O
                               Requests to the secondary interface.
                            */
    UINT16 mse : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               0 - Respond to all Memory Requests on the
                               primary interface as Unsupported Request
                               Received. Forward all memory requests from the
                               secondary interface to the primary interface. 1
                               - Enable forwarding of memory transactions to
                               the secondary interface and any internal
                               function.
                            */
    UINT16 bme : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the ability of the Function to
                               issue Memory and I/O read or write requests, and
                               the ability of Root or Switch port to forward
                               memory and I/O read or write requests in the
                               upstream direction. When this bit is 0b, memory
                               and I/O requests received at the root port or
                               downstream side of a switch port (secondary
                               side) must be handled as an Unsupported Request
                               (UR). For Non-posted requests, a completion with
                               UR completion status must be returned. For an
                               endpoint, when this bit is Set, the PCI Express
                               Function is allowed to issue Memory or I/O
                               Requests. When this bit is Clear, the PCI
                               Express Function is not allowed to issue any
                               Memory or I/O Requests. The forwarding of
                               requests other than memory or I/O requests is
                               not controlled by this bit. AtomicOp Requester
                               Enable bit in Device Control 2 register must
                               also be set in order for an AtomicOp Requests to
                               be forwarded. MSI interrupts are inband memory
                               writes and are blocked when this bit is 0b.
                            */
    UINT16 sce : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 mwie : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 vga_pse : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 pere : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the setting of the master data
                               parity error bit in the Status Register ('PCI
                               Status Register (PCISTS)' on page 186) in
                               response to a parity error received on the PCI
                               Express interface (either internal queue errors
                               or a poisoned TLP).
                            */
    UINT16 wcc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 see : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables reporting of Non-
                               Fatal and Fatal errors detected by the Function
                               of the Root Complex. For Type 1 Configuration
                               Space headers, this bit controls transmission by
                               the primary interface of ERR_NONFATAL and
                               ERR_FATAL error messages forwarded from the
                               secondary interface. ERR_COR messages are not
                               affected by this bit. Errors are reported when
                               enabled either through this bit or through the
                               PCI Express-specific bits in the Device Control
                               Register ('Device Control Register (DEVCTL)' on
                               page 228).
                            */
    UINT16 fbe : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 intxd : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the ability of the PCI-Express
                               Function to generate legacy INTx interrupt
                               message. When set, functions are prevented from
                               asserting INTx interrupt messages. Any INTx
                               emulation interrupts already asserted by the
                               function must be deasserted when this bit is set
                               by generating a Deassert_INTx message(s). This
                               bit does not affect the ability to route
                               interrupt messages received at the PCI-Express
                               port. However, this bit controls the generation
                               of legacy interrupts for PCI-Express errors
                               detected internally in this port (e.g. Malformed
                               TLP, CRC error, completion time out etc.) or
                               when receiving root port error messages or
                               interrupts due to HP/PM events generated in
                               legacy mode. This bit has no effect on
                               interrupts that pass through the port from the
                               secondary side of root ports, switch ports, and
                               bridges.
                            */
    UINT16 rsvd : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PCICMD_IIO_PCIEDMI_STRUCT;

/* PCISTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000006)                                                      */
/*      SPRB0 (0x10000006)                                                      */
/*      SPRHBM (0x10000006)                                                     */
/*      SPRC0 (0x10000006)                                                      */
/*      SPRMCC (0x10000006)                                                     */
/*      SPRUCC (0x10000006)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Status
*/


#define PCISTS_IIO_PCIEDMI_REG 0x0D010006

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 ints : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               When set, this bit indicates that an INTx
                               emulation interrupt is pending internally in
                               this function. For Type 1 configuration header
                               functions, forwarded INTx messages are not
                               reflected in this bit. unless the INTx messages
                               is being generated from the Type 1 configuration
                               header function.
                            */
    UINT16 cape : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000001*/

                            /*
                               This bit indicates the presence of an Extended
                               capabilities list items. Offset 34H indicates
                               the offset for the first entry in the linked
                               list of capabilities. All PCI Express Functions
                               are required to have a PCI Express Capability
                               Structure. So this bit must be hardwired to 1b.
                            */
    UINT16 c66 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* This bit has no meaning on PCI Express. */
    UINT16 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 fbc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* This bit has no meaning on PCI Express. */
    UINT16 mdpd : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by a requester (primary side for
                               type1 configuration header functions) if the
                               parity error response enable bit (PERE) in the
                               Command Register ('PCI Command Register
                               (PCICMD)' on page 181) is set and either of the
                               following two conditions occur: Requester
                               receives a completion marked poisoned. Requester
                               sends a poisoned request (includes writes and
                               messages) If the parity error bit is 0b, this
                               bit is never set.
                            */
    UINT16 dvt : 2;

                            /* Bits[10:9], Access Type=RO, default=0x00000000*/

                            /*
                               These bits have no meaning on PCI Express. Fast
                               decode timing is reported.
                            */
    UINT16 sta : 1;

                            /* Bits[11:11], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is Set when the port completes a Posted
                               or Non-Posted Request as a Completer Abort
                               error. This applies to a Function with a Type 1
                               Configuration header when the Completer Abort
                               was generated by its Primary Side. If the given
                               Configuration or MMIO access to the PCIe
                               internal resource does not follow formation
                               rule, then it is completed with CA status and is
                               logged as PCISTS.STA. Refer to Section 1.11.5,
                               'Master/Target abort Logging in
                               Primary/Secondary Status registers' on page 40
                               of the PCIe Gen3 Chapter.
                            */
    UINT16 rta : 1;

                            /* Bits[12:12], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a requester receives a CA
                               completions status. On Type 1 configuration
                               header functions, the bit is set when a
                               'Completer Abort' is received on the primary
                               side.
                            */
    UINT16 rma : 1;

                            /* Bits[13:13], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the requester receives a
                               completion with an UR completion status. On Type
                               1 configuration header functions, the bit is set
                               when a UR completions status is received on the
                               primary side.
                            */
    UINT16 sse : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when ERR_FATAL or ERR_NONFATAL
                               messages are sent to the root complex and the
                               SERR enable bit in the PCICMD Register ('PCI
                               Command Register (PCICMD)' on page 181) is set.
                            */
    UINT16 dpe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a poisoned TLP is received
                               from PCIe or IOSF. This bit is set even when the
                               parity error response enable bit (bit[6] of the
                               PCICMD Register'PCI Command Register (PCICMD)'
                               on page 181) is not set. On Type 1 configuration
                               header functions, the bit is set when the
                               poisoned TLP is received on the primary side.
                            */

  } Bits;
  UINT16 Data;

} PCISTS_IIO_PCIEDMI_STRUCT;

/* RID_IIO_PCIEDMI_REG supported on:                                            */
/*      SPRA0 (0x8)                                                             */
/*      SPRB0 (0x8)                                                             */
/*      SPRHBM (0x8)                                                            */
/*      SPRC0 (0x8)                                                             */
/*      SPRMCC (0x8)                                                            */
/*      SPRUCC (0x8)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Revision ID
*/


#define RID_IIO_PCIEDMI_REG 0x0D000008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 rid : 8;

                            /* Bits[7:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field specifies the specific revision of
                               this function and should be viewed as a
                               extension to the Device ID. Default values will
                               be determined by soft strap or SetIDValue or
                               fuses if supported.
                            */

  } Bits;
  UINT8 Data;

} RID_IIO_PCIEDMI_STRUCT;

/* CCRPI_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x9)                                                             */
/*      SPRB0 (0x9)                                                             */
/*      SPRHBM (0x9)                                                            */
/*      SPRC0 (0x9)                                                             */
/*      SPRMCC (0x9)                                                            */
/*      SPRUCC (0x9)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Class Code Programming Interface
*/


#define CCRPI_IIO_PCIEDMI_REG 0x0D000009

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 rlpi : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               This field identifies a specific register level
                               programming interface (if any) so that device
                               independent software can interact with the
                               Function. Encodings for interface are provided
                               in the PCI Code and ID Assignment Specification.
                               All unspecified encodings are Reserved. This
                               variable needs to be customized for the end
                               project requirements as the functionality and
                               type of end point is not known at this point.
                            */

  } Bits;
  UINT8 Data;

} CCRPI_IIO_PCIEDMI_STRUCT;

/* CCRSCC_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0xa)                                                             */
/*      SPRB0 (0xa)                                                             */
/*      SPRHBM (0xa)                                                            */
/*      SPRC0 (0xa)                                                             */
/*      SPRMCC (0xa)                                                            */
/*      SPRUCC (0xa)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Class Code Sub-Class Code
*/


#define CCRSCC_IIO_PCIEDMI_REG 0x0D00000A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 sc : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Specifies a base class sub-class, which
                               identifies more specifically the operation of
                               the Function. Encodings for sub-class are
                               provided in the PCI Code and ID Assignment
                               Specification. All unspecified encodings are
                               Reserved. This 8-bit value indicates that the
                               DMI/R-Link in RC is a host bridge to prevent
                               software from manipulating the register.s
                            */

  } Bits;
  UINT8 Data;

} CCRSCC_IIO_PCIEDMI_STRUCT;

/* CCRBCC_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0xb)                                                             */
/*      SPRB0 (0xb)                                                             */
/*      SPRHBM (0xb)                                                            */
/*      SPRC0 (0xb)                                                             */
/*      SPRMCC (0xb)                                                            */
/*      SPRUCC (0xb)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* The CCR register has an attribute of RW-L PRST to allow configuration software to modify and lock the register from further update. Lock Key bit is located in the Personality Lock Key Control Register ('PLKCTL').
*/


#define CCRBCC_IIO_PCIEDMI_REG 0x0D00000B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bc : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               A code that broadly classifies the type of
                               operation the Function performs. Encodings for
                               base class, are provided in the PCI Code and ID
                               Assignment Specification. All unspecified
                               encodings are Reserved. The value of 06h
                               indicates that this is a bridge device.
                            */

  } Bits;
  UINT8 Data;

} CCRBCC_IIO_PCIEDMI_STRUCT;

/* CLS_IIO_PCIEDMI_REG supported on:                                            */
/*      SPRA0 (0xc)                                                             */
/*      SPRB0 (0xc)                                                             */
/*      SPRHBM (0xc)                                                            */
/*      SPRC0 (0xc)                                                             */
/*      SPRMCC (0xc)                                                            */
/*      SPRUCC (0xc)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Cacheline Size
*/


#define CLS_IIO_PCIEDMI_REG 0x0D00000C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 cls : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               These bits specify the system cache-line size in
                               units of DWords. This field is implemented by
                               PCI Express devices but has no effect on device
                               behavior.
                            */

  } Bits;
  UINT8 Data;

} CLS_IIO_PCIEDMI_STRUCT;

/* PLAT_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0xd)                                                             */
/*      SPRB0 (0xd)                                                             */
/*      SPRHBM (0xd)                                                            */
/*      SPRC0 (0xd)                                                             */
/*      SPRMCC (0xd)                                                            */
/*      SPRUCC (0xd)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Primary Latency Timer
*/


#define PLAT_IIO_PCIEDMI_REG 0x0D00000D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 prim_lat_timer : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to PCI-Express. Hardwired to 00h.
                               This register is typically called as 'latency
                               Timer' for Endpoints in PCI 3.0 specification
                            */

  } Bits;
  UINT8 Data;

} PLAT_IIO_PCIEDMI_STRUCT;

/* HDR_IIO_PCIEDMI_REG supported on:                                            */
/*      SPRA0 (0xe)                                                             */
/*      SPRB0 (0xe)                                                             */
/*      SPRHBM (0xe)                                                            */
/*      SPRC0 (0xe)                                                             */
/*      SPRMCC (0xe)                                                            */
/*      SPRUCC (0xe)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Header Type
*/


#define HDR_IIO_PCIEDMI_REG 0x0D00000E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 htype : 7;

                            /* Bits[6:0], Access Type=RW/L, default=None*/

                            /*
                               These bits define the layout of addresses 10h
                               through 3Fh in the configuration space. For an
                               end point device, default is 00h indicating a
                               conventional type 00h PCI header.
                            */
    UINT8 mfd : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               The root port, DMI/R-Link in RC, Virtual Root
                               port/switch port and downstream ports are single
                               function only.
                            */

  } Bits;
  UINT8 Data;

} HDR_IIO_PCIEDMI_STRUCT;

/* BIST_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0xf)                                                             */
/*      SPRB0 (0xf)                                                             */
/*      SPRHBM (0xf)                                                            */
/*      SPRC0 (0xf)                                                             */
/*      SPRMCC (0xf)                                                            */
/*      SPRUCC (0xf)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register is used for reporting control and status information of BIST checks within a PCIExpress port. It is not supported in this implementation.
*/


#define BIST_IIO_PCIEDMI_REG 0x0D00000F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_tst : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Not supported. Hardwired to 0h */

  } Bits;
  UINT8 Data;

} BIST_IIO_PCIEDMI_STRUCT;

/* EXPPTMBAR_N0_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x20000010)                                                      */
/*      SPRB0 (0x20000010)                                                      */
/*      SPRHBM (0x20000010)                                                     */
/*      SPRC0 (0x20000010)                                                      */
/*      SPRMCC (0x20000010)                                                     */
/*      SPRUCC (0x20000010)                                                     */
/* Register default value on SPRA0: 0x00000004                                  */
/* Register default value on SPRB0: 0x00000004                                  */
/* Register default value on SPRHBM: 0x00000004                                 */
/* Register default value on SPRC0: 0x00000004                                  */
/* Register default value on SPRMCC: 0x00000004                                 */
/* Register default value on SPRUCC: 0x00000004                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Express Port Memory Base Address
*/


#define EXPPTMBAR_N0_IIO_PCIEDMI_REG 0x0D020010

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 msi : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /* 0b: Memory space 1b: IO space */
    UINT32 type : 2;

                            /* Bits[2:1], Access Type=RO, default=0x00000002*/

                            /*
                               The memory mapped space can be placed anywhere
                               within the 64-bit addressable region of the
                               device
                            */
    UINT32 pref : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Not prefetchable Memory Space. */
    UINT32 rsvd : 13;

                            /* Bits[16:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 baddr : 15;

                            /* Bits[31:17], Access Type=RW, default=0x00000000*/

                            /* Base Address */

  } Bits;
  UINT32 Data;

} EXPPTMBAR_N0_IIO_PCIEDMI_STRUCT;

/* EXPPTMBAR_N1_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x20000014)                                                      */
/*      SPRB0 (0x20000014)                                                      */
/*      SPRHBM (0x20000014)                                                     */
/*      SPRC0 (0x20000014)                                                      */
/*      SPRMCC (0x20000014)                                                     */
/*      SPRUCC (0x20000014)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Express Port Memory Base Address
*/


#define EXPPTMBAR_N1_IIO_PCIEDMI_REG 0x0D020014

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 baddr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Base Address */

  } Bits;
  UINT32 Data;

} EXPPTMBAR_N1_IIO_PCIEDMI_STRUCT;

/* SECSTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x1000001e)                                                      */
/*      SPRB0 (0x1000001e)                                                      */
/*      SPRHBM (0x1000001e)                                                     */
/*      SPRC0 (0x1000001e)                                                      */
/*      SPRMCC (0x1000001e)                                                     */
/*      SPRUCC (0x1000001e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Secondary Status
*/


#define SECSTS_IIO_PCIEDMI_REG 0x0D01001E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 5;

                            /* Bits[4:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 c66 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 fbc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 mdpd : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side requester
                               if the Parity Error Response Enable (PERE) bit
                               in the Bridge Control Register (BCTL) is set and
                               either of the following conditions occurs:
                               Requester receives completion marked poisoned
                               Requester sends a poisoned request (includes
                               writes and messages) If the PERE bit in the
                               Bridge Control Register (BCTL) is clear, this
                               bit is never set.
                            */
    UINT16 dvt : 2;

                            /* Bits[10:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sta : 1;

                            /* Bits[11:11], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 configuration space header function (for
                               requests completed by type 1 header functions
                               itself) completes a Posted or Non-posted request
                               as a Completer Abort error.
                            */
    UINT16 rta : 1;

                            /* Bits[12:12], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 Configuration Space Header Function (for
                               Requests initiated by the Type 1 header Function
                               itself) receives a completion with Completer
                               About Completion Status.
                            */
    UINT16 rma : 1;

                            /* Bits[13:13], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 configuration space header function (for
                               requests initiated by the Type 1 header function
                               itself) receives a completion with Unsupported
                               Requests Completion Status.
                            */
    UINT16 rse : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side for a Type
                               1 Configuration Space header function whenever
                               it receives an ERR_FATAL or ERR_NONFATAL
                               message.
                            */
    UINT16 dpe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side for a Type
                               1 Configuration Space header function whenever
                               it receives a Poisoned TLP, regardless of the
                               state in the Parity Error Response Enable (PERE)
                               field of the Bridge Control Register (BCTL).
                            */

  } Bits;
  UINT16 Data;

} SECSTS_IIO_PCIEDMI_STRUCT;

/* CAPPTR_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x34)                                                            */
/*      SPRB0 (0x34)                                                            */
/*      SPRHBM (0x34)                                                           */
/*      SPRC0 (0x34)                                                            */
/*      SPRMCC (0x34)                                                           */
/*      SPRUCC (0x34)                                                           */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Capabilities Pointer
*/


#define CAPPTR_IIO_PCIEDMI_REG 0x0D000034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 cptr : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000040*/

                            /*
                               Contains the offset of the first item in the
                               list of capabilities. (EXPCAPLST)
                            */

  } Bits;
  UINT8 Data;

} CAPPTR_IIO_PCIEDMI_STRUCT;

/* INTL_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x3c)                                                            */
/*      SPRB0 (0x3c)                                                            */
/*      SPRHBM (0x3c)                                                           */
/*      SPRC0 (0x3c)                                                            */
/*      SPRMCC (0x3c)                                                           */
/*      SPRUCC (0x3c)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Interrupt Line
*/


#define INTL_IIO_PCIEDMI_REG 0x0D00003C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 intl : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This register is used to communicate interrupt
                               line routing information. The device itself does
                               not use this value, rather it is used by device
                               drivers and operating systems. (compatibility)
                            */

  } Bits;
  UINT8 Data;

} INTL_IIO_PCIEDMI_STRUCT;

/* INTP_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x3d)                                                            */
/*      SPRB0 (0x3d)                                                            */
/*      SPRHBM (0x3d)                                                           */
/*      SPRC0 (0x3d)                                                            */
/*      SPRMCC (0x3d)                                                           */
/*      SPRUCC (0x3d)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Interrupt Pin
*/


#define INTP_IIO_PCIEDMI_REG 0x0D00003D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 intp : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               This register tells which interrupt pin the
                               function uses. 01h: Generate INTA 02h: Generate
                               INTB 03h: Generate INTC 04h: Generate INTD
                               Others: Reserved BIOS has the ability to write
                               this register once during boot to setup the
                               correct interrupt for the Function.
                            */

  } Bits;
  UINT8 Data;

} INTP_IIO_PCIEDMI_STRUCT;

/* BCTL_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x1000003e)                                                      */
/*      SPRB0 (0x1000003e)                                                      */
/*      SPRHBM (0x1000003e)                                                     */
/*      SPRC0 (0x1000003e)                                                      */
/*      SPRMCC (0x1000003e)                                                     */
/*      SPRUCC (0x1000003e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register provides extensions to the Command Register ('PCI Command Register (PCICMD)' on page 181) that are specific to a bridge. The Bridge Control Register provides many of the same controls for the secondary interface that are provided by the Command Register for the primary interface. Some bits affect operation of both interfaces of the bridge.
*/


#define BCTL_IIO_PCIEDMI_REG 0x0D01003E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the response to poisoned TLPs
                               in the PCI Express port. 1: Enables reporting of
                               poisoned TLP errors. 0: Disables reporting of
                               poisoned TLP errors.
                            */
    UINT16 se : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the forwarding of PCI Express
                               ERR_COR, ERR_NONFATAL and ERR_FATAL messages to
                               the primary side. 1: Enables forwarding of
                               ERR_COR, ERR_NONFATAL, ERR_FATAL messages. 0:
                               Disables forwarding of ERR_COR, ERR_NONFATAL,
                               ERR_FATAL messages.
                            */
    UINT16 ie : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit modifies the response by the bridge to
                               ISA I/O addresses. This field applies only to
                               I/O addresses that are enabled by the I/O base
                               and I/O limit registers and are in the first 64
                               KB of PCI I/O space. When this bit is set, the
                               bridge blocks all forwarding from primary to
                               secondary of I/O transactions addressing the
                               last 768 bytes in each 1 KB block (offsets 100h
                               to 3FFh). In the opposite direction (secondary
                               to primary), I/O transactions will be forwarded
                               if they address the last 768B in each 1 KB
                               block. 1: Forward upstream ISA I/O addresses in
                               the address range defined by the I/O Base and
                               I/O Limit registers that are in the firsts 64KB
                               of PCI I/O address space (Top 768B of each 1K
                               block). 0: Forward downstream all I/O addresses
                               in the address range defined by the I/O Base and
                               I/O Limit registers.
                            */
    UINT16 vgae : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit modifies the response to VGA-compatible
                               addresses. When set to 1b, the bridge positively
                               decodes and forwards the following transactions
                               from primary side to secondary side regardless
                               of the value of the I/O base and limit
                               registers. The transactions are qualified by the
                               memory enable and I/O enable in the command
                               register. Memory addresses: 000A 0000h-000B
                               FFFFh I/O addresses: 3B0h-3BBh and 3C0h-3DFh in
                               first 64 KB of I/O address space (Inclusive of
                               ISA address aliases when IO address bits[15:10]
                               are not decoded)
                            */
    UINT16 vga16bd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the bridge to provide 16-bit
                               decoding of VGA I/O address precluding the
                               decoding of VGA alias addresses every 1 KB. This
                               bit requires the VGA enable bit (bit 3 of this
                               register) to be set to 1. 0: execute 10-bit
                               address decode on VGA I/O accesses 1: execute
                               16-bit address decode on VGA I/O accesses
                            */
    UINT16 mam : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sbr : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Setting this bit triggers a hot reset on the
                               downstream link for the corresponding PCIe
                               Express port and the PCI Express hierarchy
                               domain subordinate to the port. Software must
                               ensure a minimum reset duration of 1us as
                               defined in the PCI Local Bus Specification,
                               Revision 3.0. Hardware will continue to maintain
                               the hot reset state as long as the SBR bit is
                               set. For Root Ports, it is recommended that
                               software assert this field for a minimum of 2 ms
                               to ensure that all downstream links enters hot
                               reset state. A secondary bus reset will not
                               reset any register of a Type 1 configuration
                               space header function.
                            */
    UINT16 fbe : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 pdt : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sdt : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 dts : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 dtse : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} BCTL_IIO_PCIEDMI_STRUCT;

/* EXPCAPLST_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000040)                                                      */
/*      SPRB0 (0x10000040)                                                      */
/*      SPRHBM (0x10000040)                                                     */
/*      SPRC0 (0x10000040)                                                      */
/*      SPRMCC (0x10000040)                                                     */
/*      SPRUCC (0x10000040)                                                     */
/* Register default value on SPRA0: 0x0000A010                                  */
/* Register default value on SPRB0: 0x0000A010                                  */
/* Register default value on SPRHBM: 0x0000A010                                 */
/* Register default value on SPRC0: 0x0000A010                                  */
/* Register default value on SPRMCC: 0x0000A010                                 */
/* Register default value on SPRUCC: 0x0000A010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PCI Express Capability List
*/


#define EXPCAPLST_IIO_PCIEDMI_REG 0x0D010040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /* Identifies the function as PCI Express capable. */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RO, default=0x000000A0*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list. (PMCAPLST)
                            */

  } Bits;
  UINT16 Data;

} EXPCAPLST_IIO_PCIEDMI_STRUCT;

/* EXPCAP_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000042)                                                      */
/*      SPRB0 (0x10000042)                                                      */
/*      SPRHBM (0x10000042)                                                     */
/*      SPRC0 (0x10000042)                                                      */
/*      SPRMCC (0x10000042)                                                     */
/*      SPRUCC (0x10000042)                                                     */
/* Register default value on SPRA0: 0x00000002                                  */
/* Register default value on SPRB0: 0x00000002                                  */
/* Register default value on SPRHBM: 0x00000002                                 */
/* Register default value on SPRC0: 0x00000002                                  */
/* Register default value on SPRMCC: 0x00000002                                 */
/* Register default value on SPRUCC: 0x00000002                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register stores the version number of the capability item and other base information contained in the capability structure.
*/


#define EXPCAP_IIO_PCIEDMI_REG 0x0D010042

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vn : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000002*/

                            /*
                               These bits indicate the version number of the
                               PCI Express capability structure.
                            */
    UINT16 dt : 4;

                            /* Bits[7:4], Access Type=RW/V/L, default=None*/

                            /*
                               9h: Root Complex Integrated Endpoint when in DMI
                               mode. 4h: Root Port of a PCIe Root Complex when
                               in RP mode. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . The
                               default value will be determined by fuse/sStrap
                               when in combo of DMI-RP mode.
                            */
    UINT16 si : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               Hardwired to 0 for non root ports and non DP.
                               vRP/SP is defined not to have any slots
                               implemented as it communicates with an internal
                               multifunction device.
                            */
    UINT16 imn : 5;

                            /* Bits[13:9], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the interrupt message
                               number that is generated from the PCI Express
                               port. When there is more than one MSI interrupt
                               number, this register is required to contain the
                               offset between the base Message Data and the MSI
                               Message that is generated when the status bits
                               in the slot status register or root port status
                               registers are set. The Chipset is required to
                               update this field if the number of MSI messages
                               change.
                            */
    UINT16 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} EXPCAP_IIO_PCIEDMI_STRUCT;

/* DEVCAP_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000044)                                                      */
/*      SPRB0 (0x20000044)                                                      */
/*      SPRHBM (0x20000044)                                                     */
/*      SPRC0 (0x20000044)                                                      */
/*      SPRMCC (0x20000044)                                                     */
/*      SPRUCC (0x20000044)                                                     */
/* Register default value on SPRA0: 0x00008000                                  */
/* Register default value on SPRB0: 0x00008000                                  */
/* Register default value on SPRHBM: 0x00008000                                 */
/* Register default value on SPRC0: 0x00008000                                  */
/* Register default value on SPRMCC: 0x00008000                                 */
/* Register default value on SPRUCC: 0x00008000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Device Capabilities
*/


#define DEVCAP_IIO_PCIEDMI_REG 0x0D020044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mpss : 3;

                            /* Bits[2:0], Access Type=RW/L, default=None*/

                            /*
                               The PCIe SIP can tolerate upto 512-byte packets
                               as maximum payload for project specific. Defined
                               encodings are: 000b 128 bytes max payload size
                               001b 256 bytes max payload size 010b 512 bytes
                               max payload size 011b 1024 bytes max payload
                               size 100b 2048 bytes max payload size 101b 4096
                               bytes max payload size 110b Reserved 111b
                               Reserved Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 pfs : 2;

                            /* Bits[4:3], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the number of most
                               significant bits of the function number portion
                               of Requester ID in a TLP that are logically
                               combined with the Tag identifier. The PCIe
                               cluster does not support phantom functions
                            */
    UINT32 etfg : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This bit, in combination with the 10-Bit Tag
                               Requester Supported bit in the Device
                               Capabilities 2 register, indicates the maximum
                               supported size of the Tag field as a Requester.
                               This bit must be Set if the 10-Bit Tag Requester
                               Supported bit is Set. Defined encodings are: 0b
                               5-bit Tag field supported 1b 8-bit Tag field
                               supported Note that 8-bit Tag field generation
                               must be enabled by the Extended Tag Field Enable
                               bit in the Device Control register of the
                               Requester Function before 8-bit Tags can be
                               generated by the Requester. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 epl0al : 3;

                            /* Bits[8:6], Access Type=RO, default=0x00000000*/

                            /*
                               This field only applies to Endpoint and is
                               hardwired to 0 for other types such as root
                               ports, upstream/downstream ports
                            */
    UINT32 epl1al : 3;

                            /* Bits[11:9], Access Type=RO, default=0x00000000*/

                            /*
                               This field only applies to Endpoint and is
                               hardwired to 0 for other types such as root
                               ports, upstream/downstream ports
                            */
    UINT32 undefined : 3;

                            /* Bits[14:12], Access Type=RO, default=0x00000000*/

                            /* Undefined */
    UINT32 rber : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000001*/

                            /*
                               The PCIe cluster supports Role-based Error
                               Reporting.
                            */
    UINT32 rsvd : 2;

                            /* Bits[17:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 csplv : 8;

                            /* Bits[25:18], Access Type=RO, default=0x00000000*/

                            /*
                               In combination with the Slot Power Limit Scale
                               value (bits[27:26]), this field specifies the
                               upper limit of the power supplied by slot. The
                               power limit (in Watts) is calculated by
                               multiplying the value in this field by the value
                               in the Slot Power Limit Scale field. This value
                               is set by the Set_Slot_Power_Limit message. Does
                               not apply to root ports or integrated devices or
                               downstream ports or Virtual Root Port/switch
                               ports
                            */
    UINT32 cspls : 2;

                            /* Bits[27:26], Access Type=RO, default=0x00000000*/

                            /*
                               In combination with the Slot Power Limit value
                               (bits[25:18], this field specifies the upper
                               limit of the power supplied by slot. The power
                               limit (in Watts) is calculated by multiplying
                               the value in this field by the value in the Slot
                               Power Limit Value field. This value is set by
                               the Set_Slot_Power_Limit message. Does not apply
                               to root ports or integrated devices or
                               downstream ports or Virtual Root Port/switch
                               port
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DEVCAP_IIO_PCIEDMI_STRUCT;

/* DEVCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000048)                                                      */
/*      SPRB0 (0x10000048)                                                      */
/*      SPRHBM (0x10000048)                                                     */
/*      SPRC0 (0x10000048)                                                      */
/*      SPRMCC (0x10000048)                                                     */
/*      SPRUCC (0x10000048)                                                     */
/* Register default value on SPRA0: 0x00002010                                  */
/* Register default value on SPRB0: 0x00002010                                  */
/* Register default value on SPRHBM: 0x00002010                                 */
/* Register default value on SPRC0: 0x00002010                                  */
/* Register default value on SPRMCC: 0x00002010                                 */
/* Register default value on SPRUCC: 0x00002010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Control
*/


#define DEVCTL_IIO_PCIEDMI_REG 0x0D010048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the ERR_CORR
                               message is enabled.
                            */
    UINT16 nfere : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the
                               ERR_NONFATAL message is enabled.
                            */
    UINT16 fere : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the
                               ERR_FATAL message is enabled.
                            */
    UINT16 urre : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the enabling of ERR_CORR,
                               ERR_NONFATAL or ERR_FATAL messages on PCI
                               Express for reporting 'Unsupported Request'
                               errors.
                            */
    UINT16 enro : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000001*/

                            /*
                               If this bit is Set, the Function is permitted to
                               set the Relaxed Ordering bit in the Attributes
                               field of transactions it initiates that do not
                               require strong write ordering. A Function is
                               permitted to hardwire this bit to 0b if it never
                               sets the Relaxed Ordering attribute in
                               transactions it initiates as a Requester.
                               Default value of this bit is 1b.
                            */
    UINT16 mps : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets maximum TLP payload size for the
                               function. As a receiver, the function must
                               handle TLPs as large as the set value. As a
                               Transmitter, the function must not generate TLPs
                               exceeding the set value. 000b: 128 bytes maximum
                               payload size (default) 001b: 256 bytes maximum
                               payload size 010b: 512 bytes maximum payload
                               size 011b: 1024 bytes maximum payload size 100b:
                               2048 bytes maximum payload size 101b: 4096 bytes
                               maximum payload size Others: Reserved
                            */
    UINT16 etfe : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables a function to use an
                               8-bit tag field as a Requester. Functions that
                               do not implement this capability hardwire this
                               bit to 0b.
                            */
    UINT16 pfe : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, in combination with the 10-Bit Tag
                               Requester Enable bit in the Device Control 2
                               register, determines how many Tag field bits a
                               Requester is permitted to use. When the 10-Bit
                               Tag Requester Enable bit is Clear, the following
                               paragraph applies. See PCIe Spec. Section
                               2.2.6.2 for complete details. When Set, this bit
                               enables a Function to use unclaimed Functions as
                               Phantom Functions to extend the number of
                               outstanding transaction identifiers. If the bit
                               is Clear, the Function is not allowed to use
                               Phantom Functions. Software should not change
                               the value of this bit while the Function has
                               outstanding Non-Posted Requests, otherwise, the
                               result is undefined. Functions that do not
                               implement this capability hardwire this bit to
                               0b. Default value of this bit is 0b.
                            */
    UINT16 auxpme : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 enosnp : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               If this bit this is set, the function is
                               permitted to set the No Snoop bit in the
                               Requester attributes of transactions it
                               initiates that do not require hardware enforced
                               cache coherency. This bit is permitted to be
                               hardwired to 0b if a function would never set
                               the No Snoop attribute in transactions it
                               initiates.
                            */
    UINT16 mrrs : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000002*/

                            /*
                               This field sets the maximum Read Requests size
                               of the function as a requester. The Function
                               must not generate read requests with size
                               exceeding the set value. 000b: 128 bytes maximum
                               Read Request size 001b: 256 bytes maximum Read
                               Request size 010b: 512 bytes maximum Read
                               Request size 011b: 1024 bytes maximum Read
                               Request size 100b: 2048 bytes maximum Read
                               Request size 101b: 4096 bytes maximum Read
                               Request size Others: Reserved Functions that do
                               not generate Read Requests larger than 128B and
                               functions that do not generate Read Requests on
                               their own behalf are permitted to implement this
                               field as Read Only (RO) with a value of 000b.
                            */
    UINT16 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DEVCTL_IIO_PCIEDMI_STRUCT;

/* DEVSTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x1000004a)                                                      */
/*      SPRB0 (0x1000004a)                                                      */
/*      SPRHBM (0x1000004a)                                                     */
/*      SPRC0 (0x1000004a)                                                      */
/*      SPRMCC (0x1000004a)                                                     */
/*      SPRUCC (0x1000004a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Status
*/


#define DEVSTS_IIO_PCIEDMI_REG 0x0D01004A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ced : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Correctable error. Errors are logged
                               in this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 nfed : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Non-Fatal error. Errors are logged in
                               this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 fed : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Fatal error. Errors are logged in
                               this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 urd : 1;

                            /* Bits[3:3], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function received
                               an unsupported request from PCI Express link.
                               Errors are logged in this register regardless of
                               whether error reporting is enabled or not in the
                               Device Control register.
                            */
    UINT16 apd : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /* Auxiliary Power is not supported. */
    UINT16 tp : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit indicates that the function
                               has issued Non-Posted Requests that have not
                               been completed. For Root or Switch port, it
                               applies to Non-Posted Requests the port has
                               issued on its own behalf (Port's Request ID). A
                               function reports this bit cleared only when all
                               outstanding Non-Posted Requests have completed.
                               Functions that do not issue Non-Posted requests
                               on their own behalf should hardwire this bit to
                               0b. The implementation may set this bit based on
                               internal Request-Completion Tracking Table if
                               not empty for any outstanding/valid outbound or
                               inbound NP request (including split request).
                               Currently, it's only applicable to Root Ports.
                            */
    UINT16 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DEVSTS_IIO_PCIEDMI_STRUCT;

/* LINKCAP_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x2000004c)                                                      */
/*      SPRB0 (0x2000004c)                                                      */
/*      SPRHBM (0x2000004c)                                                     */
/*      SPRC0 (0x2000004c)                                                      */
/*      SPRMCC (0x2000004c)                                                     */
/*      SPRUCC (0x2000004c)                                                     */
/* Register default value on SPRA0: 0x00000084                                  */
/* Register default value on SPRB0: 0x00000084                                  */
/* Register default value on SPRHBM: 0x00000084                                 */
/* Register default value on SPRC0: 0x00000084                                  */
/* Register default value on SPRMCC: 0x00000084                                 */
/* Register default value on SPRUCC: 0x00000084                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Link Capabilities
*/


#define LINKCAP_IIO_PCIEDMI_REG 0x0D02004C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mls : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000004*/

                            /*
                               This field indicates the maximum Link speed of
                               the associated Port. The encoded value specifies
                               a bit location in the Supported Link Speeds
                               Vector (in the Link Capabilities 2 register)
                               that corresponds to the maximum Link speed.
                               Defined encodings are: 0001b Supported Link
                               Speeds Vector field bit 0 0010b Supported Link
                               Speeds Vector field bit 1 0011b Supported Link
                               Speeds Vector field bit 2 0100b Supported Link
                               Speeds Vector field bit 3 0101b Supported Link
                               Speeds Vector field bit 4 0110b Supported Link
                               Speeds Vector field bit 5 0111b Supported Link
                               Speeds Vector field bit 6 All other encodings
                               are reserved. Multi-Function Devices associated
                               with an Upstream Port must report the same value
                               in this field for all Functions.
                            */
    UINT32 mlw : 6;

                            /* Bits[9:4], Access Type=RO/V, default=0x00000008*/

                            /*
                               This field indicates the maximum link width
                               implemented by the given PCI Express Link. 00h:
                               Reserved 01h: x1 02h: x2 04h: x4 08h: x8 10h:
                               x16 20h: x32 (Unsupported) Others Reserved
                               Default value is determined by HW after port
                               training is initiated for ports that bifurcate.
                               Hence effective MLW can be smaller than
                               indicated by default
                            */
    UINT32 aspmsup : 2;

                            /* Bits[11:10], Access Type=RW/V/L, default=None*/

                            /*
                               This field indicates the level of ASPM supported
                               on the given PCI Express Link. 00b: No ASPM
                               Support 01b: L0s Supported 10b: L1 Supported
                               11b: L0s and L1 Supported Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . New PCIe Gen3 ECN provides additional
                               encoding of ASPMSUP field to provide optional
                               support of L0s and L1 Software must not enable
                               L0s in either direction on a given Link unless
                               components on both sides of the Link each
                               support L0s. L0s should not be advertised when
                               operating with SRIS.
                            */
    UINT32 l0sel : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the L0s exit latency for
                               the given PCI-Express Link. It indicates the
                               length of time this port requires to complete
                               transition from L0s to L0. 000b: Less than 64ns
                               001b: 64ns to less than 128ns 010b: 128ns to
                               less than 256ns 011b: 256ns to less than 512ns
                               100b 512 ns to less than 1 us 101b: 1us to less
                               than 2us 110b: 2us to less than 4us 111b: More
                               than 4us Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . If L0s
                               is not supported, the value is undefined.
                            */
    UINT32 l1el : 3;

                            /* Bits[17:15], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the L1 exit latency for the
                               given PCI-Express Link. It indicates the length
                               of time this port requires to complete
                               transition from L1 to L0. 000: Less than 1us
                               001: 1us to less than 2us 010: 2us to less than
                               4us 011: 4us to less than 8us 100: 8us to less
                               than 16us 101: 16us to less than 32us 110: 32us
                               to less than 64us 111: More than 64us Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register . If L1 is not supported, the
                               value is undefined.
                            */
    UINT32 cpmc : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               For Upstream Ports, a value of 1b in this bit
                               indicates that the component tolerates the
                               removal of any reference clock(s) via the 'clock
                               request' (CLKREQ#) mechanism when the Link is in
                               the L1 and L2/L3 Ready Link states. A value of
                               0b indicates the component does not have this
                               capability and that reference clock(s) must not
                               be removed in these Link states. L1 PM Substates
                               defines other semantics for the CLKREQ# signal,
                               which are managed independently of Clock Power
                               Management. This Capability is applicable only
                               in form factors that support 'clock request'
                               (CLKREQ#) capability. For a multi-Function
                               device associated with an Upstream Port, each
                               Function indicates its capability independently.
                               Power Management configuration software must
                               only permit reference clock removal if all
                               Functions of the multi-Function device indicate
                               a 1b in this bit. For ARI Devices, all Functions
                               must indicate the same value in this bit. For
                               Downstream Ports, this bit must be hardwired to
                               0b.
                            */
    UINT32 slderc : 1;

                            /* Bits[19:19], Access Type=RW/L, default=None*/

                            /*
                               For a Downstream Port, this bit must be Set if
                               the component supports the optional capability
                               of detecting and reporting a Surprise Down error
                               condition. For Upstream Ports and components
                               that do not support this optional capability,
                               this bit must be hardwired to 0b. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 dllerc : 1;

                            /* Bits[20:20], Access Type=RW/L, default=None*/

                            /*
                               For a Downstream Port, this bit must be
                               hardwired to 1b if the component supports the
                               optional capability of reporting the DL_Active
                               state of the Data Link Control and Management
                               State Machine. For a hot-plug capable Downstream
                               Port (as indicated by the Hot-Plug Capable bit
                               of the Slot Capabilities register) or a
                               Downstream Port that supports Link speeds
                               greater than 5 GT/s, this bit must be hardwired
                               to 1b. For Upstream Ports and components that do
                               not support this optional capability, this bit
                               must be hardwired to 0b. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 lbnc : 1;

                            /* Bits[21:21], Access Type=RW/L, default=None*/

                            /*
                               A value of 1b indicates support for the Link
                               Bandwidth Notification status and interrupt
                               mechanisms. This capability is required for all
                               Root Ports and Switch Downstream Ports
                               supporting Links wider than x1 and/or multiple
                               Link speeds. This field is not applicable and is
                               reserved for Endpoints, PCI Express to PCI/PCI-X
                               bridges, and Upstream Ports of Switches. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 aspmopcmp : 1;

                            /* Bits[22:22], Access Type=RW/L, default=None*/

                            /*
                               The ASPM Optionality Compliance bit was created
                               as a tool to set clear expectations for hardware
                               and software interaction. This bit is Set to
                               indicate hardware that conforms to the current
                               specification. Software is permitted to use the
                               value of this bit to help determine whether to
                               enable ASPM or whether to run ASPM compliance
                               tests. System software as well as compliance
                               software can assume that if this bit is Set,
                               that the associated hardware conforms to the
                               current specification. Hardware should be fully
                               capable of supporting ASPM configuration
                               management by system software without needing
                               component-specific treatment. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rsvd : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pn : 8;

                            /* Bits[31:24], Access Type=RW/V/L, default=None*/

                            /*
                               This field indicates the PCI Express port number
                               assigned to this link. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . DMI port in RC is listed here for
                            */

  } Bits;
  UINT32 Data;

} LINKCAP_IIO_PCIEDMI_STRUCT;

/* LINKCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x10000050)                                                      */
/*      SPRB0 (0x10000050)                                                      */
/*      SPRHBM (0x10000050)                                                     */
/*      SPRC0 (0x10000050)                                                      */
/*      SPRMCC (0x10000050)                                                     */
/*      SPRUCC (0x10000050)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Control
*/


#define LINKCTL_IIO_PCIEDMI_REG 0x0D010050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 aspmctl : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls the level of ASPM enabled on
                               a given PCI Express Link. 00b: Disabled 01b: L0s
                               Entry Enabled 10b: L1 Entry Enabled 11b: L0s and
                               L1 Entry Enabled ''L0s Entry Enabled' enables
                               the Transmitter to enter L0s. If L0s is
                               supported, the Receiver must be capable of
                               entering L0s even when the Transmitter is
                               disabled from entering L0s (00b or 10b).
                            */
    UINT16 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 rcb : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /*
                               This bit indicates the RCB value for Root Port,
                               Endpoints and Bridges. 0b: 64 byte 1b: 128 byte
                               Configuration software must only set this bit if
                               the Root Port Upstream from the Endpoint or
                               Bridge reports an RCB value of 128 bytes (Root
                               Port only)
                            */
    UINT16 ld : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit disables the Link by directing the
                               LTSSM to the Disabled state when Set, This is
                               used by the downstream ports, Root ports or DMI
                               EP in RC only. For the upstream port or virtual
                               switch port, it is Read-only.
                            */
    UINT16 rl : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, this bit initiates link retraining by
                               directing the physical layer LTSSM to recovery
                               state. If the LTSSM is already in REcovery or
                               configuration, re-entering Recovery is permitted
                               but not required. Reads of this bit always
                               return 0b. This is used by the downstream ports,
                               Root ports or DMI EP in RC only. For the
                               upstream port or virtual switch port, it is
                               Read-only.
                            */
    UINT16 cccfg : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit indicates that this component
                               and the component at the opposite end of this
                               link are operating with distributed common
                               reference clocks. A value of 0b indicates that
                               this component and the component at the opposite
                               end of this link are operating with asynchronous
                               reference clock. After changing the value in
                               this bit in both components on a link, software
                               must trigger the link to retrain by writing a 1b
                               to the Retrain Link bit of the Downstream Port.
                            */
    UINT16 es : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit forces extended transmission
                               of 4096 FTS ordered sets in FTS and an extra
                               1024 TS1 at exit from L1 prior to entering L0.
                               This mode provides external devices monitoring
                               the link time to achieve bit and symbol lock
                               before the link enters L0 state and resumes
                               communication. Default value for this bit is 0.
                            */
    UINT16 ecpm : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               Applicable only for Upstream Ports and with form
                               factors that support a 'Clock Request' (CLKREQ#)
                               mechanism, this bit operates as follows: 0b
                               Clock power management is disabled and device
                               must hold CLKREQ# signal low. 1b When this bit
                               is Set, the device is permitted to use CLKREQ#
                               signal to power manage Link clock according to
                               protocol defined in appropriate form factor
                               specification. For a non-ARI multi-Function
                               device, power-management-configuration software
                               must only Set this bit if all Functions of the
                               multi-Function device indicate a 1b in the Clock
                               Power Management bit of the Link Capabilities
                               register. The component is permitted to use the
                               CLKREQ# signal to power manage Link clock only
                               if this bit is Set for all Functions. For ARI
                               Devices, Clock Power Management is enabled
                               solely by the setting in Function 0. The
                               settings in the other Functions always return
                               whatever value software programmed for each, but
                               otherwise are ignored by the component. The
                               CLKREQ# signal may also be controlled via the L1
                               PM Substates mechanism. Such control is not
                               affected by the setting of this bit. Downstream
                               Ports and components that do not support Clock
                               Power Management (as indicated by a 0b value in
                               the Clock Power Management bit of the Link
                               Capabilities register) must hardwire this bit to
                               0b. Default value of this bit is 0b, unless
                               specified otherwise by the form factor
                               specification. The value of this field will be
                               reflected by CAPSR.LINKCTL_ECPM.
                            */
    UINT16 hawd : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set, this bit disables hardware from changing
                               the Link width for reasons other than attempting
                               to correct unreliable Link operation by reducing
                               Link width. For a Multi-Function device
                               associated with an Upstream Port, the bit in
                               Function 0 is of type RW, and only Function 0
                               controls the components Link behavior. In all
                               other Functions of that device, this bit is of
                               type RsvdP. Components that do not implement the
                               ability autonomously to change Link width are
                               permitted to hardwire this bit to 0b. Default
                               value of this bit is 0b.
                            */
    UINT16 lbmie : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt to indicate that the Link Bandwidth
                               Management Status bit has been set. This bit is
                               not applicable and is reserved for Endpoints,
                               PCI Express-to-PCI/PCI-X bridges, and Upstream
                               Ports of Switches.
                            */
    UINT16 labie : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of an
                               interrupt to indicate that the Link Autonomous
                               Bandwidth Status bit has been set. Functions
                               that do not implement the Link Bandwidth
                               Notification Capability must hardwire this bit
                               to 0b.
                            */
    UINT16 rsvd_12 : 2;

                            /* Bits[13:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 drs : 2;

                            /* Bits[15:14], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the mechanism used to report reception
                               of a DRS message. Must be implemented for
                               Downstream Ports with the DRS Supported bit Set
                               in the Link Capabilities 2 Register. Encodings
                               are: 00b DRS not Reported: If DRS Supported is
                               Set, receiving a DRS Message will set DRS
                               Message Received in the Link Status 2 Register
                               but will otherwise have no effect 01b DRS
                               Interrupt Enabled: If the DRS Message Received
                               bit in the Link Status 2 Register transitions
                               from 0 to 1, and either MSI or MSI-X is enabled,
                               an MSI or MSI-X interrupt is generated using the
                               vector in Interrupt Message Number 10b DRS to
                               FRS Signaling Enabled: If the DRS Message
                               Received bit in the Link Status 2 Register
                               transitions from 0 to 1, the Port must send an
                               FRS Message Upstream with the FRS Reason field
                               set to DRS Message Received Behavior is
                               undefined if this field is set to 10b and the
                               FRS Supported bit in the Device Capabilities 2
                               Register is Clear. Behavior is undefined if this
                               field is set to 11b. Downstream Ports with the
                               DRS Supported bit Clear in the Link Capabilities
                               2 register must hardwire this field to 00b. This
                               field is Reserved for Upstream Ports. Default
                               value of this field is 00b.
                            */

  } Bits;
  UINT16 Data;

} LINKCTL_IIO_PCIEDMI_STRUCT;

/* LINKSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x10000052)                                                      */
/*      SPRB0 (0x10000052)                                                      */
/*      SPRHBM (0x10000052)                                                     */
/*      SPRC0 (0x10000052)                                                      */
/*      SPRMCC (0x10000052)                                                     */
/*      SPRUCC (0x10000052)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Status
*/


#define LINKSTS_IIO_PCIEDMI_REG 0x0D010052

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cls : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field indicates the negotiated link speed
                               of the given PCI Express link. The encoded value
                               specifies a bit location in the Supported Link
                               Speeds Vector (in the Link Capabilities 2
                               register) that corresponds to the current Link
                               speed. Defined encodings are: 0001b Supported
                               Link Speeds Vector field bit 0 0010b Supported
                               Link Speeds Vector field bit 1 0011b Supported
                               Link Speeds Vector field bit 2 0100b Supported
                               Link Speeds Vector field bit 3 0101b Supported
                               Link Speeds Vector field bit 4 0110b Supported
                               Link Speeds Vector field bit 5 0111b Supported
                               Link Speeds Vector field bit 6 All other
                               encodings are Reserved The value in this field
                               is undefined when the link is not up.
                            */
    UINT16 nlw : 6;

                            /* Bits[9:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates the negotiated width of the
                               PCI Express link. 00 0001b: x1 00 0010b: X2 00
                               0100b: x4 00 1000b: X8 00 1100b: X12not
                               supported 01 0000b: X16 10 0000b: X32not
                               supported All other values are reserved. The
                               value in this field is undefined when the link
                               is not up.
                            */
    UINT16 undefined : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not applicable */
    UINT16 lt : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /*
                               For PCIe device, this bit indicates that the
                               Physical Layer LTSSM is in the Configuration or
                               Recovery state, or a 1b was written to the
                               Retrain Link bit but the Link training has not
                               yet begun. Hardware clears this bit when the
                               LTSSM exits the Configuration/Recovery state.
                            */
    UINT16 scc : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000001*/

                            /*
                               When to 1b, this bit indicates that the
                               component uses the same physical reference clock
                               that he platform provides on the connector. If
                               the device uses an independent clock
                               irrespective of the presence of a reference on
                               the connector, this bit must be clear. 1:
                               Indicates same reference clock. 0: Indicates
                               independent reference clock The value of this
                               field will be reflected by CAPSR.LINKSTS_SCC.
                            */
    UINT16 dllla : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the status of the Data Link
                               Control and Management Status Machine. It
                               returns a 1b to indicate the DL_Active state, 0b
                               otherwise.
                            */
    UINT16 lbms : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by hardware to indicate that
                               either of the following has occurred without the
                               port transitioning through DL_Down status: A
                               link retraining has completed following a write
                               of 1b to the Retrain link bit. Hardware has
                               changed link speed of width to attempt to
                               correct unreliable link operation, either
                               through an LTSSM timeout or a higher level
                               process. This bit must be set if the Physical
                               Layer reports a non-autonomous speed or width
                               change initiated by the Upstream Port.
                            */
    UINT16 labs : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by hardware to indicate that the
                               PCIe cluster has autonomously changed link or
                               width, without the port transitioning through
                               DL_Down status, for reason other than to attempt
                               to correct unreliable link operation. This bit
                               must be set if the Physical Layer reports an
                               autonomous speed or width change initiated by
                               the Upstream Port.
                            */

  } Bits;
  UINT16 Data;

} LINKSTS_IIO_PCIEDMI_STRUCT;

/* SLOTCAP_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000054)                                                      */
/*      SPRB0 (0x20000054)                                                      */
/*      SPRHBM (0x20000054)                                                     */
/*      SPRC0 (0x20000054)                                                      */
/*      SPRMCC (0x20000054)                                                     */
/*      SPRUCC (0x20000054)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Lock Key bit is located in the Personality Lock Key Control Register ('PLKCTL').
*/


#define SLOTCAP_IIO_PCIEDMI_REG 0x0D020054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 abp : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an Attention Button is
                               implemented on the chassis for this slot. 0:
                               indicates that an Attention Button is not
                               present 1: indicates that an Attention Button is
                               present
                            */
    UINT32 pcp : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that a Power Controller is
                               implemented on the chassis for this slot. 0:
                               indicates that a Power Controller is not present
                               1: indicates that a Power Controller is present
                            */
    UINT32 mrlsp : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an MRL Sensor is
                               implemented on the chassis for this slot. 0:
                               indicates that an MRL Sensor is not present 1:
                               indicates that an MRL Sensor is present
                            */
    UINT32 aip : 1;

                            /* Bits[3:3], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an Attention Indicator
                               is implemented on the chassis for this slot. 0:
                               indicates that an Attention Indicator is not
                               present 1: indicates that an Attention Indicator
                               is present
                            */
    UINT32 pip : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that a Power Indicator is
                               implemented on the chassis for this slot. 0:
                               indicates that Power Indicator is not present 1:
                               indicates that Power Indicator is present
                            */
    UINT32 hps : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This field indicates that a device in this slot
                               may be removed from the system without prior
                               notification. 0: indicates that hot-plug
                               surprise is not supported 1: indicates that hot-
                               plug surprise is supported
                            */
    UINT32 hpc : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               This field defines hot-plug support capabilities
                               for the PCI-Express port. 0: indicates that this
                               slot is not capable of supporting Hot-plug
                               operations. 1: indicates that this slot is
                               capable of supporting Hot-plug operations
                            */
    UINT32 splv : 8;

                            /* Bits[14:7], Access Type=RW/L, default=None*/

                            /*
                               This field specifies the upper limit on power
                               supplied by slot in conjunction with the Slot
                               Power Limit Scale value defined previously Power
                               limit (in Watts). i.e Power limit = SPLS x SPLV.
                               This register must be implemented if the Slot
                               Implemented bit is set in EXPCAP. Writes to this
                               register (SLOTCAP) when the Data Link Layer
                               reports DL_Up status, or the link transitions
                               from a non-DL_Up to a DL_Up would cause the Port
                               to send the Set_Slot_Power_Limit Message.
                            */
    UINT32 spls : 2;

                            /* Bits[16:15], Access Type=RW/L, default=None*/

                            /*
                               This field specifies the scale used for the Slot
                               Power Limit Value. Range of Values: 00: 1.0x 01:
                               0.1x 10: 0.01x 11: 0.001x This register must be
                               implemented if the Slot Implemented bit is set
                               in EXPCAP. Writes to this register (SLOTCAP)
                               when the Data Link Layer reports DL_Up status,
                               or the link transitions from a non-DL_Up to a
                               DL_Up would cause the Port to send the
                               Set_Slot_Power_Limit Message.
                            */
    UINT32 emip : 1;

                            /* Bits[17:17], Access Type=RW/L, default=None*/

                            /*
                               This bit when set indicates that an
                               Electromechanical Interlock is implemented on
                               the chassis for this slot and that lock is
                               controlled by bit 11 in Slot Control Register.
                            */
    UINT32 nccs : 1;

                            /* Bits[18:18], Access Type=RW/L, default=None*/

                            /*
                               When Set, this bit indicates that this slot does
                               not generate software notification when an
                               issued command is completed by the Hot-Plug
                               Controller. This bit is only permitted to be Set
                               if the hot-plug capable Port is able to accept
                               writes to all fields of the Slot Control
                               register without delay between successive
                               writes. The EIP PCIe port is capable of
                               interrupt notification when completing the
                               hotplug command The field name is made
                               consistent with PCIe 2.0a spec
                            */
    UINT32 psn : 13;

                            /* Bits[31:19], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the physical slot number
                               connected to the PCI-Express port. It should be
                               initialized to 0 for ports connected to devices
                               that are either integrated on the system board
                               or integrated within the same silicon such as
                               the switch device or the Root port.
                            */

  } Bits;
  UINT32 Data;

} SLOTCAP_IIO_PCIEDMI_STRUCT;

/* SLOTCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x10000058)                                                      */
/*      SPRB0 (0x10000058)                                                      */
/*      SPRHBM (0x10000058)                                                     */
/*      SPRC0 (0x10000058)                                                      */
/*      SPRMCC (0x10000058)                                                     */
/*      SPRUCC (0x10000058)                                                     */
/* Register default value on SPRA0: 0x000003C0                                  */
/* Register default value on SPRB0: 0x000003C0                                  */
/* Register default value on SPRHBM: 0x000003C0                                 */
/* Register default value on SPRC0: 0x000003C0                                  */
/* Register default value on SPRMCC: 0x000003C0                                 */
/* Register default value on SPRUCC: 0x000003C0                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Slot Control
*/


#define SLOTCTL_IIO_PCIEDMI_REG 0x0D010058

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 abpe : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via an attention
                               button pressed event. 0: Disables generation of
                               hot-plug interrupts or wake messages when the
                               attention button is pressed. 1: Enables
                               generation of hot-plug interrupts or wake
                               messages when the attention button is pressed
                            */
    UINT16 pfdie : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a power fault
                               event. 0: Disables generation of hot-plug
                               interrupts or wake messages when a power fault
                               event happens. 1: Enables generation of hot-plug
                               interrupts or wake messages when a power fault
                               event happens.
                            */
    UINT16 mscie : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a MRL Sensor
                               changed event. 0: Disables generation of hot-
                               plug interrupts or wake messages when an MRL
                               Sensor changed event happens. 1: Enables
                               generation of hot-plug interrupts or wake
                               messages when an MRL Sensor changed event
                               happens.
                            */
    UINT16 pdcie : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a presence
                               detect changed event. 0: Disables generation of
                               hot-plug interrupts or wake messages when a
                               presence detect changed event happens. 1-
                               Enables generation of hot-plug interrupts or
                               wake messages when a presence detect changed
                               event happens.
                            */
    UINT16 ccie : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables the generation of Hot-plug
                               interrupts when a command is completed by the
                               Hot-plug controller connected to the PCI-Express
                               port. 0: Disables hot-plug interrupts on a
                               command completion by a hot-plug Controller 1:
                               Enables hot-plug interrupts on a command
                               completion by a hot-plug Controller
                            */
    UINT16 hpie : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables the generation of Hot-plug
                               interrupts and events in the PCIExpress port. 0:
                               Disables Hot-plug events and interrupts 1:
                               Enables Hot-plug events and interrupts
                            */
    UINT16 aic : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000003*/

                            /*
                               If an Attention Indicator is implemented, writes
                               to this register sets the Attention Indicator to
                               the written state. Reads of this field reflect
                               the value from the latest write, even if the
                               corresponding hot-plug command is not executed
                               yet at the VPP, unless software issues a write
                               without waiting for the previous command to
                               complete in which case the read value is
                               undefined. 00: Reserved. 01: On 10: Blink (The
                               switch drives 1.5 Hz square wave) 11: Off When
                               this register is written, the event is signaled
                               via the virtual pins of the switch over a
                               dedicated SMBus port.
                            */
    UINT16 pic : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000003*/

                            /*
                               If a Power Indicator is implemented, writes to
                               this register set the Power Indicator to the
                               written state. Reads of this field must reflect
                               the value from the latest write, even if the
                               corresponding hot-plug command is not executed
                               yet at the VPP, unless software issues a write
                               without waiting for the previous command to
                               complete in which case the read value is
                               undefined. 00: Reserved. 01: On 10: Blink (The
                               PCIe cluster drives 1.5 Hz square wave for
                               Chassis mounted LEDs in the case of legacy card
                               form factor for PCI-Express devices) 11: Off
                               When this register is written, the event is
                               signaled via the virtual pins of the switch over
                               a dedicated SMBus port. The switch does not
                               generated the Power_Indicator_On/Off/Blink
                               messages on PCI Express when this field is
                               written to by software.
                            */
    UINT16 pcc : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates the current state of the
                               Power applied to the slot of the PCIExpress
                               port. Reads of this field must reflect the value
                               from the latest write, even if the corresponding
                               hot-plug command is not executed yet at the VPP,
                               unless software issues a write without waiting
                               for the previous command to complete in which
                               case the read value is undefined. 0: Power On 1:
                               Power Off
                            */
    UINT16 eic : 1;

                            /* Bits[11:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               When software writes either a 1 to this bit, The
                               PCIe port pulses the EMIL pin per PCIExpress
                               Server/Workstation Module Electromechanical Spec
                               Rev 1.0. Write of 0 has no effect. This bit
                               always returns a 0 when read. If
                               electromechanical lock is not implemented, then
                               either a write of 1 or 0 to this register has no
                               effect.
                            */
    UINT16 dllsce : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, this field enables software
                               notification when Data Link Layer Link Active
                               reporting field is changed.
                            */
    UINT16 aspld : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this disables the automatic sending of
                               a Set_Slot_Power_Limit Message when a Link
                               transitions from a non-DL_Up status to a DL_Up
                               status.
                            */
    UINT16 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} SLOTCTL_IIO_PCIEDMI_STRUCT;

/* SLOTSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x1000005a)                                                      */
/*      SPRB0 (0x1000005a)                                                      */
/*      SPRHBM (0x1000005a)                                                     */
/*      SPRC0 (0x1000005a)                                                      */
/*      SPRMCC (0x1000005a)                                                     */
/*      SPRUCC (0x1000005a)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Slot Status
*/


#define SLOTSTS_IIO_PCIEDMI_REG 0x0D01005A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 abp : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the attention button is
                               pressed. It is subsequently cleared by software
                               after the field has been read and processed. On-
                               board logic per slot must set the VPP signal
                               corresponding to this bit inactive if the
                               FF/system does not support out-of-band presence
                               detect. Design should implement this as an edge
                               detection logic in the chipset/platform to
                               recognize a 0 -> 1 transition as a ABP event.
                               Due to the long time frames for human
                               interaction, software could potentially have
                               serviced and cleared this event while the
                               operator is pressing the attention button. For
                               instance, if the user presses the Attention
                               button that lasts for 2ms and the VPP sampling
                               rate is, say 100us and if the Interrupt Service
                               routine (ISR) processes and clears the ABP in
                               100us, there could be up to 10 (i.e
                               2000/(100+100)) different interrupts for the
                               same event.Hardware must only generate 1
                               interrupt for every ABP event by treating it as
                               edge based rather than level based event.
                            */
    UINT16 pfd : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a power fault event is
                               detected by the power controller. It is
                               subsequently cleared by software after the field
                               has been read and processed. On-board logic per
                               slot must set the VPP signal corresponding to
                               this bit inactive if the FF/system does not
                               support out-of-band presence detect.
                            */
    UINT16 mrlsc : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when an MRL Sensor Changed event
                               is detected. It is subsequently cleared by
                               software after the field has been read and
                               processed. On-board logic per slot must set the
                               VPP signal corresponding to this bit inactive if
                               the FF/system does not support out-of-band
                               presence detect.
                            */
    UINT16 pdcs : 1;

                            /* Bits[3:3], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the value reported in the
                               Presence Detect State bit is changed. It is
                               subsequently cleared by software after the field
                               has been read and processed. On-board logic per
                               slot must set the VPP signal corresponding to
                               this bit inactive if the system does not support
                               out-of-band presence detect. RPs may hold the
                               re-training to occur until the SLOTSTS.PDCS bit
                               has been cleared by software for the removal
                               event.
                            */
    UINT16 ccs : 1;

                            /* Bits[4:4], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the hot-plug controller
                               completes an issued command and is ready to
                               accept a new command. It is subsequently cleared
                               by software after the field has been read and
                               processed. If Command Completed notification is
                               supported, then the No Command Completed Support
                               bit in the Slot Capabilities register should be
                               0.
                            */
    UINT16 mrlss : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit reports the status of an MRL sensor if
                               it is implemented. 0: MRL Closed 1: MRL Open If
                               Hotplug is implemented through VPP, the correct
                               polarity of the external MRL sensor in the
                               motherboard should be translated to map to the
                               encodings as defined in this register field.
                               (Tylersburg issue)
                            */
    UINT16 pds : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field conveys the Presence Detect status of
                               an adapter in the slot. It reflects the Logical
                               'OR' of the Physical Layer in-band presence
                               detect mechanism and any out-of-band presence
                               detect mechanism defined for the slot's
                               corresponding form factor. 0: Card/Module/Cable
                               slot empty or Cable Slot occupied but not
                               powered 1: Card/module Present in slot (powered
                               or unpowered) or cable present and powered on
                               the other end. This field is set to 1 by the
                               switch following reset for all the ports since
                               it is related to the complement of the EXPCAP.SI
                               bit whose default is 0 implying that the card is
                               connected to the switch on the motherboard.
                               Software should ensure that for those standard
                               PCI-Express ports which are hot-plug capable, it
                               sets the EXPCAP.SI field to '1' such that PDS
                               becomes 0. Then any subsequent hotplug action
                               will ensure that this field is set. Refer to the
                               algorithm given below: if (EXPCAP.SI == FALSE)
                               // always set to 1b and ignore the input from
                               inband/OOB presence detect SLOTSTS.PDS = 1b else
                               // if (EXPCAP.SI == TRUE) // Slot Empty = 0,
                               Card Present = 1 SLOTSTS.PDS reflects slot
                               status of side-band SMBUS Presence Detect signal
                               OR Inband Presence Detect Mechanism.
                            */
    UINT16 els : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /*
                               A read to this register returns the current
                               state of the Electromechanical Interlock (the
                               EMILS pin) which has the defined encodings as:
                               0: Electromechanical Interlock Disengaged 1:
                               Electromechanical Interlock Engaged
                            */
    UINT16 dllscs : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set (if it is not already set) when
                               the state of the Data Link Layer Link Active bit
                               in the Link Status register has changed.
                               Software must read Data Link Layer Active field
                               to determine the link state before initiating
                               configuration cycles to the hot plugged device.
                            */
    UINT16 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} SLOTSTS_IIO_PCIEDMI_STRUCT;

/* ROOTCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x1000005c)                                                      */
/*      SPRB0 (0x1000005c)                                                      */
/*      SPRHBM (0x1000005c)                                                     */
/*      SPRC0 (0x1000005c)                                                      */
/*      SPRMCC (0x1000005c)                                                     */
/*      SPRUCC (0x1000005c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Control
*/


#define ROOTCTL_IIO_PCIEDMI_REG 0x0D01005C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 secee : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for
                               correctable errors. 1: indicates that a System
                               Error should be generated if a correctable error
                               (ERR_COR) is reported by any of the devices in
                               the hierarchy associated with and including this
                               PCI-Express port 0: No System Error should be
                               generated on a correctable error (ERR_COR)
                               reported by any of the devices in the hierarchy
                               associated with and including this PCI-Express
                               port.
                            */
    UINT16 senfee : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for non-fatal
                               errors. 1: indicates that a System Error should
                               be generated if a non-fatal error (ERR_NONFATAL)
                               is reported by any of the devices in the
                               hierarchy associated with and including this
                               PCI-Express port. 0: No System Error should be
                               generated on a non-fatal error (ERR_NONFATAL)
                               reported by any of the devices in the hierarchy.
                            */
    UINT16 sefee : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for fatal
                               errors. 1: indicates that a System Error should
                               be generated if a fatal error (ERR_FATAL) is
                               reported by any of the devices in the hierarchy
                               associated with and including this PCI-Express
                               port. 0: No System Error should be generated on
                               a fatal error (ERR_FATAL) reported by any of the
                               devices in the hierarchy.
                            */
    UINT16 pmeie : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls the generation of interrupts
                               for PME messages. 1: Enables interrupt
                               generation upon receipt of a PME message as
                               reflected in the PME Status bit defined in the
                               ROOTSTS register. A PME interrupt is generated
                               if the PMESTATUS register bit defined in Section
                               1.5.2.15, 'Root Status Register (ROOTSTS)' on
                               page 270, is set when this bit is set from a
                               cleared state. 0: Disables interrupt generation
                               for PME messages.
                            */
    UINT16 crssve : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the Root Port to
                               return Configuration Request Retry Status (CRS)
                               Completion Status to software (see PCIe Spec.
                               Section 2.3.1). Root Ports that do not implement
                               this capability must hardwire this bit to 0b.
                               Default value of this bit is 0b.
                            */
    UINT16 rsvd : 11;

                            /* Bits[15:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ROOTCTL_IIO_PCIEDMI_STRUCT;

/* ROOTCAP_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x1000005e)                                                      */
/*      SPRB0 (0x1000005e)                                                      */
/*      SPRHBM (0x1000005e)                                                     */
/*      SPRC0 (0x1000005e)                                                      */
/*      SPRMCC (0x1000005e)                                                     */
/*      SPRUCC (0x1000005e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Root Capabilities
*/


#define ROOTCAP_IIO_PCIEDMI_REG 0x0D01005E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 crssv : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit, when set, indicates that the Root Port
                               is capable of returning Configuration Retry
                               Status (CRS) on completions to software. Based
                               on Design input, the CRS notification will be
                               implemented in the EIP PCIe macro and hence the
                               default is set to 1. The field attribute is made
                               as RW-O for any specific changes to be installed
                               by BIOS
                            */
    UINT16 rsvd : 15;

                            /* Bits[15:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ROOTCAP_IIO_PCIEDMI_STRUCT;

/* ROOTSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000060)                                                      */
/*      SPRB0 (0x20000060)                                                      */
/*      SPRHBM (0x20000060)                                                     */
/*      SPRC0 (0x20000060)                                                      */
/*      SPRMCC (0x20000060)                                                     */
/*      SPRUCC (0x20000060)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Status
*/


#define ROOTSTS_IIO_PCIEDMI_REG 0x0D020060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmerid : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates the PCI requester ID of the
                               last PME requestor.
                            */
    UINT32 pmests : 1;

                            /* Bits[16:16], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This field indicates status of a PME that is
                               underway in the PCI-Express port. 1: PME was
                               asserted by a requester as indicated by the
                               PMEREQID field This bit is cleared by software
                               by writing a '1'. Subsequent PMEs are kept
                               pending until the PME Status is cleared.
                            */
    UINT32 pmepend : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates that another PME is pending
                               when the PME Status bit is set. When the PME
                               Status bit is cleared by software, the pending
                               PME is delivered by hardware by setting the PME
                               Status bit again and updating the Requestor ID
                               appropriately. The PME pending bit is cleared by
                               hardware if no more PMEs are pending. NOTE: The
                               root port can handle two outstanding PM_PME
                               messages in its internal queues of the Power
                               Management controller per port. If the
                               downstream device issues more than 2 PM_PME
                               messages successively, it will be dropped.
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ROOTSTS_IIO_PCIEDMI_STRUCT;

/* DEVCAP2_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000064)                                                      */
/*      SPRB0 (0x20000064)                                                      */
/*      SPRHBM (0x20000064)                                                     */
/*      SPRC0 (0x20000064)                                                      */
/*      SPRMCC (0x20000064)                                                     */
/*      SPRUCC (0x20000064)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Device Capabilities 2
*/


#define DEVCAP2_IIO_PCIEDMI_REG 0x0D020064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ctrs : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               This field indicates device support for the
                               optional Completion Timeout programmability
                               mechanism. This mechanism allows system software
                               to modify the Completion Timeout value. This
                               field is applicable only to Root Ports,
                               Endpoints that issue requests on their own
                               behalf, and PCI Express to PCI/PCI-X Bridges
                               that take ownership of request issues on PCI
                               Express. Four time values ranges are defined:
                               Range A: 50us to 10ms Range B: 10ms to 250ms
                               Range C: 250ms to 4s Range D: 4s to 64s Bits
                               ares set according to table below to show
                               timeout value ranges supported. 0000b:
                               Completions Timeout programming not supported --
                               values is fixed by implementation in the range
                               50us to 50ms. 0001b: Range A 0010b: Range B
                               0011b: Range A and B 0110b: Range B and C 0111b:
                               Range A, B, and C 1110b: Range B, C, and D
                               1111b: Range A, B, C, and D All other values are
                               reserved. For all other devices this field is
                               reserved and maybe be hardwired to 0000b. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ctds : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000001*/

                            /*
                               A value of 1b indicates support for the
                               completion Timeout Disable Mechanism. Support of
                               completion timeout disable is optional for Root
                               Ports. The PCIe port supports completions
                               timeout disable.
                            */
    UINT32 ari : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This bit is set to 1b indicating that the
                               downstream port supports this capability.
                               Applicable only to Switch Downstream Ports and
                               Root Ports, must be 0b for other Function types.
                               This bit must be set to 1b if a Switch
                               Downstream Port or Root Port supports this
                               optional capability. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 ars : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the port supports
                               this optional capability. Applicable only to
                               switch upstream ports, Switch downstream ports,
                               and root ports,. Must be 00b for other function
                               types. Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 ad32acs : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               Applicable to Functions with Memory Space BARs
                               as well as all Root Ports, must be 0b otherwise.
                               Includes FetchAdd, Swap, and CAS AtomicOps. This
                               bit must be set to 1b if the Function supports
                               this optional capability. This is set to 1 for
                               Rootport implementations in the PCIe EIP. Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 ad64acs : 1;

                            /* Bits[8:8], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the function
                               supports this optional capability. Applicable to
                               Functions with Memory Space BARs as well as all
                               Root Ports, must be 0b otherwise. Includes
                               FetchAdd, Swap, and CAS AtomicOps. Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 ad128acs : 1;

                            /* Bits[9:9], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the function
                               supports this optional capability. Applicable to
                               functions with memory space BARs as well as Root
                               Ports. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 nroeprpass : 1;

                            /* Bits[10:10], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the routing element never
                               carries out the passing permitted by Table 2-39
                               entry A2b that is associated with the Relaxed
                               Ordering Attribute field being Set. This bit
                               applies only for Switches and RCs that support
                               peer-topeer traffic between Root Ports. This bit
                               applies only to Posted Requests being forwarded
                               through the Switch or RC and does not apply to
                               traffic originating or terminating within the
                               Switch or RC itself. All Ports on a Switch or RC
                               must report the same value for this bit. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ltrms : 1;

                            /* Bits[11:11], Access Type=RW/V/L, default=None*/

                            /*
                               This bit when set indicates support for the
                               Latency Tolerance Reporting (LTR) mechanism.
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register . H/W will change this
                               field to 'RO' of zero when DISALBE_LTR fuse is
                               set to 1 if supported.
                            */
    UINT32 tphcs : 2;

                            /* Bits[13:12], Access Type=RW/L, default=None*/

                            /*
                               Value indicates Completer support for TPH or
                               Extended TPH. 00b:TPH and Extended TPH Completer
                               not supported 01b: TPH Completer supported,
                               Extended TPH completer not supported 10b:
                               Reserved 11b: Both TPH and Extended TPH
                               Completer supported Applicable only to Root
                               Ports and Endpoints. Must be 00b for other
                               function types. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tenbtcs : 1;

                            /* Bits[16:16], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the Function supports 10-Bit
                               Tag Completer capability, otherwise, the
                               Function does not. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 tenbtrs : 1;

                            /* Bits[17:17], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the Function supports 10-Bit
                               Tag Requester capability, otherwise, the
                               Function does not. This bit must not be Set if
                               the 10-Bit Tag Completer Supported bit is Clear.
                               Note that 10-Bit Tag field generation must be
                               enabled by the 10- Bit Tag Requester Enable bit
                               in the Device Control 2 register of the
                               Requester Function before 10-Bit Tags can be
                               generated by the Requester. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 obffs : 2;

                            /* Bits[19:18], Access Type=RW/L, default=None*/

                            /*
                               00b: OBFF Not Supported 01b: OBFF supported
                               using Message signaling only 10b: OBFF supported
                               using WAKE# signaling only 11b: OBFF supported
                               using WAKE# and Message signaling Applicable
                               only to Root Ports, Switch Ports, and Endpoints
                               that support this capability. Must be 00b for
                               other function types. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 exfmtfs : 1;

                            /* Bits[20:20], Access Type=RW/L, default=None*/

                            /*
                               0: The Function supports a 2-bit definition of
                               the Fmt field (default) 1: The Function supports
                               the 3-bit definition of the Fmt field. Must be
                               Set for Functions that support End-End TLP
                               Prefixes. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 e2etlps : 1;

                            /* Bits[21:21], Access Type=RW/L, default=None*/

                            /*
                               Indicates whether End-End TLP Prefix support is
                               offered by a Function. 0: No Support 1: Support
                               is provided to receive TLPs containing End-End
                               TLP Prefixes. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 maxe2etlp : 2;

                            /* Bits[23:22], Access Type=RW/V/L, default=None*/

                            /*
                               Indicates the maximum number of End-End TLP
                               Prefixes supported by this Function. TLPs
                               received by this Function that contain more End-
                               End TLP Prefixes than are supported must be
                               handled as Malformed TLPs. 01: 1 End-End TLP
                               Prefix 10: 2 End-End TLP Prefixes 11: 3 End-End
                               TLP Prefixes 00: 4 End-End TLP Prefixes If End-
                               End TLP Prefix Supported is Clear, this field is
                               Reserved. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 rsvd_24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frs : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               When Set, indicates support for the optional
                               Function Readiness Status (FRS) capability. Must
                               be Set for all Functions that support generation
                               or receipt capabilities of FRS Messages. Must
                               not be Set by Switch Functions that do not
                               generate FRS Messages on their own behalf. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} DEVCAP2_IIO_PCIEDMI_STRUCT;

/* DEVCTL2_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x10000068)                                                      */
/*      SPRB0 (0x10000068)                                                      */
/*      SPRHBM (0x10000068)                                                     */
/*      SPRC0 (0x10000068)                                                      */
/*      SPRMCC (0x10000068)                                                     */
/*      SPRUCC (0x10000068)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Control 2
*/


#define DEVCTL2_IIO_PCIEDMI_REG 0x0D010068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ctv : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               In devices that support completion timeout
                               programmability, this field allows system
                               software to modify the completion timeout range.
                               The following encodings and corresponding
                               timeout ranges are defined based on
                               implementation choice. This field provides finer
                               control based over the ranges chosen by
                               DEVAP2.CTRS. The implementation specific range
                               is shown in brackets 0000b: 50us to 50ms (16.8ms
                               - 25.2ms based on core clk period) 0001b: 50us
                               to 100us (65.5us - 99.3us based on core clk
                               period) 0010b: 1ms to 10ms (4.2ms - 6.3ms based
                               on core clk period) 0101b: 16ms to 55ms (33.6ms
                               - 50.3ms based on core clk period) 0110b: 65ms
                               to 210ms (134.2ms - 201.3ms based on core clk
                               period) 1001b: 260ms to 900ms (536.9ms - 805.3ms
                               based on core clk period) 1010b: 1s to 3.5s
                               (2.1s - 3.2s based on core clk period) 1101b: 4s
                               to 13s (8.6s - 12.9s based on core clk period)
                               1110b: 17s to 64s (34.4s - 51.5s based on core
                               clk period) All others are reserved. It is
                               highly recommended that the completion timeout
                               value not be less then 10ms. A small completion
                               timeout value may result in premature completion
                               timeout for slower responding devices.
                            */
    UINT16 ctd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               1: Disable the completions timeout mechanism for
                               all NP transactions. 0: Completion timeout is
                               enabled for all NP transactions.
                            */
    UINT16 arie : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1b, ARI is enabled for the
                               downstream port or root ports. The Downstream
                               Port disables its traditional Device Number
                               field being 0 enforcement when turning a Type 1
                               Configuration Request into a Type 0
                               Configuration Request, permitting access to
                               Extended Functions in an ARI Device immediately
                               below the Port. Default value of this bit is 0b.
                            */
    UINT16 are : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Applicable only to Endpoints and Root Ports,
                               must be hardwired to 0b for other Function
                               types. The Function is allowed to initiate
                               AtomicOp Requests only if this bit and the Bus
                               Master Enable bit in the Command register are
                               both Set.
                            */
    UINT16 aeb : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, AtomicOp requests that
                               target this out going Egress port must be
                               blocked. Applicable and mandatory for switch
                               Upstream Ports, Switch Downstream Ports, and
                               Root Ports that implement AtomicOp routing
                               capability. Otherwise, must be hardwired to 0b.
                            */
    UINT16 idore : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               This bit when set to 1b allows the function to
                               set the ID-Based Ordering (IDO) bit on requests
                               it initiates. Applicable only to Endpoints
                               including RC integrated Endpoints and Root
                               Ports.
                            */
    UINT16 idoce : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /*
                               This bit when set to 1b allows the function to
                               set the ID-Based Ordering (IDO) bit of
                               completions it returns. Applicable only to
                               Endpoints including RC integrated Endpoints and
                               Root Ports.
                            */
    UINT16 ltrme : 1;

                            /* Bits[10:10], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set to 1b, this bit enables Upstream Ports
                               to send LTR messages and Downstream Ports to
                               process LTR Messages. Applicable to Root Ports,
                               Switches, and Endpoints that implement the LTR
                               capability must implement this bit. For
                               Downstream Ports, this bit must be reset to the
                               default value if the Port goes to DL_Down
                               status. H/W will change this field to 'RO' of
                               zero when DISALBE_LTR fuse is set to 1 if
                               supported.
                            */
    UINT16 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 tenbtre : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, in combination with the Extended Tag
                               Field Enable bit in the Device Control register,
                               determines how many Tag field bits a Requester
                               is permitted to use. When the 10-Bit Tag
                               Requester Enable bit is Set, the Requester is
                               permitted to use 10-Bit Tags. See PCIe Spec.
                               Section 2.2.6.2 for complete details. Software
                               should not change the value of this bit while
                               the Function has outstanding Non-Posted
                               Requests, otherwise, the result is undefined.
                               Functions that do not implement 10-Bit Tag
                               Requester capability are permitted to hardwire
                               this bit to 0b. Default value of this bit is 0b
                            */
    UINT16 obffe : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               00b: OBFF Disabled 01b: OBFF Enabled using
                               Message signaling [Variation A] 10b: OBFF
                               Enabled using Message signaling [Variation B]
                               11b: OBFF Enabled using WAKE# signaling This
                               field is required for all Ports that support the
                               OBFF Capability. For a Multi-Function Device
                               associated with an Upstream Port of a Device
                               that implements OBFF, the field in Function 0 is
                               of type RW, and only Function 0 controls the
                               Component's behavior. In all other Functions of
                               that Device, this field is of type RsvdP.
                            */
    UINT16 e2etlpblk : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               Controls whether the routing function is
                               permitted to forward TLPs containing an End-End
                               TLP Prefix. 0: Forwarding Enabled - Function is
                               permitted to send TLPs with End-End TLP
                               Prefixes. 1: Forwarding Blocked - Function is
                               not permitted to send TLPs with End-End TLP
                               Prefixes. This bit is applicable to Root Ports
                               and Switch Ports where the End-End TLP Prefix
                               Supported bit is Set. This bit is not applicable
                               and is RsvdP in all other cases
                            */

  } Bits;
  UINT16 Data;

} DEVCTL2_IIO_PCIEDMI_STRUCT;

/* LINKCAP2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x2000006c)                                                      */
/*      SPRB0 (0x2000006c)                                                      */
/*      SPRHBM (0x2000006c)                                                     */
/*      SPRC0 (0x2000006c)                                                      */
/*      SPRMCC (0x2000006c)                                                     */
/*      SPRUCC (0x2000006c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Link Capabilities 2
*/


#define LINKCAP2_IIO_PCIEDMI_REG 0x0D02006C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 slnkspv : 7;

                            /* Bits[7:1], Access Type=RO/V, default=0x0000000F*/

                            /*
                               This field indicates the supported Link speed(s)
                               of the associated Port. For each bit, a value of
                               1b indicates that the corresponding Link speed
                               is supported, otherwise, the Link speed is not
                               supported. Bit definitions within this field
                               are: bit 0 2.5 GT/s bit 1 5.0 GT/s bit 2 8.0
                               GT/s bit 3 16.0 GT/s bit 6:4 Reserved Multi-
                               Function devices associated with an Upstream
                               Port must report the same value in this field
                               for all Functions.
                            */
    UINT32 cls : 1;

                            /* Bits[8:8], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports crosslinks When set to
                               0b on a Port that supports Link speeds of 8.0
                               GT/s or higher, this bit indicates that the
                               associated Port does not support crosslinks.
                               When set to 0b on a Port that only supports Link
                               speeds of 2.5 GT/s or 5.0 GT/s, this bit
                               provides no information regarding the Port's
                               level of crosslink support. It is recommended
                               that this bit be Set in any Port that supports
                               crosslinks even though doing so is only required
                               for Ports that also support operating at 8.0
                               GT/s or higher Link speeds. Note: Software
                               should use this bit when referencing fields
                               whose definition depends on whether or not the
                               Port supports crosslinks. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 lskposgssv : 7;

                            /* Bits[15:9], Access Type=RW/L, default=None*/

                            /*
                               If this field is non-zero, it indicates that the
                               Port, when operating at the indicated speed(s)
                               supports SRIS and also supports software control
                               of the SKP Ordered Set transmission scheduling
                               rate. Bit definitions within this field are: Bit
                               0 2.5 GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3
                               16.0 GT/s Bits 6:4 RsvdP Multi-Function devices
                               associated with an Upstream Port must report the
                               same value in this field for all Functions.
                               Behavior is undefined if a bit is Set in this
                               field and the corresponding bit is not Set in
                               the Supported Link Speeds Vector. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 lskposrssv : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               If this field is non-zero, it indicates that the
                               Port, when operating at the indicated speed(s)
                               supports SRIS and also supports receiving SKP OS
                               at the rate defined for SRNS while running in
                               SRIS. Bit definitions within this field are: Bit
                               0 2.5 GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3
                               16.0 GT/s Bits 6:4 RsvdP Multi-Function devices
                               associated with an Upstream Port must report the
                               same value in this field for all Functions.
                               Behavior is undefined if a bit is Set in this
                               field and the corresponding bit is not Set in
                               the Supported Link Speeds Vector. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register . Currently, design does not
                               support reception of low frequency SOS in L0.
                            */
    UINT32 rpds : 1;

                            /* Bits[23:23], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports detection and reporting
                               of Retimer presence. This bit must be set to 1b
                               in a Port when the Supported Link Speeds Vector
                               of the Link Capabilities 2 register indicates
                               support for a Link speed of 16.0 GT/s or higher.
                               It is permitted to be set to 1b regardless of
                               the supported Link speeds. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rpds2 : 1;

                            /* Bits[24:24], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports detection and reporting
                               of two Retimers presence. This bit must be set
                               to 1b in a Port when the Supported Link Speeds
                               Vector of the Link Capabilities 2 register
                               indicates support for a Link speed of 16.0 GT/s
                               or higher. It is permitted to be set to 1b
                               regardless of the supported Link speeds if the
                               Retimer Presence Detect Supported bit is also
                               set to 1b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 rsvd_25 : 6;

                            /* Bits[30:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 drss : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               When Set, indicates support for the optional
                               Device Readiness Status (DRS) capability. Must
                               be Set in Downstream Ports that support DRS.
                               Must be Set in Downstream Ports that support
                               FRS. For Upstream Ports that support DRS, it is
                               strongly recommended that this bit be Set in
                               Function 0. For all other Functions associated
                               with an Upstream Port, this bit must be Clear.
                               Must be Clear in Functions that are not
                               associated with a Port. RsvdP in all other
                               Functions. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} LINKCAP2_IIO_PCIEDMI_STRUCT;

/* LINKCTL2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x10000070)                                                      */
/*      SPRB0 (0x10000070)                                                      */
/*      SPRHBM (0x10000070)                                                     */
/*      SPRC0 (0x10000070)                                                      */
/*      SPRMCC (0x10000070)                                                     */
/*      SPRUCC (0x10000070)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Control 2
*/


#define LINKCTL2_IIO_PCIEDMI_REG 0x0D010070

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 tls : 4;

                            /* Bits[3:0], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               For Downstream Ports, this field sets an upper
                               limit on Link operational speed by restricting
                               the values advertised by the Upstream component
                               in its training sequences. The encoded value
                               specifies a bit location in the Supported Link
                               Speeds Vector (in the Link Capabilities 2
                               register) that corresponds to the desired target
                               Link speed. Defined encodings are: 0001b
                               Supported Link Speeds Vector field bit 0 0010b
                               Supported Link Speeds Vector field bit 1 0011b
                               Supported Link Speeds Vector field bit 2 0100b
                               Supported Link Speeds Vector field bit 3 0101b
                               Supported Link Speeds Vector field bit 4 0110b
                               Supported Link Speeds Vector field bit 5 0111b
                               Supported Link Speeds Vector field bit 6 All
                               other encodings are Reserved. If a value is
                               written to this field that does not correspond
                               to a supported speed (as indicated by the
                               Supported Link Speeds Vector), the result is
                               undefined. If either of the Enter Compliance or
                               Enter Modified Compliance bits are implemented,
                               then this field must also be implemented. The
                               default value of this field is the highest Link
                               speed supported by the component (as reported in
                               the Max Link Speed field of the Link
                               Capabilities register) unless the corresponding
                               platform/form factor requires a different
                               default value. For both Upstream and Downstream
                               Ports, this field is used to set the target
                               compliance mode speed when software is using the
                               Enter Compliance bit to force a Link into
                               compliance mode. For Upstream Ports, if the
                               Enter Compliance bit is clear, this field is
                               permitted to have no effect. For a Multi-
                               Function device associated with an Upstream
                               Port, the field in Function 0 is of type RWS,
                               and only Function 0 controls the component's
                               Link behavior. In all other Functions of that
                               device, this field is of type RsvdP. Components
                               that support only the 2.5 GT/s speed are
                               permitted to hardwire this field to 0000b. The
                               encoding is the binary value of the bit in the
                               Supported Link Speeds Vector (in the Link
                               Capabilities 2 register) that corresponds to the
                               desired target Link speed. All other encodings
                               are reserved If a value is written to this field
                               that does not correspond to a speed included in
                               the Supported Link Speeds field, the result is
                               undefined. The default value of this field is
                               the highest Link speed supported by the
                               component (as reported in the Max Link Speed
                               field of the Link Capabilities register) unless
                               the corresponding platform/form factor requires
                               a different default value. For both Upstream and
                               Downstream Ports, this field is used to set the
                               target compliance mode speed when software is
                               using the Enter Compliance bit to force a Link
                               into compliance mode.
                            */
    UINT16 ec : 1;

                            /* Bits[4:4], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Software is permitted to force a link to enter
                               compliance mode at the speed indicated in the
                               Target Link Speed field by setting this bit to
                               1b in both components on a link and then
                               initiating a hot reset on the link.
                            */
    UINT16 hasd : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, this bit disables hardware from
                               changing the link speed for device specific
                               reasons other than attempting to correct
                               unreliable link operation by reducing link speed
                               for device-specific reasons other than
                               attempting to correct unreliable link operations
                               by reducing link speed. Initial transition to
                               the highest supported common link speed is not
                               blocked by this bit.
                            */
    UINT16 sd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               Applicable to RootPorts and downstream ports of
                               PCI Express to PCIe bridges. When the link is
                               operating at 5 Gb/s speed, this bit selects the
                               level of de-emphasis for an Downstream Port.
                               Encodings: 1b -3.5 dB 0b -6 dB When the Link is
                               operating at 2.5 GT/s speed, the setting of this
                               bit has no effect. The value of this field will
                               be reflected by CAPSR.LINKCTL2_SD.
                            */
    UINT16 tm : 3;

                            /* Bits[9:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field controls the value of the non-de-
                               emphasized voltage level at the transmitter
                               pins. This field is reset to 000b on entry to
                               the LTSSM Polling.Configuration substate. 000b:
                               Normal operating range 001b: 800-1200mV for full
                               swing and 400-700mV for half-swing 010b-110b:
                               reserved Others: Reserved This register is
                               intended for debug, compliance testing purposes
                               only. System firmware and software is allowed to
                               modify this register only during debug or
                               compliance testing. In all other cases, the
                               system must ensure that this register is set to
                               the default value.
                            */
    UINT16 emc : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set to 1b, the device transmits Modified
                               Compliance Pattern if the LTSSM enters
                               Polling.Compliance substate. This register is
                               intended for debug, compliance testing purposes
                               only. System firmware and software is allowed to
                               modify this register only during debug or
                               compliance testing. In all other cases, the
                               system must ensure that this register is set to
                               the default value.
                            */
    UINT16 csos : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set to 1b, the LTSSM is required to send
                               Skip Ordered Sets periodically in between the
                               (modified) compliance patterns.
                            */
    UINT16 cd : 4;

                            /* Bits[15:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               For 8.0 GT/s and higher Data Rate: This field
                               sets the Transmitter Preset in
                               Polling.Compliance state if the entry occurred
                               due to the Enter Compliance bit being 1b. The
                               encodings are defined in Section 4.2.3.2.
                               Results are undefined if a reserved preset
                               encoding is used when entering
                               Polling.Compliance in this way. For 5.0 GT/s
                               Data Rate: This field sets the de-emphasis level
                               in Polling.Compliance state if the entry
                               occurred due to the Enter Compliance bit being
                               1b. Defined Encodings are: 0001b -3.5 dB 0000b
                               -6 dB When the Link is operating at 2.5 GT/s,
                               the setting of this field has no effect.
                               Components that support only 2.5 GT/s speed are
                               permitted to hardwire this field to 0000b. For a
                               Multi-Function device associated with an
                               Upstream Port, the field in Function 0 is of
                               type RWS, and only Function 0 controls the
                               component's Link behavior. In all other
                               Functions of that device, this field is of type
                               RsvdP. The default value of this field is 0000b.
                               This field is intended for debug and compliance
                               testing purposes. System firmware and software
                               is allowed to modify this field only during
                               debug or compliance testing. In all other cases,
                               the system must ensure that this field is set to
                               the default value. With the M-PCIe PHY, this
                               feature is unused and this field is hardwired to
                               0000b.
                            */

  } Bits;
  UINT16 Data;

} LINKCTL2_IIO_PCIEDMI_STRUCT;

/* LINKSTS2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x10000072)                                                      */
/*      SPRB0 (0x10000072)                                                      */
/*      SPRHBM (0x10000072)                                                     */
/*      SPRC0 (0x10000072)                                                      */
/*      SPRMCC (0x10000072)                                                     */
/*      SPRUCC (0x10000072)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Status 2
*/


#define LINKSTS2_IIO_PCIEDMI_REG 0x0D010072

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cdl : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               When the link is operating at 5 Gb/s speed, this
                               bit reflects the level of de-emphasis. 1b: -3.5
                               dB 0b: -6dB The value in this bit is undefined
                               when the Link is not operating at 5.0 GT/s
                               speed. Components that support only the 2.5 GT/s
                               speed are permitted to hardwire this bit to 0b.
                            */
    UINT16 eqcmplt : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that the
                               Transmitter Equalization procedure at the 8.0
                               GT/s data rate has completed. Details of the
                               Transmitter Equalization process and when this
                               bit needs to be set to 1b is provided in PCIe
                               Spec. Section 4.2.6.4.2. The default value of
                               this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph1succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph2succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph3succ : 1;

                            /* Bits[4:4], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 lnkeqreq : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 8.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 rpd : 1;

                            /* Bits[6:6], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that a
                               Retimer was present during the most recent Link
                               negotiation. The default value of this bit is
                               0b. This bit is required for Ports that have the
                               Retimer Presence Detect Supported bit of the
                               Link Capabilities 2 register set to 1b. Ports
                               that have the Retimer Presence Detect Supported
                               bit set to 0b are permitted to hardwire this bit
                               to 0b.
                            */
    UINT16 rpd2 : 1;

                            /* Bits[7:7], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that two
                               Retimers were present during the most recent
                               Link negotiation. The default value of this bit
                               is 0b. This bit is required for Ports that have
                               the Two Retimers Presence Detect Supported bit
                               of the Link Capabilities 2 register set to 1b.
                               Ports that have the Two Retimers Presence Detect
                               Supported bit set to 0b are permitted to
                               hardwire this bit to 0b.
                            */
    UINT16 clres : 2;

                            /* Bits[9:8], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the state of the Crosslink
                               negotiation. It must be implemented if Crosslink
                               Supported is Set and the Port supports 16.0 GT/s
                               or higher data rate. It is permitted to be
                               implemented in all other Ports. If Crosslink
                               Supported is Clear, this field may be hardwired
                               to 01b or 10b. Encoding is: 00b Crosslink
                               Resolution is not supported. No information is
                               provided regarding the status of the Crosslink
                               negotiation. 01b Crosslink negotiation resolved
                               as an Upstream Port. 10b Crosslink negotiation
                               resolved as a Downstream Port. 11b Crosslink
                               negotiation is not completed. Once a value of
                               01b or 10b is returned in this field, that value
                               must continue to be returned while the Link is
                               Up.
                            */
    UINT16 rsvd : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 dcp : 3;

                            /* Bits[14:12], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field indicates the presence and DRS status
                               for the Downstream Component, if any, connected
                               to the Link, defined values are: 000b Link Down
                               - Presence Not Determined 001b Link Down -
                               Component Not Present indicates the Downstream
                               Port (DP) has determined that a Downstream
                               Component is not present 010b Link Down -
                               Component Present indicates the DP has
                               determined that a Downstream Component is
                               present, but the Data Link Layer is not active
                               011b Reserved 100b Link Up - Component Present
                               indicates the DP has determined that a
                               Downstream Component is present, but no DRS
                               Message has been received since the Data Link
                               Layer became active 101b Link Up - Component
                               Present and DRS Received indicates the DP has
                               received a DRS Message since the Data Link Layer
                               became active 110b Reserved 111b Reserved
                               Component Presence state must be determined by
                               the logical 'OR' of the Physical Layer in-band
                               presence detect mechanism and, if present, any
                               out-of-band presence detect mechanism
                               implemented for the Link. If no out-of-band
                               presence detect mechanism is implemented, then
                               Component Presence state must be determined
                               solely by the Physical Layer in-band presence
                               detect mechanism. This field must be implemented
                               in any Downstream Port where the DRS Supported
                               bit is Set in the Link Capabilities 2 register.
                               This field is RsvdZ for all other Functions.
                               Default value of this field is 000b
                            */
    UINT16 drsmr : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit must be Set whenever the Port receives
                               a DRS Message. This bit must be Cleared in
                               DL_Down. This bit must be implemented in any
                               Downstream Port where the DRS Supported bit is
                               Set in the Link Capabilities 2 register. This
                               bit is RsvdZ for all other Functions. Default
                               value of this bit is 0b.
                            */

  } Bits;
  UINT16 Data;

} LINKSTS2_IIO_PCIEDMI_STRUCT;

/* MSICAPLST_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000080)                                                      */
/*      SPRB0 (0x10000080)                                                      */
/*      SPRHBM (0x10000080)                                                     */
/*      SPRC0 (0x10000080)                                                      */
/*      SPRMCC (0x10000080)                                                     */
/*      SPRUCC (0x10000080)                                                     */
/* Register default value on SPRA0: 0x00000005                                  */
/* Register default value on SPRB0: 0x00000005                                  */
/* Register default value on SPRHBM: 0x00000005                                 */
/* Register default value on SPRC0: 0x00000005                                  */
/* Register default value on SPRMCC: 0x00000005                                 */
/* Register default value on SPRUCC: 0x00000005                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* MSI Capability List
*/


#define MSICAPLST_IIO_PCIEDMI_REG 0x0D010080

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000005*/

                            /* Identifies the function as MSI capable. */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list (MSIXCAPLST). A null value is
                               used to indicate that this is the last
                               capability. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . The Next
                               Pointer is terminated for DP, vRP/vSP, RP and
                               DMI EP in RC.
                            */

  } Bits;
  UINT16 Data;

} MSICAPLST_IIO_PCIEDMI_STRUCT;

/* MSICTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000082)                                                      */
/*      SPRB0 (0x10000082)                                                      */
/*      SPRHBM (0x10000082)                                                     */
/*      SPRC0 (0x10000082)                                                      */
/*      SPRMCC (0x10000082)                                                     */
/*      SPRUCC (0x10000082)                                                     */
/* Register default value on SPRA0: 0x00000100                                  */
/* Register default value on SPRB0: 0x00000100                                  */
/* Register default value on SPRHBM: 0x00000100                                 */
/* Register default value on SPRC0: 0x00000100                                  */
/* Register default value on SPRMCC: 0x00000100                                 */
/* Register default value on SPRUCC: 0x00000100                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Control
*/


#define MSICTL_IIO_PCIEDMI_REG 0x0D010082

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 msie : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set, MSI is enabled and traditional
                               interrupt pins are not used to generate
                               interrupts.
                            */
    UINT16 mmc : 3;

                            /* Bits[3:1], Access Type=RO, default=0x00000000*/

                            /* Only one message is supported. */
    UINT16 mmen : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               Only one message is supported. These bits are
                               R/W for software compatibility.
                            */
    UINT16 ad64c : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit indicates that the function
                               is capable of generating a 64-bit message
                               address.
                            */
    UINT16 pvm : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000001*/

                            /*
                               This bit indicates that PCI Express ports
                               support MSI per-vector masking. The value of
                               this field will be reflected by
                               CAPSR.MSICTL_PVM.
                            */
    UINT16 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} MSICTL_IIO_PCIEDMI_STRUCT;

/* MSIADDR_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000084)                                                      */
/*      SPRB0 (0x20000084)                                                      */
/*      SPRHBM (0x20000084)                                                     */
/*      SPRC0 (0x20000084)                                                      */
/*      SPRMCC (0x20000084)                                                     */
/*      SPRUCC (0x20000084)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Address
*/


#define MSIADDR_IIO_PCIEDMI_REG 0x0D020084

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address : 30;

                            /* Bits[31:2], Access Type=RW, default=0x00000000*/

                            /*
                               Message address specified by the system, always
                               DWORD aligned
                            */

  } Bits;
  UINT32 Data;

} MSIADDR_IIO_PCIEDMI_STRUCT;

/* MSIDATA_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000088)                                                      */
/*      SPRB0 (0x20000088)                                                      */
/*      SPRHBM (0x20000088)                                                     */
/*      SPRC0 (0x20000088)                                                      */
/*      SPRMCC (0x20000088)                                                     */
/*      SPRUCC (0x20000088)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Data
*/


#define MSIDATA_IIO_PCIEDMI_REG 0x0D020088

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 iv : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               The interrupt vector will be modified by the EIP
                               PCIe Gen3 to provide context sensitive interrupt
                               information for different events that require
                               attention from the processor. e.g Hot plug,
                               Power Management and RAS error events. Since
                               only one MSI message is supported, there is no
                               modification as shown in Table 1-26 on page 322.
                               However if more than one message is supported in
                               the future, the IV can be modified on the LSB.
                            */
    UINT32 dm : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               0000: Fixed: Trigger Mode can be edge or level.
                               0001: Lowest Priority: Trigger Mode can be edge
                               or level. 0010: SMI/PMI/MCA - Not supported via
                               MSI of root port 0011: Reserved - Not supported
                               via MSI of root port 0100: NMI - Not supported
                               via MSI of root port 0101: INIT - Not supported
                               via MSI of root port 0110: Reserved 0111: ExtINT
                               - Not supported via MSI of primary port 1000
                               -1111 - Reserved
                            */
    UINT32 future : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are don't care for an IOxAPIC
                               interrupt message data field specification.
                            */
    UINT32 lvl : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               if TM is 0h, then this field is a don't care.
                               Edge triggered messages are always treated as
                               assert messages. For level triggered interrupts,
                               this bit reflects the state of the interrupt
                               input if TM is 1h, then 0: Deassert Messages 1:
                               Assert Messages
                            */
    UINT32 tm : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* 0: Edge Triggered 1: Level Triggered */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIDATA_IIO_PCIEDMI_STRUCT;

/* MSIMSK_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x2000008c)                                                      */
/*      SPRB0 (0x2000008c)                                                      */
/*      SPRHBM (0x2000008c)                                                     */
/*      SPRC0 (0x2000008c)                                                      */
/*      SPRMCC (0x2000008c)                                                     */
/*      SPRUCC (0x2000008c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The MSI Mask Bit register enables software to disable message sending on a per-vector basis.
*/


#define MSIMSK_IIO_PCIEDMI_REG 0x0D02008C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mskb : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               For each Mask bit that is set, the PCI Express
                               port is prohibited from sending the associated
                               message. Corresponding bits are masked if set to
                               '1'
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIMSK_IIO_PCIEDMI_STRUCT;

/* MSIPENDING_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000090)                                                      */
/*      SPRB0 (0x20000090)                                                      */
/*      SPRHBM (0x20000090)                                                     */
/*      SPRC0 (0x20000090)                                                      */
/*      SPRMCC (0x20000090)                                                     */
/*      SPRUCC (0x20000090)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Mask Pending register enables software to defer message sending on a per-vector basis.
*/


#define MSIPENDING_IIO_PCIEDMI_REG 0x0D020090

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pb : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For each Pending bit that is set, the PCI
                               Express port has a pending associated message.
                               Corresponding bits are pending if set to '1'
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIPENDING_IIO_PCIEDMI_STRUCT;

/* SSCAPLST_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x10000094)                                                      */
/*      SPRB0 (0x10000094)                                                      */
/*      SPRHBM (0x10000094)                                                     */
/*      SPRC0 (0x10000094)                                                      */
/*      SPRMCC (0x10000094)                                                     */
/*      SPRUCC (0x10000094)                                                     */
/* Register default value on SPRA0: 0x0000800D                                  */
/* Register default value on SPRB0: 0x0000800D                                  */
/* Register default value on SPRHBM: 0x0000800D                                 */
/* Register default value on SPRC0: 0x0000800D                                  */
/* Register default value on SPRMCC: 0x0000800D                                 */
/* Register default value on SPRUCC: 0x0000800D                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Subsystem Capability List
*/


#define SSCAPLST_IIO_PCIEDMI_REG 0x0D010094

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x0000000D*/

                            /*
                               Identifies the function as Subsystem
                               Identification capable.
                            */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000080*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list. (MSICAPLST)
                            */

  } Bits;
  UINT16 Data;

} SSCAPLST_IIO_PCIEDMI_STRUCT;

/* PMCAPLST_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x100000a0)                                                      */
/*      SPRB0 (0x100000a0)                                                      */
/*      SPRHBM (0x100000a0)                                                     */
/*      SPRC0 (0x100000a0)                                                      */
/*      SPRMCC (0x100000a0)                                                     */
/*      SPRUCC (0x100000a0)                                                     */
/* Register default value on SPRA0: 0x00009401                                  */
/* Register default value on SPRB0: 0x00009401                                  */
/* Register default value on SPRHBM: 0x00009401                                 */
/* Register default value on SPRC0: 0x00009401                                  */
/* Register default value on SPRMCC: 0x00009401                                 */
/* Register default value on SPRUCC: 0x00009401                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Power Management Capability List
*/


#define PMCAPLST_IIO_PCIEDMI_REG 0x0D0100A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capabilityid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000001*/

                            /*
                               Identifies the function as PCI Power Management
                               capable.
                            */
    UINT16 nextpointer : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000094*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list.
                            */

  } Bits;
  UINT16 Data;

} PMCAPLST_IIO_PCIEDMI_STRUCT;

/* PMCAP_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x100000a2)                                                      */
/*      SPRB0 (0x100000a2)                                                      */
/*      SPRHBM (0x100000a2)                                                     */
/*      SPRC0 (0x100000a2)                                                      */
/*      SPRMCC (0x100000a2)                                                     */
/*      SPRUCC (0x100000a2)                                                     */
/* Register default value on SPRA0: 0x0000C803                                  */
/* Register default value on SPRB0: 0x0000C803                                  */
/* Register default value on SPRHBM: 0x0000C803                                 */
/* Register default value on SPRC0: 0x0000C803                                  */
/* Register default value on SPRMCC: 0x0000C803                                 */
/* Register default value on SPRUCC: 0x0000C803                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Power Management Capabilities
*/


#define PMCAP_IIO_PCIEDMI_REG 0x0D0100A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ver : 3;

                            /* Bits[2:0], Access Type=RO, default=0x00000003*/

                            /*
                               The PM implementation in the PCIe cluster is
                               compliant with PCI Bus Power Management
                               Interface Specification, Revision 1.2.
                            */
    UINT16 pmeclk : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Does not apply to PCI Express. Hard-wired to 0. */
    UINT16 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 dsi : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Device-specific initialization is not required
                               when transitioning to D0 from D3hot state. This
                               bit is zero.
                            */
    UINT16 ac : 3;

                            /* Bits[8:6], Access Type=RO, default=0x00000000*/

                            /* Auxiliary power is not supported. */
    UINT16 d1s : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 d2s : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 pmes : 5;

                            /* Bits[15:11], Access Type=RO, default=0x00000019*/

                            /*
                               PME assertion is supported when in D3hot/D3cold.
                               Identifies power states in which the PCIe can
                               send an 'Assert_PMEGPE/ Deassert PMEGPE'
                               message. Bits 15, 14 and 11 must be set to '1'
                               for PCIPCI bridge structures representing ports
                               on root complexes. The definition of these bits
                               is taken from the PCI Bus Power Management
                               Interface Specification Revision 1.1. XXXX1b -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D0 XXX1Xb - Assert_PMEGPE/Deassert PMEGPE can be
                               sent from D1 (Not supported by PCI-E) XX1XXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D2 (Not supported by PCI-E) X1XXXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D3 hot (Supported by PCI-E) 1XXXXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D3 cold (Supported by PCI-E) In the EIP PCIe
                               implementation, there is no PME support for D3
                               cold as the part does not have the capability.
                               For PCIe compliance purposes, bit 15 is set to
                               1.
                            */

  } Bits;
  UINT16 Data;

} PMCAP_IIO_PCIEDMI_STRUCT;

/* PMCSR_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x100000a4)                                                      */
/*      SPRB0 (0x100000a4)                                                      */
/*      SPRHBM (0x100000a4)                                                     */
/*      SPRC0 (0x100000a4)                                                      */
/*      SPRMCC (0x100000a4)                                                     */
/*      SPRUCC (0x100000a4)                                                     */
/* Register default value on SPRA0: 0x00000008                                  */
/* Register default value on SPRB0: 0x00000008                                  */
/* Register default value on SPRHBM: 0x00000008                                 */
/* Register default value on SPRC0: 0x00000008                                  */
/* Register default value on SPRMCC: 0x00000008                                 */
/* Register default value on SPRUCC: 0x00000008                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Power Management Control Status
*/


#define PMCSR_IIO_PCIEDMI_REG 0x0D0100A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ps : 2;

                            /* Bits[1:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used both to determine the current
                               power state of a function and to set the
                               function into a new power state. The definition
                               of the supported values is given below: 0h - D0
                               3h - D3hot If software attempts to write an
                               unsupported, optional state to this field, the
                               write operation must complete normally, however,
                               the data is discarded and no state change
                               occurs.
                            */
    UINT16 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 nsr : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000001*/

                            /*
                               This bit indicates the state of the Function
                               afer writing the PowerState field to transition
                               the Function from D3Hot to D0. When Set, this
                               transition preserves internal Function state.
                               The Function is in D0Active and no additional
                               sofware intervention is required. When Clear,
                               this transition results in undefined internal
                               Function state. Regardless of this bit,
                               Functions that transition from D3Hot to D0 by
                               Fundamental Reset will return to D0uninitialized
                               with only PME context preserved if PME is
                               supported and enabled. The value of this field
                               will be reflected by CAPSR.PMCSR_NSR.
                            */
    UINT16 rsvd_4 : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 pmeen : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, the Function is permitted to generate
                               a PME. When Clear, the Function is not permitted
                               to generate a PME.
                            */
    UINT16 ds : 4;

                            /* Bits[12:9], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 dc : 2;

                            /* Bits[14:13], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 pmests : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set when the Function would normally
                               generate a PME signal. The value of this bit is
                               not affected by the value of the PME_En bit.
                            */

  } Bits;
  UINT16 Data;

} PMCSR_IIO_PCIEDMI_STRUCT;


/* CRSRT_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x100000be)                                                      */
/*      SPRB0 (0x100000be)                                                      */
/*      SPRHBM (0x100000be)                                                     */
/*      SPRC0 (0x100000be)                                                      */
/*      SPRMCC (0x100000be)                                                     */
/*      SPRUCC (0x100000be)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* CRS Retry Timeout
*/


#define CRSRT_IIO_PCIEDMI_REG 0x0D0100BE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 crsrtv : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000010*/

                            /*
                               When handling a Completion with Configuration
                               Retry Status, the rules as specified in Section
                               2.3.2 of the PCIe Spec apply for both the case
                               when CRS Software Visibility is enabled and when
                               it is not enabled. The IP should re-issue the
                               request till a programmable H/W timer expires
                               and then complete the request as UR without any
                               error logging. The programmable H/W timer will
                               be timeout after the requested values - 'Timeout
                               after' with min/max. as specified. The
                               implementation specific range is shown in
                               brackets 00h: disabled 01h: 64ms (67.1ms -
                               100.7ms based on core clk period) 02h: 256ms
                               (268.4ms - 402.7ms based on core clk period)
                               08h: 512ms (536.9ms - 805.3ms based on core clk
                               period) 10h: 1s (1.1s - 1.6s based on core clk
                               period) 20h: 2s (2.1s - 3.2s based on core clk
                               period) 40h: 4s (4.3s - 6.4s based on core clk
                               period) 80h: 8s (8.6s - 12.9s based on core clk
                               period) All others are reserved.
                            */
    UINT16 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} CRSRT_IIO_PCIEDMI_STRUCT;





/* PPD0_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x200000d4)                                                      */
/*      SPRB0 (0x200000d4)                                                      */
/*      SPRHBM (0x200000d4)                                                     */
/*      SPRC0 (0x200000d4)                                                      */
/*      SPRMCC (0x200000d4)                                                     */
/*      SPRUCC (0x200000d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCIe Port Definition Control Register 0
*/


#define PPD0_IIO_PCIEDMI_REG 0x0D0200D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 clrtrnenonlnkdn : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               when set to 1, a link down event will cause the
                               link train enable field (ILINKTRN0) of this
                               register to be cleared and block subsequent
                               training until that train enable is set again.
                               If 0, a link down will not clear the train
                               enable unless a link down causes a reset.
                            */
    UINT32 rsvd : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ilinktrn0 : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit controls PCI Express port link training
                               for the associated port. A value of '1'
                               initiates link training on the corresponding
                               port. After writing this bit to a '1', software
                               can poll the Data Link Layer link active bit in
                               the LINKSTS register to determine if a port is
                               up and running. This bit clears on warm reset,
                               i.e. the associated port will not automatically
                               initiate link training after warm reset.
                               Hardware-aware of software should set
                               PPD0.ClrTrnEnOnLnkDn to '1' on DL_Down events if
                               desirable, such as in NTB mode. 0: The
                               associated PCI Express port has not initiated
                               link training. 1: The associated PCI Express
                               port is initiating link training or has trained.
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PPD0_IIO_PCIEDMI_STRUCT;


/* AERCAPHDR_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000100)                                                      */
/*      SPRB0 (0x20000100)                                                      */
/*      SPRHBM (0x20000100)                                                     */
/*      SPRC0 (0x20000100)                                                      */
/*      SPRMCC (0x20000100)                                                     */
/*      SPRUCC (0x20000100)                                                     */
/* Register default value on SPRA0: 0x00010001                                  */
/* Register default value on SPRB0: 0x00010001                                  */
/* Register default value on SPRHBM: 0x00010001                                 */
/* Register default value on SPRC0: 0x00010001                                  */
/* Register default value on SPRMCC: 0x00010001                                 */
/* Register default value on SPRUCC: 0x00010001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Advanced Error Reporting Extended Capability Header
*/


#define AERCAPHDR_IIO_PCIEDMI_REG 0x0D020100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 excapid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000001*/

                            /*
                               Identifies the function as Advanced Error
                               Reporting capable.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. This field must be 2h if the
                               End-End TLP Prefix Supported bit of Device
                               Capabilities 2 Register is Set and must be 1h or
                               2h otherwise.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities list. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} AERCAPHDR_IIO_PCIEDMI_STRUCT;

/* ERRUNCSTS_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000104)                                                      */
/*      SPRB0 (0x20000104)                                                      */
/*      SPRHBM (0x20000104)                                                     */
/*      SPRC0 (0x20000104)                                                      */
/*      SPRMCC (0x20000104)                                                     */
/*      SPRUCC (0x20000104)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register reports the error status of individual uncorrectable error sources. An individual error status bit that is set to 1 indicates that a particular error occurred. Software can clear an error status by writing a 1 to the respective bit.
*/


#define ERRUNCSTS_IIO_PCIEDMI_REG 0x0D020104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpe : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a data link protocol error
                               is detected.
                            */
    UINT32 slde : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a surprise down error is
                               detected. This bit does not apply to the
                               upstream port.
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpe : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set and the bridge logs the header
                               when a poisoned TLP is received from PCI
                               Express.
                            */
    UINT32 fce : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a flow control protocol
                               error is detected.
                            */
    UINT32 cte : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               For Switch Ports, this bit is set if the Switch
                               Port issues Non-Posted Requests on its own
                               behalf (vs. only forwarding such as Requests
                               generated by other devices).
                            */
    UINT32 cae : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The bridge sets this bit and logs the header
                               associated with the request when the
                               configuration unit signals a completer abort.
                            */
    UINT32 uce : 1;

                            /* Bits[16:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever a completion is
                               received with a requestor ID that does not match
                               side A or side B, or when a completion is
                               received with a matching requestor ID but an
                               unexpected tag field. Header logging is
                               performed.
                            */
    UINT32 roe : 1;

                            /* Bits[17:17], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when the PCI Express interface
                               unit receive buffers overflow.
                            */
    UINT32 mtlpe : 1;

                            /* Bits[18:18], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when it receives a malformed
                               TLP. Header logging is performed.
                            */
    UINT32 ecrce : 1;

                            /* Bits[19:19], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* ECRC checking is optional for project specific. */
    UINT32 ure : 1;

                            /* Bits[20:20], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an unsupported request
                               is detected on PCI Express port
                            */
    UINT32 acse : 1;

                            /* Bits[21:21], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an ACS violation is
                               detected by the PCI Express port.
                            */
    UINT32 uie : 1;

                            /* Bits[22:22], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an uncorrectable
                               internal error is detected.
                            */
    UINT32 mce : 1;

                            /* Bits[23:23], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever a Multicast TLP is
                               blocked.
                            */
    UINT32 aebe : 1;

                            /* Bits[24:24], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an Atomic OP TLP is
                               blocked on any egress port
                            */
    UINT32 tpbe : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /* TLP Prefix Blocked Error Status */
    UINT32 ptlpeb : 1;

                            /* Bits[26:26], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Poisoned TLP Egress Blocked Status */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCSTS_IIO_PCIEDMI_STRUCT;

/* ERRUNCMSK_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000108)                                                      */
/*      SPRB0 (0x20000108)                                                      */
/*      SPRHBM (0x20000108)                                                     */
/*      SPRC0 (0x20000108)                                                      */
/*      SPRMCC (0x20000108)                                                     */
/*      SPRUCC (0x20000108)                                                     */
/* Register default value on SPRA0: 0x04400000                                  */
/* Register default value on SPRB0: 0x04400000                                  */
/* Register default value on SPRHBM: 0x04400000                                 */
/* Register default value on SPRC0: 0x04400000                                  */
/* Register default value on SPRMCC: 0x04400000                                 */
/* Register default value on SPRUCC: 0x04400000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the reporting of individual uncorrectable errors by device to the host bridge via a PCI Express error message. This register also controls the logging of the header. Refer to the PCI Express specifications for details of how the mask bits function. A masked error (respective bit set in the mask register) is not reported to the host bridge by the switch, nor is the header logged (status bits unaffected by the mask bit). There is a mask bit per bit of the Uncorrectable Error Status Register.
The attr. of AER Error Mask bits in VRSP will be changed to be compliant with PCIe Spec.
*/


#define ERRUNCMSK_IIO_PCIEDMI_REG 0x0D020108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpem : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /* Data Link Protocol Error Mask */
    UINT32 sldem : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               This bit does not apply to the upstream port or
                               End point
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Received Mask */
    UINT32 fcem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Flow Control Protocol Error Mask */
    UINT32 ctem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /* Completion Timeout Mask */
    UINT32 caem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Completer Abort Mask */
    UINT32 ucem : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Unexpected Completion Mask */
    UINT32 roem : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Receiver Overflow Mask */
    UINT32 mtlpem : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Malformed TLP Mask */
    UINT32 ecrcem : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* ECRC Error Mask */
    UINT32 urem : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /* Unsupported Request Error Mask */
    UINT32 acsem : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* ACS Violation Mask */
    UINT32 uiem : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000001*/

                            /* Uncorrectable Internal Error Mask */
    UINT32 mcem : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /* MC Blocked TLP Mask */
    UINT32 aebem : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* AtomicOp Egress Blocked Mask */
    UINT32 tpbem : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /* TLP Prefix Blocked Error Mask */
    UINT32 ptlpebm : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000001*/

                            /* Poisoned TLP Egress Blocked Mask */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCMSK_IIO_PCIEDMI_STRUCT;

/* ERRUNCSEV_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x2000010c)                                                      */
/*      SPRB0 (0x2000010c)                                                      */
/*      SPRHBM (0x2000010c)                                                     */
/*      SPRC0 (0x2000010c)                                                      */
/*      SPRMCC (0x2000010c)                                                     */
/*      SPRUCC (0x2000010c)                                                     */
/* Register default value on SPRA0: 0x00462030                                  */
/* Register default value on SPRB0: 0x00462030                                  */
/* Register default value on SPRHBM: 0x00462030                                 */
/* Register default value on SPRC0: 0x00462030                                  */
/* Register default value on SPRMCC: 0x00462030                                 */
/* Register default value on SPRUCC: 0x00462030                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls whether an individual uncorrectable error is reported as a fatal error. An uncorrectable error is reported as fatal when the corresponding error bit in this register is set. When the bit is cleared, the corresponding error is considered non-fatal. 
The attr. of AER Error Severity bits in VRSP will be changed to be compliant with PCIe Spec.
*/


#define ERRUNCSEV_IIO_PCIEDMI_REG 0x0D02010C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpes : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000001*/

                            /* Data Link Protocol Error Severity */
    UINT32 sldes : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000001*/

                            /*
                               This bit does not apply to the upstream port or
                               end point
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpes : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Received Severity */
    UINT32 fces : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Flow Control Protocol Error Severity */
    UINT32 ctes : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /* Completion Timeout Error Severity */
    UINT32 caes : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Completer Abort Error Severity */
    UINT32 uces : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Unexpected Completion Error Severity */
    UINT32 roes : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000001*/

                            /* Receiver Overflow Error Severity */
    UINT32 mtlpes : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /* Malformed TLP Severity */
    UINT32 ecrces : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* ECRC Error Severity */
    UINT32 ures : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /* Unsupported Request Error Severity */
    UINT32 acses : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* ACS Violation Severity */
    UINT32 uies : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000001*/

                            /* Uncorrectable Internal Error Severity */
    UINT32 mces : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /* MC Blocked TLP Severity */
    UINT32 aebes : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* AtomicOp Egress Blocked Severity */
    UINT32 tpbes : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /* TLP Prefix Blocked Error Severity */
    UINT32 ptlpebs : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Egress Blocked Severity */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCSEV_IIO_PCIEDMI_STRUCT;

/* ERRCORSTS_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000110)                                                      */
/*      SPRB0 (0x20000110)                                                      */
/*      SPRHBM (0x20000110)                                                     */
/*      SPRC0 (0x20000110)                                                      */
/*      SPRMCC (0x20000110)                                                     */
/*      SPRUCC (0x20000110)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register reports the error status of individual correctable error sources on a PCI Express device. An individual error status bit set to 1 indicates that a particular error has occurred. Software can clear the error status by writing a 1 to the respective bit.
*/


#define ERRCORSTS_IIO_PCIEDMI_REG 0x0D020110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 re : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when the physical layer
                               detects a receiver error.
                            */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpe : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* The switch sets this bit on CRC errors on TLP. */
    UINT32 bdllpe : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* The switch sets this bit on CRC errors on DLLP. */
    UINT32 rnre : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when the replay number
                               rolls over from 11 to 00.
                            */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rtte : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when replay timer time-
                               out occurs.
                            */
    UINT32 anfe : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Advisory Non-Fatal Error */
    UINT32 cie : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Correctable Internal Error */
    UINT32 hloe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Header Log Overflow Error */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRCORSTS_IIO_PCIEDMI_STRUCT;

/* ERRCORMSK_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000114)                                                      */
/*      SPRB0 (0x20000114)                                                      */
/*      SPRHBM (0x20000114)                                                     */
/*      SPRC0 (0x20000114)                                                      */
/*      SPRMCC (0x20000114)                                                     */
/*      SPRUCC (0x20000114)                                                     */
/* Register default value on SPRA0: 0x0000E000                                  */
/* Register default value on SPRB0: 0x0000E000                                  */
/* Register default value on SPRHBM: 0x0000E000                                 */
/* Register default value on SPRC0: 0x0000E000                                  */
/* Register default value on SPRMCC: 0x0000E000                                 */
/* Register default value on SPRUCC: 0x0000E000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the reporting of individual correctable errors via ERR_COR message. A masked error (respective bit set in mask register) is not reported to the host bridge by the switch. There is a mask bit corresponding to every bit in the Correctable Error Status Register.
*/


#define ERRCORMSK_IIO_PCIEDMI_REG 0x0D020114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rem : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Receiver Error Mask */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpem : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /* Bad TLP Error Mask */
    UINT32 bdllpem : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Bad DLLP Error Mask */
    UINT32 rnrem : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* Replay Number Rollover Error Mask */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rttem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Replay Timer Timeout Error Mask */
    UINT32 anfem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Advisory Non-Fatal Error Mask */
    UINT32 ciem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /* Correctable Internal Error Mask */
    UINT32 hloem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Header Log Overflow Error Mask */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRCORMSK_IIO_PCIEDMI_STRUCT;

/* AERCAPCTL_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000118)                                                      */
/*      SPRB0 (0x20000118)                                                      */
/*      SPRHBM (0x20000118)                                                     */
/*      SPRC0 (0x20000118)                                                      */
/*      SPRMCC (0x20000118)                                                     */
/*      SPRUCC (0x20000118)                                                     */
/* Register default value on SPRA0: 0x00001000                                  */
/* Register default value on SPRB0: 0x00001000                                  */
/* Register default value on SPRHBM: 0x00001000                                 */
/* Register default value on SPRC0: 0x00001000                                  */
/* Register default value on SPRMCC: 0x00001000                                 */
/* Register default value on SPRUCC: 0x00001000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register gives the status and control for ECRC checks and also the pointer to the first uncorrectable error that happened.
*/


#define AERCAPCTL_IIO_PCIEDMI_REG 0x0D020118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fep : 5;

                            /* Bits[4:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field identifies the bit position of the
                               first error reported in the Uncorrectable Error
                               Status Register (xref). This register re-arms
                               itself (which does not change its current value)
                               as soon as the error status bit indicated by the
                               pointer is cleared by the software by writing a
                               1 to that status bit.
                            */
    UINT32 egc : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, this bit indicates that the Function is
                               capable of generating ECRC. The value of this
                               field will be reflected by CAPSR.AERCAPCTL_EGC.
                            */
    UINT32 ege : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, ECRC generation is enabled. Functions
                               that do not implement the associated mechanism
                               are permitted to hardwire this bit to 0b.
                               Default value of this bit is 0b.
                            */
    UINT32 ecc : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, this bit indicates that the Function is
                               capable of checking ECRC. The value of this
                               field will be reflected by CAPSR.AERCAPCTL_ECC.
                            */
    UINT32 ece : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, ECRC checking is enabled. Functions
                               that do not implement the associated mechanism
                               are permitted to hardwire this bit to 0b.
                            */
    UINT32 mhrc : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Supports more than one error header. */
    UINT32 mhre : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit enables the function to
                               record more than one error header.
                            */
    UINT32 tlpplp : 1;

                            /* Bits[11:11], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               If Set and the First Error Pointer is valid,
                               indicates that the TLP Prefix Log register
                               contains valid information. If Clear or if First
                               Error Pointer is invalid, the TLP Prefix Log
                               register is undefined.
                            */
    UINT32 ctphlc : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000001*/

                            /*
                               If Set, this bit indicates that the Function
                               records the prefix/header of Request TLPs that
                               experience a Completion Timeout error. The value
                               of this field will be reflected by
                               CAPSR.AERCAPCTL_CTPHLC
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} AERCAPCTL_IIO_PCIEDMI_STRUCT;

/* AERHDRLOG1_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x2000011c)                                                      */
/*      SPRB0 (0x2000011c)                                                      */
/*      SPRHBM (0x2000011c)                                                     */
/*      SPRC0 (0x2000011c)                                                      */
/*      SPRMCC (0x2000011c)                                                     */
/*      SPRUCC (0x2000011c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG1_IIO_PCIEDMI_REG 0x0D02011C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG1_IIO_PCIEDMI_STRUCT;

/* AERHDRLOG2_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000120)                                                      */
/*      SPRB0 (0x20000120)                                                      */
/*      SPRHBM (0x20000120)                                                     */
/*      SPRC0 (0x20000120)                                                      */
/*      SPRMCC (0x20000120)                                                     */
/*      SPRUCC (0x20000120)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG2_IIO_PCIEDMI_REG 0x0D020120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG2_IIO_PCIEDMI_STRUCT;

/* AERHDRLOG3_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000124)                                                      */
/*      SPRB0 (0x20000124)                                                      */
/*      SPRHBM (0x20000124)                                                     */
/*      SPRC0 (0x20000124)                                                      */
/*      SPRMCC (0x20000124)                                                     */
/*      SPRUCC (0x20000124)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG3_IIO_PCIEDMI_REG 0x0D020124

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG3_IIO_PCIEDMI_STRUCT;

/* AERHDRLOG4_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000128)                                                      */
/*      SPRB0 (0x20000128)                                                      */
/*      SPRHBM (0x20000128)                                                     */
/*      SPRC0 (0x20000128)                                                      */
/*      SPRMCC (0x20000128)                                                     */
/*      SPRUCC (0x20000128)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG4_IIO_PCIEDMI_REG 0x0D020128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG4_IIO_PCIEDMI_STRUCT;

/* ROOTERRCMD_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x2000012c)                                                      */
/*      SPRB0 (0x2000012c)                                                      */
/*      SPRHBM (0x2000012c)                                                     */
/*      SPRC0 (0x2000012c)                                                      */
/*      SPRMCC (0x2000012c)                                                     */
/*      SPRUCC (0x2000012c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Error Command
*/


#define ROOTERRCMD_IIO_PCIEDMI_REG 0x0D02012C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Correctable error is reported
                               by any of the functions in the hierarchy
                               associated with this Root Port.
                            */
    UINT32 nfere : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Non-Fatal error is reported by
                               any of the functions in the hierarchy associated
                               with this Root Port.
                            */
    UINT32 fere : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Fatal error is reported by any
                               of the functions in the hierarchy associated
                               with this Root Port.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ROOTERRCMD_IIO_PCIEDMI_STRUCT;

/* ROOTERRSTS_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000130)                                                      */
/*      SPRB0 (0x20000130)                                                      */
/*      SPRHBM (0x20000130)                                                     */
/*      SPRC0 (0x20000130)                                                      */
/*      SPRMCC (0x20000130)                                                     */
/*      SPRUCC (0x20000130)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Error Status
*/


#define ROOTERRSTS_IIO_PCIEDMI_REG 0x0D020130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cer : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Correctable Error Received */
    UINT32 mcer : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Multiple Error Correctable Error Received */
    UINT32 efr : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Error Fatal/Non-Fatal Received */
    UINT32 mefr : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Multiple Error Fatal/Non-Fatal Received */
    UINT32 fuf : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* First Uncorrectable Fatal */
    UINT32 nfemr : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Non-Fatal Error message Received */
    UINT32 femr : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Fatal Error Message Received */
    UINT32 rsvd : 20;

                            /* Bits[26:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 aemn : 5;

                            /* Bits[31:27], Access Type=RO/V, default=0x00000000*/

                            /*
                               This register indicates which MSI/MSI-X vector
                               is used for the interrupt message generated in
                               association with any of the status bits of this
                               Capability. For MSI, the value in this register
                               indicates the offset between the base Message
                               Data and the interrupt message that is
                               generated. Hardware is required to update this
                               field so that it is correct if the number of MSI
                               Messages assigned to the Function changes when
                               software writes to the Multiple Message Enable
                               field in the MSI Message Control register. For
                               MSI-X, the value in this register indicates
                               which MSI-X Table entry is used to generate the
                               interrupt message. The entry must be one of the
                               first 32 entries even if the Function implements
                               more than 32 entries. For a given MSI-X
                               implementation, the entry must remain constant.
                               For remaining fields info, please refer to PCIe
                               Spec. for more details.
                            */

  } Bits;
  UINT32 Data;

} ROOTERRSTS_IIO_PCIEDMI_STRUCT;

/* ERRSRCID_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000134)                                                      */
/*      SPRB0 (0x20000134)                                                      */
/*      SPRHBM (0x20000134)                                                     */
/*      SPRC0 (0x20000134)                                                      */
/*      SPRMCC (0x20000134)                                                     */
/*      SPRUCC (0x20000134)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Error Source Identification
*/


#define ERRSRCID_IIO_PCIEDMI_REG 0x0D020134

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecsid : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Loaded with the Requester ID indicated in the
                               received ERR_COR Message when the ERR_COR
                               Received bit is not already set.
                            */
    UINT32 efsid : 16;

                            /* Bits[31:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Loaded with the Requester ID indicated in the
                               received ERR_FATAL or ERR_NONFATAL Message when
                               the ERR_FATAL/NONFATAL Received bit is not
                               already set.
                            */

  } Bits;
  UINT32 Data;

} ERRSRCID_IIO_PCIEDMI_STRUCT;

/* TLPPLOG1_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000138)                                                      */
/*      SPRB0 (0x20000138)                                                      */
/*      SPRHBM (0x20000138)                                                     */
/*      SPRC0 (0x20000138)                                                      */
/*      SPRMCC (0x20000138)                                                     */
/*      SPRUCC (0x20000138)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG1_IIO_PCIEDMI_REG 0x0D020138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG1_IIO_PCIEDMI_STRUCT;

/* TLPPLOG2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x2000013c)                                                      */
/*      SPRB0 (0x2000013c)                                                      */
/*      SPRHBM (0x2000013c)                                                     */
/*      SPRC0 (0x2000013c)                                                      */
/*      SPRMCC (0x2000013c)                                                     */
/*      SPRUCC (0x2000013c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG2_IIO_PCIEDMI_REG 0x0D02013C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG2_IIO_PCIEDMI_STRUCT;

/* TLPPLOG3_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000140)                                                      */
/*      SPRB0 (0x20000140)                                                      */
/*      SPRHBM (0x20000140)                                                     */
/*      SPRC0 (0x20000140)                                                      */
/*      SPRMCC (0x20000140)                                                     */
/*      SPRUCC (0x20000140)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG3_IIO_PCIEDMI_REG 0x0D020140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG3_IIO_PCIEDMI_STRUCT;

/* TLPPLOG4_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000144)                                                      */
/*      SPRB0 (0x20000144)                                                      */
/*      SPRHBM (0x20000144)                                                     */
/*      SPRC0 (0x20000144)                                                      */
/*      SPRMCC (0x20000144)                                                     */
/*      SPRUCC (0x20000144)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG4_IIO_PCIEDMI_REG 0x0D020144

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG4_IIO_PCIEDMI_STRUCT;

/* EINJCAPHDR_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000190)                                                      */
/*      SPRB0 (0x20000190)                                                      */
/*      SPRHBM (0x20000190)                                                     */
/*      SPRC0 (0x20000190)                                                      */
/*      SPRMCC (0x20000190)                                                     */
/*      SPRUCC (0x20000190)                                                     */
/* Register default value on SPRA0: 0x0001000B                                  */
/* Register default value on SPRB0: 0x0001000B                                  */
/* Register default value on SPRHBM: 0x0001000B                                 */
/* Register default value on SPRC0: 0x0001000B                                  */
/* Register default value on SPRMCC: 0x0001000B                                 */
/* Register default value on SPRUCC: 0x0001000B                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* EINJ Extended Capability Header
*/


#define EINJCAPHDR_IIO_PCIEDMI_REG 0x0D020190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000000B*/

                            /* Vendor Defined Capability */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/V/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . H/W may skip over the linked
                               capabilities list when DISALBE_DPC fuse is set
                               to 1 if supported, or hardware-aware S/W will
                               need to program this field appropriately for
                               linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} EINJCAPHDR_IIO_PCIEDMI_STRUCT;

/* EINJHDR_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000194)                                                      */
/*      SPRB0 (0x20000194)                                                      */
/*      SPRHBM (0x20000194)                                                     */
/*      SPRC0 (0x20000194)                                                      */
/*      SPRMCC (0x20000194)                                                     */
/*      SPRUCC (0x20000194)                                                     */
/* Register default value on SPRA0: 0x00A00003                                  */
/* Register default value on SPRB0: 0x00A00003                                  */
/* Register default value on SPRHBM: 0x00A00003                                 */
/* Register default value on SPRC0: 0x00A00003                                  */
/* Register default value on SPRMCC: 0x00A00003                                 */
/* Register default value on SPRUCC: 0x00A00003                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* EINJ Header
*/


#define EINJHDR_IIO_PCIEDMI_REG 0x0D020194

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vsecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000003*/

                            /*
                               This field is a vendor-defined ID number that
                               indicates the nature and format of the VSEC
                               structure. Software must qualify the Vendor ID
                               before interpreting this field. 3h is assigned
                               to WHEA Error Injection.
                            */
    UINT32 vsecrev : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               This field is a vendor-defined version number
                               that indicates the version of the VSEC
                               structure. Software must qualify the Vendor ID
                               and VSEC ID before interpreting this field.
                            */
    UINT32 vseclen : 12;

                            /* Bits[31:20], Access Type=RO, default=0x0000000A*/

                            /*
                               This field indicates the number of bytes in the
                               entire VSEC structure, including the PCI Express
                               Extended Capability header, the Vendor-Specific
                               header, and the Vendor-Specific registers.
                            */

  } Bits;
  UINT32 Data;

} EINJHDR_IIO_PCIEDMI_STRUCT;

/* EINJCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x10000198)                                                      */
/*      SPRB0 (0x10000198)                                                      */
/*      SPRHBM (0x10000198)                                                     */
/*      SPRC0 (0x10000198)                                                      */
/*      SPRMCC (0x10000198)                                                     */
/*      SPRUCC (0x10000198)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* EINJ Control
*/


#define EINJCTL_IIO_PCIEDMI_REG 0x0D010198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 einjdis : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit disables the usage of the PCIe Error
                               Injection bits for EINJCTL.INJRCVERR, INJCTOERR
                               Note: Lock Key bit is located in the EINJCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 injrcverr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is written from 0 to 1, one and
                               only one error assertion pulse is produced on
                               the error source signal for the given port. This
                               error will appear equivalent to an actual error
                               assertion because this event is OR'd into the
                               existing error reporting structure. To log
                               another error, this bit must be cleared first,
                               before setting again. Leaving this bit in a 1
                               state does not produce a persistent error
                               condition.
                            */
    UINT16 injctoerr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is written from 0 to 1, one and
                               only one error assertion pulse is produced on
                               the error source signal for the given port. This
                               error will appear equivalent to an actual error
                               assertion because this event is OR'd into the
                               existing error reporting structure. To log
                               another error, this bit must be cleared first,
                               before setting again. Leaving this bit in a 1
                               state does not produce a persistent error
                               condition.
                            */
    UINT16 rsvd : 13;

                            /* Bits[15:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} EINJCTL_IIO_PCIEDMI_STRUCT;

/* EDPCPR_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x2000019c)                                                      */
/*      SPRB0 (0x2000019c)                                                      */
/*      SPRHBM (0x2000019c)                                                     */
/*      SPRC0 (0x2000019c)                                                      */
/*      SPRMCC (0x2000019c)                                                     */
/*      SPRUCC (0x2000019c)                                                     */
/* Register default value on SPRA0: 0x00000E00                                  */
/* Register default value on SPRB0: 0x00000E00                                  */
/* Register default value on SPRHBM: 0x00000E00                                 */
/* Register default value on SPRC0: 0x00000E00                                  */
/* Register default value on SPRMCC: 0x00000E00                                 */
/* Register default value on SPRUCC: 0x00000E00                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* eDPC Policy
*/


#define EDPCPR_IIO_PCIEDMI_REG 0x0D02019C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 serr_cor : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with correctable severity.
                            */
    UINT32 serr_fnat : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with non-fatal severity.
                            */
    UINT32 serr_fat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with fatal severity.
                            */
    UINT32 rsvd : 6;

                            /* Bits[8:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cplsts : 3;

                            /* Bits[11:9], Access Type=RW/P/L, default=0x00000007*/

                            /*
                               This is the completion status field used to
                               signal a synchronous processor exception. If
                               this field is non-zero, this field is used
                               instead of the UR/CA determined by the logic. If
                               this field is zero, the completion status is
                               based on the DPCCTL.DPCCC field. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register . This field is only applicable
                               to RPs and should be treated as reserved for
                               other devices.
                            */
    UINT32 txure : 1;

                            /* Bits[12:12], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit enables RP PIO error handling for all
                               cases where downstream non-posted requests are
                               completed by the root port with a UR/CA
                               completion. This includes non-posted requests
                               outstanding when the link goes down, non-posted
                               requests targeting a link that is down, non-
                               posted requests received from the device core
                               after DPC has been triggered, and AER cases such
                               as AEB, PTLPEB, etc. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} EDPCPR_IIO_PCIEDMI_STRUCT;

/* DPCECH_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x200001a0)                                                      */
/*      SPRB0 (0x200001a0)                                                      */
/*      SPRHBM (0x200001a0)                                                     */
/*      SPRC0 (0x200001a0)                                                      */
/*      SPRMCC (0x200001a0)                                                     */
/*      SPRUCC (0x200001a0)                                                     */
/* Register default value on SPRA0: 0x0001001D                                  */
/* Register default value on SPRB0: 0x0001001D                                  */
/* Register default value on SPRHBM: 0x0001001D                                 */
/* Register default value on SPRC0: 0x0001001D                                  */
/* Register default value on SPRMCC: 0x0001001D                                 */
/* Register default value on SPRUCC: 0x0001001D                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* DPC Extended Capability Header
*/


#define DPCECH_IIO_PCIEDMI_REG 0x0D0201A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000001D*/

                            /* Identifies the function as DPC capable. */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/V/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . H/W may skip over the linked
                               capabilities list when DISALBE_DPC fuse is set
                               to 1 if supported, or hardware-aware S/W will
                               need to program this field appropriately for
                               linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} DPCECH_IIO_PCIEDMI_STRUCT;

/* DPCCAP_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x100001a4)                                                      */
/*      SPRB0 (0x100001a4)                                                      */
/*      SPRHBM (0x100001a4)                                                     */
/*      SPRC0 (0x100001a4)                                                      */
/*      SPRMCC (0x100001a4)                                                     */
/*      SPRUCC (0x100001a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* DPC Capability
*/


#define DPCCAP_IIO_PCIEDMI_REG 0x0D0101A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcimn : 5;

                            /* Bits[4:0], Access Type=RW/L, default=None*/

                            /*
                               This field indicates which MSI/MSI-X vector is
                               used for the interrupt message generated in
                               association with the DPC Capability structure.
                               For MSI, the value in this field indicates the
                               offset between the base Message Data and the
                               interrupt message that is generated. Hardware is
                               required to update this field so that it is
                               correct if the number of MSI Messages assigned
                               to the Function changes when software writes to
                               the Multiple Message Enable field in the MSI
                               Message Control register. For MSI-X, the value
                               in this field indicates which MSI-X Table entry
                               is used to generate the interrupt message. The
                               entry must be one of the first 32 entries even
                               if the Function implements more than 32 entries.
                               For a given MSI-X implementation, the entry must
                               remain constant. If both MSI and MSI-X are
                               implemented, they are permitted to use different
                               vectors, though software is permitted to enable
                               only one mechanism at a time. If MSI-X is
                               enabled, the value in this field must indicate
                               the vector for MSI-X. If MSI is enabled or
                               neither is enabled, the value in this field must
                               indicate the vector for MSI. If software enables
                               both MSI and MSI-X at the same time, the value
                               in this field is undefined.
                            */
    UINT16 rpedpc : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that a Root Port
                               supports a defined set of DPC Extensions that
                               are specific to Root Ports. Switch Downstream
                               Ports must not Set this bit.
                            */
    UINT16 ptlpebs : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that the Root Port or
                               Switch Downstream Port supports the ability to
                               block the transmission of a poisoned TLP from
                               its Egress Port. Root Ports that support RP
                               Extensions for DPC must Set this bit
                            */
    UINT16 dpcsts : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that a Root Port or
                               Switch Downstream Port supports the ability for
                               software to trigger DPC. Root Ports that support
                               RP Extensions for DPC must Set this bit.
                            */
    UINT16 rppiols : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               This field indicates how many DWORDs are
                               allocated for the RP PIO log registers,
                               comprised by the RP PIO Header Log, the RP PIO
                               ImpSpec Log, and RP PIO TLP Prefix Log. If the
                               Root Port supports RP Extensions for DPC, the
                               value of this field must be 4 or greater,
                               otherwise, the value of this field must be 0.
                            */
    UINT16 dlaecss : 1;

                            /* Bits[12:12], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that the Root Port or
                               Switch Downstream Port supports the ability to
                               signal with ERR_COR when the Link transitions to
                               the DL_Active state. Root Ports that support RP
                               Extensions for DPC must Set this bit.
                            */
    UINT16 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCCAP_IIO_PCIEDMI_STRUCT;

/* DPCCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x100001a6)                                                      */
/*      SPRB0 (0x100001a6)                                                      */
/*      SPRHBM (0x100001a6)                                                     */
/*      SPRC0 (0x100001a6)                                                      */
/*      SPRMCC (0x100001a6)                                                     */
/*      SPRUCC (0x100001a6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DPC Control
*/


#define DPCCTL_IIO_PCIEDMI_REG 0x0D0101A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcte : 2;

                            /* Bits[1:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field enables DPC and controls the
                               conditions that cause DPC to be triggered.
                               Defined encodings are: 00b DPC is disabled 01b
                               DPC is enabled and is triggered when the
                               Downstream Port detects an unmasked
                               uncorrectable error or when the Downstream Port
                               receives an ERR_FATAL Message. 10b DPC is
                               enabled and is triggered when the Downstream
                               Port detects an unmasked uncorrectable error or
                               when the Downstream Port receives an
                               ERR_NONFATAL or ERR_FATAL Message. 11b Reserved
                               H/W will change this field to 'RO' of zero when
                               DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dpccc : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit controls the Completion Status for
                               Completions formed during DPC. 0b Completer
                               Abort (CA) Completion Status 1b Unsupported
                               Request (UR) Completion Status H/W will change
                               this field to 'RO' of zero when DISALBE_DPC fuse
                               is set to 1 if supported.
                            */
    UINT16 dpcie : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of an
                               interrupt to indicate that DPC has been
                               triggered H/W will change this field to 'RO' of
                               zero when DISALBE_DPC fuse is set to 1 if
                               supported.
                            */
    UINT16 dpcece : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the sending of an
                               ERR_COR Message to indicate that DPC has been
                               triggered. H/W will change this field to 'RO' of
                               zero when DISALBE_DPC fuse is set to 1 if
                               supported.
                            */
    UINT16 ptlpebe : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the Poisoned TLP Egress
                               Blocking Supported bit is Set, otherwise, it is
                               permitted to be hardwired to 0b. Software must
                               not Set this bit unless the Poisoned TLP Egress
                               Blocking Supported bit is Set. When Set, this
                               bit enables the associated Egress Port to block
                               the transmission of poisoned TLPs. H/W will
                               change this field to 'RO' of zero when
                               DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dpcst : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the DPC Software
                               Triggering Supported bit is Set, otherwise, it
                               is permitted to be hardwired to 0b. If DPC is
                               enabled and the DPC Trigger Status bit is Clear,
                               when software writes 1b to this bit, DPC is
                               triggered. Otherwise, software writing a 1b to
                               this bit has no effect. It is permitted to write
                               1b to this bit while simultaneously writing
                               updated values to other fields in this register,
                               notably the DPC Trigger Enable field. For this
                               case, the DPC Software Trigger semantics are
                               based on the updated value of the DPC Trigger
                               Enable field. This bit always returns 0b when
                               read. H/W will change this field to 'RO' of zero
                               when DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dlaece : 1;

                            /* Bits[7:7], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the DL_Active ERR_COR
                               Signaling Supported bit is Set, otherwise, it is
                               permitted to be hardwired to 0b. Software must
                               not Set this bit unless the DL_Active ERR_COR
                               Signaling Supported bit is Set. When Set, this
                               bit enables the associated Downstream Port to
                               signal with ERR_COR when the Link transitions to
                               the DL_Active state. H/W will change this field
                               to 'RO' of zero when DISALBE_DPC fuse is set to
                               1 if supported.
                            */
    UINT16 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCCTL_IIO_PCIEDMI_STRUCT;

/* DPCSTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x100001a8)                                                      */
/*      SPRB0 (0x100001a8)                                                      */
/*      SPRHBM (0x100001a8)                                                     */
/*      SPRC0 (0x100001a8)                                                      */
/*      SPRMCC (0x100001a8)                                                     */
/*      SPRUCC (0x100001a8)                                                     */
/* Register default value on SPRA0: 0x00001F00                                  */
/* Register default value on SPRB0: 0x00001F00                                  */
/* Register default value on SPRHBM: 0x00001F00                                 */
/* Register default value on SPRC0: 0x00001F00                                  */
/* Register default value on SPRMCC: 0x00001F00                                 */
/* Register default value on SPRUCC: 0x00001F00                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DPC Status
*/


#define DPCSTS_IIO_PCIEDMI_REG 0x0D0101A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcts : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that DPC has been
                               triggered. DPC is event triggered. While this
                               bit is Set, hardware must direct the LTSSM to
                               the Disabled State. This bit must be cleared
                               before the LTSSM can be released from the
                               Disabled State. See Section 6.2.10 of eDPC ECN
                               for requirements on how long software must leave
                               the Downstream Port in DPC. Once these
                               requirements are met, software is permitted to
                               clear this bit regardless of the state of other
                               status bits associated with the triggering
                               event. After clearing this bit, software must
                               honor timing requirements defined in Section
                               6.6.1 of eDPC ECN with respect to the first
                               Configuration Read following a Conventional
                               Reset.
                            */
    UINT16 dpctr : 2;

                            /* Bits[2:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field indicates why DPC has been triggered.
                               Defined encodings are: 00b DPC was triggered due
                               to an unmasked uncorrectable error. 01b DPC was
                               triggered due to receiving an ERR_NONFATAL. 10b
                               DPC was triggered due to receiving an ERR_FATAL.
                               11b Reserved DPC was triggered due to a reason
                               that is indicated by the DPC Trigger Reason
                               Extension field. This field is valid only when
                               the DPC Trigger Status bit is Set, otherwise the
                               value of this field is undefined
                            */
    UINT16 dpcis : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set if DPC is triggered while the
                               DPC Interrupt Enable bit is Set. This may cause
                               the generation of an interrupt.
                            */
    UINT16 dpcrpb : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               When the DPC Trigger Status bit is Set and this
                               bit is Set, the Root Port is busy with internal
                               activity that must complete before software is
                               permitted to Clear the DPC Trigger Status bit.
                               If software Clears the DPC Trigger Status bit
                               while this bit is Set, the behavior is
                               undefined. This field is valid only when the DPC
                               Trigger Status bit is Set, otherwise the value
                               of this field is undefined. This bit is
                               applicable only for Root Ports that support RP
                               Extensions for DPC, and is Reserved for Switch
                               Downstream Ports. Default value of this bit is
                               undefined.
                            */
    UINT16 dpctre : 2;

                            /* Bits[6:5], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field serves as an extension to the DPC
                               Trigger Reason field. When that field is valid
                               and has a value of 11b, this field indicates why
                               DPC has been triggered. Defined encodings are:
                               00b DPC was triggered due to an RP PIO error.
                               01b DPC was triggered due to the DPC Software
                               Trigger bit. 10b Reserved 11b Reserved This
                               field is valid only when the DPC Trigger Status
                               bit is Set and the value of the DPC Trigger
                               Reason field is 11b, otherwise the value of this
                               field is undefined.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 rppiofep : 5;

                            /* Bits[12:8], Access Type=RO/V/P, default=0x0000001F*/

                            /*
                               The value of this field identifies a bit
                               position in the RP PIO Status register, and this
                               field is considered valid when that bit is Set.
                               When this field is valid, and software writes a
                               1b to the indicated RP PIO Status bit (thus
                               clearing it), this field must revert to its
                               default value. This field is applicable only for
                               Root Ports that support RP Extensions for DPC,
                               and otherwise is Reserved. If this field is not
                               Reserved, its default value is 11111b,
                               indicating a permanently Reserved RP PIO Status
                               bit, thus guaranteeing that this field is not
                               considered valid.
                            */
    UINT16 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCSTS_IIO_PCIEDMI_STRUCT;

/* DPCESID_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x100001aa)                                                      */
/*      SPRB0 (0x100001aa)                                                      */
/*      SPRHBM (0x100001aa)                                                     */
/*      SPRC0 (0x100001aa)                                                      */
/*      SPRMCC (0x100001aa)                                                     */
/*      SPRUCC (0x100001aa)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* DPC Error Source ID
*/


#define DPCESID_IIO_PCIEDMI_REG 0x0D0101AA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcesid : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When the DPC Trigger Reason field indicates that
                               DPC was triggered due to the reception of an
                               ERR_NONFATAL or ERR_FATAL, this register
                               contains the Requester ID of the received
                               Message. Otherwise, the value of this register
                               is undefined.
                            */

  } Bits;
  UINT16 Data;

} DPCESID_IIO_PCIEDMI_STRUCT;

/* RPPIOSTS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200001ac)                                                      */
/*      SPRB0 (0x200001ac)                                                      */
/*      SPRHBM (0x200001ac)                                                     */
/*      SPRC0 (0x200001ac)                                                      */
/*      SPRMCC (0x200001ac)                                                     */
/*      SPRUCC (0x200001ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Status
*/


#define RPPIOSTS_IIO_PCIEDMI_REG 0x0D0201AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSTS_IIO_PCIEDMI_STRUCT;

/* RPPIOMSK_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200001b0)                                                      */
/*      SPRB0 (0x200001b0)                                                      */
/*      SPRHBM (0x200001b0)                                                     */
/*      SPRC0 (0x200001b0)                                                      */
/*      SPRMCC (0x200001b0)                                                     */
/*      SPRUCC (0x200001b0)                                                     */
/* Register default value on SPRA0: 0x00070707                                  */
/* Register default value on SPRB0: 0x00070707                                  */
/* Register default value on SPRHBM: 0x00070707                                 */
/* Register default value on SPRC0: 0x00070707                                  */
/* Register default value on SPRMCC: 0x00070707                                 */
/* Register default value on SPRUCC: 0x00070707                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Mask
*/


#define RPPIOMSK_IIO_PCIEDMI_REG 0x0D0201B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Configuration Request received UR Completion
                               Mask
                            */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000001*/

                            /*
                               Configuration Request received CA Completion
                               Mask
                            */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000001*/

                            /* Configuration Request Completion Timeout Mask */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request received UR Completion Mask */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request received CA Completion Mask */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request Completion Timeout Mask */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request received UR Completion Mask */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request received CA Completion Mask */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request Completion Timeout Mask */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOMSK_IIO_PCIEDMI_STRUCT;

/* RPPIOSEV_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200001b4)                                                      */
/*      SPRB0 (0x200001b4)                                                      */
/*      SPRHBM (0x200001b4)                                                     */
/*      SPRC0 (0x200001b4)                                                      */
/*      SPRMCC (0x200001b4)                                                     */
/*      SPRUCC (0x200001b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Severity
*/


#define RPPIOSEV_IIO_PCIEDMI_REG 0x0D0201B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request received UR Completion
                               Severity
                            */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request received CA Completion
                               Severity
                            */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request Completion Timeout
                               Severity
                            */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion Severity */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion Severity */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout Severity */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion Severity */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion Severity */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout Severity */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSEV_IIO_PCIEDMI_STRUCT;

/* RPPIOSE_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200001b8)                                                      */
/*      SPRB0 (0x200001b8)                                                      */
/*      SPRHBM (0x200001b8)                                                     */
/*      SPRC0 (0x200001b8)                                                      */
/*      SPRMCC (0x200001b8)                                                     */
/*      SPRUCC (0x200001b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO SysError
*/


#define RPPIOSE_IIO_PCIEDMI_REG 0x0D0201B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSE_IIO_PCIEDMI_STRUCT;

/* RPPIOEXC_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200001bc)                                                      */
/*      SPRB0 (0x200001bc)                                                      */
/*      SPRHBM (0x200001bc)                                                     */
/*      SPRC0 (0x200001bc)                                                      */
/*      SPRMCC (0x200001bc)                                                     */
/*      SPRUCC (0x200001bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Exception
*/


#define RPPIOEXC_IIO_PCIEDMI_REG 0x0D0201BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOEXC_IIO_PCIEDMI_STRUCT;

/* RPPIOHDRLOG1_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x200001c0)                                                      */
/*      SPRB0 (0x200001c0)                                                      */
/*      SPRHBM (0x200001c0)                                                     */
/*      SPRC0 (0x200001c0)                                                      */
/*      SPRMCC (0x200001c0)                                                     */
/*      SPRUCC (0x200001c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG1_IIO_PCIEDMI_REG 0x0D0201C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG1_IIO_PCIEDMI_STRUCT;

/* RPPIOHDRLOG2_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x200001c4)                                                      */
/*      SPRB0 (0x200001c4)                                                      */
/*      SPRHBM (0x200001c4)                                                     */
/*      SPRC0 (0x200001c4)                                                      */
/*      SPRMCC (0x200001c4)                                                     */
/*      SPRUCC (0x200001c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG2_IIO_PCIEDMI_REG 0x0D0201C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG2_IIO_PCIEDMI_STRUCT;

/* RPPIOHDRLOG3_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x200001c8)                                                      */
/*      SPRB0 (0x200001c8)                                                      */
/*      SPRHBM (0x200001c8)                                                     */
/*      SPRC0 (0x200001c8)                                                      */
/*      SPRMCC (0x200001c8)                                                     */
/*      SPRUCC (0x200001c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG3_IIO_PCIEDMI_REG 0x0D0201C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG3_IIO_PCIEDMI_STRUCT;

/* RPPIOHDRLOG4_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x200001cc)                                                      */
/*      SPRB0 (0x200001cc)                                                      */
/*      SPRHBM (0x200001cc)                                                     */
/*      SPRC0 (0x200001cc)                                                      */
/*      SPRMCC (0x200001cc)                                                     */
/*      SPRUCC (0x200001cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG4_IIO_PCIEDMI_REG 0x0D0201CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG4_IIO_PCIEDMI_STRUCT;

/* ACSCAPHDR_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000220)                                                      */
/*      SPRB0 (0x20000220)                                                      */
/*      SPRHBM (0x20000220)                                                     */
/*      SPRC0 (0x20000220)                                                      */
/*      SPRMCC (0x20000220)                                                     */
/*      SPRUCC (0x20000220)                                                     */
/* Register default value on SPRA0: 0x0001000D                                  */
/* Register default value on SPRB0: 0x0001000D                                  */
/* Register default value on SPRHBM: 0x0001000D                                 */
/* Register default value on SPRC0: 0x0001000D                                  */
/* Register default value on SPRMCC: 0x0001000D                                 */
/* Register default value on SPRUCC: 0x0001000D                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Access Control Services Extended Capability Header
*/


#define ACSCAPHDR_IIO_PCIEDMI_REG 0x0D020220

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000000D*/

                            /*
                               Identifies the function as Access Control
                               Services capable.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} ACSCAPHDR_IIO_PCIEDMI_STRUCT;

/* ACSCAP_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000224)                                                      */
/*      SPRB0 (0x10000224)                                                      */
/*      SPRHBM (0x10000224)                                                     */
/*      SPRC0 (0x10000224)                                                      */
/*      SPRMCC (0x10000224)                                                     */
/*      SPRUCC (0x10000224)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register identifies the Access Control Services (ACS) capabilities.
*/


#define ACSCAP_IIO_PCIEDMI_REG 0x0D010224

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vacssv : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Source Validation. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT16 bacstb : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Translation Blocking. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 racsp2prr : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS P2P
                               Request Redirect. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT16 cacsp2prr : 1;

                            /* Bits[3:3], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS P2P
                               Completion Redirect. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This includes Read Completions,
                               AtomicOp Completions, and other Completions,
                               either with or without data.
                            */
    UINT16 uacsuf : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Upstream Forwarding. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 eacsp2pec : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Hardwired to 0. Indicates that the component
                               does not implement ACS P2P Egress Control.
                            */
    UINT16 tacsdtp2p : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component does implement ACS
                               Direct Translated P2P. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Required for Root Ports that support
                               Address Translation Services (ATS) and also
                               support peer-to-peer traffic with other Root
                               Ports, required for Switch Downstream Ports,
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 ecvs : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the number of bits in the Egress
                               Control Vector. This is set to 00h as ACS P2P
                               Egress Control (ACSP2PEC) bit 5 in this register
                               is 0b.
                            */

  } Bits;
  UINT16 Data;

} ACSCAP_IIO_PCIEDMI_STRUCT;

/* ACSCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000226)                                                      */
/*      SPRB0 (0x10000226)                                                      */
/*      SPRHBM (0x10000226)                                                     */
/*      SPRC0 (0x10000226)                                                      */
/*      SPRMCC (0x10000226)                                                     */
/*      SPRUCC (0x10000226)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register identifies the Access Control Services (ACS) control bits.
*/


#define ACSCTL_IIO_PCIEDMI_REG 0x0D010226

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vacssve : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component validates the Bus Number
                               from the Requester ID of upstream Requests
                               against the secondary / subordinate Bus Numbers.
                            */
    UINT16 bacstbe : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component blocks all upstream
                               Memory Requests whose Address Translation (AT)
                               field is not set to the default value.
                            */
    UINT16 racsp2prre : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit determines when the component redirects
                               peer-to-peer Requests upstream.
                            */
    UINT16 cacsp2pcre : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               Determines when the component redirects peer-to-
                               peer Completions upstream, applicable only to
                               Read Completions whose Relaxed Ordering
                               Attribute is clear.
                            */
    UINT16 uacsufe : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component forwards upstream any
                               Request or Completion TLPs it receives that were
                               redirected upstream by a component lower in the
                               hierarchy. Note that the U bit only applies to
                               upstream TLPs arriving at a Downstream Port, and
                               whose normal routing targets the same Downstream
                               Port.
                            */
    UINT16 eacsp2pece : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               This is hardwired to 0b as the component does
                               not implement ACS P2P Egress Control.
                            */
    UINT16 tacsp2pece : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, overrides the ACS P2P Request Redirect
                               and ACS P2P Egress Control mechanisms with peer-
                               to-peer Memory Requests whose Address
                               Translation (AT) field indicates a Translated
                               address This bit is ignored if ACS Translation
                               Blocking (B) is enabled.
                            */
    UINT16 rsvd : 9;

                            /* Bits[15:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ACSCTL_IIO_PCIEDMI_STRUCT;

/* VCECH_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000280)                                                      */
/*      SPRB0 (0x20000280)                                                      */
/*      SPRHBM (0x20000280)                                                     */
/*      SPRC0 (0x20000280)                                                      */
/*      SPRMCC (0x20000280)                                                     */
/*      SPRUCC (0x20000280)                                                     */
/* Register default value on SPRA0: 0x00010002                                  */
/* Register default value on SPRB0: 0x00010002                                  */
/* Register default value on SPRHBM: 0x00010002                                 */
/* Register default value on SPRC0: 0x00010002                                  */
/* Register default value on SPRMCC: 0x00010002                                 */
/* Register default value on SPRUCC: 0x00010002                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Virtual Channel Extended Capability Header
*/


#define VCECH_IIO_PCIEDMI_REG 0x0D020280

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000002*/

                            /*
                               Extended Capability ID for the Virtual Channel
                               Capability is either 0002h or 0009h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} VCECH_IIO_PCIEDMI_STRUCT;

/* PVCCR1_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000284)                                                      */
/*      SPRB0 (0x20000284)                                                      */
/*      SPRHBM (0x20000284)                                                     */
/*      SPRC0 (0x20000284)                                                      */
/*      SPRMCC (0x20000284)                                                     */
/*      SPRUCC (0x20000284)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Port VC Capability Register 1
*/


#define PVCCR1_IIO_PCIEDMI_REG 0x0D020284

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 evcc : 3;

                            /* Bits[2:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates the number of (extended) Virtual
                               Channels in addition to the default VC supported
                               by the device. This field is valid for all
                               Functions. The minimum value of this field is
                               000b (for devices that only support the default
                               VC). The maximum value is 7. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PVCCR1_IIO_PCIEDMI_STRUCT;

/* PVCCR2_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000288)                                                      */
/*      SPRB0 (0x20000288)                                                      */
/*      SPRHBM (0x20000288)                                                     */
/*      SPRC0 (0x20000288)                                                      */
/*      SPRMCC (0x20000288)                                                     */
/*      SPRUCC (0x20000288)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Port VC Capability Register 2
*/


#define PVCCR2_IIO_PCIEDMI_REG 0x0D020288

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vcac : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the types of VC Arbitration supported
                               by the Function for the LPVC group. This field
                               is valid for all Functions that report a Low
                               Priority Extended VC Count field greater than 0.
                               For all other Functions, this field must be
                               hardwired to 00h. Each bit location within this
                               field corresponds to a VC Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the Port can be
                               configured to provide different VC arbitration
                               services. Defined bit positions are: Bit 0
                               Hardware fixed arbitration scheme, e.g., Round
                               Robin Bit 1 Weighted Round Robin (WRR)
                               arbitration with 32 phases Bit 2 WRR arbitration
                               with 64 phases Bit 3 WRR arbitration with 128
                               phases Bits 4-7 Reserved
                            */
    UINT32 rsvd : 16;

                            /* Bits[23:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcato : 8;

                            /* Bits[31:24], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the location of the VC Arbitration
                               Table. This field is valid for all Functions.
                               This field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 0 indicates that the table
                               is not present.
                            */

  } Bits;
  UINT32 Data;

} PVCCR2_IIO_PCIEDMI_STRUCT;

/* PVCCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x1000028c)                                                      */
/*      SPRB0 (0x1000028c)                                                      */
/*      SPRHBM (0x1000028c)                                                     */
/*      SPRC0 (0x1000028c)                                                      */
/*      SPRMCC (0x1000028c)                                                     */
/*      SPRUCC (0x1000028c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Port VC Control
*/


#define PVCCTL_IIO_PCIEDMI_REG 0x0D01028C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 lvcat : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Used by software to update the VC Arbitration
                               Table. This bit is valid for all Functions when
                               the selected VC Arbitration uses the VC
                               Arbitration Table. Software sets this bit to
                               request hardware to apply new values programmed
                               into VC Arbitration Table, clearing this bit has
                               no effect. Software checks the VC Arbitration
                               Table Status bit to confirm that new values
                               stored in the VC Arbitration Table are latched
                               by the VC arbitration logic. This bit always
                               returns 0b when read.
                            */
    UINT16 vcas : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /*
                               Used by software to configure the VC arbitration
                               by selecting one of the supported VC Arbitration
                               schemes indicated by the VC Arbitration
                               Capability field in the Port VC Capability
                               register 2. This field is valid for all
                               Functions. The permissible values of this field
                               are numbers corresponding to one of the asserted
                               bits in the VC Arbitration Capability field.
                               This field cannot be modified when more than one
                               VC in the LPVC group is enabled.
                            */
    UINT16 rsvd : 12;

                            /* Bits[15:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PVCCTL_IIO_PCIEDMI_STRUCT;

/* PVCSTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x1000028e)                                                      */
/*      SPRB0 (0x1000028e)                                                      */
/*      SPRHBM (0x1000028e)                                                     */
/*      SPRC0 (0x1000028e)                                                      */
/*      SPRMCC (0x1000028e)                                                     */
/*      SPRUCC (0x1000028e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Port VC Status
*/


#define PVCSTS_IIO_PCIEDMI_REG 0x0D01028E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vcats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indicates the coherency status of the VC
                               Arbitration Table. This bit is valid for all
                               Functions when the selected VC uses the VC
                               Arbitration Table. This bit is Set by hardware
                               when any entry of the VC Arbitration Table is
                               written by software. This bit is Cleared by
                               hardware when hardware finishes loading values
                               stored in the VC Arbitration Table after
                               software sets the Load VC Arbitration Table bit
                               in the Port VC Control register. Default value
                               of this bit is 0b.
                            */
    UINT16 rsvd : 15;

                            /* Bits[15:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PVCSTS_IIO_PCIEDMI_STRUCT;

/* VC0RC_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000290)                                                      */
/*      SPRB0 (0x20000290)                                                      */
/*      SPRHBM (0x20000290)                                                     */
/*      SPRC0 (0x20000290)                                                      */
/*      SPRMCC (0x20000290)                                                     */
/*      SPRUCC (0x20000290)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* VC0 Resource Capability
*/


#define VC0RC_IIO_PCIEDMI_REG 0x0D020290

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pac : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates types of Port Arbitration supported by
                               the VC resource. This field is valid for all
                               Switch Ports, Root Ports that support peer-to-
                               peer traffic, and RCRBs, but not for Endpoints
                               or Root Ports that do not support peer-to-peer
                               traffic. Each bit location within this field
                               corresponds to a Port Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the VC resource
                               can be configured to provide different
                               arbitration services. Software selects among
                               these capabilities by writing to the Port
                               Arbitration Select field (see Section 7.11.7).
                               Defined bit positions are: Bit 0 Non-
                               configurable hardware-fixed arbitration scheme,
                               e.g., Round Robin (RR) Bit 1 Weighted Round
                               Robin (WRR) arbitration with 32 phases Bit 2 WRR
                               arbitration with 64 phases Bit 3 WRR arbitration
                               with 128 phases Bit 4 Time-based WRR with 128
                               phases Bit 5 WRR arbitration with 256 phases
                               Bits 6-7 Reserved Note: Lock Key bit is located
                               in the Personality Lock Key Control Register
                            */
    UINT32 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rst : 1;

                            /* Bits[15:15], Access Type=RW/L, default=None*/

                            /*
                               When Clear, transactions with or without the No
                               Snoop bit Set within the TLP header are allowed
                               on this VC. When Set, any transaction for which
                               the No Snoop attribute is applicable but is not
                               Set within the TLP header is permitted to be
                               rejected as an Unsupported Request. This bit is
                               valid for Root Ports and RCRB, it is not valid
                               for Endpoints or Switch Ports. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 mts : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the maximum number of time slots
                               (minus one) that the VC resource is capable of
                               supporting when it is configured for time-based
                               WRR Port Arbitration. For example, a value 000
                               0000b in this field indicates the supported
                               maximum number of time slots is 1 and a value of
                               111 1111b indicates the supported maximum number
                               of time slots is 128. This field is valid for
                               all Switch Ports, Root Ports that support peer-
                               to-peer traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this field is
                               valid only when the Port Arbitration Capability
                               field indicates that the VC resource supports
                               time-based WRR Port Arbitration. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pato : 8;

                            /* Bits[31:24], Access Type=RW/L, default=None*/

                            /*
                               Indicates the location of the Port Arbitration
                               Table associated with the VC resource. This
                               field is valid for all Switch Ports, Root Ports
                               that support peer-to-peer traffic, and RCRBs,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. This
                               field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 00h indicates that the
                               table is not present. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} VC0RC_IIO_PCIEDMI_STRUCT;

/* VC0RCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000294)                                                      */
/*      SPRB0 (0x20000294)                                                      */
/*      SPRHBM (0x20000294)                                                     */
/*      SPRC0 (0x20000294)                                                      */
/*      SPRMCC (0x20000294)                                                     */
/*      SPRUCC (0x20000294)                                                     */
/* Register default value on SPRA0: 0x8000007F                                  */
/* Register default value on SPRB0: 0x8000007F                                  */
/* Register default value on SPRHBM: 0x8000007F                                 */
/* Register default value on SPRC0: 0x8000007F                                  */
/* Register default value on SPRMCC: 0x8000007F                                 */
/* Register default value on SPRUCC: 0x8000007F                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC0 Resource Control
*/


#define VC0RCTL_IIO_PCIEDMI_REG 0x0D020294

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tc0vcm : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000001*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. Bit 0 of this field is
                               read-only. It must be Set for the default VC0
                               and Clear for all other enabled VCs.
                            */
    UINT32 tcvcm : 7;

                            /* Bits[7:1], Access Type=RW, default=0x0000003F*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. For example, when bit 7
                               is Set in this field, TC7 is mapped to this VC
                               resource. When more than 1 bit in this field is
                               Set, it indicates that multiple TCs are mapped
                               to the VC resource. In order to remove one or
                               more TCs from the TC/VC Map of an enabled VC,
                               software must ensure that no new or outstanding
                               transactions with the TC labels are targeted at
                               the given Link. Default value of this field is
                               3Fh for the first VC resource with MVC and is
                               00h for other VC resources.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lpat : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit updates the Port Arbitration
                               logic from the Port Arbitration Table for the VC
                               resource. This bit is valid for all Switch
                               Ports, Root Ports that support peer-to-peer
                               traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this bit is
                               only valid when the Port Arbitration Table is
                               used by the selected Port Arbitration scheme
                               (that is indicated by a Set bit in the Port
                               Arbitration Capability field selected by Port
                               Arbitration Select). Software sets this bit to
                               signal hardware to update Port Arbitration logic
                               with new values stored in Port Arbitration
                               Table, clearing this bit has no effect. Software
                               uses the Port Arbitration Table Status bit to
                               confirm whether the new values of Port
                               Arbitration Table are completely latched by the
                               arbitration logic. This bit always returns 0b
                               when read.
                            */
    UINT32 lpas : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000000*/

                            /*
                               This field configures the VC resource to provide
                               a particular Port Arbitration service. This
                               field is valid for RCRBs, Root Ports that
                               support peer-to-peer traffic, and Switch Ports,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. The
                               permissible value of this field is a number
                               corresponding to one of the asserted bits in the
                               Port Arbitration Capability field of the VC
                               resource.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcid : 3;

                            /* Bits[26:24], Access Type=RO, default=0x00000000*/

                            /*
                               This field assigns a VC ID to the VC resource
                               (see note for exceptions). This field is valid
                               for all Functions. This field cannot be modified
                               when the VC is already enabled. Note: For the
                               first VC resource (default VC), this field is
                               read-only and must be hardwired to 000b.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcen : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000001*/

                            /*
                               This bit, when Set, enables a Virtual Channel
                               (see note 1 for exceptions). The Virtual Channel
                               is disabled when this bit is cleared. This bit
                               is valid for all Functions. Software must use
                               the VC Negotiation Pending bit to check whether
                               the VC negotiation is complete. Default value of
                               this bit is 1b for the first VC resource and is
                               0b for other VC resource(s). Notes: 1. This bit
                               is hardwired to 1b for the default VC (VC0),
                               i.e., writing to this bit has no effect for VC0.
                               2. To enable a Virtual Channel, the VC Enable
                               bits for that Virtual Channel must be Set in
                               both components on a Link. 3. To disable a
                               Virtual Channel, the VC Enable bits for that
                               Virtual Channel must be cleared in both
                               components on a Link. 4. Software must ensure
                               that no traffic is using a Virtual Channel at
                               the time it is disabled. 5. Software must fully
                               disable a Virtual Channel in both components on
                               a Link before re-enabling the Virtual Channel.
                            */

  } Bits;
  UINT32 Data;

} VC0RCTL_IIO_PCIEDMI_STRUCT;

/* VC0RSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x1000029a)                                                      */
/*      SPRB0 (0x1000029a)                                                      */
/*      SPRHBM (0x1000029a)                                                     */
/*      SPRC0 (0x1000029a)                                                      */
/*      SPRMCC (0x1000029a)                                                     */
/*      SPRUCC (0x1000029a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC0 Resource Status
*/


#define VC0RSTS_IIO_PCIEDMI_REG 0x0D01029A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the coherency status of the
                               Port Arbitration Table associated with the VC
                               resource. This bit is valid for RCRBs, Root
                               Ports that support peer-to-peer traffic, and
                               Switch Ports, but is not valid for Endpoints or
                               Root Ports that do not support peer-to-peer
                               traffic. In addition, this bit is valid only
                               when the Port Arbitration Table is used by the
                               selected Port Arbitration for the VC resource.
                               This bit is Set by hardware when any entry of
                               the Port Arbitration Table is written to by
                               software. This bit is Cleared by hardware when
                               hardware finishes loading values stored in the
                               Port Arbitration Table after software sets the
                               Load Port Arbitration Table bit.
                            */
    UINT16 vcnp : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates whether the Virtual Channel
                               negotiation (initialization or disabling) is in
                               pending state. This bit is valid for all
                               Functions. The value of this bit is defined only
                               when the Link is in the DL_Active state and the
                               Virtual Channel is enabled (its VC Enable bit is
                               Set). When this bit is Set by hardware, it
                               indicates that the VC resource has not completed
                               the process of negotiation. This bit is Cleared
                               by hardware after the VC negotiation is complete
                               (on exit from the FC_INIT2 state). For VC0, this
                               bit is permitted to be hardwired to 0b. Before
                               using a Virtual Channel, software must check
                               whether the VC Negotiation Pending bits for that
                               Virtual Channel are Clear in both components on
                               the Link.
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} VC0RSTS_IIO_PCIEDMI_STRUCT;

/* VC1RC_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x2000029c)                                                      */
/*      SPRB0 (0x2000029c)                                                      */
/*      SPRHBM (0x2000029c)                                                     */
/*      SPRC0 (0x2000029c)                                                      */
/*      SPRMCC (0x2000029c)                                                     */
/*      SPRUCC (0x2000029c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* VC1 Resource Capability
*/


#define VC1RC_IIO_PCIEDMI_REG 0x0D02029C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pac : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates types of Port Arbitration supported by
                               the VC resource. This field is valid for all
                               Switch Ports, Root Ports that support peer-to-
                               peer traffic, and RCRBs, but not for Endpoints
                               or Root Ports that do not support peer-to-peer
                               traffic. Each bit location within this field
                               corresponds to a Port Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the VC resource
                               can be configured to provide different
                               arbitration services. Software selects among
                               these capabilities by writing to the Port
                               Arbitration Select field (see Section 7.11.7).
                               Defined bit positions are: Bit 0 Non-
                               configurable hardware-fixed arbitration scheme,
                               e.g., Round Robin (RR) Bit 1 Weighted Round
                               Robin (WRR) arbitration with 32 phases Bit 2 WRR
                               arbitration with 64 phases Bit 3 WRR arbitration
                               with 128 phases Bit 4 Time-based WRR with 128
                               phases Bit 5 WRR arbitration with 256 phases
                               Bits 6-7 Reserved Note: Lock Key bit is located
                               in the Personality Lock Key Control Register
                            */
    UINT32 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rst : 1;

                            /* Bits[15:15], Access Type=RW/L, default=None*/

                            /*
                               When Clear, transactions with or without the No
                               Snoop bit Set within the TLP header are allowed
                               on this VC. When Set, any transaction for which
                               the No Snoop attribute is applicable but is not
                               Set within the TLP header is permitted to be
                               rejected as an Unsupported Request. This bit is
                               valid for Root Ports and RCRB, it is not valid
                               for Endpoints or Switch Ports. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 mts : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the maximum number of time slots
                               (minus one) that the VC resource is capable of
                               supporting when it is configured for time-based
                               WRR Port Arbitration. For example, a value 000
                               0000b in this field indicates the supported
                               maximum number of time slots is 1 and a value of
                               111 1111b indicates the supported maximum number
                               of time slots is 128. This field is valid for
                               all Switch Ports, Root Ports that support peer-
                               to-peer traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this field is
                               valid only when the Port Arbitration Capability
                               field indicates that the VC resource supports
                               time-based WRR Port Arbitration. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pato : 8;

                            /* Bits[31:24], Access Type=RW/L, default=None*/

                            /*
                               Indicates the location of the Port Arbitration
                               Table associated with the VC resource. This
                               field is valid for all Switch Ports, Root Ports
                               that support peer-to-peer traffic, and RCRBs,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. This
                               field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 00h indicates that the
                               table is not present. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} VC1RC_IIO_PCIEDMI_STRUCT;

/* VC1RCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200002a0)                                                      */
/*      SPRB0 (0x200002a0)                                                      */
/*      SPRHBM (0x200002a0)                                                     */
/*      SPRC0 (0x200002a0)                                                      */
/*      SPRMCC (0x200002a0)                                                     */
/*      SPRUCC (0x200002a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Currently port arbitration table is not supported in VCx Resource Control registers and should be treated as reserved.
*/


#define VC1RCTL_IIO_PCIEDMI_REG 0x0D0202A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tc0vcm : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. Bit 0 of this field is
                               read-only. It must be Set for the default VC0
                               and Clear for all other enabled VCs.
                            */
    UINT32 tcvcm : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. For example, when bit 7
                               is Set in this field, TC7 is mapped to this VC
                               resource. When more than 1 bit in this field is
                               Set, it indicates that multiple TCs are mapped
                               to the VC resource. In order to remove one or
                               more TCs from the TC/VC Map of an enabled VC,
                               software must ensure that no new or outstanding
                               transactions with the TC labels are targeted at
                               the given Link. Traffic Class 7 is always routed
                               to VCm so it will be 0 in other VCs.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lpat : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit updates the Port Arbitration
                               logic from the Port Arbitration Table for the VC
                               resource. This bit is valid for all Switch
                               Ports, Root Ports that support peer-to-peer
                               traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this bit is
                               only valid when the Port Arbitration Table is
                               used by the selected Port Arbitration scheme
                               (that is indicated by a Set bit in the Port
                               Arbitration Capability field selected by Port
                               Arbitration Select). Software sets this bit to
                               signal hardware to update Port Arbitration logic
                               with new values stored in Port Arbitration
                               Table, clearing this bit has no effect. Software
                               uses the Port Arbitration Table Status bit to
                               confirm whether the new values of Port
                               Arbitration Table are completely latched by the
                               arbitration logic. This bit always returns 0b
                               when read.
                            */
    UINT32 lpas : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000000*/

                            /*
                               This field configures the VC resource to provide
                               a particular Port Arbitration service. This
                               field is valid for RCRBs, Root Ports that
                               support peer-to-peer traffic, and Switch Ports,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. The
                               permissible value of this field is a number
                               corresponding to one of the asserted bits in the
                               Port Arbitration Capability field of the VC
                               resource.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcid : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field assigns a VC ID to the VC resource
                               (see note for exceptions). This field is valid
                               for all Functions. This field cannot be modified
                               when the VC is already enabled. Note: For the
                               first VC resource (default VC), this field is
                               read-only and must be hardwired to 000b.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcen : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, when Set, enables a Virtual Channel
                               (see note 1 for exceptions). The Virtual Channel
                               is disabled when this bit is cleared. This bit
                               is valid for all Functions. Software must use
                               the VC Negotiation Pending bit to check whether
                               the VC negotiation is complete. Default value of
                               this bit is 1b for the first VC resource and is
                               0b for other VC resource(s). Notes: 1. This bit
                               is hardwired to 1b for the default VC (VC0),
                               i.e., writing to this bit has no effect for VC0.
                               2. To enable a Virtual Channel, the VC Enable
                               bits for that Virtual Channel must be Set in
                               both components on a Link. 3. To disable a
                               Virtual Channel, the VC Enable bits for that
                               Virtual Channel must be cleared in both
                               components on a Link. 4. Software must ensure
                               that no traffic is using a Virtual Channel at
                               the time it is disabled. 5. Software must fully
                               disable a Virtual Channel in both components on
                               a Link before re-enabling the Virtual Channel.
                            */

  } Bits;
  UINT32 Data;

} VC1RCTL_IIO_PCIEDMI_STRUCT;

/* VC1RSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x100002a6)                                                      */
/*      SPRB0 (0x100002a6)                                                      */
/*      SPRHBM (0x100002a6)                                                     */
/*      SPRC0 (0x100002a6)                                                      */
/*      SPRMCC (0x100002a6)                                                     */
/*      SPRUCC (0x100002a6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC1 Resource Status
*/


#define VC1RSTS_IIO_PCIEDMI_REG 0x0D0102A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the coherency status of the
                               Port Arbitration Table associated with the VC
                               resource. This bit is valid for RCRBs, Root
                               Ports that support peer-to-peer traffic, and
                               Switch Ports, but is not valid for Endpoints or
                               Root Ports that do not support peer-to-peer
                               traffic. In addition, this bit is valid only
                               when the Port Arbitration Table is used by the
                               selected Port Arbitration for the VC resource.
                               This bit is Set by hardware when any entry of
                               the Port Arbitration Table is written to by
                               software. This bit is Cleared by hardware when
                               hardware finishes loading values stored in the
                               Port Arbitration Table after software sets the
                               Load Port Arbitration Table bit.
                            */
    UINT16 vcnp : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates whether the Virtual Channel
                               negotiation (initialization or disabling) is in
                               pending state. This bit is valid for all
                               Functions. The value of this bit is defined only
                               when the Link is in the DL_Active state and the
                               Virtual Channel is enabled (its VC Enable bit is
                               Set). When this bit is Set by hardware, it
                               indicates that the VC resource has not completed
                               the process of negotiation. This bit is Cleared
                               by hardware after the VC negotiation is complete
                               (on exit from the FC_INIT2 state). For VC0, this
                               bit is permitted to be hardwired to 0b. Before
                               using a Virtual Channel, software must check
                               whether the VC Negotiation Pending bits for that
                               Virtual Channel are Clear in both components on
                               the Link.
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} VC1RSTS_IIO_PCIEDMI_STRUCT;

/* VCMRC_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x200002a8)                                                      */
/*      SPRB0 (0x200002a8)                                                      */
/*      SPRHBM (0x200002a8)                                                     */
/*      SPRC0 (0x200002a8)                                                      */
/*      SPRMCC (0x200002a8)                                                     */
/*      SPRUCC (0x200002a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* VCm Resource Capability
*/


#define VCMRC_IIO_PCIEDMI_REG 0x0D0202A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pac : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates types of Port Arbitration supported by
                               the VC resource. This field is valid for all
                               Switch Ports, Root Ports that support peer-to-
                               peer traffic, and RCRBs, but not for Endpoints
                               or Root Ports that do not support peer-to-peer
                               traffic. Each bit location within this field
                               corresponds to a Port Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the VC resource
                               can be configured to provide different
                               arbitration services. Software selects among
                               these capabilities by writing to the Port
                               Arbitration Select field (see Section 7.11.7).
                               Defined bit positions are: Bit 0 Non-
                               configurable hardware-fixed arbitration scheme,
                               e.g., Round Robin (RR) Bit 1 Weighted Round
                               Robin (WRR) arbitration with 32 phases Bit 2 WRR
                               arbitration with 64 phases Bit 3 WRR arbitration
                               with 128 phases Bit 4 Time-based WRR with 128
                               phases Bit 5 WRR arbitration with 256 phases
                               Bits 6-7 Reserved Note: Lock Key bit is located
                               in the Personality Lock Key Control Register
                            */
    UINT32 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rst : 1;

                            /* Bits[15:15], Access Type=RW/L, default=None*/

                            /*
                               When Clear, transactions with or without the No
                               Snoop bit Set within the TLP header are allowed
                               on this VC. When Set, any transaction for which
                               the No Snoop attribute is applicable but is not
                               Set within the TLP header is permitted to be
                               rejected as an Unsupported Request. This bit is
                               valid for Root Ports and RCRB, it is not valid
                               for Endpoints or Switch Ports. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 mts : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the maximum number of time slots
                               (minus one) that the VC resource is capable of
                               supporting when it is configured for time-based
                               WRR Port Arbitration. For example, a value 000
                               0000b in this field indicates the supported
                               maximum number of time slots is 1 and a value of
                               111 1111b indicates the supported maximum number
                               of time slots is 128. This field is valid for
                               all Switch Ports, Root Ports that support peer-
                               to-peer traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this field is
                               valid only when the Port Arbitration Capability
                               field indicates that the VC resource supports
                               time-based WRR Port Arbitration. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pato : 8;

                            /* Bits[31:24], Access Type=RW/L, default=None*/

                            /*
                               Indicates the location of the Port Arbitration
                               Table associated with the VC resource. This
                               field is valid for all Switch Ports, Root Ports
                               that support peer-to-peer traffic, and RCRBs,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. This
                               field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 00h indicates that the
                               table is not present. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} VCMRC_IIO_PCIEDMI_STRUCT;

/* VCMRCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200002ac)                                                      */
/*      SPRB0 (0x200002ac)                                                      */
/*      SPRHBM (0x200002ac)                                                     */
/*      SPRC0 (0x200002ac)                                                      */
/*      SPRMCC (0x200002ac)                                                     */
/*      SPRUCC (0x200002ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VCm Resource Control
*/


#define VCMRCTL_IIO_PCIEDMI_REG 0x0D0202AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tc0vcm : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. Bit 0 of this field is
                               read-only. It must be Set for the default VC0
                               and Clear for all other enabled VCs.
                            */
    UINT32 tcvcm : 7;

                            /* Bits[7:1], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. For example, when bit 7
                               is Set in this field, TC7 is mapped to this VC
                               resource. When more than 1 bit in this field is
                               Set, it indicates that multiple TCs are mapped
                               to the VC resource. In order to remove one or
                               more TCs from the TC/VC Map of an enabled VC,
                               software must ensure that no new or outstanding
                               transactions with the TC labels are targeted at
                               the given Link. Default value of this field is
                               FFh for the first VC resource and is 00h for
                               other VC resources. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Traffic Class 7 is always routed to
                               VCm so it will be 0 in other VCs if applicable.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lpat : 1;

                            /* Bits[16:16], Access Type=RW/V/L, default=None*/

                            /*
                               When Set, this bit updates the Port Arbitration
                               logic from the Port Arbitration Table for the VC
                               resource. This bit is valid for all Switch
                               Ports, Root Ports that support peer-to-peer
                               traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this bit is
                               only valid when the Port Arbitration Table is
                               used by the selected Port Arbitration scheme
                               (that is indicated by a Set bit in the Port
                               Arbitration Capability field selected by Port
                               Arbitration Select). Software sets this bit to
                               signal hardware to update Port Arbitration logic
                               with new values stored in Port Arbitration
                               Table, clearing this bit has no effect. Software
                               uses the Port Arbitration Table Status bit to
                               confirm whether the new values of Port
                               Arbitration Table are completely latched by the
                               arbitration logic. This bit always returns 0b
                               when read. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 lpas : 3;

                            /* Bits[19:17], Access Type=RW/L, default=None*/

                            /*
                               This field configures the VC resource to provide
                               a particular Port Arbitration service. This
                               field is valid for RCRBs, Root Ports that
                               support peer-to-peer traffic, and Switch Ports,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. The
                               permissible value of this field is a number
                               corresponding to one of the asserted bits in the
                               Port Arbitration Capability field of the VC
                               resource. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcid : 3;

                            /* Bits[26:24], Access Type=RW/L, default=None*/

                            /*
                               This field assigns a ME VC ID (reserved) to the
                               VC resource. This field is valid for all
                               Functions. This field cannot be modified when
                               the VC is already enabled. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcen : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               This bit, when Set, enables a Virtual Channel
                               (see note 1 for exceptions). The Virtual Channel
                               is disabled when this bit is cleared. This bit
                               is valid for all Functions. Software must use
                               the VC Negotiation Pending bit to check whether
                               the VC negotiation is complete. Default value of
                               this bit is 1b for the first VC resource and is
                               0b for other VC resource(s). Notes: 1. This bit
                               is hardwired to 1b for the default VC (VC0),
                               i.e., writing to this bit has no effect for VC0.
                               2. To enable a Virtual Channel, the VC Enable
                               bits for that Virtual Channel must be Set in
                               both components on a Link. 3. To disable a
                               Virtual Channel, the VC Enable bits for that
                               Virtual Channel must be cleared in both
                               components on a Link. 4. Software must ensure
                               that no traffic is using a Virtual Channel at
                               the time it is disabled. 5. Software must fully
                               disable a Virtual Channel in both components on
                               a Link before re-enabling the Virtual Channel.
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} VCMRCTL_IIO_PCIEDMI_STRUCT;

/* VCMRSTS_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x100002b2)                                                      */
/*      SPRB0 (0x100002b2)                                                      */
/*      SPRHBM (0x100002b2)                                                     */
/*      SPRC0 (0x100002b2)                                                      */
/*      SPRMCC (0x100002b2)                                                     */
/*      SPRUCC (0x100002b2)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VCm Resource Status
*/


#define VCMRSTS_IIO_PCIEDMI_REG 0x0D0102B2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the coherency status of the
                               Port Arbitration Table associated with the VC
                               resource. This bit is valid for RCRBs, Root
                               Ports that support peer-to-peer traffic, and
                               Switch Ports, but is not valid for Endpoints or
                               Root Ports that do not support peer-to-peer
                               traffic. In addition, this bit is valid only
                               when the Port Arbitration Table is used by the
                               selected Port Arbitration for the VC resource.
                               This bit is Set by hardware when any entry of
                               the Port Arbitration Table is written to by
                               software. This bit is Cleared by hardware when
                               hardware finishes loading values stored in the
                               Port Arbitration Table after software sets the
                               Load Port Arbitration Table bit.
                            */
    UINT16 vcnp : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates whether the Virtual Channel
                               negotiation (initialization or disabling) is in
                               pending state. This bit is valid for all
                               Functions. The value of this bit is defined only
                               when the Link is in the DL_Active state and the
                               Virtual Channel is enabled (its VC Enable bit is
                               Set). When this bit is Set by hardware, it
                               indicates that the VC resource has not completed
                               the process of negotiation. This bit is Cleared
                               by hardware after the VC negotiation is complete
                               (on exit from the FC_INIT2 state). For VC0, this
                               bit is permitted to be hardwired to 0b. Before
                               using a Virtual Channel, software must check
                               whether the VC Negotiation Pending bits for that
                               Virtual Channel are Clear in both components on
                               the Link.
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} VCMRSTS_IIO_PCIEDMI_STRUCT;




/* IOSFDEVCLKGCTL_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x100002e4)                                                      */
/*      SPRB0 (0x100002e4)                                                      */
/*      SPRHBM (0x100002e4)                                                     */
/*      SPRC0 (0x100002e4)                                                      */
/*      SPRMCC (0x100002e4)                                                     */
/*      SPRUCC (0x100002e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* The IOSFDEVCLKGCTL is not defined in eEP for BWD. 
It is included for DMI in RC as an extension of Rootport definition.
*/


#define IOSFDEVCLKGCTL_IIO_PCIEDMI_REG 0x0D0102E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block controls the delay before going
                               into IDLE. 16 (default value) is the minimum
                               number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /* This bit when set enables clock gating to occur. */

  } Bits;
  UINT16 Data;

} IOSFDEVCLKGCTL_IIO_PCIEDMI_STRUCT;

/* SBDEVCLKGCTL_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x100002e6)                                                      */
/*      SPRB0 (0x100002e6)                                                      */
/*      SPRHBM (0x100002e6)                                                     */
/*      SPRC0 (0x100002e6)                                                      */
/*      SPRMCC (0x100002e6)                                                     */
/*      SPRUCC (0x100002e6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Sideband Device Clock Gate Control
*/


#define SBDEVCLKGCTL_IIO_PCIEDMI_REG 0x0D0102E6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer. On SPR, this also enables the
                               controller to request gating of the ART clock
                               used for PTM master time.
                            */

  } Bits;
  UINT16 Data;

} SBDEVCLKGCTL_IIO_PCIEDMI_STRUCT;

/* NTBDEVCLKGCTL_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x100002ea)                                                      */
/*      SPRB0 (0x100002ea)                                                      */
/*      SPRHBM (0x100002ea)                                                     */
/*      SPRC0 (0x100002ea)                                                      */
/*      SPRMCC (0x100002ea)                                                     */
/*      SPRUCC (0x100002ea)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* NTB Device Clock Gate Control
*/


#define NTBDEVCLKGCTL_IIO_PCIEDMI_REG 0x0D0102EA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block controls the delay before going
                               into IDLE. 16 (default value) is the minimum
                               number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /* This bit when set enables clock gating to occur. */

  } Bits;
  UINT16 Data;

} NTBDEVCLKGCTL_IIO_PCIEDMI_STRUCT;




/* PPD1_IIO_PCIEDMI_REG supported on:                                           */
/*      SPRA0 (0x200004c0)                                                      */
/*      SPRB0 (0x200004c0)                                                      */
/*      SPRHBM (0x200004c0)                                                     */
/*      SPRC0 (0x200004c0)                                                      */
/*      SPRMCC (0x200004c0)                                                     */
/*      SPRUCC (0x200004c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* PCIe Port Definition Control Register 1
*/


#define PPD1_IIO_PCIEDMI_REG 0x0D0204C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 npd : 3;

                            /* Bits[10:8], Access Type=RW/V/L, default=None*/

                            /*
                               000b - Reserved 001b - Operate as RP 010b -
                               Operate as NTB-NTB (NT Port) if supported 011b -
                               Operate as NTB-> DSP (NTB EP) if supported 100b
                               - Operate as DMI if supported The remaining
                               encoding are reserved. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . The default value is determined by
                               soft straps/fuse proxy. (DSP and NTB only)
                            */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pcfgor : 2;

                            /* Bits[13:12], Access Type=RW/V/L, default=None*/

                            /*
                               11 - Force Port to DSD/USP. 10 - Force Port to
                               USD/DSP. 01 - Reserved 00 - Use external Port
                               Configuration Strap pin if applicable to
                               determine USD (default) or DSD Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register . This field will be reserved
                               in case of pure DSP. Refer to Table 3-27, 'Port
                               Configuration' for more details.
                            */
    UINT32 pcfgsts : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit is written by hardware and shows the
                               result of the Port Configuration strap combined
                               with the Port Configuration override settings,
                               or an indication of IAL.io mode. 0 - Port is
                               configured as USD/DSP for NTB or proprietary RP,
                               else in non-IAL.io 1 - Port is configured as
                               DSD/USP for NTB or proprietary RP, else in
                               IAL.io. This field will be reserved in all other
                               devices.
                            */
    UINT32 cre : 1;

                            /* Bits[15:15], Access Type=RW/V/L, default=None*/

                            /*
                               This bit controls the ability of the external
                               side of the NTB to respond to transactions
                               (normal, UR, CRS). The PCIe link is expected to
                               be active after training in about 10-100ms from
                               platform reset deassertion. However, the
                               internal controller may take longer to boot, and
                               to initialize its registers. To allow longer
                               boot time, the CRE bit is used to ensure that
                               the Internal side and related functionality is
                               up and operational before allowing transactions
                               from the external side to be processed even
                               though link training could have been completed
                               prior. 0: External Link handles PCIe
                               transactions (configuration, memory, messages)
                               in the normal fashion during linkup state. 1:
                               External Link presents Configuration Retry
                               Status (CRS) to the incoming configuration cycle
                               on the external cycle in the linkup state. All
                               other requests will be URed. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . The NTB will respond with
                               Configuration Retry Status (CRS) on the PCIe
                               link for configuration cycles until such time
                               when the internal firmware completes
                               initialization of all internal resources. If the
                               external side sends any other request (memory,
                               messages) before this initialization is done, it
                               will be master aborted (UR) on the external
                               side. It is the responsibility of software to
                               adhere to this flow. This bit is reserved in
                               Downstream Port .
                            */
    UINT32 safemode_en : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               The default value of 1 is for non-RC ports (0
                               for RC ports)
                            */
    UINT32 safemode_exit : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               def 0 (write to unblock clearing of safemode),
                               self clears once safemode_en state has been
                               updated to 0 internally
                            */
    UINT32 safemode_mlw : 6;

                            /* Bits[23:18], Access Type=RO, default=0x00000000*/

                            /*
                               max link width to support in safe mode, 0 is
                               reserved. refer to MLW definition.
                            */
    UINT32 rsvd_24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cl : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RW-L bits of PPD1 register
                               only. 1b: Lock 0b: Unlocked Note: Lock Key bit
                               is located in the PPD1 Register . This bit is
                               self-locking. Once this bit is set to a 1b, this
                               key bit can not be unlocked. Writing a 0b has no
                               effect on this bit.
                            */

  } Bits;
  UINT32 Data;

} PPD1_IIO_PCIEDMI_STRUCT;





/* IBSTERRCRCSTS_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x200004e0)                                                      */
/*      SPRB0 (0x200004e0)                                                      */
/*      SPRHBM (0x200004e0)                                                     */
/*      SPRC0 (0x200004e0)                                                      */
/*      SPRMCC (0x200004e0)                                                     */
/*      SPRUCC (0x200004e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* REUT-ERR-CED0-3
*/


#define IBSTERRCRCSTS_IIO_PCIEDMI_REG 0x0D0204E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 crcecc2errcnt : 15;

                            /* Bits[14:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* CRC Error Counter */
    UINT32 crcecc2ovrflow : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* CRC Error Overflow */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} IBSTERRCRCSTS_IIO_PCIEDMI_STRUCT;

/* IBSTERRRCRVSTS_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x200004e4)                                                      */
/*      SPRB0 (0x200004e4)                                                      */
/*      SPRHBM (0x200004e4)                                                     */
/*      SPRC0 (0x200004e4)                                                      */
/*      SPRMCC (0x200004e4)                                                     */
/*      SPRUCC (0x200004e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* REUT-ERR-ECCRCV0-3
IBSTERRRCRVSTS[1-3] are valid only for multi-port configuration.
*/


#define IBSTERRRCRVSTS_IIO_PCIEDMI_REG 0x0D0204E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxerrcnt : 15;

                            /* Bits[14:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This field indicates the number of times the
                               link(s) has detected an 8b/10b receiver error.
                            */
    UINT32 rxerrcntovrflow : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit when 1b, indicates the receive error
                               counter has overflowed.
                            */
    UINT32 recovcnt : 15;

                            /* Bits[30:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This field indicates the number of times the
                               link(s) LTSSM state machine has entered the
                               recovery state.
                            */
    UINT32 linkrecovoverflow : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit when 1b, indicates the recovery counter
                               has overflowed.
                            */

  } Bits;
  UINT32 Data;

} IBSTERRRCRVSTS_IIO_PCIEDMI_STRUCT;










/* LTSSMSMSTS_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000520)                                                      */
/*      SPRB0 (0x20000520)                                                      */
/*      SPRHBM (0x20000520)                                                     */
/*      SPRC0 (0x20000520)                                                      */
/*      SPRMCC (0x20000520)                                                     */
/*      SPRUCC (0x20000520)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* LTSSM SM
*/


#define LTSSMSMSTS_IIO_PCIEDMI_REG 0x0D020520

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ltssmlnkup : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* LTSSM Link UP. */
    UINT32 dlactive : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* DL_Active */
    UINT32 lnkreversed : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* Link Reversed */
    UINT32 rcvratesup : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /* Received Rate Support. */
    UINT32 lnknum : 8;

                            /* Bits[13:6], Access Type=RO/V, default=0x00000000*/

                            /* Link Number. */
    UINT32 rsvd : 6;

                            /* Bits[19:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ltssmrxl0ssm : 3;

                            /* Bits[22:20], Access Type=RO/V, default=0x00000000*/

                            /* LTSSM RxL0s SM */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ltssmstatesub : 4;

                            /* Bits[27:24], Access Type=RO/V, default=0x00000000*/

                            /* LTSSM State Sub State. */
    UINT32 ltssmstatemain : 4;

                            /* Bits[31:28], Access Type=RO/V, default=0x00000000*/

                            /* LTSSM State Main. */

  } Bits;
  UINT32 Data;

} LTSSMSMSTS_IIO_PCIEDMI_STRUCT;

/* LTSSMSTATELOG0_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x20000524)                                                      */
/*      SPRB0 (0x20000524)                                                      */
/*      SPRHBM (0x20000524)                                                     */
/*      SPRC0 (0x20000524)                                                      */
/*      SPRMCC (0x20000524)                                                     */
/*      SPRUCC (0x20000524)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM STATE LOG0
*/


#define LTSSMSTATELOG0_IIO_PCIEDMI_REG 0x0D020524

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 last8main : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               [3:0] present ltssm (or last if stopped) (newest
                               state) [7:4] prior state [11:8] [15:12] [19:16]
                               [23:20] [27:24] [31:28] oldest state logged
                            */

  } Bits;
  UINT32 Data;

} LTSSMSTATELOG0_IIO_PCIEDMI_STRUCT;

/* LTSSMSTATELOG1_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x20000528)                                                      */
/*      SPRB0 (0x20000528)                                                      */
/*      SPRHBM (0x20000528)                                                     */
/*      SPRC0 (0x20000528)                                                      */
/*      SPRMCC (0x20000528)                                                     */
/*      SPRUCC (0x20000528)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM STATE LOG1
*/


#define LTSSMSTATELOG1_IIO_PCIEDMI_REG 0x0D020528

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 last8sub : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               [3:0] present ltssm (or last if stopped) (newest
                               state) [7:4] prior state [11:8] [15:12] [19:16]
                               [23:20] [27:24] [31:28] oldest state logged
                            */

  } Bits;
  UINT32 Data;

} LTSSMSTATELOG1_IIO_PCIEDMI_STRUCT;

/* LTSSMSTATELOG2_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x2000052c)                                                      */
/*      SPRB0 (0x2000052c)                                                      */
/*      SPRHBM (0x2000052c)                                                     */
/*      SPRC0 (0x2000052c)                                                      */
/*      SPRMCC (0x2000052c)                                                     */
/*      SPRUCC (0x2000052c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM STATE LOG2
*/


#define LTSSMSTATELOG2_IIO_PCIEDMI_REG 0x0D02052C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 last8rxl0s : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               [3:0] present ltssm (or last if stopped) (newest
                               state) [7:4] prior state [11:8] [15:12] [19:16]
                               [23:20] [27:24] [31:28] oldest state logged
                            */

  } Bits;
  UINT32 Data;

} LTSSMSTATELOG2_IIO_PCIEDMI_STRUCT;

/* LTSSMSTATELOGCTL_IIO_PCIEDMI_REG supported on:                               */
/*      SPRA0 (0x20000530)                                                      */
/*      SPRB0 (0x20000530)                                                      */
/*      SPRHBM (0x20000530)                                                     */
/*      SPRC0 (0x20000530)                                                      */
/*      SPRMCC (0x20000530)                                                     */
/*      SPRUCC (0x20000530)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM STATE LOG Control
*/


#define LTSSMSTATELOGCTL_IIO_PCIEDMI_REG 0x0D020530

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               0-->1 transition clears log registers and
                               restarts logging
                            */
    UINT32 stop : 8;

                            /* Bits[8:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Match register to freeze logging [7:4] LTSSM sub
                               state to match [3:0] LTSSM main state to match
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTSSMSTATELOGCTL_IIO_PCIEDMI_STRUCT;



/* PT0PHYCLKGCTL_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x10000544)                                                      */
/*      SPRB0 (0x10000544)                                                      */
/*      SPRHBM (0x10000544)                                                     */
/*      SPRC0 (0x10000544)                                                      */
/*      SPRMCC (0x10000544)                                                     */
/*      SPRUCC (0x10000544)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 Physical Clock Gate Control
*/


#define PT0PHYCLKGCTL_IIO_PCIEDMI_REG 0x0D010544

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0PHYCLKGCTL_IIO_PCIEDMI_STRUCT;

/* PLLSTBYCTL_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x2000054c)                                                      */
/*      SPRB0 (0x2000054c)                                                      */
/*      SPRHBM (0x2000054c)                                                     */
/*      SPRC0 (0x2000054c)                                                      */
/*      SPRMCC (0x2000054c)                                                     */
/*      SPRUCC (0x2000054c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* This register is only valid for project specific w/ PLLSTBY feature.
*/


#define PLLSTBYCTL_IIO_PCIEDMI_REG 0x0D02054C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pclk_trunk_cge : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               0: disable pclk_req de-assertion 1: allow
                               pclk_req to de-assert on idle
                            */
    UINT32 rsvd_5 : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 p2vsp1 : 1;

                            /* Bits[8:8], Access Type=RW, default=None*/

                            /*
                               0 = lane in P1 equal to idle for PLL standby
                               (see PIPECTL for P2 disable) 1 = lane in P2
                               equal to idle for PLL standby
                            */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pclk_ack1toreq0 : 4;

                            /* Bits[15:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Min time to assert pclk_req after pclk_ack
                               asserts 0: 3 AUXCLK periods (i.e. auxclk=25Mhz,
                               120ns) 1-15: (val+1)*64ns
                            */
    UINT32 pclk_idletoreq0 : 4;

                            /* Bits[19:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Time to wait after reaching idle state before
                               de-asserting pclk_req 0: 3 AUXCLK periods (i.e.
                               auxclk=25Mhz, 120ns) 1-15: (val+1)*64ns
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PLLSTBYCTL_IIO_PCIEDMI_STRUCT;


/* PLKCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000558)                                                      */
/*      SPRB0 (0x10000558)                                                      */
/*      SPRHBM (0x10000558)                                                     */
/*      SPRC0 (0x10000558)                                                      */
/*      SPRMCC (0x10000558)                                                     */
/*      SPRUCC (0x10000558)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX2                                             */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* Personality Lock Key Control
*/


#define PLKCTL_IIO_PCIEDMI_REG 0x0D010558

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cl : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits (capabilities,
                               next capability pointer, SSID/SVID, slot
                               register, etc) bits for the function. 1b: Lock
                               0b: Unlocked Note: Lock Key bit is located in
                               the PLKCTL Register . This bit is self-locking.
                               Once this bit is set to a 1b, this key bit can
                               not be unlocked. Writing a 0b has no effect on
                               this bit.
                            */
    UINT16 tlcl : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in
                               XPEINJ[1:0], XPCDTHROTTLEP,N,C, XPTDEF*,
                               MBAR01CTL EXPPTMBARCTL, XPERRINJCTL,
                               SWERRINJCTL, IDFERRINJCTL. 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 llcl : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in the
                               following CSRs. XPLDEF XPLDEF2 LLRBERRINJCTL
                               RXPERRINJCTL CRCERRINJCTL CRCERRINJMSK RTRYCTL
                               PACKTHRESH ECRCERRINJCTL 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 plcl : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in the
                               following CSRs. OBEINJCTL 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit. Only applicable to PCIe Phy Layer, and
                               should be treated as reserved if not applicable.
                            */
    UINT16 rsvd_5 : 11;

                            /* Bits[15:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PLKCTL_IIO_PCIEDMI_STRUCT;

/* XPPMDL0_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000580)                                                      */
/*      SPRB0 (0x20000580)                                                      */
/*      SPRHBM (0x20000580)                                                     */
/*      SPRC0 (0x20000580)                                                      */
/*      SPRMCC (0x20000580)                                                     */
/*      SPRUCC (0x20000580)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data Low Bits
*/


#define XPPMDL0_IIO_PCIEDMI_REG 0x0D020580

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* Low order bits [31:0] for PM data counter[1:0]. */

  } Bits;
  UINT32 Data;

} XPPMDL0_IIO_PCIEDMI_STRUCT;

/* XPPMDL1_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000584)                                                      */
/*      SPRB0 (0x20000584)                                                      */
/*      SPRHBM (0x20000584)                                                     */
/*      SPRC0 (0x20000584)                                                      */
/*      SPRMCC (0x20000584)                                                     */
/*      SPRUCC (0x20000584)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data Low Bits
*/


#define XPPMDL1_IIO_PCIEDMI_REG 0x0D020584

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* Low order bits [31:0] for PM data counter[1:0]. */

  } Bits;
  UINT32 Data;

} XPPMDL1_IIO_PCIEDMI_STRUCT;

/* XPPMCL0_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000588)                                                      */
/*      SPRB0 (0x20000588)                                                      */
/*      SPRHBM (0x20000588)                                                     */
/*      SPRC0 (0x20000588)                                                      */
/*      SPRMCC (0x20000588)                                                     */
/*      SPRUCC (0x20000588)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare Low Bits
*/


#define XPPMCL0_IIO_PCIEDMI_REG 0x0D020588

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0xFFFFFFFF*/

                            /*
                               Low order bits [31:0] for PM compare
                               register[1:0].
                            */

  } Bits;
  UINT32 Data;

} XPPMCL0_IIO_PCIEDMI_STRUCT;

/* XPPMCL1_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x2000058c)                                                      */
/*      SPRB0 (0x2000058c)                                                      */
/*      SPRHBM (0x2000058c)                                                     */
/*      SPRC0 (0x2000058c)                                                      */
/*      SPRMCC (0x2000058c)                                                     */
/*      SPRUCC (0x2000058c)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare Low Bits
*/


#define XPPMCL1_IIO_PCIEDMI_REG 0x0D02058C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0xFFFFFFFF*/

                            /*
                               Low order bits [31:0] for PM compare
                               register[1:0].
                            */

  } Bits;
  UINT32 Data;

} XPPMCL1_IIO_PCIEDMI_STRUCT;

/* XPPMDH_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000590)                                                      */
/*      SPRB0 (0x10000590)                                                      */
/*      SPRHBM (0x10000590)                                                     */
/*      SPRC0 (0x10000590)                                                      */
/*      SPRMCC (0x10000590)                                                     */
/*      SPRUCC (0x10000590)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data High Bits
*/


#define XPPMDH_IIO_PCIEDMI_REG 0x0D010590

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cnth0 : 4;

                            /* Bits[3:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               High order bits [35:32] of the 36-bit PM Data0
                               register.
                            */
    UINT16 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 cnth1 : 4;

                            /* Bits[11:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               High order bits [35:32] of the 36-bit PM Data1
                               register.
                            */
    UINT16 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} XPPMDH_IIO_PCIEDMI_STRUCT;

/* XPPMCH_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x10000592)                                                      */
/*      SPRB0 (0x10000592)                                                      */
/*      SPRHBM (0x10000592)                                                     */
/*      SPRC0 (0x10000592)                                                      */
/*      SPRMCC (0x10000592)                                                     */
/*      SPRUCC (0x10000592)                                                     */
/* Register default value on SPRA0: 0x00000F0F                                  */
/* Register default value on SPRB0: 0x00000F0F                                  */
/* Register default value on SPRHBM: 0x00000F0F                                 */
/* Register default value on SPRC0: 0x00000F0F                                  */
/* Register default value on SPRMCC: 0x00000F0F                                 */
/* Register default value on SPRUCC: 0x00000F0F                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare High Bits
*/


#define XPPMCH_IIO_PCIEDMI_REG 0x0D010592

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cmph0 : 4;

                            /* Bits[3:0], Access Type=RW/V, default=0x0000000F*/

                            /*
                               High order bits [35:32] of the 36-bit PM
                               Compare0 register.
                            */
    UINT16 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 cmph1 : 4;

                            /* Bits[11:8], Access Type=RW/V, default=0x0000000F*/

                            /*
                               High order bits [35:32] of the 36-bit PM
                               Compare1 register.
                            */
    UINT16 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} XPPMCH_IIO_PCIEDMI_STRUCT;

/* XPPMR0_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000594)                                                      */
/*      SPRB0 (0x20000594)                                                      */
/*      SPRHBM (0x20000594)                                                     */
/*      SPRC0 (0x20000594)                                                      */
/*      SPRMCC (0x20000594)                                                     */
/*      SPRUCC (0x20000594)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Response Control
*/


#define XPPMR0_IIO_PCIEDMI_REG 0x0D020594

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntrst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit resets the following bit
                               fields. This only applies to the set of
                               registers for this PM block. Setting this bit
                               resets the PMD counter, the associated adder
                               storage register and the count mode state latch
                               (see bits CNTMD) to the default state. It does
                               not change the state of this PMR register, the
                               event selections, or the value in the compare
                               register. Note: This bit must be cleared by
                               software, otherwise the counters remain in
                               reset. There is also a reset bit in the
                               XPPERFCON register which clears all PM registers
                               including the PMR.
                            */
    UINT32 ovs : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures the overflow event from
                               the PMD counter. This bit remains set once an
                               event is reported even though the original
                               condition is no longer valid. Writing a logic
                               '1' clears the bit.
                            */
    UINT32 cmpstat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures a count compare event.
                               0: no event 1: count compare - PMD counter
                               greater than PMC register when in compare mode.
                               This bit remains set once an event is reported
                               even though the original condition is no longer
                               valid. Writing a logic '1' clears the bit.
                            */
    UINT32 pto : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects what the signal is
                               communicated to the chip's event logic
                               structure. 00: No cluster trigger output from
                               PerfMons or header match. 01: PM Status. 10: PM
                               Event Detection. 11: Address Header Match
                            */
    UINT32 pmssig : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0: Level output from status/overflow signals. 1:
                               Pulsed output from status/overflow signals.
                            */
    UINT32 cmpmd : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               This field defines how the PMC (compare)
                               register is to be used. 00: compare mode
                               disabled (PMC register not used) sig p = sig s
                               01: max compare only: The PMC register value is
                               compared with the counter value. If the counter
                               value is greater then the Compare Status
                               (CMPSTAT) will be set. sig p = sig n 10: max
                               compare with update of PMC at end of sample: The
                               PMC register value is compared with the counter
                               value, and if the counter value is greater, the
                               PMC register is updated with the counter value.
                               Note, the Compare Status field is not affected
                               in this mode. sig p = sig n 11: Reserved
                            */
    UINT32 rstevsel : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field will reset the PMD counter. For
                               details regarding usage and pair mode operation
                               see Chapter 21. 000: No reset condition 001:
                               Partner's event status: When the partner counter
                               causes an event status condition to be
                               activated, either by a counter overflow or max
                               comparison, then this counter will reset and
                               continue counting. 010: Partners PME register
                               event: When the partner counter detects a match
                               condition which meets its selected PME register
                               qualifications, then this counter will reset and
                               continue counting. 011: This PM counter's status
                               output. 100: GE[0], from the Global Debug Event
                               Block. 101: GE[1], from the Global Debug Event
                               Block. 110: GE[2], from the Global Debug Event
                               Block. 111: GE[3], from the Global Debug Event
                               Block. Note: The GEs used are dependent on bit
                               31 (LOCGLOBEVSEL). If bit 31 is used, local
                               events will be used instead of global events.
                            */
    UINT32 cens : 3;

                            /* Bits[13:11], Access Type=RW, default=0x00000000*/

                            /*
                               These bits identify which input enables the
                               counter. Default value disables counting. 000:
                               Disabled 001: Local Count Enabled (LCEN). This
                               bit is always a logic 1. 010: Partner counter's
                               event status (max compare or overflow) 011:
                               Header MatchOut signal 100: GE[0], from the
                               Global Debug Event Block 101: GE[1], from the
                               Global Debug Event Block 110: GE[2], from the
                               Global Debug Event Block 111: GE[3], from the
                               Global Debug Event Block Note: Address/Header
                               MatchOut signal must align with PMEVL,H events
                               for this to be effective. Note: The GEs used are
                               dependent on bit 31 (LOCGLOBEVSEL). If bit 31 is
                               used, local events will be used instead of
                               global events.
                            */
    UINT32 cntmd : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets how the events will be counted.
                               00: Count clocks for the duration of event
                               signal is active. 01: Count rising edge events
                               (for active low signals EVPOLINV must be set for
                               correct measurements). 10: Count clocks
                               continuously after the event was asserted. The
                               latched state of this condition is cleared by
                               PerfMon reset block, PMR.CNTRST bit, or
                               XPPERFCON.GRST. 11: Enable queue threshold
                               measuring. This mode will reassign the event
                               selection registers from both PerfMons, selects
                               a modified count enable, and enables add/sub
                               operation. Selecting this mode will not allow
                               normal PerfMon operations to occur. To simplify
                               the logic a strict assignment of functions is
                               applied. PM0's event selection registers are
                               assigned to the add (increment) function and
                               PM1's event selection registers are assigned to
                               the subtract (decrement) function. When both PM0
                               and PM1 events are asserted or when both are not
                               asserted do not add or subtract values from the
                               queue. PM0Ev.........PM1Ev............PM
                               condition
                               ....0...................0...................Do
                               not add/sub ....1...................0...........
                               ..........Add queue value ....0.................
                               ..1.....................Sub queue value
                               ....1...................1...................Do
                               not add/sub Setting this mode enables the PM
                               event registers as described but it also enables
                               the selection of a Qempty signal to be used a
                               count enable signal. The count enable is latched
                               high continuously and only cleared with PM
                               global reset or local counter reset. The
                               THRQMSRSTR bit field selects which bit[3] of
                               each nibble in each byte lane that acts as a
                               count enable. Once this event occurs it is
                               latched and queue counting begins. Because this
                               signal is latched a counter reset or PERCON
                               global reset is required to start another
                               measurement. This latched condition is cleared
                               by the PMR.CNTRST bit, or XPPERFCON.GRST.
                            */
    UINT32 evpolinv : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               This bit inverts the polarity of the conditioned
                               event signal. 0: No inversion 1: Invert the
                               polarity of the conditioned event signal
                            */
    UINT32 cntevsel : 2;

                            /* Bits[18:17], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the condition for incrementing the
                               performance monitor counter. 00: Event source
                               selected by PMEVL,H 01: Partner event status
                               (max compare or overflow) 10: All clocks when
                               enabled 11: Reserved
                            */
    UINT32 egs : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which event register to use for
                               performance monitoring. 00: Bus events
                               (XPPMEVL,H register) 01: Resource utilizations
                               (in the XPPMER register) 10: Queue measurement
                               (in the XPPMER register) 11: FIFO queue
                               measurements (selects 1h on the queue
                               measurement bus).
                            */
    UINT32 ldes : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This selection enables the local debug bus to be
                               selected for event counting. Enabling this
                               selection changes the PMEVL,H register into
                               24bits of DFx masking and matching. 0: Disable
                               DFx event monitoring 1: Enable DFx event
                               monitoring.
                            */
    UINT32 dfxlnsel : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field is only active when LDES is
                               asserted. These bits select which set of 3 byte
                               lanes from the 72 bit (9 byte lane) local debug
                               bus is active for DFx event counting with the
                               PerfMons. 00: Local Debug Byte Lanes 0-2 01:
                               Local Debug Byte Lanes 3-5 10: Local Debug Byte
                               Lanes 6-8 11: Reserved
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rstpulsen : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will select a pulsed version of
                               the reset signal source in the reset block. 0:
                               Normal reset signaling 1: Select a pulsed reset
                               from the reset signal sources.
                            */
    UINT32 latcntensel : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               0: Normal PM operation. Use CENS as count
                               enable. 1: Use Latched count enable from queue
                               empty events
                            */
    UINT32 frcpmdaddz : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               This feature is used with the queue measurement
                               bus. When this bit is set the value on the queue
                               measurement bus is added to zero so the result
                               in PMD will always reflect the value from the
                               queue measurement bus. 0: Do not add zero.
                               Normal PerfMon operation. 1: Add zero with input
                               queue bus.
                            */
    UINT32 notgrtcmp : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               0: PMC will compare a greater than function.
                               When clear the perfmon status will assert when
                               the PMD is greater than the PMC. 1: PMC will
                               compare with NOT(greater than) function. When
                               set the perfmon status will assert when the PMD
                               is less than or equal to the PMC. CSPEC NOTE:
                               This bit was not in Seaburg.
                            */
    UINT32 locglobevsel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This register bit allows for standalone cluster
                               simulation. Normally the global events are used
                               as control signals for the performance monitors.
                               When this bit is set to1, the internal
                               IPTRIG[0-3] signals are selected respectively in
                               place of the external GE[0-3] signals. Note: It
                               is possible to have one PERFMON use the internal
                               events, while the other PERFMON uses the
                               external events. 0:Global events are selected
                               1:Local events are selected
                            */

  } Bits;
  UINT32 Data;

} XPPMR0_IIO_PCIEDMI_STRUCT;

/* XPPMR1_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000598)                                                      */
/*      SPRB0 (0x20000598)                                                      */
/*      SPRHBM (0x20000598)                                                     */
/*      SPRC0 (0x20000598)                                                      */
/*      SPRMCC (0x20000598)                                                     */
/*      SPRUCC (0x20000598)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Response Control
*/


#define XPPMR1_IIO_PCIEDMI_REG 0x0D020598

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntrst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit resets the following bit
                               fields. This only applies to the set of
                               registers for this PM block. Setting this bit
                               resets the PMD counter, the associated adder
                               storage register and the count mode state latch
                               (see bits CNTMD) to the default state. It does
                               not change the state of this PMR register, the
                               event selections, or the value in the compare
                               register. Note: This bit must be cleared by
                               software, otherwise the counters remain in
                               reset. There is also a reset bit in the
                               XPPERFCON register which clears all PM registers
                               including the PMR.
                            */
    UINT32 ovs : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures the overflow event from
                               the PMD counter. This bit remains set once an
                               event is reported even though the original
                               condition is no longer valid. Writing a logic
                               '1' clears the bit.
                            */
    UINT32 cmpstat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures a count compare event.
                               0: no event 1: count compare - PMD counter
                               greater than PMC register when in compare mode.
                               This bit remains set once an event is reported
                               even though the original condition is no longer
                               valid. Writing a logic '1' clears the bit.
                            */
    UINT32 pto : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects what the signal is
                               communicated to the chip's event logic
                               structure. 00: No cluster trigger output from
                               PerfMons or header match. 01: PM Status. 10: PM
                               Event Detection. 11: Address Header Match
                            */
    UINT32 pmssig : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0: Level output from status/overflow signals. 1:
                               Pulsed output from status/overflow signals.
                            */
    UINT32 cmpmd : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               This field defines how the PMC (compare)
                               register is to be used. 00: compare mode
                               disabled (PMC register not used) sig p = sig s
                               01: max compare only: The PMC register value is
                               compared with the counter value. If the counter
                               value is greater then the Compare Status
                               (CMPSTAT) will be set. sig p = sig n 10: max
                               compare with update of PMC at end of sample: The
                               PMC register value is compared with the counter
                               value, and if the counter value is greater, the
                               PMC register is updated with the counter value.
                               Note, the Compare Status field is not affected
                               in this mode. sig p = sig n 11: Reserved
                            */
    UINT32 rstevsel : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field will reset the PMD counter. For
                               details regarding usage and pair mode operation
                               see Chapter 21. 000: No reset condition 001:
                               Partner's event status: When the partner counter
                               causes an event status condition to be
                               activated, either by a counter overflow or max
                               comparison, then this counter will reset and
                               continue counting. 010: Partners PME register
                               event: When the partner counter detects a match
                               condition which meets its selected PME register
                               qualifications, then this counter will reset and
                               continue counting. 011: This PM counter's status
                               output. 100: GE[0], from the Global Debug Event
                               Block. 101: GE[1], from the Global Debug Event
                               Block. 110: GE[2], from the Global Debug Event
                               Block. 111: GE[3], from the Global Debug Event
                               Block. Note: The GEs used are dependent on bit
                               31 (LOCGLOBEVSEL). If bit 31 is used, local
                               events will be used instead of global events.
                            */
    UINT32 cens : 3;

                            /* Bits[13:11], Access Type=RW, default=0x00000000*/

                            /*
                               These bits identify which input enables the
                               counter. Default value disables counting. 000:
                               Disabled 001: Local Count Enabled (LCEN). This
                               bit is always a logic 1. 010: Partner counter's
                               event status (max compare or overflow) 011:
                               Header MatchOut signal 100: GE[0], from the
                               Global Debug Event Block 101: GE[1], from the
                               Global Debug Event Block 110: GE[2], from the
                               Global Debug Event Block 111: GE[3], from the
                               Global Debug Event Block Note: Address/Header
                               MatchOut signal must align with PMEVL,H events
                               for this to be effective. Note: The GEs used are
                               dependent on bit 31 (LOCGLOBEVSEL). If bit 31 is
                               used, local events will be used instead of
                               global events.
                            */
    UINT32 cntmd : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets how the events will be counted.
                               00: Count clocks for the duration of event
                               signal is active. 01: Count rising edge events
                               (for active low signals EVPOLINV must be set for
                               correct measurements). 10: Count clocks
                               continuously after the event was asserted. The
                               latched state of this condition is cleared by
                               PerfMon reset block, PMR.CNTRST bit, or
                               XPPERFCON.GRST. 11: Enable queue threshold
                               measuring. This mode will reassign the event
                               selection registers from both PerfMons, selects
                               a modified count enable, and enables add/sub
                               operation. Selecting this mode will not allow
                               normal PerfMon operations to occur. To simplify
                               the logic a strict assignment of functions is
                               applied. PM0's event selection registers are
                               assigned to the add (increment) function and
                               PM1's event selection registers are assigned to
                               the subtract (decrement) function. When both PM0
                               and PM1 events are asserted or when both are not
                               asserted do not add or subtract values from the
                               queue. PM0Ev.........PM1Ev............PM
                               condition
                               ....0...................0...................Do
                               not add/sub ....1...................0...........
                               ..........Add queue value ....0.................
                               ..1.....................Sub queue value
                               ....1...................1...................Do
                               not add/sub Setting this mode enables the PM
                               event registers as described but it also enables
                               the selection of a Qempty signal to be used a
                               count enable signal. The count enable is latched
                               high continuously and only cleared with PM
                               global reset or local counter reset. The
                               THRQMSRSTR bit field selects which bit[3] of
                               each nibble in each byte lane that acts as a
                               count enable. Once this event occurs it is
                               latched and queue counting begins. Because this
                               signal is latched a counter reset or PERCON
                               global reset is required to start another
                               measurement. This latched condition is cleared
                               by the PMR.CNTRST bit, or XPPERFCON.GRST.
                            */
    UINT32 evpolinv : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               This bit inverts the polarity of the conditioned
                               event signal. 0: No inversion 1: Invert the
                               polarity of the conditioned event signal
                            */
    UINT32 cntevsel : 2;

                            /* Bits[18:17], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the condition for incrementing the
                               performance monitor counter. 00: Event source
                               selected by PMEVL,H 01: Partner event status
                               (max compare or overflow) 10: All clocks when
                               enabled 11: Reserved
                            */
    UINT32 egs : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which event register to use for
                               performance monitoring. 00: Bus events
                               (XPPMEVL,H register) 01: Resource utilizations
                               (in the XPPMER register) 10: Queue measurement
                               (in the XPPMER register) 11: FIFO queue
                               measurements (selects 1h on the queue
                               measurement bus).
                            */
    UINT32 ldes : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This selection enables the local debug bus to be
                               selected for event counting. Enabling this
                               selection changes the PMEVL,H register into
                               24bits of DFx masking and matching. 0: Disable
                               DFx event monitoring 1: Enable DFx event
                               monitoring.
                            */
    UINT32 dfxlnsel : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field is only active when LDES is
                               asserted. These bits select which set of 3 byte
                               lanes from the 72 bit (9 byte lane) local debug
                               bus is active for DFx event counting with the
                               PerfMons. 00: Local Debug Byte Lanes 0-2 01:
                               Local Debug Byte Lanes 3-5 10: Local Debug Byte
                               Lanes 6-8 11: Reserved
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rstpulsen : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will select a pulsed version of
                               the reset signal source in the reset block. 0:
                               Normal reset signaling 1: Select a pulsed reset
                               from the reset signal sources.
                            */
    UINT32 latcntensel : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               0: Normal PM operation. Use CENS as count
                               enable. 1: Use Latched count enable from queue
                               empty events
                            */
    UINT32 frcpmdaddz : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               This feature is used with the queue measurement
                               bus. When this bit is set the value on the queue
                               measurement bus is added to zero so the result
                               in PMD will always reflect the value from the
                               queue measurement bus. 0: Do not add zero.
                               Normal PerfMon operation. 1: Add zero with input
                               queue bus.
                            */
    UINT32 notgrtcmp : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               0: PMC will compare a greater than function.
                               When clear the perfmon status will assert when
                               the PMD is greater than the PMC. 1: PMC will
                               compare with NOT(greater than) function. When
                               set the perfmon status will assert when the PMD
                               is less than or equal to the PMC. CSPEC NOTE:
                               This bit was not in Seaburg.
                            */
    UINT32 locglobevsel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This register bit allows for standalone cluster
                               simulation. Normally the global events are used
                               as control signals for the performance monitors.
                               When this bit is set to1, the internal
                               IPTRIG[0-3] signals are selected respectively in
                               place of the external GE[0-3] signals. Note: It
                               is possible to have one PERFMON use the internal
                               events, while the other PERFMON uses the
                               external events. 0:Global events are selected
                               1:Local events are selected
                            */

  } Bits;
  UINT32 Data;

} XPPMR1_IIO_PCIEDMI_STRUCT;

/* XPPMEVL0_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x2000059c)                                                      */
/*      SPRB0 (0x2000059c)                                                      */
/*      SPRHBM (0x2000059c)                                                     */
/*      SPRC0 (0x2000059c)                                                      */
/*      SPRMCC (0x2000059c)                                                     */
/*      SPRUCC (0x2000059c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVH except where noted.
The qualifications for fields in this register are as follows:
PMEV Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) and INOUTBND) + GESEL
 IO_Cfg_Write_event = (REQCMP[0] and CMPR[1] and RDWR[1] and DATALEN and (TTYP[2] + (TTYP[1] and CFGTYP)))
 IO_Cfg_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and (TTYP[2] + (FMTTYP[1] and CFGTYP)))
 Mem_Write_event = (REQCMP[0] and CMPR[0] and RDWR[1] and DATALEN and TTYP[3] and LOCK and EXTADDR and SNATTR)
 Note: An outbound memory write does not have a snoop attribute as an inbound memory write has. So the user should set SNATTR='11' for outbound memory write transaction event counting.
 Mem_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and ((TTYP[3] and LOCK and EXTADDR and SNATTR) + TTYP[2] + (TTYP[1] and CFGTYP)))
 Note: For outbound memory reads there is no concept of issuing a snoop cycle. The user should select SNATTR='11' for either snoop attribute.
 Msg_event = (TTYP[0] and DND)
 (INOUTBND[0] and (MatchEq) + (IOBND[1] and (MatchEq)
Note: Setting both bits in INOUTBND is acceptable however the performance data gathered will not be accurate since once one header can be counted at a time.
*/


#define XPPMEVL0_IIO_PCIEDMI_REG 0x0D02059C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpstat : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               (for Completion Packet) or message encoding (for
                               Request Packet). 1xxx: Completer abort x1xx:
                               Configuration request retry status (only used
                               for receive completions) xx1x: Unsupported
                               request xxx1: Successful completion 1111: Any
                               status
                            */
    UINT32 datlen : 7;

                            /* Bits[10:4], Access Type=RW, default=0x00000000*/

                            /*
                               1xxxxxx: (129 to 256 bytes) x1xxxxx: (65 to 128
                               bytes) xx1xxxx: (33 to 64 bytes) xxx1xxx: (17 to
                               32 bytes) xxxx1xx: (9 to 16 bytes) xxxxx1x: (0
                               to 8 bytes) xxxxxx1: 0 bytes, used for a special
                               zero length encoded packets 111111: Any Data
                               length
                            */
    UINT32 ttyp : 5;

                            /* Bits[15:11], Access Type=RW, default=0x00000000*/

                            /*
                               (ORed group) 1xxxx: Trusted x1xxx: Memory xx1xx:
                               IO xxx1x: Configuration xxxx1: Messages 11111:
                               Any transaction type
                            */
    UINT32 cfgtyp : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               (If Config cycle Space selected) x1: Type 0 1x:
                               Type 1 11: Either
                            */
    UINT32 extaddr : 2;

                            /* Bits[19:18], Access Type=RW, default=0x00000000*/

                            /* x1: 32b addressing 1x: 64b addressing 11: Either */
    UINT32 lock : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* x1: No lock 1x: Lock 11: Either */
    UINT32 cmpr : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               (Request packet only) x1: No completion required
                               1x: Completion required 11: Either
                            */
    UINT32 rdwr : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /* x1: Read 1x: Write 11: Either */
    UINT32 reqcmp : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request packet 1x: Completion packet 11:
                               Either
                            */
    UINT32 snattr : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Snoop required 1x: No snoop required 11:
                               Either
                            */
    UINT32 dnd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request/completion/message packet with data
                               1x: Request/completion/message packet without
                               data
                            */

  } Bits;
  UINT32 Data;

} XPPMEVL0_IIO_PCIEDMI_STRUCT;

/* XPPMEVL1_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200005a0)                                                      */
/*      SPRB0 (0x200005a0)                                                      */
/*      SPRHBM (0x200005a0)                                                     */
/*      SPRC0 (0x200005a0)                                                      */
/*      SPRMCC (0x200005a0)                                                     */
/*      SPRUCC (0x200005a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVH except where noted.
The qualifications for fields in this register are as follows:
PMEV Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) and INOUTBND) + GESEL
 IO_Cfg_Write_event = (REQCMP[0] and CMPR[1] and RDWR[1] and DATALEN and (TTYP[2] + (TTYP[1] and CFGTYP)))
 IO_Cfg_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and (TTYP[2] + (FMTTYP[1] and CFGTYP)))
 Mem_Write_event = (REQCMP[0] and CMPR[0] and RDWR[1] and DATALEN and TTYP[3] and LOCK and EXTADDR and SNATTR)
 Note: An outbound memory write does not have a snoop attribute as an inbound memory write has. So the user should set SNATTR='11' for outbound memory write transaction event counting.
 Mem_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and ((TTYP[3] and LOCK and EXTADDR and SNATTR) + TTYP[2] + (TTYP[1] and CFGTYP)))
 Note: For outbound memory reads there is no concept of issuing a snoop cycle. The user should select SNATTR='11' for either snoop attribute.
 Msg_event = (TTYP[0] and DND)
 (INOUTBND[0] and (MatchEq) + (IOBND[1] and (MatchEq)
Note: Setting both bits in INOUTBND is acceptable however the performance data gathered will not be accurate since once one header can be counted at a time.
*/


#define XPPMEVL1_IIO_PCIEDMI_REG 0x0D0205A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpstat : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               (for Completion Packet) or message encoding (for
                               Request Packet). 1xxx: Completer abort x1xx:
                               Configuration request retry status (only used
                               for receive completions) xx1x: Unsupported
                               request xxx1: Successful completion 1111: Any
                               status
                            */
    UINT32 datlen : 7;

                            /* Bits[10:4], Access Type=RW, default=0x00000000*/

                            /*
                               1xxxxxx: (129 to 256 bytes) x1xxxxx: (65 to 128
                               bytes) xx1xxxx: (33 to 64 bytes) xxx1xxx: (17 to
                               32 bytes) xxxx1xx: (9 to 16 bytes) xxxxx1x: (0
                               to 8 bytes) xxxxxx1: 0 bytes, used for a special
                               zero length encoded packets 111111: Any Data
                               length
                            */
    UINT32 ttyp : 5;

                            /* Bits[15:11], Access Type=RW, default=0x00000000*/

                            /*
                               (ORed group) 1xxxx: Trusted x1xxx: Memory xx1xx:
                               IO xxx1x: Configuration xxxx1: Messages 11111:
                               Any transaction type
                            */
    UINT32 cfgtyp : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               (If Config cycle Space selected) x1: Type 0 1x:
                               Type 1 11: Either
                            */
    UINT32 extaddr : 2;

                            /* Bits[19:18], Access Type=RW, default=0x00000000*/

                            /* x1: 32b addressing 1x: 64b addressing 11: Either */
    UINT32 lock : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* x1: No lock 1x: Lock 11: Either */
    UINT32 cmpr : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               (Request packet only) x1: No completion required
                               1x: Completion required 11: Either
                            */
    UINT32 rdwr : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /* x1: Read 1x: Write 11: Either */
    UINT32 reqcmp : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request packet 1x: Completion packet 11:
                               Either
                            */
    UINT32 snattr : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Snoop required 1x: No snoop required 11:
                               Either
                            */
    UINT32 dnd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request/completion/message packet with data
                               1x: Request/completion/message packet without
                               data
                            */

  } Bits;
  UINT32 Data;

} XPPMEVL1_IIO_PCIEDMI_STRUCT;

/* XPPMEVH0_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200005a4)                                                      */
/*      SPRB0 (0x200005a4)                                                      */
/*      SPRHBM (0x200005a4)                                                     */
/*      SPRC0 (0x200005a4)                                                      */
/*      SPRMCC (0x200005a4)                                                     */
/*      SPRUCC (0x200005a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVL except for the Global Event signals. These signals are OR'ed with any event in the XPPMEVL and enables for debug operations requiring the accumulation of specific debug signals.
*/


#define XPPMEVH0_IIO_PCIEDMI_REG 0x0D0205A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxtxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which path to count transactions. 1x:
                               Transmit x1: Receive (from PCI bus) 11: Either
                            */
    UINT32 gesel : 4;

                            /* Bits[5:2], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which GE[3:0] is used for event
                               counting. This field is OR'd with other fields
                               in this register. The GEs cannot be qualified
                               with other PerfMon signals. If more than 1 GE is
                               selected then the resultant event is the OR
                               between each GE. However, properly counting
                               Global Event based on design, XP PM Response
                               Control Register bit [13:11] CENS must be set to
                               choose GE[3:0] and also bit[18:17] CNTEVSEL must
                               be set to 2'b10. 1xxx: GE[3] x1xx: GE[2] xx1x:
                               GE[1] xxx1: GE[0]
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMEVH0_IIO_PCIEDMI_STRUCT;

/* XPPMEVH1_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x200005a8)                                                      */
/*      SPRB0 (0x200005a8)                                                      */
/*      SPRHBM (0x200005a8)                                                     */
/*      SPRC0 (0x200005a8)                                                      */
/*      SPRMCC (0x200005a8)                                                     */
/*      SPRUCC (0x200005a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVL except for the Global Event signals. These signals are OR'ed with any event in the XPPMEVL and enables for debug operations requiring the accumulation of specific debug signals.
*/


#define XPPMEVH1_IIO_PCIEDMI_REG 0x0D0205A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxtxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which path to count transactions. 1x:
                               Transmit x1: Receive (from PCI bus) 11: Either
                            */
    UINT32 gesel : 4;

                            /* Bits[5:2], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which GE[3:0] is used for event
                               counting. This field is OR'd with other fields
                               in this register. The GEs cannot be qualified
                               with other PerfMon signals. If more than 1 GE is
                               selected then the resultant event is the OR
                               between each GE. However, properly counting
                               Global Event based on design, XP PM Response
                               Control Register bit [13:11] CENS must be set to
                               choose GE[3:0] and also bit[18:17] CNTEVSEL must
                               be set to 2'b10. 1xxx: GE[3] x1xx: GE[2] xx1x:
                               GE[1] xxx1: GE[0]
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMEVH1_IIO_PCIEDMI_STRUCT;

/* XPPMER0_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200005ac)                                                      */
/*      SPRB0 (0x200005ac)                                                      */
/*      SPRHBM (0x200005ac)                                                     */
/*      SPRC0 (0x200005ac)                                                      */
/*      SPRMCC (0x200005ac)                                                     */
/*      SPRUCC (0x200005ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is used to select queuing structures for measurement. Use of this event register is mutually exclusive with the XPPMEVL,H registers. The Event Register Select field in the PMR register must select this register for to enable monitoring operations of the queues.
*/


#define XPPMER0_IIO_PCIEDMI_REG 0x0D0205AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects a Tx/Rx queue to monitor.
                               Either receiver or transmit direction for
                               measurement. 1x: Transmit x1: Receive (from PCIe
                               bus) 11: Either Transmit or Receive direction
                            */
    UINT32 fccsel : 3;

                            /* Bits[4:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which flow class for resource
                               event xx1: Posted x1x: Non-Posted 1xx:
                               Completion
                            */
    UINT32 vcsel : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which VC to count. Only one
                               VC can be counted at a time.
                            */
    UINT32 avcsel : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               0: Not all VC selected 1: All VC selected This
                               bit will override VCSEL if selected
                            */
    UINT32 hdsel : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* 0: Data Queue selected 1: Header Queue selected */
    UINT32 qmsel : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               00: Transaction Bandwidth Measurement. Counts
                               data payload in dwords going in the direction
                               programmed (RxTx, FC, VC, Port) 01: FIFO Queue
                               Histogram Measurement. Uses the queue depth.
                               (RxTx, FC, VC, Port, Hdr/Data) 10: Credit
                               Consumed Histogram Measurement. Uses the credit
                               consumed count. (RxTx, FC, VC, Port, Hdr/Data)
                               11: Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lnkutil : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Link Utilization field counts clocks that a port
                               is receiving data and checking for receiver
                               errors. It is used to calculate link
                               reliability. If one counter counts receiver
                               errors and another counter counts the cycles the
                               port was checking for receiver error, a bit
                               error rate can be calculated. 0000: No event
                               selected 1000: Port 3 of 4, where applicable
                               (DSPs only) 0100: Port 2 of 4, where applicable
                               (DSPs only) 0010: Port 1 of 4, where applicable
                               (DSPs only) 0001: Port 0 of 4 (USP, DSPs,
                               vSP/vRP) If multiple bits are set, each port
                               with a set bit will be counted (ie. you can
                               count the total traffic on all ports) For
                               configs with less then 4 ports, the upper bits
                               corresponding to non-existent ports have no
                               effect.
                            */
    UINT32 xprsca : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000000*/

                            /*
                               This selects which PCI-Express links are being
                               monitored and against with XPPMEVL and XPPMEFH
                               match registers and the queue measure select
                               modes. A logic 1 selects that PCIe link for
                               monitoring. 1000: Select port 3 for monitoring.
                               0100: Select port 2 for monitoring. 0010: Select
                               port 1 for monitoring. 0001: Select port 0 for
                               monitoring. For header match, error counting,
                               queue measure, and bandwidth measure, the
                               perfmon will measure the sum of the events
                               across the ports. However, for the
                               TxL0s/RxL0s/L1 state selection, the select feeds
                               into the single bit PMER match wire of the
                               perfmon, and is affectively a 'wire-OR' of the
                               selected ports, and thus edges, cycles counted
                               by perfmon are on the wire-OR signal and not the
                               sum of the events per port.
                            */
    UINT32 rxl0su : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               0: No rx_l0s utilization selected 1: Enable
                               rx_l0s utilization counting
                            */
    UINT32 txl0su : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               0: No tx_l0s utilization selected 1: Enable
                               tx_l0s utilization counting
                            */
    UINT32 cntcerr : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               correctable errors by the perfmon counter. Only
                               correctable errors that are not masked by the
                               ERRCORDETMSK register are counted. Errors are
                               counted on the ports enabled by the XPRSCA field
                               in this register.
                            */
    UINT32 cntucerr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               uncorrectable errors by the perfmon counter.
                               Only uncorrectable errors that are not masked by
                               the ERRUNCDETMSK register are counted. Errors
                               are counted on the ports enabled by the XPRSCA
                               field in this register.
                            */
    UINT32 l1sue : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               0: No L1 state utilization selected 1: Enable L1
                               state utilization counting XPPMR.CNTMD could be
                               utilized to count the rising edge for acquiring
                               number of times L1 is entered if desirable.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMER0_IIO_PCIEDMI_STRUCT;

/* XPPMER1_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200005b0)                                                      */
/*      SPRB0 (0x200005b0)                                                      */
/*      SPRHBM (0x200005b0)                                                     */
/*      SPRC0 (0x200005b0)                                                      */
/*      SPRMCC (0x200005b0)                                                     */
/*      SPRUCC (0x200005b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is used to select queuing structures for measurement. Use of this event register is mutually exclusive with the XPPMEVL,H registers. The Event Register Select field in the PMR register must select this register for to enable monitoring operations of the queues.
*/


#define XPPMER1_IIO_PCIEDMI_REG 0x0D0205B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects a Tx/Rx queue to monitor.
                               Either receiver or transmit direction for
                               measurement. 1x: Transmit x1: Receive (from PCIe
                               bus) 11: Either Transmit or Receive direction
                            */
    UINT32 fccsel : 3;

                            /* Bits[4:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which flow class for resource
                               event xx1: Posted x1x: Non-Posted 1xx:
                               Completion
                            */
    UINT32 vcsel : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which VC to count. Only one
                               VC can be counted at a time.
                            */
    UINT32 avcsel : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               0: Not all VC selected 1: All VC selected This
                               bit will override VCSEL if selected
                            */
    UINT32 hdsel : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* 0: Data Queue selected 1: Header Queue selected */
    UINT32 qmsel : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               00: Transaction Bandwidth Measurement. Counts
                               data payload in dwords going in the direction
                               programmed (RxTx, FC, VC, Port) 01: FIFO Queue
                               Histogram Measurement. Uses the queue depth.
                               (RxTx, FC, VC, Port, Hdr/Data) 10: Credit
                               Consumed Histogram Measurement. Uses the credit
                               consumed count. (RxTx, FC, VC, Port, Hdr/Data)
                               11: Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lnkutil : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Link Utilization field counts clocks that a port
                               is receiving data and checking for receiver
                               errors. It is used to calculate link
                               reliability. If one counter counts receiver
                               errors and another counter counts the cycles the
                               port was checking for receiver error, a bit
                               error rate can be calculated. 0000: No event
                               selected 1000: Port 3 of 4, where applicable
                               (DSPs only) 0100: Port 2 of 4, where applicable
                               (DSPs only) 0010: Port 1 of 4, where applicable
                               (DSPs only) 0001: Port 0 of 4 (USP, DSPs,
                               vSP/vRP) If multiple bits are set, each port
                               with a set bit will be counted (ie. you can
                               count the total traffic on all ports) For
                               configs with less then 4 ports, the upper bits
                               corresponding to non-existent ports have no
                               effect.
                            */
    UINT32 xprsca : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000000*/

                            /*
                               This selects which PCI-Express links are being
                               monitored and against with XPPMEVL and XPPMEFH
                               match registers and the queue measure select
                               modes. A logic 1 selects that PCIe link for
                               monitoring. 1000: Select port 3 for monitoring.
                               0100: Select port 2 for monitoring. 0010: Select
                               port 1 for monitoring. 0001: Select port 0 for
                               monitoring. For header match, error counting,
                               queue measure, and bandwidth measure, the
                               perfmon will measure the sum of the events
                               across the ports. However, for the
                               TxL0s/RxL0s/L1 state selection, the select feeds
                               into the single bit PMER match wire of the
                               perfmon, and is affectively a 'wire-OR' of the
                               selected ports, and thus edges, cycles counted
                               by perfmon are on the wire-OR signal and not the
                               sum of the events per port.
                            */
    UINT32 rxl0su : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               0: No rx_l0s utilization selected 1: Enable
                               rx_l0s utilization counting
                            */
    UINT32 txl0su : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               0: No tx_l0s utilization selected 1: Enable
                               tx_l0s utilization counting
                            */
    UINT32 cntcerr : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               correctable errors by the perfmon counter. Only
                               correctable errors that are not masked by the
                               ERRCORDETMSK register are counted. Errors are
                               counted on the ports enabled by the XPRSCA field
                               in this register.
                            */
    UINT32 cntucerr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               uncorrectable errors by the perfmon counter.
                               Only uncorrectable errors that are not masked by
                               the ERRUNCDETMSK register are counted. Errors
                               are counted on the ports enabled by the XPRSCA
                               field in this register.
                            */
    UINT32 l1sue : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               0: No L1 state utilization selected 1: Enable L1
                               state utilization counting XPPMR.CNTMD could be
                               utilized to count the rising edge for acquiring
                               number of times L1 is entered if desirable.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMER1_IIO_PCIEDMI_STRUCT;





/* XPPERFCON_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x200005c4)                                                      */
/*      SPRB0 (0x200005c4)                                                      */
/*      SPRHBM (0x200005c4)                                                     */
/*      SPRC0 (0x200005c4)                                                      */
/*      SPRMCC (0x200005c4)                                                     */
/*      SPRUCC (0x200005c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The XPPERFCON register is a local performance monitor control register used to clear all of the counters or to assign which XP (PCIe) device participates in the performance monitoring event. All perfmon blocks will needs this register.
We will perform ORing this register and global PERFCON from full chip for backup usage and self contained purpose.
*/


#define XPPERFCON_IIO_PCIEDMI_REG 0x0D0205C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 grst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit to a logic 1 will reset the
                               following bit fields in all PerfMon blocks
                               throughout the component. xxxPMDx.CNT,
                               xxxPMR.OVS, xxxPMR.CMPSTAT, xxxPMCx.PMCx
                               registers, and count mode state latch selected
                               by xxxPMR.CNTMD = '01'. Where xxx is the cluster
                               prefix name. Note: Software must clear this bit
                               after setting it, otherwise the PerfMons remain
                               in a reset state.
                            */
    UINT32 gce : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is AND'ed with the PMR.CENS mux enable
                               selection. 0: Disable all counters. 1: Enable
                               local selection of CENS.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPERFCON_IIO_PCIEDMI_STRUCT;

/* XPPERFSTAT_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x5c8)                                                           */
/*      SPRB0 (0x5c8)                                                           */
/*      SPRHBM (0x5c8)                                                          */
/*      SPRC0 (0x5c8)                                                           */
/*      SPRMCC (0x5c8)                                                          */
/*      SPRUCC (0x5c8)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Performance Monitor Local Status
*/


#define XPPERFSTAT_IIO_PCIEDMI_REG 0x0D0005C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 xppm0stat : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates the status of PM0 from either
                               the compare or overflow status. This is bit is
                               cleared by writing a '1'.
                            */
    UINT8 xppm1stat : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates the status of PM0 from either
                               the compare or overflow status. This is bit is
                               cleared by writing a '1'.
                            */
    UINT8 rsvd : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} XPPERFSTAT_IIO_PCIEDMI_STRUCT;





/* XPHMSK0_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000710)                                                      */
/*      SPRB0 (0x20000710)                                                      */
/*      SPRHBM (0x20000710)                                                     */
/*      SPRC0 (0x20000710)                                                      */
/*      SPRMCC (0x20000710)                                                     */
/*      SPRUCC (0x20000710)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Each XP cluster will support one Header Match DFx feature. One match and mask register contains bit that are equivalent to the PCIe header for a 64bit addressing mode. When the interface is operating in 32-bit addressing mode then the user must program the registers appropriately. In other words the mapping between the header and the bits in the register is a physical mapping rather than a logic mapping.
The header bits to be used in matching are selected by the mask bits in this register. A zero in a mask bit position causes the corresponding bit in the header to be ignored. A one in a mask bit position indicates that the corresponding bit in the header must match the value of the same bit in the Match register for that bit to be considered to have matched. Pattern match out is asserted only if all enabled bit match (AND matching). If all mask bits are 0, MatchOut is 0. Table below shows how the Match and Mask operators generate a MatchOut assertion on a bit-by-bit basis.
Mask and Match Operational Table
*/


#define XPHMSK0_IIO_PCIEDMI_REG 0x0D020710

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt0 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte0 */
    UINT32 hmskbyt1 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte1 */
    UINT32 hmskbyt2 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte2 */
    UINT32 hmskbyt3 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte3 */

  } Bits;
  UINT32 Data;

} XPHMSK0_IIO_PCIEDMI_STRUCT;

/* XPHMSK1_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000714)                                                      */
/*      SPRB0 (0x20000714)                                                      */
/*      SPRHBM (0x20000714)                                                     */
/*      SPRC0 (0x20000714)                                                      */
/*      SPRMCC (0x20000714)                                                     */
/*      SPRUCC (0x20000714)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK1_IIO_PCIEDMI_REG 0x0D020714

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt4 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte4 */
    UINT32 hmskbyt5 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte5 */
    UINT32 hmskbyt6 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte6 */
    UINT32 hmskbyt7 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte7 */

  } Bits;
  UINT32 Data;

} XPHMSK1_IIO_PCIEDMI_STRUCT;

/* XPHMSK2_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000718)                                                      */
/*      SPRB0 (0x20000718)                                                      */
/*      SPRHBM (0x20000718)                                                     */
/*      SPRC0 (0x20000718)                                                      */
/*      SPRMCC (0x20000718)                                                     */
/*      SPRUCC (0x20000718)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK2_IIO_PCIEDMI_REG 0x0D020718

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt8 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte8 */
    UINT32 hmskbyt9 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte9 */
    UINT32 hmskbyt10 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte10 */
    UINT32 hmskbyt11 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte11 */

  } Bits;
  UINT32 Data;

} XPHMSK2_IIO_PCIEDMI_STRUCT;

/* XPHMSK3_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x2000071c)                                                      */
/*      SPRB0 (0x2000071c)                                                      */
/*      SPRHBM (0x2000071c)                                                     */
/*      SPRC0 (0x2000071c)                                                      */
/*      SPRMCC (0x2000071c)                                                     */
/*      SPRUCC (0x2000071c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK3_IIO_PCIEDMI_REG 0x0D02071C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt12 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte12 */
    UINT32 hmskbyt13 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte13 */
    UINT32 hmskbyt14 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte14 */
    UINT32 hmskbyt15 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte15 */

  } Bits;
  UINT32 Data;

} XPHMSK3_IIO_PCIEDMI_STRUCT;

/* XPHMAT0_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000720)                                                      */
/*      SPRB0 (0x20000720)                                                      */
/*      SPRHBM (0x20000720)                                                     */
/*      SPRC0 (0x20000720)                                                      */
/*      SPRMCC (0x20000720)                                                     */
/*      SPRUCC (0x20000720)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Least Significant Dword (LSDW) of a 128-bit match register that is used to compare inbound transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions. The output of the match logic is connected to XP[7,3,0]CTO0.
*/


#define XPHMAT0_IIO_PCIEDMI_REG 0x0D020720

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt0 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte0 */
    UINT32 hmatbyt1 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte1 */
    UINT32 hmatbyt2 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte2 */
    UINT32 hmatbyt3 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte3 */

  } Bits;
  UINT32 Data;

} XPHMAT0_IIO_PCIEDMI_STRUCT;

/* XPHMAT1_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000724)                                                      */
/*      SPRB0 (0x20000724)                                                      */
/*      SPRHBM (0x20000724)                                                     */
/*      SPRC0 (0x20000724)                                                      */
/*      SPRMCC (0x20000724)                                                     */
/*      SPRUCC (0x20000724)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Least Significant +1 Dword (LSDW+1) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT1_IIO_PCIEDMI_REG 0x0D020724

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt4 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte4 */
    UINT32 hmatbyt5 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte5 */
    UINT32 hmatbyt6 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte6 */
    UINT32 hmatbyt7 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte7 */

  } Bits;
  UINT32 Data;

} XPHMAT1_IIO_PCIEDMI_STRUCT;

/* XPHMAT2_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000728)                                                      */
/*      SPRB0 (0x20000728)                                                      */
/*      SPRHBM (0x20000728)                                                     */
/*      SPRC0 (0x20000728)                                                      */
/*      SPRMCC (0x20000728)                                                     */
/*      SPRUCC (0x20000728)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Most Significant -1 Dword (MSDW-1) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT2_IIO_PCIEDMI_REG 0x0D020728

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt8 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte8 */
    UINT32 hmatbyt9 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte9 */
    UINT32 hmatbyt10 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte10 */
    UINT32 hmatbyt11 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte11 */

  } Bits;
  UINT32 Data;

} XPHMAT2_IIO_PCIEDMI_STRUCT;

/* XPHMAT3_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x2000072c)                                                      */
/*      SPRB0 (0x2000072c)                                                      */
/*      SPRHBM (0x2000072c)                                                     */
/*      SPRC0 (0x2000072c)                                                      */
/*      SPRMCC (0x2000072c)                                                     */
/*      SPRUCC (0x2000072c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Most Significant Dword (MSDW) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT3_IIO_PCIEDMI_REG 0x0D02072C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt12 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte12 */
    UINT32 hmatbyt13 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte13 */
    UINT32 hmatbyt14 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte14 */
    UINT32 hmatbyt15 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte15 */

  } Bits;
  UINT32 Data;

} XPHMAT3_IIO_PCIEDMI_STRUCT;

/* XPTRIGSEL_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000730)                                                      */
/*      SPRB0 (0x10000730)                                                      */
/*      SPRHBM (0x10000730)                                                     */
/*      SPRC0 (0x10000730)                                                      */
/*      SPRMCC (0x10000730)                                                     */
/*      SPRUCC (0x10000730)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The name 'IP' in this reference refers to the PCIe Ports as a whole, meaning transaction, link, and physical layers. There is one register defined for the upstream PCIe port, one for each downstream PCIe x16 port, and one for the virtual switch/root port.
*/


#define XPTRIGSEL_IIO_PCIEDMI_REG 0x0D010730

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ipt0sel : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt1sel : 4;

                            /* Bits[7:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt2sel : 4;

                            /* Bits[11:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt3sel : 4;

                            /* Bits[15:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */

  } Bits;
  UINT16 Data;

} XPTRIGSEL_IIO_PCIEDMI_STRUCT;









/* CAPSR_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000748)                                                      */
/*      SPRB0 (0x20000748)                                                      */
/*      SPRHBM (0x20000748)                                                     */
/*      SPRC0 (0x20000748)                                                      */
/*      SPRMCC (0x20000748)                                                     */
/*      SPRUCC (0x20000748)                                                     */
/* Register default value on SPRA0: 0x00054041                                  */
/* Register default value on SPRB0: 0x00054041                                  */
/* Register default value on SPRHBM: 0x00054041                                 */
/* Register default value on SPRC0: 0x00054041                                  */
/* Register default value on SPRMCC: 0x00054041                                 */
/* Register default value on SPRUCC: 0x00054041                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Capability Shadowed
*/


#define CAPSR_IIO_PCIEDMI_REG 0x0D020748

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmcsr_nsr : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding PMCSR.NSR once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 msixctl_ts : 11;

                            /* Bits[11:1], Access Type=RW/P, default=0x00000020*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding MSIXCTL.TS once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_egc : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.EGC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_ecc : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.ECC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_ctphlc : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.CPTHLC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linkctl_ecpm : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKCTL.ECPM once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linksts_scc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKSTS.SCC once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linkctl2_sd : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKCTL2.SD once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 msictl_pvm : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding MSICTL.PVM once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 g5sts_txprecreq : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding G5STS.TXPREREQ
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CAPSR_IIO_PCIEDMI_STRUCT;



/* CORERRCNTMSK_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x20000760)                                                      */
/*      SPRB0 (0x20000760)                                                      */
/*      SPRHBM (0x20000760)                                                     */
/*      SPRC0 (0x20000760)                                                      */
/*      SPRMCC (0x20000760)                                                     */
/*      SPRUCC (0x20000760)                                                     */
/* Register default value on SPRA0: 0x0000F1C1                                  */
/* Register default value on SPRB0: 0x0000F1C1                                  */
/* Register default value on SPRHBM: 0x0000F1C1                                 */
/* Register default value on SPRC0: 0x0000F1C1                                  */
/* Register default value on SPRMCC: 0x0000F1C1                                 */
/* Register default value on SPRUCC: 0x0000F1C1                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Counter Mask
*/


#define CORERRCNTMSK_IIO_PCIEDMI_REG 0x0D020760

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rem : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /* Link receiver error counter mask. */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpem : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000001*/

                            /* Link bad TLP error counter mask. */
    UINT32 bdllpem : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000001*/

                            /* Link bad DLLP error counter mask. */
    UINT32 rnrem : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /* Link replay number rollover error counter mask */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rttem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000001*/

                            /* Link replay timer timeout error counter mask. */
    UINT32 anfem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Link advisory non-fatal error counter mask. */
    UINT32 ciem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /* Correctable internal error counter mask. */
    UINT32 hloem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Header log overflow error counter mask. */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORERRCNTMSK_IIO_PCIEDMI_STRUCT;

/* CORERRCNT_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000764)                                                      */
/*      SPRB0 (0x20000764)                                                      */
/*      SPRHBM (0x20000764)                                                     */
/*      SPRC0 (0x20000764)                                                      */
/*      SPRMCC (0x20000764)                                                     */
/*      SPRUCC (0x20000764)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Counter
*/


#define CORERRCNT_IIO_PCIEDMI_REG 0x0D020764

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errcnt : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Link correctable error counter. 1. A Correctable
                               Error Counter Mask register controls which
                               errors contribute to the counter. a. Masked
                               errors (mask=1) do not contribute to the counter
                               2. Logic is in parallel to AER Correctable mask
                               and reporting. a. Correctable Errors masked by
                               AER Correctable Error Mask can contribute to the
                               counter if unmasked in Correctable Error Counter
                               Mask b. This provides the ability to have
                               certain errors be counted and certain errors
                               generate messages always.
                            */

  } Bits;
  UINT32 Data;

} CORERRCNT_IIO_PCIEDMI_STRUCT;

/* CORERRTH_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000768)                                                      */
/*      SPRB0 (0x20000768)                                                      */
/*      SPRHBM (0x20000768)                                                     */
/*      SPRC0 (0x20000768)                                                      */
/*      SPRMCC (0x20000768)                                                     */
/*      SPRUCC (0x20000768)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Threshold
*/


#define CORERRTH_IIO_PCIEDMI_REG 0x0D020768

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errth : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Link correctable error threshold. Non zero
                               threshold value enables the correctable error
                               counter. When the Correctable Error Counter is
                               enabled, an internal ERR_COR message is
                               generated when the counter becomes equal to
                               threshold. If threshold is 15 and count is 14,
                               the next correctable error generates 1
                               Correctable error message. Same holds true for
                               count and threshold of 0xFFFFFFFF.
                               CORERRCNT.ERRCNT would be saturated, i.e. stops
                               counting at 0xFFFFFFFF accordingly.
                            */

  } Bits;
  UINT32 Data;

} CORERRTH_IIO_PCIEDMI_STRUCT;
























/* FCCRDSSCTL_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000880)                                                      */
/*      SPRB0 (0x20000880)                                                      */
/*      SPRHBM (0x20000880)                                                     */
/*      SPRC0 (0x20000880)                                                      */
/*      SPRMCC (0x20000880)                                                     */
/*      SPRUCC (0x20000880)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Snapshot Control
*/


#define FCCRDSSCTL_IIO_PCIEDMI_REG 0x0D020880

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 flow_class : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /* 00 = Posted 01 = Non-Posted 10 = Completion */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 virtual_channel : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               The virtual channel to select (VC0-VC7). In
                               addition, this field could be optional expanded
                               and associated with Credit Throttling registers
                               per VC, however it's implementation specific
                            */
    UINT32 freeze_cnt : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, it freezes the counts in the credit
                               observability registers. If the bit is clear,
                               the counts continuously update.
                            */
    UINT32 rsvd_8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDSSCTL_IIO_PCIEDMI_STRUCT;

/* FCCRDLSS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000884)                                                      */
/*      SPRB0 (0x20000884)                                                      */
/*      SPRHBM (0x20000884)                                                     */
/*      SPRC0 (0x20000884)                                                      */
/*      SPRMCC (0x20000884)                                                     */
/*      SPRUCC (0x20000884)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Limit Snapshot
*/


#define FCCRDLSS_IIO_PCIEDMI_REG 0x0D020884

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 12;

                            /* Bits[11:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfd : 1;

                            /* Bits[12:12], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Data of flow class specified in FCCRDSSCTL.
                               May not be valid until FCCRDSSCTL.FREEZE_CNT is
                               written.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hss : 8;

                            /* Bits[23:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfh : 1;

                            /* Bits[24:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Header of flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hs : 2;

                            /* Bits[26:25], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Gen4 FC Header Credit Scale for flow class
                               specified in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 ds : 2;

                            /* Bits[28:27], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Gen4 FC Data Credit Scale for flow class
                               specified in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDLSS_IIO_PCIEDMI_STRUCT;

/* FCCRDASS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000888)                                                      */
/*      SPRB0 (0x20000888)                                                      */
/*      SPRHBM (0x20000888)                                                     */
/*      SPRC0 (0x20000888)                                                      */
/*      SPRMCC (0x20000888)                                                     */
/*      SPRUCC (0x20000888)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Allocated Snapshot
*/


#define FCCRDASS_IIO_PCIEDMI_REG 0x0D020888

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfd : 1;

                            /* Bits[16:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Data of flow class specified in FCCRDSSCTL.
                               May not be valid until FCCRDSSCTL.FREEZE_CNT is
                               written.
                            */
    UINT32 hss : 12;

                            /* Bits[28:17], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 icfh : 1;

                            /* Bits[29:29], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Header of flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDASS_IIO_PCIEDMI_STRUCT;

/* FCCRDCSS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x2000088c)                                                      */
/*      SPRB0 (0x2000088c)                                                      */
/*      SPRHBM (0x2000088c)                                                     */
/*      SPRC0 (0x2000088c)                                                      */
/*      SPRMCC (0x2000088c)                                                     */
/*      SPRUCC (0x2000088c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Consumed Snapshot
*/


#define FCCRDCSS_IIO_PCIEDMI_REG 0x0D02088C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hss : 12;

                            /* Bits[27:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDCSS_IIO_PCIEDMI_STRUCT;

/* FCCRDRSS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000890)                                                      */
/*      SPRB0 (0x20000890)                                                      */
/*      SPRHBM (0x20000890)                                                     */
/*      SPRC0 (0x20000890)                                                      */
/*      SPRMCC (0x20000890)                                                     */
/*      SPRUCC (0x20000890)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Note: The credit_allocated and credit_received counters in the RTL are only big enough to cover the size of the max credits advertised. The values displayed in those credit registers will not have the full 8 bit header, 12 bit data counts. Some of the upper bits will be zeroed out.
*/


#define FCCRDRSS_IIO_PCIEDMI_REG 0x0D020890

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hss : 12;

                            /* Bits[27:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDRSS_IIO_PCIEDMI_STRUCT;

/* FCCRDDSS_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000894)                                                      */
/*      SPRB0 (0x20000894)                                                      */
/*      SPRHBM (0x20000894)                                                     */
/*      SPRC0 (0x20000894)                                                      */
/*      SPRMCC (0x20000894)                                                     */
/*      SPRUCC (0x20000894)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Difference Snapshot
*/


#define FCCRDDSS_IIO_PCIEDMI_REG 0x0D020894

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdd : 8;

                            /* Bits[7:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Rx data credit
                               allocated (FCCRDASS) and data credit received
                               counts (FCCRDRSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rhd : 8;

                            /* Bits[15:8], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Rx header credit
                               allocated (FCCRDASS) and header credit received
                               counts (FCCRDRSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 tdd : 8;

                            /* Bits[23:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Tx data credit
                               limit (FCCRDLSS) and data credit consumed counts
                               (FCCRDCSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 thd : 8;

                            /* Bits[31:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Tx header credit
                               limit (FCCRDLSS) and header credit consumed
                               counts (FCCRDCSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */

  } Bits;
  UINT32 Data;

} FCCRDDSS_IIO_PCIEDMI_STRUCT;







/* PT0TXNCLKGCTL_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x100008e4)                                                      */
/*      SPRB0 (0x100008e4)                                                      */
/*      SPRHBM (0x100008e4)                                                     */
/*      SPRC0 (0x100008e4)                                                      */
/*      SPRMCC (0x100008e4)                                                     */
/*      SPRUCC (0x100008e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 Transaction Clock Gate Control
*/


#define PT0TXNCLKGCTL_IIO_PCIEDMI_REG 0x0D0108E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0TXNCLKGCTL_IIO_PCIEDMI_STRUCT;


/* TXCRSTOCTL_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x200008f0)                                                      */
/*      SPRB0 (0x200008f0)                                                      */
/*      SPRHBM (0x200008f0)                                                     */
/*      SPRC0 (0x200008f0)                                                      */
/*      SPRMCC (0x200008f0)                                                     */
/*      SPRUCC (0x200008f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Transmit Timeout and Configuration Retry Timeout
*/


#define TXCRSTOCTL_IIO_PCIEDMI_REG 0x0D0208F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txtofcen : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               When a TLP reaches the top of the transmit queue
                               and met all ordering requirements, different
                               resources may block the TLP from being
                               sent/processed. This field enables a transmit
                               timeout timer per class to allow status and
                               further action should a TLP be blocked from
                               sending for a long time. Bit 0 enables the timer
                               for the posted flow class. Bit 1 enables the
                               timer for the non-posted flow class. Bit 2
                               enables the timer for the completion flow class.
                            */
    UINT32 txnpctodis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               When completion timeout is enabled, if a non-
                               posted request cannot be sent due to credits and
                               there are no outstanding non-posted requests, a
                               timer will start and time out the request if it
                               is not sent before the programmed completion
                               timer value is reached. Setting this bit
                               disables the timer and blocks the timeout. The
                               transmit timeout functionality in this register
                               runs in parallel and may timeout the non-posted
                               request using the transmit timeout value, even
                               if this bit disables the request timeout due to
                               the completion timeout expiration.
                            */
    UINT32 txtov : 4;

                            /* Bits[7:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is the encoded range for the transmit
                               timeout counter. The timer is used for each flow
                               class. 0 65us to 98us 1 131us to 196us 2 262us
                               to 393us 3 524us to 786us 4 1ms to 1.6ms 5 2ms
                               to 3ms 6 4ms to 6ms 7 8ms to 12ms 8 16ms to 25ms
                               9 33ms to 50ms 10 67ms to 100ms 11 134ms to
                               201ms 12 268ms to 402ms 13 536ms to 805ms 14 1s
                               to 1.6s 15 2s to 3s
                            */
    UINT32 txtouren : 3;

                            /* Bits[10:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               These bits enable the transmitter to treat a TLP
                               that has timed out by the transmit timeout
                               mechanism as an unsupported request. For posted
                               and completions, the TLP is silently dropped.
                               For non-posted, a completion with UR status is
                               synthesized and returned.
                            */
    UINT32 txtolden : 3;

                            /* Bits[13:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               These bits enable a transmit timeout to trigger
                               a link down. When the link goes down, any
                               requests blocked by external credits will be
                               completed following the normal link down
                               handling. Once the packet that caused the
                               timeout is processed, the link will be allowed
                               to retrain.
                            */
    UINT32 txtostr : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Once a transaction times out, it is expected
                               that the following transactions will also time
                               out. Therefore, the default handling is to use
                               the transmit timeout status bits to UR requests
                               or keep the link down until the status bits are
                               cleared. Setting this bit changes that behavior
                               so the timed out transaction will UR or bring
                               the link down, but following transaction will
                               need to timeout before being handled by the
                               timeout logic. Note that link down will drop
                               and/or UR packets until the link retrains.
                            */
    UINT32 crs_to_dis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               If a configuration request is retried for more
                               than the timeout specified by CRSRT.CRSRTV, the
                               targeted device is determined to be broken, and
                               a completion with unsupported request is
                               returned. Setting this bit disables the retry
                               timeout, allowing the retries to occur forever.
                            */
    UINT32 txtosts : 3;

                            /* Bits[18:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This field indicates a request or completion
                               could not be sent or processed before the
                               transmit timeout timer has expired. Bit 0 is for
                               the posted flow class. Bit 1 is for the non-
                               posted flow class. Bit 2 is for the completion
                               flow class.
                            */
    UINT32 txnpctosts : 1;

                            /* Bits[19:19], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set if a non-posted request cannot
                               be sent and the completion timeout mechanism
                               triggered a UR completion.
                            */
    UINT32 crs_to_sts : 1;

                            /* Bits[20:20], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set if a configuration request is
                               retried for more than the timeout specified by
                               CRSRT.CRSRTV, dependently of the configuration
                               retry timeout disable.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TXCRSTOCTL_IIO_PCIEDMI_STRUCT;

/* XPTDEF_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x200008f4)                                                      */
/*      SPRB0 (0x200008f4)                                                      */
/*      SPRHBM (0x200008f4)                                                     */
/*      SPRC0 (0x200008f4)                                                      */
/*      SPRMCC (0x200008f4)                                                     */
/*      SPRUCC (0x200008f4)                                                     */
/* Register default value on SPRA0: 0x00008000                                  */
/* Register default value on SPRB0: 0x00008000                                  */
/* Register default value on SPRHBM: 0x00008000                                 */
/* Register default value on SPRC0: 0x00008000                                  */
/* Register default value on SPRMCC: 0x00008000                                 */
/* Register default value on SPRUCC: 0x00008000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Lock Key bit is located in the Personality Lock Key Control Register (PLKCTL.TLCL).
*/


#define XPTDEF_IIO_PCIEDMI_REG 0x0D0208F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 27;

                            /* Bits[26:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 malchkd : 1;

                            /* Bits[28:28], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit disables optional malform
                               checks on TLP packets received on the port.
                               Specifically, this disables the byte enable
                               checks, 4K page crossing check, I/O and config
                               request field checks, and message direction
                               checks (ie. broadcast from root complex going
                               upstream to the root complex) Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rsvd_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPTDEF_IIO_PCIEDMI_STRUCT;

/* XPTDEF2_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x200008f8)                                                      */
/*      SPRB0 (0x200008f8)                                                      */
/*      SPRHBM (0x200008f8)                                                     */
/*      SPRC0 (0x200008f8)                                                      */
/*      SPRMCC (0x200008f8)                                                     */
/*      SPRUCC (0x200008f8)                                                     */
/* Register default value on SPRA0: 0x000C1D00                                  */
/* Register default value on SPRB0: 0x000C1D00                                  */
/* Register default value on SPRHBM: 0x000C1D00                                 */
/* Register default value on SPRC0: 0x000C1D00                                  */
/* Register default value on SPRMCC: 0x000C1D00                                 */
/* Register default value on SPRUCC: 0x000C1D00                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Lock Key bit is located in the Personality Lock Key Control Register (PLKCTL.TLCL).
*/


#define XPTDEF2_IIO_PCIEDMI_REG 0x0D0208F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 gblstopd : 1;

                            /* Bits[0:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               When the design detects an uncorrectable
                               internal error, a stop signal in the design
                               asserts, blocking the processing of transactions
                               in both directions in the transaction layer.
                               Setting this bit, disables the stop mechanism,
                               allowing the transactions to proceed as if no
                               error occurred. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 msixsmsgv : 1;

                            /* Bits[1:1], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit when set, causes only a single MSI-X
                               vector to be generated if MSI-X is enabled. This
                               bit affects the default value of the MSI-X Table
                               Size field Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 mctpdbc : 1;

                            /* Bits[2:2], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit will disable the Bus 0 check
                               for all MCTP VDM Type1 messages. MCTP will be
                               dropped in case of Bus Check failure. The check
                               is enabled by default as following: Upstream -
                               ReqBus =/= 0 Downstream RID - TgtBus =/= 0
                               Downstream BRC - ReqBus == 0 (RP only) Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ucchkd : 1;

                            /* Bits[3:3], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit disables some optional
                               unexpected checks on completions. Specifically,
                               it disables the checking on the byte count and
                               lower address fields. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 crd : 1;

                            /* Bits[4:4], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit disables the re-issuing of a
                               configuration request if the request is
                               completed with a configuration retry status
                               (CRS). The completion with CRS will be returned
                               to the requestor. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 cplcombine_d : 1;

                            /* Bits[5:5], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               When a larger read request is split into smaller
                               read requests, the completions for the small
                               requests may be opportunistically combined into
                               larger completions to enable higher bandwidth
                               and link utilization, as long as packet
                               formation rules are not violated. This bit
                               disables the port from combining completions.
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register . This is only valid
                               for project specific .
                            */
    UINT32 msigenov : 1;

                            /* Bits[6:6], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               1: Enables Root Port MSI generation override
                               even if PCICMD.BME = 0 for the root port device
                               as required by PCI Express specification. 0:
                               Normal operation for Root Port behavior. If
                               PCICMD.BME = 0, the root port will not generate
                               a MSI. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . This is
                               only valid for project specific .
                            */
    UINT32 erco : 1;

                            /* Bits[7:7], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               The default ordering is to allow received
                               completions to pass received posted requests to
                               avoid receiver overflow conditions if posted
                               requests cannot be processed. Setting this bit
                               will enable PCI Express ordering for
                               completions, preventing completions from passing
                               posted requests. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                               This is only valid for project specific
                            */
    UINT32 evpid : 1;

                            /* Bits[8:8], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               1: Enables SB Virtual Port ID mode with
                               allocated VPIDs which is associated with ports
                               for all the egress INTx messages based on
                               project specific. We will assign <N-1> virtual
                               sideband PortID's to associate with the physical
                               PortID which is port 0. The physical one is the
                               same one as being assigned by the router as we
                               have now, and would be used for all non-INTx
                               messages and INTx messages from port 0. However,
                               the VPIDs would be used for INTx messages
                               routing from port<N-1:1>, respectively. This
                               allows all INTx from N ports to be forwarded to
                               the ILB accordingly, so ILB can differentiate
                               the source of the INTx message. 0: Normal
                               operation with single SB Port ID per cluster for
                               INTx delivery. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register . This
                               is only valid for project specific with multi
                               root ports.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mmbnce : 1;

                            /* Bits[10:10], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set, if the Requester ID bus number of an
                               MCTP message request received on the PCIe link
                               does not fall within the range between SCBN and
                               SBBN, the MCTP message will be silently
                               discarded. This is applicable to (v)RP for
                               security measure. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 tcpar_chk_dis : 1;

                            /* Bits[11:11], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set this bit disables the command parity
                               check for incoming commands into the IOSF Target
                               block. The logic will ignore the command parity
                               bit and will operate as though the parity bit
                               did not exist. No errors will be logged and good
                               DW based parity will be written into the header
                               queue. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 tdpar_chk_dis : 1;

                            /* Bits[12:12], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set this bit disables the data parity check
                               for incoming data into the IOSF Target block.
                               The logic will ignore the data parity bit and
                               will operate as though the parity bit did not
                               exist. No errors will be logged and good DW
                               based parity will be written into the data
                               queue. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 uprodis : 1;

                            /* Bits[13:13], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disables the ability of upstream relaxed ordered
                               completions from passing posted requests in the
                               same direction. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 dnrodis : 1;

                            /* Bits[14:14], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disables the ability of downstream relaxed
                               ordered completions from passing posted requests
                               in the same direction. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 forcerodn : 1;

                            /* Bits[15:15], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Forces all downstream completions to follow
                               relaxed ordering rules. This allows downstream
                               completions to pass downstream posted requests.
                               Note that setting this bit breaks the producer
                               consumer model when the data is in the address
                               space below the port and the flag is in the
                               address space outside the port, because the read
                               of the flag will not push the data writes down
                               the port. The belief is that usage model is not
                               used. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 msiavcd : 1;

                            /* Bits[16:16], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disable MSI address violation check that does
                               not target 0xFEEx_xxxx. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This is only valid for RPs usage.
                            */
    UINT32 ecrcmfepd : 1;

                            /* Bits[17:17], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit changes the error precedence if a TLP
                               has both a ECRC error and is malform. When this
                               bit is set to 1, the packet will be logged as an
                               ECRC error. When set to 0, the packet will be
                               logged as a malform TLP, which is compliant to
                               the PCIe spec errata. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Only the type of error logged is
                               affected. If the TLP is malform, it will be
                               dropped with no credit return. If there is only
                               an ECRC error detected on a packet, it will be
                               dropped and credits will be returned per PCI-SIG
                               Errata.
                            */
    UINT32 hrsrd : 1;

                            /* Bits[18:18], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               For Surprise Removal, EIP RPs will not allow
                               retrain to occur until the SLOTSTS.PDCS bit has
                               been cleared by software for the removal event.
                               This bit is to disable the above behavior and
                               allow the retrain to occur. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 hrdllscsd : 1;

                            /* Bits[19:19], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               EIP RPs will not allow retrain to occur until
                               the SLOTSTS.DLLSCS bit has been cleared by
                               software for the DL_Active event changed. This
                               bit is to disable the above behavior and allow
                               the retrain to occur. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 hrhpid : 1;

                            /* Bits[20:20], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               EIP RPs will not allow retrain if hot plug
                               interrupts are enabled until SLOTSTS.PDCS or
                               SLOTSTS.DLLSCS bit has been cleared by software
                               for removal or DL_Active event changed. This bit
                               is to disable the above behavior and allow the
                               retrain to occur. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                               This field is only applicable to RPs and should
                               be treated as reserved for other devices.
                            */
    UINT32 recop : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is reserved for ECO or scratch
                               purpose.
                            */
    UINT32 rsp : 1;

                            /* Bits[22:22], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               0 - When an inbound read is processed the read
                               splitting logic will only split the TLP up if it
                               is greater than the programmed MPS value in the
                               DEVCTL.MPS register field. When a transaction is
                               larger than the DEVCTL.MPS programming the split
                               will occur on DEVCTL.MPS address aligned values.
                               1 - When an inbound read is processed the read
                               splitting logic will split the TLP on address
                               boundaries determined by the programming of
                               DEVCTL.MPS. This will potentially lead to
                               transactions getting split that are smaller than
                               what is programmed in the DEVCTL.MPS. If the
                               request is not aligned to the programmed value
                               then the read splitting logic will split it up
                               so that it is aligned. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This is only valid for RPs usage.
                            */
    UINT32 reco : 8;

                            /* Bits[30:23], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This field is reserved for ECO purpose. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register . RECO[0] is assigned to
                               disable Flow Control Protocol Error checks.
                            */
    UINT32 msiavs : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               MSI address violation check status that does not
                               target 0xFEEx_xxxx while MSIAVCD is not being
                               set. This is only valid for RPs usage.
                            */

  } Bits;
  UINT32 Data;

} XPTDEF2_IIO_PCIEDMI_STRUCT;


/* FCUCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000900)                                                      */
/*      SPRB0 (0x20000900)                                                      */
/*      SPRHBM (0x20000900)                                                     */
/*      SPRC0 (0x20000900)                                                      */
/*      SPRMCC (0x20000900)                                                     */
/*      SPRUCC (0x20000900)                                                     */
/* Register default value on SPRA0: 0x0018619E                                  */
/* Register default value on SPRB0: 0x0018619E                                  */
/* Register default value on SPRHBM: 0x0018619E                                 */
/* Register default value on SPRC0: 0x0018619E                                  */
/* Register default value on SPRMCC: 0x0018619E                                 */
/* Register default value on SPRUCC: 0x0018619E                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update Control
*/


#define FCUCTL_IIO_PCIEDMI_REG 0x0D020900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_fc_period : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x0000001E*/

                            /*
                               This field dictates the period at which flow
                               control updates are sent when there are no
                               additional credits to return for a particular
                               flow class/VC. The timer is set to
                               'idle_fc_period' * 1.024us -1.024us/+0us. A
                               value of 0 is illegal
                            */
    UINT32 fc_c_period : 6;

                            /* Bits[11:6], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fc_n_period : 6;

                            /* Bits[17:12], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fc_p_period : 6;

                            /* Bits[23:18], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fcu_mode : 2;

                            /* Bits[25:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = Spec Defined (Default) 01 = SG-Like 10 =
                               'Just-In-Time'
                            */
    UINT32 rsvd : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUCTL_IIO_PCIEDMI_STRUCT;

/* FCUJITPCTL0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000904)                                                      */
/*      SPRB0 (0x20000904)                                                      */
/*      SPRHBM (0x20000904)                                                     */
/*      SPRC0 (0x20000904)                                                      */
/*      SPRMCC (0x20000904)                                                     */
/*      SPRUCC (0x20000904)                                                     */
/* Register default value on SPRA0: 0x00004009                                  */
/* Register default value on SPRB0: 0x00004009                                  */
/* Register default value on SPRHBM: 0x00004009                                 */
/* Register default value on SPRC0: 0x00004009                                  */
/* Register default value on SPRMCC: 0x00004009                                 */
/* Register default value on SPRUCC: 0x00004009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT P Control
*/


#define FCUJITPCTL0_IIO_PCIEDMI_REG 0x0D020904

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000009*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Data Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000004*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Header Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the data threshold is reached
                               or crossed. This field does not impact the
                               updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITPCTL0_IIO_PCIEDMI_STRUCT;

/* FCUJITPCTL1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000908)                                                      */
/*      SPRB0 (0x20000908)                                                      */
/*      SPRHBM (0x20000908)                                                     */
/*      SPRC0 (0x20000908)                                                      */
/*      SPRMCC (0x20000908)                                                     */
/*      SPRUCC (0x20000908)                                                     */
/* Register default value on SPRA0: 0x00004009                                  */
/* Register default value on SPRB0: 0x00004009                                  */
/* Register default value on SPRHBM: 0x00004009                                 */
/* Register default value on SPRC0: 0x00004009                                  */
/* Register default value on SPRMCC: 0x00004009                                 */
/* Register default value on SPRUCC: 0x00004009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT P Control
*/


#define FCUJITPCTL1_IIO_PCIEDMI_REG 0x0D020908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000009*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Data Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000004*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Header Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the data threshold is reached
                               or crossed. This field does not impact the
                               updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITPCTL1_IIO_PCIEDMI_STRUCT;

/* FCUJITPCTL2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x2000090c)                                                      */
/*      SPRB0 (0x2000090c)                                                      */
/*      SPRHBM (0x2000090c)                                                     */
/*      SPRC0 (0x2000090c)                                                      */
/*      SPRMCC (0x2000090c)                                                     */
/*      SPRUCC (0x2000090c)                                                     */
/* Register default value on SPRA0: 0x00004009                                  */
/* Register default value on SPRB0: 0x00004009                                  */
/* Register default value on SPRHBM: 0x00004009                                 */
/* Register default value on SPRC0: 0x00004009                                  */
/* Register default value on SPRMCC: 0x00004009                                 */
/* Register default value on SPRUCC: 0x00004009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT P Control
*/


#define FCUJITPCTL2_IIO_PCIEDMI_REG 0x0D02090C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000009*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Data Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000004*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Header Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the data threshold is reached
                               or crossed. This field does not impact the
                               updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITPCTL2_IIO_PCIEDMI_STRUCT;

/* FCUJITNCTL0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000910)                                                      */
/*      SPRB0 (0x20000910)                                                      */
/*      SPRHBM (0x20000910)                                                     */
/*      SPRC0 (0x20000910)                                                      */
/*      SPRMCC (0x20000910)                                                     */
/*      SPRUCC (0x20000910)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT NP Control
*/


#define FCUJITNCTL0_IIO_PCIEDMI_REG 0x0D020910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Data Queue before a FC-NP Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Header Queue before a FC-NP
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITNCTL0_IIO_PCIEDMI_STRUCT;

/* FCUJITNCTL1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000914)                                                      */
/*      SPRB0 (0x20000914)                                                      */
/*      SPRHBM (0x20000914)                                                     */
/*      SPRC0 (0x20000914)                                                      */
/*      SPRMCC (0x20000914)                                                     */
/*      SPRUCC (0x20000914)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT NP Control
*/


#define FCUJITNCTL1_IIO_PCIEDMI_REG 0x0D020914

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Data Queue before a FC-NP Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Header Queue before a FC-NP
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITNCTL1_IIO_PCIEDMI_STRUCT;

/* FCUJITNCTL2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000918)                                                      */
/*      SPRB0 (0x20000918)                                                      */
/*      SPRHBM (0x20000918)                                                     */
/*      SPRC0 (0x20000918)                                                      */
/*      SPRMCC (0x20000918)                                                     */
/*      SPRUCC (0x20000918)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT NP Control
*/


#define FCUJITNCTL2_IIO_PCIEDMI_REG 0x0D020918

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Data Queue before a FC-NP Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Header Queue before a FC-NP
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITNCTL2_IIO_PCIEDMI_STRUCT;

/* FCUJITCCTL0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x2000091c)                                                      */
/*      SPRB0 (0x2000091c)                                                      */
/*      SPRHBM (0x2000091c)                                                     */
/*      SPRC0 (0x2000091c)                                                      */
/*      SPRMCC (0x2000091c)                                                     */
/*      SPRUCC (0x2000091c)                                                     */
/* Register default value on SPRA0: 0x00002016                                  */
/* Register default value on SPRB0: 0x00002016                                  */
/* Register default value on SPRHBM: 0x00002016                                 */
/* Register default value on SPRC0: 0x00002016                                  */
/* Register default value on SPRMCC: 0x00002016                                 */
/* Register default value on SPRUCC: 0x00002016                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT CPL Control
*/


#define FCUJITCCTL0_IIO_PCIEDMI_REG 0x0D02091C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Data Queue before a FC-CPL Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000002*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Header Queue before a FC-CPL
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITCCTL0_IIO_PCIEDMI_STRUCT;

/* FCUJITCCTL1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000920)                                                      */
/*      SPRB0 (0x20000920)                                                      */
/*      SPRHBM (0x20000920)                                                     */
/*      SPRC0 (0x20000920)                                                      */
/*      SPRMCC (0x20000920)                                                     */
/*      SPRUCC (0x20000920)                                                     */
/* Register default value on SPRA0: 0x00002016                                  */
/* Register default value on SPRB0: 0x00002016                                  */
/* Register default value on SPRHBM: 0x00002016                                 */
/* Register default value on SPRC0: 0x00002016                                  */
/* Register default value on SPRMCC: 0x00002016                                 */
/* Register default value on SPRUCC: 0x00002016                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT CPL Control
*/


#define FCUJITCCTL1_IIO_PCIEDMI_REG 0x0D020920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Data Queue before a FC-CPL Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000002*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Header Queue before a FC-CPL
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITCCTL1_IIO_PCIEDMI_STRUCT;

/* FCUJITCCTL2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000924)                                                      */
/*      SPRB0 (0x20000924)                                                      */
/*      SPRHBM (0x20000924)                                                     */
/*      SPRC0 (0x20000924)                                                      */
/*      SPRMCC (0x20000924)                                                     */
/*      SPRUCC (0x20000924)                                                     */
/* Register default value on SPRA0: 0x00002016                                  */
/* Register default value on SPRB0: 0x00002016                                  */
/* Register default value on SPRHBM: 0x00002016                                 */
/* Register default value on SPRC0: 0x00002016                                  */
/* Register default value on SPRMCC: 0x00002016                                 */
/* Register default value on SPRUCC: 0x00002016                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT CPL Control
*/


#define FCUJITCCTL2_IIO_PCIEDMI_REG 0x0D020924

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Data Queue before a FC-CPL Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000002*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Header Queue before a FC-CPL
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITCCTL2_IIO_PCIEDMI_STRUCT;


/* VCXINITDLY_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000934)                                                      */
/*      SPRB0 (0x20000934)                                                      */
/*      SPRHBM (0x20000934)                                                     */
/*      SPRC0 (0x20000934)                                                      */
/*      SPRMCC (0x20000934)                                                     */
/*      SPRUCC (0x20000934)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* This register is applicable to the device that supports more than 1 VC.
*/


#define VCXINITDLY_IIO_PCIEDMI_REG 0x0D020934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 delay : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Delay in [us] between FC Inits for VCx. A value
                               of 0 is not recommended as it may starve other
                               VC's traffic.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} VCXINITDLY_IIO_PCIEDMI_STRUCT;


/* ACKCTL_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000940)                                                      */
/*      SPRB0 (0x20000940)                                                      */
/*      SPRHBM (0x20000940)                                                     */
/*      SPRC0 (0x20000940)                                                      */
/*      SPRMCC (0x20000940)                                                     */
/*      SPRUCC (0x20000940)                                                     */
/* Register default value on SPRA0: 0x00000016                                  */
/* Register default value on SPRB0: 0x00000016                                  */
/* Register default value on SPRHBM: 0x00000016                                 */
/* Register default value on SPRC0: 0x00000016                                  */
/* Register default value on SPRMCC: 0x00000016                                 */
/* Register default value on SPRUCC: 0x00000016                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* ACK Control
*/


#define ACKCTL_IIO_PCIEDMI_REG 0x0D020940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ack_threshold : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               In JIT Mode, specified the number of 16B
                               quantities (header and.or data) that is received
                               before scheduling an ACK.
                            */
    UINT32 ack_period : 5;

                            /* Bits[15:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               In 'SG Mode' this specifies the latency after
                               which a packet will be acked. The timer starts
                               running once it is internally received. For X16,
                               the number of cycles is csr_period * 4 * (gen1 ?
                               4 : gen2 ? 2 : 1). For X8 or X4, the number is
                               scaled by 2, for X2, the number is scaled by 4,
                               and for x1, the number is scaled by 8 from the
                               X16 number. Finally, the value of the timer is
                               shifted left by the value in devctrl.mps to
                               obtain the final ack timer. The timer has an
                               accuracy for +- 4 cycles. Note: A value of 0 is
                               illegal.
                            */
    UINT32 ack_mode : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* 0 = Spec Defined (Default) 1 = SG-Like */
    UINT32 jit_mode : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               0 = Spec Defined or SG-Like depending on
                               ACK_MODE (Default) 1 = 'Just-In-Time' Mode In
                               this mode, it is suggested to also enable SG
                               Mode in bit 16 and set the ACK_PERIOD as large
                               as possible w/o causing a REPLAY_TIMEOUT. This
                               allows the JIT logic to control the majority of
                               the ACKing. In the case where the traffic volume
                               is low and does not trigger the JIT Threshold,
                               the ACK_PERIOD timer will eventually TO and
                               cause an ACK to be scheduled. When set to 0,
                               ACKing is purely based on the ACK_PERIOD (in SG
                               Mode) or the spec-defined timeout (in Spec
                               Mode).
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ACKCTL_IIO_PCIEDMI_STRUCT;

















#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJCTL_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRB0 (0x200009d0)                                                      */
/*      SPRHBM (0x200009d0)                                                     */
/*      SPRC0 (0x200009d0)                                                      */
/*      SPRMCC (0x200009d0)                                                     */
/*      SPRUCC (0x200009d0)                                                     */
/* Register default value on SPRB0: 0x00FFF000                                  */
/* Register default value on SPRHBM: 0x00FFF000                                 */
/* Register default value on SPRC0: 0x00FFF000                                  */
/* Register default value on SPRMCC: 0x00FFF000                                 */
/* Register default value on SPRUCC: 0x00FFF000                                 */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Control
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJMSK_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRB0 (0x200009d4)                                                      */
/*      SPRHBM (0x200009d4)                                                     */
/*      SPRC0 (0x200009d4)                                                      */
/*      SPRMCC (0x200009d4)                                                     */
/*      SPRUCC (0x200009d4)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Mask
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJMSKWID_IIO_PCIEDMI_REG supported on:                                */
/*      SPRB0 (0x200009d8)                                                      */
/*      SPRHBM (0x200009d8)                                                     */
/*      SPRC0 (0x200009d8)                                                      */
/*      SPRMCC (0x200009d8)                                                     */
/*      SPRUCC (0x200009d8)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Mask Width ID
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* PT0LNKCLKGCTL_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x100009e4)                                                      */
/*      SPRB0 (0x100009e4)                                                      */
/*      SPRHBM (0x100009e4)                                                     */
/*      SPRC0 (0x100009e4)                                                      */
/*      SPRMCC (0x100009e4)                                                     */
/*      SPRUCC (0x100009e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 Link Clock Gate Control
*/


#define PT0LNKCLKGCTL_IIO_PCIEDMI_REG 0x0D0109E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0LNKCLKGCTL_IIO_PCIEDMI_STRUCT;

/* CFGPCIECLKGCTL_IIO_PCIEDMI_REG supported on:                                 */
/*      SPRA0 (0x100009ec)                                                      */
/*      SPRB0 (0x100009ec)                                                      */
/*      SPRHBM (0x100009ec)                                                     */
/*      SPRC0 (0x100009ec)                                                      */
/*      SPRMCC (0x100009ec)                                                     */
/*      SPRUCC (0x100009ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Configuration PCIe Clock Gate Control
*/


#define CFGPCIECLKGCTL_IIO_PCIEDMI_REG 0x0D0109EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} CFGPCIECLKGCTL_IIO_PCIEDMI_STRUCT;

/* SECEXPCAP_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000a30)                                                      */
/*      SPRB0 (0x20000a30)                                                      */
/*      SPRHBM (0x20000a30)                                                     */
/*      SPRC0 (0x20000a30)                                                      */
/*      SPRMCC (0x20000a30)                                                     */
/*      SPRUCC (0x20000a30)                                                     */
/* Register default value on SPRA0: 0x00010019                                  */
/* Register default value on SPRB0: 0x00010019                                  */
/* Register default value on SPRHBM: 0x00010019                                 */
/* Register default value on SPRC0: 0x00010019                                  */
/* Register default value on SPRMCC: 0x00010019                                 */
/* Register default value on SPRUCC: 0x00010019                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Secondary PCI Express Extended Capability Header
*/


#define SECEXPCAP_IIO_PCIEDMI_REG 0x0D020A30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000019*/

                            /*
                               PCI Express Extended Capability ID for the
                               Secondary PCI Express Extended Capability is
                               0019h
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Extended Capability structure or 000h if
                               no other items exist in the linked list of
                               Capabilities. Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} SECEXPCAP_IIO_PCIEDMI_STRUCT;

/* LINKCTL3_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000a34)                                                      */
/*      SPRB0 (0x20000a34)                                                      */
/*      SPRHBM (0x20000a34)                                                     */
/*      SPRC0 (0x20000a34)                                                      */
/*      SPRMCC (0x20000a34)                                                     */
/*      SPRUCC (0x20000a34)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Control 3
*/


#define LINKCTL3_IIO_PCIEDMI_REG 0x0D020A34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pe : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               When this register is 1b and a 1b is written to
                               the 'Link Retrain' register with 'Target Link
                               Speed' set to 8 GT/s or higher, the Downstream
                               Port must perform Transmitter Equalization.
                               Software must guarantee that no transactions are
                               pending in the link while the link is in
                               Recovery when this bit is set to 1b. This bit is
                               not applicable and is reserved for Endpoints,
                               PCI Express to PCI/PCIX bridges, and Upstream
                               Ports of Switches.
                            */
    UINT32 lnkeqreqinten : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of
                               interrupt to indicate that the Link Equalization
                               Request bit or the Link Equalization Request
                               16.0 GT/s bit has been set. This bit is not
                               applicable and is reserved for Endpoints, PCI
                               Express to PCI/PCIX bridges, and Upstream Ports
                               of Switches.
                            */
    UINT32 rsvd : 7;

                            /* Bits[8:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 elskposgv : 4;

                            /* Bits[12:9], Access Type=RW, default=0x00000000*/

                            /*
                               When the Link is in L0 and the bit in this field
                               corresponding to the current Link speed is Set,
                               SKP Ordered Sets are scheduled at the rate
                               defined for SRNS, overriding the rate required
                               based on the clock tolerance architecture. See
                               section 4.2.7 for additional requirements. Bit
                               definitions within this field are: Bit 0 2.5
                               GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3 16.0
                               GT/s Bits 6:4 RsvdP Each unreserved bit in this
                               field must be RW if the corresponding bit in the
                               Lower SKP OS Generation Supported Speeds Vector
                               is Set, otherwise the bit must to be RW or
                               hardwired to 0. Behavior is undefined if a bit
                               is Set in this field and the corresponding bit
                               in the Lower SKP OS Generation Supported Speeds
                               Vector is not Set. The default value of this
                               field is 000 0000b
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINKCTL3_IIO_PCIEDMI_STRUCT;

/* LANEERRSTS_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000a38)                                                      */
/*      SPRB0 (0x20000a38)                                                      */
/*      SPRHBM (0x20000a38)                                                     */
/*      SPRC0 (0x20000a38)                                                      */
/*      SPRMCC (0x20000a38)                                                     */
/*      SPRUCC (0x20000a38)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Equalization Control Register consist of control fields required for per lane equalization and the number of entries in this register are sized by Max Link Width
*/


#define LANEERRSTS_IIO_PCIEDMI_REG 0x0D020A38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l0err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l1err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l2err : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l3err : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l4err : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l5err : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l6err : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l7err : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LANEERRSTS_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a3c)                                                      */
/*      SPRB0 (0x10000a3c)                                                      */
/*      SPRHBM (0x10000a3c)                                                     */
/*      SPRC0 (0x10000a3c)                                                      */
/*      SPRMCC (0x10000a3c)                                                     */
/*      SPRUCC (0x10000a3c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_0_IIO_PCIEDMI_REG 0x0D010A3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_0_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a3e)                                                      */
/*      SPRB0 (0x10000a3e)                                                      */
/*      SPRHBM (0x10000a3e)                                                     */
/*      SPRC0 (0x10000a3e)                                                      */
/*      SPRMCC (0x10000a3e)                                                     */
/*      SPRUCC (0x10000a3e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_1_IIO_PCIEDMI_REG 0x0D010A3E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_1_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a40)                                                      */
/*      SPRB0 (0x10000a40)                                                      */
/*      SPRHBM (0x10000a40)                                                     */
/*      SPRC0 (0x10000a40)                                                      */
/*      SPRMCC (0x10000a40)                                                     */
/*      SPRUCC (0x10000a40)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_2_IIO_PCIEDMI_REG 0x0D010A40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_2_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_3_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a42)                                                      */
/*      SPRB0 (0x10000a42)                                                      */
/*      SPRHBM (0x10000a42)                                                     */
/*      SPRC0 (0x10000a42)                                                      */
/*      SPRMCC (0x10000a42)                                                     */
/*      SPRUCC (0x10000a42)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_3_IIO_PCIEDMI_REG 0x0D010A42

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_3_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_4_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a44)                                                      */
/*      SPRB0 (0x10000a44)                                                      */
/*      SPRHBM (0x10000a44)                                                     */
/*      SPRC0 (0x10000a44)                                                      */
/*      SPRMCC (0x10000a44)                                                     */
/*      SPRUCC (0x10000a44)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_4_IIO_PCIEDMI_REG 0x0D010A44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_4_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_5_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a46)                                                      */
/*      SPRB0 (0x10000a46)                                                      */
/*      SPRHBM (0x10000a46)                                                     */
/*      SPRC0 (0x10000a46)                                                      */
/*      SPRMCC (0x10000a46)                                                     */
/*      SPRUCC (0x10000a46)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_5_IIO_PCIEDMI_REG 0x0D010A46

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_5_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_6_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a48)                                                      */
/*      SPRB0 (0x10000a48)                                                      */
/*      SPRHBM (0x10000a48)                                                     */
/*      SPRC0 (0x10000a48)                                                      */
/*      SPRMCC (0x10000a48)                                                     */
/*      SPRUCC (0x10000a48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_6_IIO_PCIEDMI_REG 0x0D010A48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_6_IIO_PCIEDMI_STRUCT;

/* LANEEQCTL_7_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000a4a)                                                      */
/*      SPRB0 (0x10000a4a)                                                      */
/*      SPRHBM (0x10000a4a)                                                     */
/*      SPRC0 (0x10000a4a)                                                      */
/*      SPRMCC (0x10000a4a)                                                     */
/*      SPRUCC (0x10000a4a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Lane Equalization Control
*/


#define LANEEQCTL_7_IIO_PCIEDMI_REG 0x0D010A4A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 8.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 1111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 dprph : 3;

                            /* Bits[6:4], Access Type=RW/L, default=None*/

                            /*
                               Receiver Preset Hint may be used as a hint for
                               8.0 GT/s receiver equalization by this Port when
                               the Port is operating as a Downstream Port. This
                               field is ignored when the Port is operating as
                               an Upstream Port. See Chapter 9 for details. The
                               field encodings are defined in Section 4.2.3.2.
                               For an Upstream Port if Crosslink Supported is
                               0b, this field is RsvdP. Otherwise, this field
                               is HwInit. See Section 7.10.18. The default
                               value is 111b. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 uptp : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during 8.0 GT/s Link Equalization.
                               Field usage varies, see PCIe Spec. for details.
                               See PCIe Spec. Sections 4.2.3 and Chapter 9 for
                               details. The field encodings are defined in PCIe
                               Spec. Section 4.2.3.2. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 uprph : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Receiver Preset Hint value
                               sent or received during 8.0 GT/s Link
                               Equalization. Field usage varies, see PCIe Spec.
                               for details. See PCIe Spec. Sections 4.2.3 and
                               Chapter 9 for details. The field encodings are
                               defined in PCIe Spec. Section 4.2.3.2. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} LANEEQCTL_7_IIO_PCIEDMI_STRUCT;

/* DLFECH_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000a90)                                                      */
/*      SPRB0 (0x20000a90)                                                      */
/*      SPRHBM (0x20000a90)                                                     */
/*      SPRC0 (0x20000a90)                                                      */
/*      SPRMCC (0x20000a90)                                                     */
/*      SPRUCC (0x20000a90)                                                     */
/* Register default value on SPRA0: 0x00010025                                  */
/* Register default value on SPRB0: 0x00010025                                  */
/* Register default value on SPRHBM: 0x00010025                                 */
/* Register default value on SPRC0: 0x00010025                                  */
/* Register default value on SPRMCC: 0x00010025                                 */
/* Register default value on SPRUCC: 0x00010025                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Data Link Feature Extended Capability Header
*/


#define DLFECH_IIO_PCIEDMI_REG 0x0D020A90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000025*/

                            /*
                               This field is a PCISIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. Extended Capability ID for Data Link
                               Feature is 0025h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities list. (G4ECH). Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register . Software will need to program
                               this field appropriately for linked capabilities
                               list if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} DLFECH_IIO_PCIEDMI_STRUCT;

/* DLFCAP_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000a94)                                                      */
/*      SPRB0 (0x20000a94)                                                      */
/*      SPRHBM (0x20000a94)                                                     */
/*      SPRC0 (0x20000a94)                                                      */
/*      SPRMCC (0x20000a94)                                                     */
/*      SPRUCC (0x20000a94)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Data Link Feature Capabilities
*/


#define DLFCAP_IIO_PCIEDMI_REG 0x0D020A94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ldlfs : 23;

                            /* Bits[22:0], Access Type=RW/L, default=None*/

                            /*
                               This field contains the Feature Supported value
                               used when this Port sends a Data Link Feature
                               DLLP (see PCIe Spec. Figure 3-12). Defined
                               features are: Bit 0 - Local Scaled Flow Control
                               Supported This bit indicates that this Port
                               supports the Scaled Flow Control Feature (see
                               PCIe Spec. Section 3.4.2). Bits 22:1 RsvdP Bits
                               associated with features that this Port is
                               capable of supporting are HwInit, defaulting to
                               1b. Other bits in this field are RsvdP. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 rsvd : 8;

                            /* Bits[30:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlfee : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that this Port will
                               enter the DL_Feature negotiation state (see PCIe
                               Spec. Section 3.2.1). Default is 1b. Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */

  } Bits;
  UINT32 Data;

} DLFCAP_IIO_PCIEDMI_STRUCT;

/* DLFSTS_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000a98)                                                      */
/*      SPRB0 (0x20000a98)                                                      */
/*      SPRHBM (0x20000a98)                                                     */
/*      SPRC0 (0x20000a98)                                                      */
/*      SPRMCC (0x20000a98)                                                     */
/*      SPRUCC (0x20000a98)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Data Link Feature Status
*/


#define DLFSTS_IIO_PCIEDMI_REG 0x0D020A98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdlfs : 23;

                            /* Bits[22:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               These bits indicate that the Remote Port
                               supports the corresponding Data Link Feature.
                               These bits capture all information from the
                               Feature Supported field of the Data Link Feature
                               DLLP even when this Port does not support the
                               corresponding feature. This field is Cleared on
                               entry to state DL_Inactive (see PCIe Spec.
                               Section 3.2.1). Features currently defined are:
                               Bit 0 - Remote Scaled Flow Control Supported
                               This bit indicates that the Remote Port supports
                               the Scaled Flow Control Feature (see PCIe Spec.
                               Section 3.4.2). Bits 22:1 - Undefined
                            */
    UINT32 rsvd : 8;

                            /* Bits[30:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rdlfsv : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates that the Port has received a
                               Data Link Feature DLLP in state DL_Feature (see
                               PCIe Spec. Section 3.2.1) and that the Remote
                               Data Link Feature Supported field is meaningful.
                               This bit is Cleared on entry to state
                               DL_Inactive (see PCIe Spec. Section 3.2.1).
                               Default is 0b.
                            */

  } Bits;
  UINT32 Data;

} DLFSTS_IIO_PCIEDMI_STRUCT;

/* G4ECH_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000a9c)                                                      */
/*      SPRB0 (0x20000a9c)                                                      */
/*      SPRHBM (0x20000a9c)                                                     */
/*      SPRC0 (0x20000a9c)                                                      */
/*      SPRMCC (0x20000a9c)                                                     */
/*      SPRUCC (0x20000a9c)                                                     */
/* Register default value on SPRA0: 0x00010026                                  */
/* Register default value on SPRB0: 0x00010026                                  */
/* Register default value on SPRHBM: 0x00010026                                 */
/* Register default value on SPRC0: 0x00010026                                  */
/* Register default value on SPRMCC: 0x00010026                                 */
/* Register default value on SPRUCC: 0x00010026                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Physical Layer 16.0 GT/s Extended Capability Header
*/


#define G4ECH_IIO_PCIEDMI_REG 0x0D020A9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000026*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Physical Layer 16.0 GT/s Capability is 0026h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} G4ECH_IIO_PCIEDMI_STRUCT;

/* G4CAP_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000aa0)                                                      */
/*      SPRB0 (0x20000aa0)                                                      */
/*      SPRHBM (0x20000aa0)                                                     */
/*      SPRC0 (0x20000aa0)                                                      */
/*      SPRMCC (0x20000aa0)                                                     */
/*      SPRUCC (0x20000aa0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* 16.0 GT/s Capabilities
*/


#define G4CAP_IIO_PCIEDMI_REG 0x0D020AA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvdp : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* RsvdP */

  } Bits;
  UINT32 Data;

} G4CAP_IIO_PCIEDMI_STRUCT;

/* G4CTL_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000aa4)                                                      */
/*      SPRB0 (0x20000aa4)                                                      */
/*      SPRHBM (0x20000aa4)                                                     */
/*      SPRC0 (0x20000aa4)                                                      */
/*      SPRMCC (0x20000aa4)                                                     */
/*      SPRUCC (0x20000aa4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s Control
*/


#define G4CTL_IIO_PCIEDMI_REG 0x0D020AA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvdp : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* RsvdP */

  } Bits;
  UINT32 Data;

} G4CTL_IIO_PCIEDMI_STRUCT;

/* G4STS_IIO_PCIEDMI_REG supported on:                                          */
/*      SPRA0 (0x20000aa8)                                                      */
/*      SPRB0 (0x20000aa8)                                                      */
/*      SPRHBM (0x20000aa8)                                                     */
/*      SPRC0 (0x20000aa8)                                                      */
/*      SPRMCC (0x20000aa8)                                                     */
/*      SPRUCC (0x20000aa8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s Status
*/


#define G4STS_IIO_PCIEDMI_REG 0x0D020AA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eq16cmplt : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that the 16.0 GT/s
                               Transmitter Equalization procedure has
                               completed. Details of the Transmitter
                               Equalization process and when this bit needs to
                               be set to 1b is provided in PCIe Spec. Section
                               4.2.6.4.2. The default value of this bit is 0b.
                               For a Multi-Function Upstream Port, this bit
                               must be implemented in Function 0 and RsvdZ in
                               other Functions.
                            */
    UINT32 eq16ph1succ : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq16ph2succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq16ph3succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 linkeqreq16 : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 16.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G4STS_IIO_PCIEDMI_STRUCT;

/* G4LDPMSTS_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000aac)                                                      */
/*      SPRB0 (0x20000aac)                                                      */
/*      SPRHBM (0x20000aac)                                                     */
/*      SPRC0 (0x20000aac)                                                      */
/*      SPRMCC (0x20000aac)                                                     */
/*      SPRUCC (0x20000aac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s Local Data Parity Mismatch Status
*/


#define G4LDPMSTS_IIO_PCIEDMI_REG 0x0D020AAC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l0ldpms : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l1ldpms : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l2ldpms : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l3ldpms : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l4ldpms : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l5ldpms : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l6ldpms : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l7ldpms : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l8ldpms : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l9ldpms : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l10ldpms : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l11ldpms : 1;

                            /* Bits[11:11], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l12ldpms : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l13ldpms : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l14ldpms : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 l15ldpms : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. For Ports that are narrower than
                               32 Lanes, the unused upper bits [31: Maximum
                               Link Width] are RsvdZ.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G4LDPMSTS_IIO_PCIEDMI_STRUCT;

/* G4FRDPMSTS_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000ab0)                                                      */
/*      SPRB0 (0x20000ab0)                                                      */
/*      SPRHBM (0x20000ab0)                                                     */
/*      SPRC0 (0x20000ab0)                                                      */
/*      SPRMCC (0x20000ab0)                                                     */
/*      SPRUCC (0x20000ab0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s First Retimer Data Parity Mismatch Status
*/


#define G4FRDPMSTS_IIO_PCIEDMI_REG 0x0D020AB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l0frdpms : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l1frdpms : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l2frdpms : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l3frdpms : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l4frdpms : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l5frdpms : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l6frdpms : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l7frdpms : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l8frdpms : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l9frdpms : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l10frdpms : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l11frdpms : 1;

                            /* Bits[11:11], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l12frdpms : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l13frdpms : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l14frdpms : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 l15frdpms : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present. For
                               Ports that are narrower than 32 Lanes, the
                               unused upper bits [31: Maximum Link Width] are
                               RsvdZ.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G4FRDPMSTS_IIO_PCIEDMI_STRUCT;

/* G4SRDPMSTS_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000ab4)                                                      */
/*      SPRB0 (0x20000ab4)                                                      */
/*      SPRHBM (0x20000ab4)                                                     */
/*      SPRC0 (0x20000ab4)                                                      */
/*      SPRMCC (0x20000ab4)                                                     */
/*      SPRUCC (0x20000ab4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s Second Retimer Data Parity Mismatch Status
*/


#define G4SRDPMSTS_IIO_PCIEDMI_REG 0x0D020AB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l0srdpms : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l1srdpms : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l2srdpms : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l3srdpms : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l4srdpms : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l5srdpms : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l6srdpms : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l7srdpms : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l8srdpms : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l9srdpms : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l10srdpms : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l11srdpms : 1;

                            /* Bits[11:11], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l12srdpms : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l13srdpms : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l14srdpms : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 l15srdpms : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Each bit indicates if the corresponding Lane
                               detected a Data Parity mismatch. A value of 1b
                               indicates that a mismatch was detected on the
                               corresponding Lane Number. The default value of
                               each bit is 0b. The value of this field is
                               undefined when no Retimers are present or only
                               one Retimer is present. For Ports that are
                               narrower than 32 Lanes, the unused upper bits
                               [31: Maximum Link Width] are RsvdZ.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G4SRDPMSTS_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_0_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xabc)                                                           */
/*      SPRB0 (0xabc)                                                           */
/*      SPRHBM (0xabc)                                                          */
/*      SPRC0 (0xabc)                                                           */
/*      SPRMCC (0xabc)                                                          */
/*      SPRUCC (0xabc)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_0_IIO_PCIEDMI_REG 0x0D000ABC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_0_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_1_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xabd)                                                           */
/*      SPRB0 (0xabd)                                                           */
/*      SPRHBM (0xabd)                                                          */
/*      SPRC0 (0xabd)                                                           */
/*      SPRMCC (0xabd)                                                          */
/*      SPRUCC (0xabd)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_1_IIO_PCIEDMI_REG 0x0D000ABD

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_1_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_2_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xabe)                                                           */
/*      SPRB0 (0xabe)                                                           */
/*      SPRHBM (0xabe)                                                          */
/*      SPRC0 (0xabe)                                                           */
/*      SPRMCC (0xabe)                                                          */
/*      SPRUCC (0xabe)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_2_IIO_PCIEDMI_REG 0x0D000ABE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_2_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_3_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xabf)                                                           */
/*      SPRB0 (0xabf)                                                           */
/*      SPRHBM (0xabf)                                                          */
/*      SPRC0 (0xabf)                                                           */
/*      SPRMCC (0xabf)                                                          */
/*      SPRUCC (0xabf)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_3_IIO_PCIEDMI_REG 0x0D000ABF

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_3_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_4_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xac0)                                                           */
/*      SPRB0 (0xac0)                                                           */
/*      SPRHBM (0xac0)                                                          */
/*      SPRC0 (0xac0)                                                           */
/*      SPRMCC (0xac0)                                                          */
/*      SPRUCC (0xac0)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_4_IIO_PCIEDMI_REG 0x0D000AC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_4_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_5_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xac1)                                                           */
/*      SPRB0 (0xac1)                                                           */
/*      SPRHBM (0xac1)                                                          */
/*      SPRC0 (0xac1)                                                           */
/*      SPRMCC (0xac1)                                                          */
/*      SPRUCC (0xac1)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_5_IIO_PCIEDMI_REG 0x0D000AC1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_5_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_6_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xac2)                                                           */
/*      SPRB0 (0xac2)                                                           */
/*      SPRHBM (0xac2)                                                          */
/*      SPRC0 (0xac2)                                                           */
/*      SPRMCC (0xac2)                                                          */
/*      SPRUCC (0xac2)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_6_IIO_PCIEDMI_REG 0x0D000AC2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_6_IIO_PCIEDMI_STRUCT;

/* G4LANEEQCTL_7_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0xac3)                                                           */
/*      SPRB0 (0xac3)                                                           */
/*      SPRHBM (0xac3)                                                          */
/*      SPRC0 (0xac3)                                                           */
/*      SPRMCC (0xac3)                                                          */
/*      SPRUCC (0xac3)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* 16.0 GT/s Lane Equalization Control
*/


#define G4LANEEQCTL_7_IIO_PCIEDMI_REG 0x0D000AC3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dptp : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               Transmitter Preset used for 16.0 GT/s
                               equalization by this Port when the Port is
                               operating as a Downstream Port. This field is
                               ignored when the Port is operating as an
                               Upstream Port. For an Upstream Port if Crosslink
                               Supported is 0b, this field is RsvdP. Otherwise,
                               this field is HwInit. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT8 uptp : 4;

                            /* Bits[7:4], Access Type=RW/L, default=None*/

                            /*
                               Field contains the Transmit Preset value sent or
                               received during Link Equalization. Field usage
                               varies, see PCIe Spec. for details. See PCIe
                               Spec. Sections 4.2.3 and Chapter 9 for details.
                               The field encodings are defined in PCIe Spec.
                               Section 4.2.3.2 as well. The default value is
                               1111b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT8 Data;

} G4LANEEQCTL_7_IIO_PCIEDMI_STRUCT;

/* UPCFGCSR_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d00)                                                      */
/*      SPRB0 (0x20000d00)                                                      */
/*      SPRHBM (0x20000d00)                                                     */
/*      SPRC0 (0x20000d00)                                                      */
/*      SPRMCC (0x20000d00)                                                     */
/*      SPRUCC (0x20000d00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* UP CFG Control Status
*/


#define UPCFGCSR_IIO_PCIEDMI_REG 0x0D020D00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 upcfgen : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               When UPCFGCAPEN is set to 1 and this bit is set
                               to 1, a dynamic width change is initiated if the
                               TLW field is not equal to the current link width
                               (if other end advertises support for it), this
                               bit is cleared by hardware after making one
                               attempt to change width. On error, this bit will
                               be cleared and TLW != NLW. If TLW==NLW and this
                               bit is set, hardware will clear it without
                               entering Recovery/Config.
                            */
    UINT32 tlw : 6;

                            /* Bits[6:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               This is the target link width used when
                               mastering a dynamic width change. If TLW is
                               greater than the initial trained link width when
                               LinkUp goes to 0-->1, then the initial link
                               width is chosen as a cap.
                            */
    UINT32 upcfgcapen : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               This bit when set to 1 enables advertising
                               dynamic width support in the training sequences.
                               When this bit is set 1 from 0, the link will
                               move through Recovery to Config advertising
                               upconfigure capability. It will also ignore the
                               settings in fields TLW and UPCFGEN at the time
                               the bit is set.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ilw : 6;

                            /* Bits[21:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               Initial Link Width (maximum width to up
                               configure to). ILW format is the same as MLW.
                            */
    UINT32 rcvdupcfgcap : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /* Received up configure support by link partner. */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} UPCFGCSR_IIO_PCIEDMI_STRUCT;


/* SPEEDCTL2_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d08)                                                      */
/*      SPRB0 (0x20000d08)                                                      */
/*      SPRHBM (0x20000d08)                                                     */
/*      SPRC0 (0x20000d08)                                                      */
/*      SPRMCC (0x20000d08)                                                     */
/*      SPRUCC (0x20000d08)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Speed Control 2
*/


#define SPEEDCTL2_IIO_PCIEDMI_REG 0x0D020D08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ovrdisgen4 : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Override of disabling gen4 */
    UINT32 disg4polcfg : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* Don't support advertising Gen4 speed in polling. */
    UINT32 disg4unlessrcvdts : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Don't support speeds 16GT/s and higher until
                               other device advertises it after a speed change
                               failure or the 200ms timer expires.
                            */
    UINT32 forcegen4 : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Forces LTSSM to Detect and then trains link
                               at 16GT/s mode 0: Releases forced speed
                            */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 maxadv4initeq : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, the highest rate advertised since
                               exiting Detect is used to determine the 16GT/s
                               and 32GT/s initial speed change for EQ. If not
                               set, use last advertised speed from TS2s. This
                               is applicable to DP only.
                            */
    UINT32 rsvd_9 : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 clrspeedblocks : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Clear RAS speed blocks not tied to control
                               registers Always reads 0. A write of 1 will
                               clear internal state that blocks speed support.
                               This includes but may not be limited to EQ fail
                               and speed change fail timer. If the blocker can
                               be cleared with an existing control register, it
                               is not affected by this bit.
                            */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPEEDCTL2_IIO_PCIEDMI_STRUCT;

/* LTLGCAP_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000d14)                                                      */
/*      SPRB0 (0x20000d14)                                                      */
/*      SPRHBM (0x20000d14)                                                     */
/*      SPRC0 (0x20000d14)                                                      */
/*      SPRMCC (0x20000d14)                                                     */
/*      SPRUCC (0x20000d14)                                                     */
/* Register default value on SPRA0: 0x3D000000                                  */
/* Register default value on SPRB0: 0x3D000000                                  */
/* Register default value on SPRHBM: 0x3D000000                                 */
/* Register default value on SPRC0: 0x3D000000                                  */
/* Register default value on SPRMCC: 0x3D000000                                 */
/* Register default value on SPRUCC: 0x3D000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Capability
*/


#define LTLGCAP_IIO_PCIEDMI_REG 0x0D020D14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numsublog : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /* Number of sub-loggers supported. */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ramsize : 12;

                            /* Bits[15:4], Access Type=RO/V, default=0x00000000*/

                            /* Number of total ram entries. */
    UINT32 baroffset : 16;

                            /* Bits[31:16], Access Type=RO, default=0x00003D00*/

                            /* Memory bar offset for ram entry 0 */

  } Bits;
  UINT32 Data;

} LTLGCAP_IIO_PCIEDMI_STRUCT;

/* LTLGCTRL_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d18)                                                      */
/*      SPRB0 (0x20000d18)                                                      */
/*      SPRHBM (0x20000d18)                                                     */
/*      SPRC0 (0x20000d18)                                                      */
/*      SPRMCC (0x20000d18)                                                     */
/*      SPRUCC (0x20000d18)                                                     */
/* Register default value on SPRA0: 0x00321000                                  */
/* Register default value on SPRB0: 0x00321000                                  */
/* Register default value on SPRHBM: 0x00321000                                 */
/* Register default value on SPRC0: 0x00321000                                  */
/* Register default value on SPRMCC: 0x00321000                                 */
/* Register default value on SPRUCC: 0x00321000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Control
*/


#define LTLGCTRL_IIO_PCIEDMI_REG 0x0D020D18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 splitctl : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Control of splitting logger if 1 sub log,
                               ignored if 2 sub logs, only bit 0 used [0] = 1,
                               sublog0 owns full ram [0] = 0, sublog0/1 split
                               ram if 4 sub-logs 1-- = sublog0 owns full ram
                               011 = sublog0/2 split ram in half 001 = sublog0
                               gets half, sublog2/3 get a quarter each 010 =
                               sublog0/1 get a quarter each, sublog2 gets half
                               000 = sublog0/1/2/3 get a quarter each
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 clearall : 1;

                            /* Bits[4:4], Access Type=RW/V/P, default=0x00000000*/

                            /* Clear and restart all sub-loggers. */
    UINT32 rsvd_5 : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sublog0pt : 3;

                            /* Bits[10:8], Access Type=RW/P, default=0x00000000*/

                            /* Port to assign to sub-logger 0. */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sublog1pt : 3;

                            /* Bits[14:12], Access Type=RW/P, default=0x00000001*/

                            /* Port to assign to sub-logger 1. */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sublog2pt : 3;

                            /* Bits[18:16], Access Type=RW/P, default=0x00000002*/

                            /* Port to assign to sub-logger 2. */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sublog3pt : 3;

                            /* Bits[22:20], Access Type=RW/P, default=0x00000003*/

                            /* Port to assign to sub-logger 3. */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGCTRL_IIO_PCIEDMI_STRUCT;

/* LTLGRDCT_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d1c)                                                      */
/*      SPRB0 (0x20000d1c)                                                      */
/*      SPRHBM (0x20000d1c)                                                     */
/*      SPRC0 (0x20000d1c)                                                      */
/*      SPRMCC (0x20000d1c)                                                     */
/*      SPRUCC (0x20000d1c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Read Control
*/


#define LTLGRDCT_IIO_PCIEDMI_REG 0x0D020D1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdindex : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The value in this field will point the LTLGRES
                               register to a particular log entry. 0 is the
                               latest entry 63 is oldest entry
                            */
    UINT32 rsvd : 9;

                            /* Bits[14:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 autoinc : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Every time a read to LTLGRES happens, the
                               read index increment automatically 0: manual
                               movement of the read index is required
                            */
    UINT32 logsel : 2;

                            /* Bits[17:16], Access Type=RW/P, default=0x00000000*/

                            /* Select which sub-logger to read. */
    UINT32 rsvd_18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGRDCT_IIO_PCIEDMI_STRUCT;

/* LTLGRES_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000d20)                                                      */
/*      SPRB0 (0x20000d20)                                                      */
/*      SPRHBM (0x20000d20)                                                     */
/*      SPRC0 (0x20000d20)                                                      */
/*      SPRMCC (0x20000d20)                                                     */
/*      SPRUCC (0x20000d20)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Read Result
*/


#define LTLGRES_IIO_PCIEDMI_REG 0x0D020D20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 entry : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0xFFFFFFFF*/

                            /*
                               [31] Time granularity bit 1=512ns 0=2ns Switch
                               between modes is done when [30:14] increments
                               past 1FFFFh [30:14] time unit count see bit 31
                               for unit definition [13:10] State exit arc
                               0=state not exited 1..15=see state specific map
                               [9:8] RxL0s State [7:4] LTSSM Main state [3:0]
                               LTSSM Sub state
                            */

  } Bits;
  UINT32 Data;

} LTLGRES_IIO_PCIEDMI_STRUCT;

/* LTLGSTART0_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000d24)                                                      */
/*      SPRB0 (0x20000d24)                                                      */
/*      SPRHBM (0x20000d24)                                                     */
/*      SPRC0 (0x20000d24)                                                      */
/*      SPRMCC (0x20000d24)                                                     */
/*      SPRUCC (0x20000d24)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start
*/


#define LTLGSTART0_IIO_PCIEDMI_REG 0x0D020D24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               Enable logging. 0-->1 transition will clear log
                               data If using the stop trigger, this bit will
                               clear if the stop trigger event occurs.
                               LTLGSTART[3:0] is based on one per sub-logger.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 starttriggered : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the start trigger event was hit. */
    UINT32 starttrgen : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, logging starts when the start trigger
                               field and mask match the current LTSSM state/arc
                            */
    UINT32 starttrg : 14;

                            /* Bits[17:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, start trigger value, used in
                               conjunction with the start trigger mask [13:10]
                               State exit arc [9:8] RxL0s state [7:4] LTSSM
                               main state [3:0] LTSSM sub state If XSTOPTRGEN =
                               1, bits [12:4] are used, [17:13] reserved. Here
                               is the definition of the external trigger event
                               using the mask and dmona/b values (Note: bits
                               [12:7] act as a RATEV field just like the
                               LTLGSTPEXT register) bits [6:4] 000 - trigger <=
                               (!a and !b) 001 - trigger <= ( a and !b) 010 -
                               trigger <= (!a and b) 011 - trigger <= ( a and
                               b) 100 - trigger <= (!a | !b) 101 - trigger <= (
                               a | !b) 110 - trigger <= (!a | b) 111 - trigger
                               <= ( a | b) a = bit[18] | dmona b = bit[19] |
                               dmonb
                            */
    UINT32 starttrgmsk : 14;

                            /* Bits[31:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, and any bit is set to 1, it
                               will make that corresponding start trigger bit a
                               don't care (always match). If XSTOPTRGEN = 1,
                               bits [19:18] are used and [31:20] reserved. Here
                               is the definition for a and b which is the OR
                               mask to dmona/b. a = bit[18] | dmona b = bit[19]
                               | dmonb
                            */

  } Bits;
  UINT32 Data;

} LTLGSTART0_IIO_PCIEDMI_STRUCT;

/* LTLGSTARTEXT0_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000d28)                                                      */
/*      SPRB0 (0x20000d28)                                                      */
/*      SPRHBM (0x20000d28)                                                     */
/*      SPRC0 (0x20000d28)                                                      */
/*      SPRMCC (0x20000d28)                                                     */
/*      SPRUCC (0x20000d28)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start Ext
*/


#define LTLGSTARTEXT0_IIO_PCIEDMI_REG 0x0D020D28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the start trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTARTEXT0_IIO_PCIEDMI_STRUCT;

/* LTLGSTART1_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000d2c)                                                      */
/*      SPRB0 (0x20000d2c)                                                      */
/*      SPRHBM (0x20000d2c)                                                     */
/*      SPRC0 (0x20000d2c)                                                      */
/*      SPRMCC (0x20000d2c)                                                     */
/*      SPRUCC (0x20000d2c)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start
*/


#define LTLGSTART1_IIO_PCIEDMI_REG 0x0D020D2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               Enable logging. 0-->1 transition will clear log
                               data If using the stop trigger, this bit will
                               clear if the stop trigger event occurs.
                               LTLGSTART[3:0] is based on one per sub-logger.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 starttriggered : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the start trigger event was hit. */
    UINT32 starttrgen : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, logging starts when the start trigger
                               field and mask match the current LTSSM state/arc
                            */
    UINT32 starttrg : 14;

                            /* Bits[17:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, start trigger value, used in
                               conjunction with the start trigger mask [13:10]
                               State exit arc [9:8] RxL0s state [7:4] LTSSM
                               main state [3:0] LTSSM sub state If XSTOPTRGEN =
                               1, bits [12:4] are used, [17:13] reserved. Here
                               is the definition of the external trigger event
                               using the mask and dmona/b values (Note: bits
                               [12:7] act as a RATEV field just like the
                               LTLGSTPEXT register) bits [6:4] 000 - trigger <=
                               (!a and !b) 001 - trigger <= ( a and !b) 010 -
                               trigger <= (!a and b) 011 - trigger <= ( a and
                               b) 100 - trigger <= (!a | !b) 101 - trigger <= (
                               a | !b) 110 - trigger <= (!a | b) 111 - trigger
                               <= ( a | b) a = bit[18] | dmona b = bit[19] |
                               dmonb
                            */
    UINT32 starttrgmsk : 14;

                            /* Bits[31:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, and any bit is set to 1, it
                               will make that corresponding start trigger bit a
                               don't care (always match). If XSTOPTRGEN = 1,
                               bits [19:18] are used and [31:20] reserved. Here
                               is the definition for a and b which is the OR
                               mask to dmona/b. a = bit[18] | dmona b = bit[19]
                               | dmonb
                            */

  } Bits;
  UINT32 Data;

} LTLGSTART1_IIO_PCIEDMI_STRUCT;

/* LTLGSTARTEXT1_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000d30)                                                      */
/*      SPRB0 (0x20000d30)                                                      */
/*      SPRHBM (0x20000d30)                                                     */
/*      SPRC0 (0x20000d30)                                                      */
/*      SPRMCC (0x20000d30)                                                     */
/*      SPRUCC (0x20000d30)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start Ext
*/


#define LTLGSTARTEXT1_IIO_PCIEDMI_REG 0x0D020D30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the start trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTARTEXT1_IIO_PCIEDMI_STRUCT;

/* LTLGSTART2_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000d34)                                                      */
/*      SPRB0 (0x20000d34)                                                      */
/*      SPRHBM (0x20000d34)                                                     */
/*      SPRC0 (0x20000d34)                                                      */
/*      SPRMCC (0x20000d34)                                                     */
/*      SPRUCC (0x20000d34)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start
*/


#define LTLGSTART2_IIO_PCIEDMI_REG 0x0D020D34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               Enable logging. 0-->1 transition will clear log
                               data If using the stop trigger, this bit will
                               clear if the stop trigger event occurs.
                               LTLGSTART[3:0] is based on one per sub-logger.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 starttriggered : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the start trigger event was hit. */
    UINT32 starttrgen : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, logging starts when the start trigger
                               field and mask match the current LTSSM state/arc
                            */
    UINT32 starttrg : 14;

                            /* Bits[17:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, start trigger value, used in
                               conjunction with the start trigger mask [13:10]
                               State exit arc [9:8] RxL0s state [7:4] LTSSM
                               main state [3:0] LTSSM sub state If XSTOPTRGEN =
                               1, bits [12:4] are used, [17:13] reserved. Here
                               is the definition of the external trigger event
                               using the mask and dmona/b values (Note: bits
                               [12:7] act as a RATEV field just like the
                               LTLGSTPEXT register) bits [6:4] 000 - trigger <=
                               (!a and !b) 001 - trigger <= ( a and !b) 010 -
                               trigger <= (!a and b) 011 - trigger <= ( a and
                               b) 100 - trigger <= (!a | !b) 101 - trigger <= (
                               a | !b) 110 - trigger <= (!a | b) 111 - trigger
                               <= ( a | b) a = bit[18] | dmona b = bit[19] |
                               dmonb
                            */
    UINT32 starttrgmsk : 14;

                            /* Bits[31:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, and any bit is set to 1, it
                               will make that corresponding start trigger bit a
                               don't care (always match). If XSTOPTRGEN = 1,
                               bits [19:18] are used and [31:20] reserved. Here
                               is the definition for a and b which is the OR
                               mask to dmona/b. a = bit[18] | dmona b = bit[19]
                               | dmonb
                            */

  } Bits;
  UINT32 Data;

} LTLGSTART2_IIO_PCIEDMI_STRUCT;

/* LTLGSTARTEXT2_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000d38)                                                      */
/*      SPRB0 (0x20000d38)                                                      */
/*      SPRHBM (0x20000d38)                                                     */
/*      SPRC0 (0x20000d38)                                                      */
/*      SPRMCC (0x20000d38)                                                     */
/*      SPRUCC (0x20000d38)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start Ext
*/


#define LTLGSTARTEXT2_IIO_PCIEDMI_REG 0x0D020D38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the start trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTARTEXT2_IIO_PCIEDMI_STRUCT;

/* LTLGSTART3_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000d3c)                                                      */
/*      SPRB0 (0x20000d3c)                                                      */
/*      SPRHBM (0x20000d3c)                                                     */
/*      SPRC0 (0x20000d3c)                                                      */
/*      SPRMCC (0x20000d3c)                                                     */
/*      SPRUCC (0x20000d3c)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start
*/


#define LTLGSTART3_IIO_PCIEDMI_REG 0x0D020D3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               Enable logging. 0-->1 transition will clear log
                               data If using the stop trigger, this bit will
                               clear if the stop trigger event occurs.
                               LTLGSTART[3:0] is based on one per sub-logger.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 starttriggered : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the start trigger event was hit. */
    UINT32 starttrgen : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, logging starts when the start trigger
                               field and mask match the current LTSSM state/arc
                            */
    UINT32 starttrg : 14;

                            /* Bits[17:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, start trigger value, used in
                               conjunction with the start trigger mask [13:10]
                               State exit arc [9:8] RxL0s state [7:4] LTSSM
                               main state [3:0] LTSSM sub state If XSTOPTRGEN =
                               1, bits [12:4] are used, [17:13] reserved. Here
                               is the definition of the external trigger event
                               using the mask and dmona/b values (Note: bits
                               [12:7] act as a RATEV field just like the
                               LTLGSTPEXT register) bits [6:4] 000 - trigger <=
                               (!a and !b) 001 - trigger <= ( a and !b) 010 -
                               trigger <= (!a and b) 011 - trigger <= ( a and
                               b) 100 - trigger <= (!a | !b) 101 - trigger <= (
                               a | !b) 110 - trigger <= (!a | b) 111 - trigger
                               <= ( a | b) a = bit[18] | dmona b = bit[19] |
                               dmonb
                            */
    UINT32 starttrgmsk : 14;

                            /* Bits[31:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               If XSTOPTRGEN = 0, and any bit is set to 1, it
                               will make that corresponding start trigger bit a
                               don't care (always match). If XSTOPTRGEN = 1,
                               bits [19:18] are used and [31:20] reserved. Here
                               is the definition for a and b which is the OR
                               mask to dmona/b. a = bit[18] | dmona b = bit[19]
                               | dmonb
                            */

  } Bits;
  UINT32 Data;

} LTLGSTART3_IIO_PCIEDMI_STRUCT;

/* LTLGSTARTEXT3_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000d40)                                                      */
/*      SPRB0 (0x20000d40)                                                      */
/*      SPRHBM (0x20000d40)                                                     */
/*      SPRC0 (0x20000d40)                                                      */
/*      SPRMCC (0x20000d40)                                                     */
/*      SPRUCC (0x20000d40)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Start Ext
*/


#define LTLGSTARTEXT3_IIO_PCIEDMI_REG 0x0D020D40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the start trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTARTEXT3_IIO_PCIEDMI_STRUCT;

/* LTLGSTP0_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d44)                                                      */
/*      SPRB0 (0x20000d44)                                                      */
/*      SPRHBM (0x20000d44)                                                     */
/*      SPRC0 (0x20000d44)                                                      */
/*      SPRMCC (0x20000d44)                                                     */
/*      SPRUCC (0x20000d44)                                                     */
/* Register default value on SPRA0: 0x1E000009                                  */
/* Register default value on SPRB0: 0x1E000009                                  */
/* Register default value on SPRHBM: 0x1E000009                                 */
/* Register default value on SPRC0: 0x1E000009                                  */
/* Register default value on SPRMCC: 0x1E000009                                 */
/* Register default value on SPRUCC: 0x1E000009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop
*/


#define LTLGSTP0_IIO_PCIEDMI_REG 0x0D020D44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stoptrgen : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               If set, logging stops when the stop trigger
                               field and mask match the current LTSSM
                               state/arc. LTLGSTP[3:0] is based on one per sub-
                               logger.
                            */
    UINT32 stoptrg : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000004*/

                            /*
                               Stop trigger value, used in conjunction with the
                               stop trigger mask [13:10] State exit arc [9:8]
                               RxL0s state [7:4] LTSSM main state [3:0] LTSSM
                               sub state
                            */
    UINT32 stoptrgmsk : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00003C00*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding stopt trigger bit a don't care
                               (always match)
                            */
    UINT32 xstoptrgen : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Use external trigger event to stop logging, see
                               LTLGCTL.STARTTRG and STARTTRGMSK for
                               configuration details. Enabling this does not
                               disable the state match stop event and it does
                               disable the state match start event (acts as if
                               STARTTRGEN=0).
                            */
    UINT32 xtriggered : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, external stop trigger event occurred. */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSTP0_IIO_PCIEDMI_STRUCT;

/* LTLGSTPEXT0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000d48)                                                      */
/*      SPRB0 (0x20000d48)                                                      */
/*      SPRHBM (0x20000d48)                                                     */
/*      SPRC0 (0x20000d48)                                                      */
/*      SPRMCC (0x20000d48)                                                     */
/*      SPRUCC (0x20000d48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop Ext
*/


#define LTLGSTPEXT0_IIO_PCIEDMI_REG 0x0D020D48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the stop trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTPEXT0_IIO_PCIEDMI_STRUCT;

/* LTLGSTP1_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d4c)                                                      */
/*      SPRB0 (0x20000d4c)                                                      */
/*      SPRHBM (0x20000d4c)                                                     */
/*      SPRC0 (0x20000d4c)                                                      */
/*      SPRMCC (0x20000d4c)                                                     */
/*      SPRUCC (0x20000d4c)                                                     */
/* Register default value on SPRA0: 0x1E000009                                  */
/* Register default value on SPRB0: 0x1E000009                                  */
/* Register default value on SPRHBM: 0x1E000009                                 */
/* Register default value on SPRC0: 0x1E000009                                  */
/* Register default value on SPRMCC: 0x1E000009                                 */
/* Register default value on SPRUCC: 0x1E000009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop
*/


#define LTLGSTP1_IIO_PCIEDMI_REG 0x0D020D4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stoptrgen : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               If set, logging stops when the stop trigger
                               field and mask match the current LTSSM
                               state/arc. LTLGSTP[3:0] is based on one per sub-
                               logger.
                            */
    UINT32 stoptrg : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000004*/

                            /*
                               Stop trigger value, used in conjunction with the
                               stop trigger mask [13:10] State exit arc [9:8]
                               RxL0s state [7:4] LTSSM main state [3:0] LTSSM
                               sub state
                            */
    UINT32 stoptrgmsk : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00003C00*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding stopt trigger bit a don't care
                               (always match)
                            */
    UINT32 xstoptrgen : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Use external trigger event to stop logging, see
                               LTLGCTL.STARTTRG and STARTTRGMSK for
                               configuration details. Enabling this does not
                               disable the state match stop event and it does
                               disable the state match start event (acts as if
                               STARTTRGEN=0).
                            */
    UINT32 xtriggered : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, external stop trigger event occurred. */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSTP1_IIO_PCIEDMI_STRUCT;

/* LTLGSTPEXT1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000d50)                                                      */
/*      SPRB0 (0x20000d50)                                                      */
/*      SPRHBM (0x20000d50)                                                     */
/*      SPRC0 (0x20000d50)                                                      */
/*      SPRMCC (0x20000d50)                                                     */
/*      SPRUCC (0x20000d50)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop Ext
*/


#define LTLGSTPEXT1_IIO_PCIEDMI_REG 0x0D020D50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the stop trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTPEXT1_IIO_PCIEDMI_STRUCT;

/* LTLGSTP2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d54)                                                      */
/*      SPRB0 (0x20000d54)                                                      */
/*      SPRHBM (0x20000d54)                                                     */
/*      SPRC0 (0x20000d54)                                                      */
/*      SPRMCC (0x20000d54)                                                     */
/*      SPRUCC (0x20000d54)                                                     */
/* Register default value on SPRA0: 0x1E000009                                  */
/* Register default value on SPRB0: 0x1E000009                                  */
/* Register default value on SPRHBM: 0x1E000009                                 */
/* Register default value on SPRC0: 0x1E000009                                  */
/* Register default value on SPRMCC: 0x1E000009                                 */
/* Register default value on SPRUCC: 0x1E000009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop
*/


#define LTLGSTP2_IIO_PCIEDMI_REG 0x0D020D54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stoptrgen : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               If set, logging stops when the stop trigger
                               field and mask match the current LTSSM
                               state/arc. LTLGSTP[3:0] is based on one per sub-
                               logger.
                            */
    UINT32 stoptrg : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000004*/

                            /*
                               Stop trigger value, used in conjunction with the
                               stop trigger mask [13:10] State exit arc [9:8]
                               RxL0s state [7:4] LTSSM main state [3:0] LTSSM
                               sub state
                            */
    UINT32 stoptrgmsk : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00003C00*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding stopt trigger bit a don't care
                               (always match)
                            */
    UINT32 xstoptrgen : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Use external trigger event to stop logging, see
                               LTLGCTL.STARTTRG and STARTTRGMSK for
                               configuration details. Enabling this does not
                               disable the state match stop event and it does
                               disable the state match start event (acts as if
                               STARTTRGEN=0).
                            */
    UINT32 xtriggered : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, external stop trigger event occurred. */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSTP2_IIO_PCIEDMI_STRUCT;

/* LTLGSTPEXT2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000d58)                                                      */
/*      SPRB0 (0x20000d58)                                                      */
/*      SPRHBM (0x20000d58)                                                     */
/*      SPRC0 (0x20000d58)                                                      */
/*      SPRMCC (0x20000d58)                                                     */
/*      SPRUCC (0x20000d58)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop Ext
*/


#define LTLGSTPEXT2_IIO_PCIEDMI_REG 0x0D020D58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the stop trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTPEXT2_IIO_PCIEDMI_STRUCT;

/* LTLGSTP3_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000d5c)                                                      */
/*      SPRB0 (0x20000d5c)                                                      */
/*      SPRHBM (0x20000d5c)                                                     */
/*      SPRC0 (0x20000d5c)                                                      */
/*      SPRMCC (0x20000d5c)                                                     */
/*      SPRUCC (0x20000d5c)                                                     */
/* Register default value on SPRA0: 0x1E000009                                  */
/* Register default value on SPRB0: 0x1E000009                                  */
/* Register default value on SPRHBM: 0x1E000009                                 */
/* Register default value on SPRC0: 0x1E000009                                  */
/* Register default value on SPRMCC: 0x1E000009                                 */
/* Register default value on SPRUCC: 0x1E000009                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop
*/


#define LTLGSTP3_IIO_PCIEDMI_REG 0x0D020D5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stoptrgen : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               If set, logging stops when the stop trigger
                               field and mask match the current LTSSM
                               state/arc. LTLGSTP[3:0] is based on one per sub-
                               logger.
                            */
    UINT32 stoptrg : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000004*/

                            /*
                               Stop trigger value, used in conjunction with the
                               stop trigger mask [13:10] State exit arc [9:8]
                               RxL0s state [7:4] LTSSM main state [3:0] LTSSM
                               sub state
                            */
    UINT32 stoptrgmsk : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00003C00*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding stopt trigger bit a don't care
                               (always match)
                            */
    UINT32 xstoptrgen : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Use external trigger event to stop logging, see
                               LTLGCTL.STARTTRG and STARTTRGMSK for
                               configuration details. Enabling this does not
                               disable the state match stop event and it does
                               disable the state match start event (acts as if
                               STARTTRGEN=0).
                            */
    UINT32 xtriggered : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, external stop trigger event occurred. */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSTP3_IIO_PCIEDMI_STRUCT;

/* LTLGSTPEXT3_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x20000d60)                                                      */
/*      SPRB0 (0x20000d60)                                                      */
/*      SPRHBM (0x20000d60)                                                     */
/*      SPRC0 (0x20000d60)                                                      */
/*      SPRMCC (0x20000d60)                                                     */
/*      SPRUCC (0x20000d60)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Stop Ext
*/


#define LTLGSTPEXT3_IIO_PCIEDMI_REG 0x0D020D60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the stop trigger will require a
                               match to one of the corresponding data rate bits
                               to trigger. All zeros means ignore data rate for
                               trigger matching
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTLGSTPEXT3_IIO_PCIEDMI_STRUCT;

/* LTLGTMEV0_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d64)                                                      */
/*      SPRB0 (0x20000d64)                                                      */
/*      SPRHBM (0x20000d64)                                                     */
/*      SPRC0 (0x20000d64)                                                      */
/*      SPRMCC (0x20000d64)                                                     */
/*      SPRUCC (0x20000d64)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Time Match Event
*/


#define LTLGTMEV0_IIO_PCIEDMI_REG 0x0D020D64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable timer event using port defined in the
                               start register. LTLGMEV[3:0] is based on one per
                               sub-logger.
                            */
    UINT32 smegc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Select which state matching register to use for
                               the state matching portion. The register must
                               belong to the port set in the start register.
                            */
    UINT32 unit : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               1 = 256cc 0 = 1cc Where cc is 1 pclk period and
                               the user needs to be cognizant of designs that
                               utilize variable (rate based) pclk.
                            */
    UINT32 cmp : 3;

                            /* Bits[5:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = compare to equal the time value 01 =
                               compare to greater than the time value 10 =
                               compare to less than the time value 11 =
                               reserved
                            */
    UINT32 count : 17;

                            /* Bits[22:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               The time value to compare with. The value is in
                               units defined by the UNIT field.
                            */
    UINT32 evlvl : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Event should be a level signal (high as long
                               as compare condition is true) 0: Event should be
                               a pulse
                            */
    UINT32 rsvd : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGTMEV0_IIO_PCIEDMI_STRUCT;

/* LTLGTMEV1_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d68)                                                      */
/*      SPRB0 (0x20000d68)                                                      */
/*      SPRHBM (0x20000d68)                                                     */
/*      SPRC0 (0x20000d68)                                                      */
/*      SPRMCC (0x20000d68)                                                     */
/*      SPRUCC (0x20000d68)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Time Match Event
*/


#define LTLGTMEV1_IIO_PCIEDMI_REG 0x0D020D68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable timer event using port defined in the
                               start register. LTLGMEV[3:0] is based on one per
                               sub-logger.
                            */
    UINT32 smegc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Select which state matching register to use for
                               the state matching portion. The register must
                               belong to the port set in the start register.
                            */
    UINT32 unit : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               1 = 256cc 0 = 1cc Where cc is 1 pclk period and
                               the user needs to be cognizant of designs that
                               utilize variable (rate based) pclk.
                            */
    UINT32 cmp : 3;

                            /* Bits[5:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = compare to equal the time value 01 =
                               compare to greater than the time value 10 =
                               compare to less than the time value 11 =
                               reserved
                            */
    UINT32 count : 17;

                            /* Bits[22:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               The time value to compare with. The value is in
                               units defined by the UNIT field.
                            */
    UINT32 evlvl : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Event should be a level signal (high as long
                               as compare condition is true) 0: Event should be
                               a pulse
                            */
    UINT32 rsvd : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGTMEV1_IIO_PCIEDMI_STRUCT;

/* LTLGTMEV2_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d6c)                                                      */
/*      SPRB0 (0x20000d6c)                                                      */
/*      SPRHBM (0x20000d6c)                                                     */
/*      SPRC0 (0x20000d6c)                                                      */
/*      SPRMCC (0x20000d6c)                                                     */
/*      SPRUCC (0x20000d6c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Time Match Event
*/


#define LTLGTMEV2_IIO_PCIEDMI_REG 0x0D020D6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable timer event using port defined in the
                               start register. LTLGMEV[3:0] is based on one per
                               sub-logger.
                            */
    UINT32 smegc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Select which state matching register to use for
                               the state matching portion. The register must
                               belong to the port set in the start register.
                            */
    UINT32 unit : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               1 = 256cc 0 = 1cc Where cc is 1 pclk period and
                               the user needs to be cognizant of designs that
                               utilize variable (rate based) pclk.
                            */
    UINT32 cmp : 3;

                            /* Bits[5:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = compare to equal the time value 01 =
                               compare to greater than the time value 10 =
                               compare to less than the time value 11 =
                               reserved
                            */
    UINT32 count : 17;

                            /* Bits[22:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               The time value to compare with. The value is in
                               units defined by the UNIT field.
                            */
    UINT32 evlvl : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Event should be a level signal (high as long
                               as compare condition is true) 0: Event should be
                               a pulse
                            */
    UINT32 rsvd : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGTMEV2_IIO_PCIEDMI_STRUCT;

/* LTLGTMEV3_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d70)                                                      */
/*      SPRB0 (0x20000d70)                                                      */
/*      SPRHBM (0x20000d70)                                                     */
/*      SPRC0 (0x20000d70)                                                      */
/*      SPRMCC (0x20000d70)                                                     */
/*      SPRUCC (0x20000d70)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger Time Match Event
*/


#define LTLGTMEV3_IIO_PCIEDMI_REG 0x0D020D70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable timer event using port defined in the
                               start register. LTLGMEV[3:0] is based on one per
                               sub-logger.
                            */
    UINT32 smegc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Select which state matching register to use for
                               the state matching portion. The register must
                               belong to the port set in the start register.
                            */
    UINT32 unit : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               1 = 256cc 0 = 1cc Where cc is 1 pclk period and
                               the user needs to be cognizant of designs that
                               utilize variable (rate based) pclk.
                            */
    UINT32 cmp : 3;

                            /* Bits[5:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = compare to equal the time value 01 =
                               compare to greater than the time value 10 =
                               compare to less than the time value 11 =
                               reserved
                            */
    UINT32 count : 17;

                            /* Bits[22:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               The time value to compare with. The value is in
                               units defined by the UNIT field.
                            */
    UINT32 evlvl : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               1: Event should be a level signal (high as long
                               as compare condition is true) 0: Event should be
                               a pulse
                            */
    UINT32 rsvd : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGTMEV3_IIO_PCIEDMI_STRUCT;


/* LTLGSMEV0_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d78)                                                      */
/*      SPRB0 (0x20000d78)                                                      */
/*      SPRHBM (0x20000d78)                                                     */
/*      SPRC0 (0x20000d78)                                                      */
/*      SPRMCC (0x20000d78)                                                     */
/*      SPRUCC (0x20000d78)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger State Match Event 0
*/


#define LTLGSMEV0_IIO_PCIEDMI_REG 0x0D020D78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Enable the trigger on match */
    UINT32 value : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               trigger value, used in conjunction with the mask
                               [13:10] State exit arc [9:8] RxL0s state [7:4]
                               LTSSM main state [3:0] LTSSM sub state
                            */
    UINT32 mask : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding trigger bit a don't care (always
                               match)
                            */
    UINT32 rsvd : 2;

                            /* Bits[30:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSMEV0_IIO_PCIEDMI_STRUCT;

/* LTLGSMEV1_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x20000d7c)                                                      */
/*      SPRB0 (0x20000d7c)                                                      */
/*      SPRHBM (0x20000d7c)                                                     */
/*      SPRC0 (0x20000d7c)                                                      */
/*      SPRMCC (0x20000d7c)                                                     */
/*      SPRUCC (0x20000d7c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger State Match Event 1
*/


#define LTLGSMEV1_IIO_PCIEDMI_REG 0x0D020D7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Enable the trigger on match */
    UINT32 value : 14;

                            /* Bits[14:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               trigger value, used in conjunction with the mask
                               [13:10] State exit arc [9:8] RxL0s state [7:4]
                               LTSSM main state [3:0] LTSSM sub state
                            */
    UINT32 mask : 14;

                            /* Bits[28:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               if any bit is set to 1, it will make that
                               corresponding trigger bit a don't care (always
                               match)
                            */
    UINT32 rsvd : 2;

                            /* Bits[30:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 triggered : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* If 1, the trigger event was hit. */

  } Bits;
  UINT32 Data;

} LTLGSMEV1_IIO_PCIEDMI_STRUCT;

/* LTLGSMEVEXT0_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x20000d80)                                                      */
/*      SPRB0 (0x20000d80)                                                      */
/*      SPRHBM (0x20000d80)                                                     */
/*      SPRC0 (0x20000d80)                                                      */
/*      SPRMCC (0x20000d80)                                                     */
/*      SPRUCC (0x20000d80)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger State Match Event Ext 0
*/


#define LTLGSMEVEXT0_IIO_PCIEDMI_REG 0x0D020D80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the state match event trigger will
                               require a match to one of the corresponding data
                               rate bits to trigger. All zeros means ignore
                               data rate for trigger matching
                            */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 onchange : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Only trigger on initial change to match */
    UINT32 rsvd_17 : 14;

                            /* Bits[30:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 retrig : 1;

                            /* Bits[31:31], Access Type=RW/P, default=0x00000000*/

                            /*
                               Re-arm trigger after every match 0 -- once
                               triggered, event stops firing 1 -- triggered
                               state does not block future triggers. The
                               triggered field still is set by first trigger.
                            */

  } Bits;
  UINT32 Data;

} LTLGSMEVEXT0_IIO_PCIEDMI_STRUCT;

/* LTLGSMEVEXT1_IIO_PCIEDMI_REG supported on:                                   */
/*      SPRA0 (0x20000d84)                                                      */
/*      SPRB0 (0x20000d84)                                                      */
/*      SPRHBM (0x20000d84)                                                     */
/*      SPRC0 (0x20000d84)                                                      */
/*      SPRMCC (0x20000d84)                                                     */
/*      SPRUCC (0x20000d84)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* LTSSM Logger State Match Event Ext 1
*/


#define LTLGSMEVEXT1_IIO_PCIEDMI_REG 0x0D020D84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ratev : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Rate Match Vector [0] -- Gen1 .. [3] -- Gen4,
                               [5:4] are reserved for future expansion if any
                               bit is set, the state match event trigger will
                               require a match to one of the corresponding data
                               rate bits to trigger. All zeros means ignore
                               data rate for trigger matching
                            */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 onchange : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Only trigger on initial change to match */
    UINT32 rsvd_17 : 14;

                            /* Bits[30:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 retrig : 1;

                            /* Bits[31:31], Access Type=RW/P, default=0x00000000*/

                            /*
                               Re-arm trigger after every match 0 -- once
                               triggered, event stops firing 1 -- triggered
                               state does not block future triggers. The
                               triggered field still is set by first trigger.
                            */

  } Bits;
  UINT32 Data;

} LTLGSMEVEXT1_IIO_PCIEDMI_STRUCT;

/* L1TELEMCTR_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000d88)                                                      */
/*      SPRB0 (0x20000d88)                                                      */
/*      SPRHBM (0x20000d88)                                                     */
/*      SPRC0 (0x20000d88)                                                      */
/*      SPRMCC (0x20000d88)                                                     */
/*      SPRUCC (0x20000d88)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* L1 Telemetry Counter
*/


#define L1TELEMCTR_IIO_PCIEDMI_REG 0x0D020D88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 count : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               A free running counter that counts the number of
                               L1 state exits. The counter is reset to 0
                               anytime the link is in the Detect state.
                            */

  } Bits;
  UINT32 Data;

} L1TELEMCTR_IIO_PCIEDMI_STRUCT;




/* LEKBAR_IIO_PCIEDMI_REG supported on:                                         */
/*      SPRA0 (0x20000dc4)                                                      */
/*      SPRB0 (0x20000dc4)                                                      */
/*      SPRHBM (0x20000dc4)                                                     */
/*      SPRC0 (0x20000dc4)                                                      */
/*      SPRMCC (0x20000dc4)                                                     */
/*      SPRUCC (0x20000dc4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Actions
*/


#define LEKBAR_IIO_PCIEDMI_REG 0x0D020DC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 24;

                            /* Bits[23:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lbeg2degradeen : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable LBE to trigger a speed degrade from 5GT/s
                               operation. The 5GT/s mode and higher is disabled
                               until LBEG2DIS is cleared.
                            */
    UINT32 lbeg3degradeen : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable LBE to trigger a speed degrade from 8GT/s
                               operation. The 8GT/s mode and higher is disabled
                               until LBEG3DIS is cleared.
                            */
    UINT32 lbeg4degradeen : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable LBE to trigger a speed degrade from
                               16GT/s operation. The 16GT/s mode and higher is
                               disabled until LBEG4DIS is cleared.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lbeg2dis : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set to 1, 5GT/s and higher rates are
                               disabled. Hardware or software may set this bit.
                               Hardware will set it when the LBE is enabled to
                               degrade link speed and the LBE threshold is
                               tripped. Software may set or clear at its will.
                               The register is sticky through in-band resets.
                            */
    UINT32 lbeg3dis : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set to 1, 8GT/s and higher rates are
                               disabled. Hardware or software may set this bit.
                               Hardware will set it when the LBE is enabled to
                               degrade link speed and the LBE threshold is
                               tripped. Software may set or clear at its will.
                               The register is sticky through in-band resets.
                            */
    UINT32 lbeg4dis : 1;

                            /* Bits[30:30], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set to 1, 16GT/s and higher rates are
                               disabled. Hardware or software may set this bit.
                               Hardware will set it when the LBE is enabled to
                               degrade link speed and the LBE threshold is
                               tripped. Software may set or clear at its will.
                               The register is sticky through in-band resets.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEKBAR_IIO_PCIEDMI_STRUCT;

/* LEKBERR_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000dc8)                                                      */
/*      SPRB0 (0x20000dc8)                                                      */
/*      SPRHBM (0x20000dc8)                                                     */
/*      SPRC0 (0x20000dc8)                                                      */
/*      SPRMCC (0x20000dc8)                                                     */
/*      SPRUCC (0x20000dc8)                                                     */
/* Register default value on SPRA0: 0x2000FFFF                                  */
/* Register default value on SPRB0: 0x2000FFFF                                  */
/* Register default value on SPRHBM: 0x2000FFFF                                 */
/* Register default value on SPRC0: 0x2000FFFF                                  */
/* Register default value on SPRMCC: 0x2000FFFF                                 */
/* Register default value on SPRUCC: 0x2000FFFF                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Error
*/


#define LEKBERR_IIO_PCIEDMI_REG 0x0D020DC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 aggrerr : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x0000FFFF*/

                            /*
                               The error count for the leaky bucket algorithm
                               increments by one when AGGRERR number of errors
                               have been encountered during the specified time
                               period.
                            */
    UINT32 errthresh : 5;

                            /* Bits[24:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Sets the threshold for leaky bucket error
                               handling. When the error count for a lane passes
                               this threshold, that lane will be flagged as
                               faulty.
                            */
    UINT32 g3errthresh : 5;

                            /* Bits[29:25], Access Type=RW/P, default=0x00000010*/

                            /*
                               Leaky Bucket error threshold used for 8GT/s and
                               above. When the error count for a lane passes
                               this threshold, that lane will be flagged as
                               faulty.
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 g3lbeen : 1;

                            /* Bits[31:31], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable Leaky Bucket Error Counters for gen3,
                               this allows H/W to request re-equalization based
                               on error rate.
                            */

  } Bits;
  UINT32 Data;

} LEKBERR_IIO_PCIEDMI_STRUCT;

/* LEKBERR0_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000dcc)                                                      */
/*      SPRB0 (0x20000dcc)                                                      */
/*      SPRHBM (0x20000dcc)                                                     */
/*      SPRC0 (0x20000dcc)                                                      */
/*      SPRMCC (0x20000dcc)                                                     */
/*      SPRUCC (0x20000dcc)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Time Window
*/


#define LEKBERR0_IIO_PCIEDMI_REG 0x0D020DCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 exp_ber : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0xFFFFFFFF*/

                            /*
                               [31:0] Expected BER for leaky bucket error
                               handling [31:0]. Selects the time window that is
                               sampled for aggregate errors.
                            */

  } Bits;
  UINT32 Data;

} LEKBERR0_IIO_PCIEDMI_STRUCT;

/* LEKBERR1_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000dd0)                                                      */
/*      SPRB0 (0x20000dd0)                                                      */
/*      SPRHBM (0x20000dd0)                                                     */
/*      SPRC0 (0x20000dd0)                                                      */
/*      SPRMCC (0x20000dd0)                                                     */
/*      SPRUCC (0x20000dd0)                                                     */
/* Register default value on SPRA0: 0x02000007                                  */
/* Register default value on SPRB0: 0x02000007                                  */
/* Register default value on SPRHBM: 0x02000007                                 */
/* Register default value on SPRC0: 0x02000007                                  */
/* Register default value on SPRMCC: 0x02000007                                 */
/* Register default value on SPRUCC: 0x02000007                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Time Window
*/


#define LEKBERR1_IIO_PCIEDMI_REG 0x0D020DD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 exp_ber : 18;

                            /* Bits[17:0], Access Type=RW/P, default=0x00000007*/

                            /*
                               [49:32] Expected BER for leaky bucket error
                               handling [49:32]. Selects the time window that
                               is sampled for aggregate errors.
                            */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 g3aggrerr : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000002*/

                            /*
                               Aggregate error for gen3. The error count for
                               the leaky bucket algorithm increments by one
                               when AGGRERR number of errors have been
                               encountered during the specified time period.
                            */

  } Bits;
  UINT32 Data;

} LEKBERR1_IIO_PCIEDMI_STRUCT;

/* LEKBLNERRCNT0_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000dd4)                                                      */
/*      SPRB0 (0x20000dd4)                                                      */
/*      SPRHBM (0x20000dd4)                                                     */
/*      SPRC0 (0x20000dd4)                                                      */
/*      SPRMCC (0x20000dd4)                                                     */
/*      SPRUCC (0x20000dd4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Lane Error Count
*/


#define LEKBLNERRCNT0_IIO_PCIEDMI_REG 0x0D020DD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errcnt0 : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt1 : 5;

                            /* Bits[9:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt2 : 5;

                            /* Bits[14:10], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt3 : 5;

                            /* Bits[19:15], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt4 : 5;

                            /* Bits[24:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt5 : 5;

                            /* Bits[29:25], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEKBLNERRCNT0_IIO_PCIEDMI_STRUCT;

/* LEKBLNERRCNT1_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000dd8)                                                      */
/*      SPRB0 (0x20000dd8)                                                      */
/*      SPRHBM (0x20000dd8)                                                     */
/*      SPRC0 (0x20000dd8)                                                      */
/*      SPRMCC (0x20000dd8)                                                     */
/*      SPRUCC (0x20000dd8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Lane Error Count
*/


#define LEKBLNERRCNT1_IIO_PCIEDMI_REG 0x0D020DD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errcnt6 : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt7 : 5;

                            /* Bits[9:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt8 : 5;

                            /* Bits[14:10], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt9 : 5;

                            /* Bits[19:15], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt10 : 5;

                            /* Bits[24:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt11 : 5;

                            /* Bits[29:25], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEKBLNERRCNT1_IIO_PCIEDMI_STRUCT;

/* LEKBLNERRCNT2_IIO_PCIEDMI_REG supported on:                                  */
/*      SPRA0 (0x20000ddc)                                                      */
/*      SPRB0 (0x20000ddc)                                                      */
/*      SPRHBM (0x20000ddc)                                                     */
/*      SPRC0 (0x20000ddc)                                                      */
/*      SPRMCC (0x20000ddc)                                                     */
/*      SPRUCC (0x20000ddc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Lane Error Count
*/


#define LEKBLNERRCNT2_IIO_PCIEDMI_REG 0x0D020DDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errcnt12 : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt13 : 5;

                            /* Bits[9:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt14 : 5;

                            /* Bits[14:10], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 errcnt15 : 5;

                            /* Bits[19:15], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error count seen on a lane for the current time
                               window. Decrements progressively to 0 if no
                               errors seen over a prolonged time period.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEKBLNERRCNT2_IIO_PCIEDMI_STRUCT;

/* LEKBPROERR_IIO_PCIEDMI_REG supported on:                                     */
/*      SPRA0 (0x20000de0)                                                      */
/*      SPRB0 (0x20000de0)                                                      */
/*      SPRHBM (0x20000de0)                                                     */
/*      SPRC0 (0x20000de0)                                                      */
/*      SPRMCC (0x20000de0)                                                     */
/*      SPRUCC (0x20000de0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Leaky Bucket Prolonged Error
*/


#define LEKBPROERR_IIO_PCIEDMI_REG 0x0D020DE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errlnsts : 16;

                            /* Bits[15:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Feature to check status of lane. Bit is set when
                               the current error rate exceeds the set error
                               threshold.
                            */
    UINT32 g3errlnsts : 16;

                            /* Bits[31:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Feature to check status of lane for Gen3. Bit is
                               set when the current error rate exceeds the set
                               error threshold.
                            */

  } Bits;
  UINT32 Data;

} LEKBPROERR_IIO_PCIEDMI_STRUCT;



/* RTLLCTL_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000e24)                                                      */
/*      SPRB0 (0x20000e24)                                                      */
/*      SPRHBM (0x20000e24)                                                     */
/*      SPRC0 (0x20000e24)                                                      */
/*      SPRMCC (0x20000e24)                                                     */
/*      SPRUCC (0x20000e24)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Retimer Low Latency Optimization Control
*/


#define RTLLCTL_IIO_PCIEDMI_REG 0x0D020E24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               [0] = Enable 16GT/s HW autonomous re-timer low
                               latency mode [1] = Enable 32GT/s HW autonomous
                               re-timer low latency mode
                            */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 initautohw : 1;

                            /* Bits[4:4], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               At present data rate, if proper ENABLE bit is
                               set, start initiation of HW Auto entry to
                               Retimer Low Latency mode. Clears on completion
                               or error
                            */
    UINT32 rsvd_5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RTLLCTL_IIO_PCIEDMI_STRUCT;

/* G4RTLLSTS_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000e28)                                                      */
/*      SPRB0 (0x10000e28)                                                      */
/*      SPRHBM (0x10000e28)                                                     */
/*      SPRC0 (0x10000e28)                                                      */
/*      SPRMCC (0x10000e28)                                                     */
/*      SPRUCC (0x10000e28)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* G4 Retimer Low Latency Optimization Status
*/


#define G4RTLLSTS_IIO_PCIEDMI_REG 0x0D010E28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 llsts : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               0000 - Disabled/not initiated, low latency mode
                               is off. 0001 - Low latency entry request in
                               progress. 0010 - Low latency mode exit in
                               progress. 0011 - Request retrain link for LL
                               enable, wait to enter Recovery. 0100 - Request
                               retrain link for LL disable, wait to enter
                               Recovery. 0101 - Retrain link in progress for LL
                               enable. 0110 - Retrain link in progress for LL
                               disable. 0111 - Enabled (LL mode on). 1000 - Low
                               latency mode entry timed out - low latency mode
                               is disabled. 1001 - During retrain to enable low
                               latency mode, a speed degrade occurred - low
                               latency mode is disabled. 1010 - During retrain
                               to disable low latency mode, a speed degrade
                               occurred - low latency mode is disabled. 1011 -
                               Redo eq occurred and autonomous low latency
                               enable after redo eq is blocked - low latency
                               mode is disabled. 1100 - Low latency mode is
                               blocked due to margining. 1101 - Margining is
                               stopped, quiesce for further SW margining
                               commands Reserved for the remaining encoding.
                            */
    UINT16 disonerr : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Implementation specific error detection
                               mechanism has blocked further LL mode usage.
                            */
    UINT16 disformarg : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               LL mode has been disabled as a result of
                               receiver lane margining being initiated.
                            */
    UINT16 rtmxzack : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               HW received response from Retimer X-Z during
                               retimer low latency entry.
                            */
    UINT16 rtmyack : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               HW received response from Retimer Y during
                               retimer low latency entry.
                            */
    UINT16 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} G4RTLLSTS_IIO_PCIEDMI_STRUCT;

/* RTLLCTL2_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000e2c)                                                      */
/*      SPRB0 (0x20000e2c)                                                      */
/*      SPRHBM (0x20000e2c)                                                     */
/*      SPRC0 (0x20000e2c)                                                      */
/*      SPRMCC (0x20000e2c)                                                     */
/*      SPRUCC (0x20000e2c)                                                     */
/* Register default value on SPRA0: 0x0012C902                                  */
/* Register default value on SPRB0: 0x0012C902                                  */
/* Register default value on SPRHBM: 0x0012C902                                 */
/* Register default value on SPRC0: 0x0012C902                                  */
/* Register default value on SPRMCC: 0x0012C902                                 */
/* Register default value on SPRUCC: 0x0012C902                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Retimer Low Latency Optimization Control 2
*/


#define RTLLCTL2_IIO_PCIEDMI_REG 0x0D020E2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hwreeq : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000002*/

                            /*
                               00 - Don't autonomously disable nor re-enable
                               for HW re-qualization 01 - Autonomously disable
                               for HW re-qualization 10 - Autonomously re-
                               enable for HW re-qualization 11 - Autonomously
                               disable and re-enable for HW re-qualization
                            */
    UINT32 disrxlnmarg : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               If set, will disable RT LL mode prior to sending
                               Receiver Lane Margin Control command in Control
                               SOS to Retimer.
                            */
    UINT32 lbedisll : 2;

                            /* Bits[4:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               [0] = Enable 16GT/s HW autonomous disable if LBE
                               logic triggers for 16GT/s speed [1] = Enable
                               32GT/s HW autonomous disable if LBE logic
                               triggers for 32GT/s speed
                            */
    UINT32 occ : 2;

                            /* Bits[6:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 - no override, 10 - non-common clock, 11 -
                               common clock
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wtentry : 3;

                            /* Bits[10:8], Access Type=RW/P, default=0x00000001*/

                            /*
                               0 - 50us, 1 - 100us, 2 - 150us, 3 - 200us, 4 -
                               250us, 5 - 500us, 6 - 750us, 7 - 1ms.
                            */
    UINT32 wtexit : 3;

                            /* Bits[13:11], Access Type=RW/P, default=0x00000001*/

                            /*
                               0 - 50us, 1 - 100us, 2 - 150us, 3 - 200us, 4 -
                               250us, 5 - 500us, 6 - 750us, 7 - 1ms.
                            */
    UINT32 wtmargquiesce : 2;

                            /* Bits[15:14], Access Type=RW/P, default=0x00000003*/

                            /*
                               When HW auto disable for Reciver Lane Margining
                               is enabled, this is the amount of time hardware
                               will wait prior to reenabling margining. Allows
                               a time window for software to issue a new
                               margining command to avoid thrashing retimer
                               exit and entries for margining. 0 - 20us, 1 -
                               100us, 2 - 50ms, 3 - 100ms
                            */
    UINT32 recenbtm : 3;

                            /* Bits[18:16], Access Type=RW/P, default=0x00000002*/

                            /*
                               Minimum time to hold in Recovery.ReceiverLock
                               before allowing a transition to
                               Rec.ReceiverConfig while retimer enters low
                               latency mode. 0 - 10us, 1 - 50us, 2 - 100us, 3 -
                               150us, 4 - 250us, 5 - 500us, 6 - 1ms, 7 - 2ms
                            */
    UINT32 recdistm : 3;

                            /* Bits[21:19], Access Type=RW/P, default=0x00000002*/

                            /*
                               Minimum time to hold in Recovery.ReceiverLock
                               before allowing a transition to
                               Rec.ReceiverConfig while retimer exits low
                               latency mode. 0 - 10us, 1 - 50us, 2 - 100us, 3 -
                               150us, 4 - 250us, 5 - 500us, 6 - 1ms, 7 - 2ms
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RTLLCTL2_IIO_PCIEDMI_STRUCT;

/* RTLLCTL3_IIO_PCIEDMI_REG supported on:                                       */
/*      SPRA0 (0x20000e30)                                                      */
/*      SPRB0 (0x20000e30)                                                      */
/*      SPRHBM (0x20000e30)                                                     */
/*      SPRC0 (0x20000e30)                                                      */
/*      SPRMCC (0x20000e30)                                                     */
/*      SPRUCC (0x20000e30)                                                     */
/* Register default value on SPRA0: 0x0B128086                                  */
/* Register default value on SPRB0: 0x0B128086                                  */
/* Register default value on SPRHBM: 0x0B128086                                 */
/* Register default value on SPRC0: 0x0B128086                                  */
/* Register default value on SPRMCC: 0x0B128086                                 */
/* Register default value on SPRUCC: 0x0B128086                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Retimer Low Latency Optimization Control 3
*/


#define RTLLCTL3_IIO_PCIEDMI_REG 0x0D020E30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vid : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x00008086*/

                            /*
                               The VID to use in the Control SOS command for
                               low latency retimer commands.
                            */
    UINT32 rcvrnumtgt : 3;

                            /* Bits[18:16], Access Type=RW/P, default=0x00000002*/

                            /*
                               The Receiver Number to use in the Control SOS
                               for low latency retimer commands.
                            */
    UINT32 rcvrnumrspxz : 3;

                            /* Bits[21:19], Access Type=RW/P, default=0x00000002*/

                            /*
                               The expected Receiver Number response to check
                               for retimers X or Z.
                            */
    UINT32 rcvrnumrspy : 3;

                            /* Bits[24:22], Access Type=RW/P, default=0x00000004*/

                            /*
                               The expected Receiver Number response to check
                               for retimer Y.
                            */
    UINT32 mtype : 3;

                            /* Bits[27:25], Access Type=RW/P, default=0x00000005*/

                            /* 101 - Vender Defined */
    UINT32 usagemd : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /* See PCIE base spec for definition of usage model */
    UINT32 mp76 : 2;

                            /* Bits[30:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Margin Payload bits 7 and 6 transmitted in the
                               Control SOS for low latency retimer commands.
                            */
    UINT32 vidrspmask : 1;

                            /* Bits[31:31], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, the vendor ID check on responses is
                               masked/ignored.
                            */

  } Bits;
  UINT32 Data;

} RTLLCTL3_IIO_PCIEDMI_STRUCT;

/* MARGECH_IIO_PCIEDMI_REG supported on:                                        */
/*      SPRA0 (0x20000edc)                                                      */
/*      SPRB0 (0x20000edc)                                                      */
/*      SPRHBM (0x20000edc)                                                     */
/*      SPRC0 (0x20000edc)                                                      */
/*      SPRMCC (0x20000edc)                                                     */
/*      SPRUCC (0x20000edc)                                                     */
/* Register default value on SPRA0: 0x00010027                                  */
/* Register default value on SPRB0: 0x00010027                                  */
/* Register default value on SPRHBM: 0x00010027                                 */
/* Register default value on SPRC0: 0x00010027                                  */
/* Register default value on SPRMCC: 0x00010027                                 */
/* Register default value on SPRUCC: 0x00010027                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Margining Extended Capability Header
*/


#define MARGECH_IIO_PCIEDMI_REG 0x0D020EDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000027*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Margining Capability is 0027h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI-compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} MARGECH_IIO_PCIEDMI_STRUCT;

/* MARGPTCAP_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000ee0)                                                      */
/*      SPRB0 (0x10000ee0)                                                      */
/*      SPRHBM (0x10000ee0)                                                     */
/*      SPRC0 (0x10000ee0)                                                      */
/*      SPRMCC (0x10000ee0)                                                     */
/*      SPRUCC (0x10000ee0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Margining Port Capability
*/


#define MARGPTCAP_IIO_PCIEDMI_REG 0x0D010EE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 mudsw : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               If Set, indicates that Margining is partially
                               implemented using Device Driver software.
                               Margining Software Ready indicates when this
                               software is initialized. If Clear, Margining
                               does not require device driver software. In this
                               case the value read from Margining Software
                               Ready is undefined. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 rsvd : 15;

                            /* Bits[15:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} MARGPTCAP_IIO_PCIEDMI_STRUCT;

/* MARGPTSTS_IIO_PCIEDMI_REG supported on:                                      */
/*      SPRA0 (0x10000ee2)                                                      */
/*      SPRB0 (0x10000ee2)                                                      */
/*      SPRHBM (0x10000ee2)                                                     */
/*      SPRC0 (0x10000ee2)                                                      */
/*      SPRMCC (0x10000ee2)                                                     */
/*      SPRUCC (0x10000ee2)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Port Status
*/


#define MARGPTSTS_IIO_PCIEDMI_REG 0x0D010EE2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 margrdy : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indicates when the Margining feature is ready to
                               accept margining commands. Behavior is undefined
                               if this bit is Clear and, for any Lane, any of
                               the Receiver Number, Margin Type, Usage Model,
                               or Margin Payload fields are written. Refer to
                               Margining Lane Control Register. If Margining
                               uses Driver Software is Set, Margining Ready
                               must be Set no later than 100 ms after the later
                               of Margining Software Ready becoming Set or the
                               link training to 32.0 GT/s. If Margining uses
                               Driver Software is Clear, Margining Ready must
                               be Set no later than 100 ms after the Link
                               trains to 32.0 GT/s. Default value is
                               implementation specific.
                            */
    UINT16 margswrdy : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               When Margining uses Driver Software is Set, then
                               this bit, when Set, indicates that the required
                               software has performed the required
                               initialization. The value of this bit is
                               Undefined if Margining uses Driver Software is
                               Clear. The default value of this bit is
                               implementation specific
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} MARGPTSTS_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ee4)                                                      */
/*      SPRB0 (0x10000ee4)                                                      */
/*      SPRHBM (0x10000ee4)                                                     */
/*      SPRC0 (0x10000ee4)                                                      */
/*      SPRMCC (0x10000ee4)                                                     */
/*      SPRUCC (0x10000ee4)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_0_IIO_PCIEDMI_REG 0x0D010EE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_0_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_0_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ee6)                                                      */
/*      SPRB0 (0x10000ee6)                                                      */
/*      SPRHBM (0x10000ee6)                                                     */
/*      SPRC0 (0x10000ee6)                                                      */
/*      SPRMCC (0x10000ee6)                                                     */
/*      SPRUCC (0x10000ee6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_0_IIO_PCIEDMI_REG 0x0D010EE6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_0_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ee8)                                                      */
/*      SPRB0 (0x10000ee8)                                                      */
/*      SPRHBM (0x10000ee8)                                                     */
/*      SPRC0 (0x10000ee8)                                                      */
/*      SPRMCC (0x10000ee8)                                                     */
/*      SPRUCC (0x10000ee8)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_1_IIO_PCIEDMI_REG 0x0D010EE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_1_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_1_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000eea)                                                      */
/*      SPRB0 (0x10000eea)                                                      */
/*      SPRHBM (0x10000eea)                                                     */
/*      SPRC0 (0x10000eea)                                                      */
/*      SPRMCC (0x10000eea)                                                     */
/*      SPRUCC (0x10000eea)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_1_IIO_PCIEDMI_REG 0x0D010EEA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_1_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000eec)                                                      */
/*      SPRB0 (0x10000eec)                                                      */
/*      SPRHBM (0x10000eec)                                                     */
/*      SPRC0 (0x10000eec)                                                      */
/*      SPRMCC (0x10000eec)                                                     */
/*      SPRUCC (0x10000eec)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_2_IIO_PCIEDMI_REG 0x0D010EEC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_2_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_2_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000eee)                                                      */
/*      SPRB0 (0x10000eee)                                                      */
/*      SPRHBM (0x10000eee)                                                     */
/*      SPRC0 (0x10000eee)                                                      */
/*      SPRMCC (0x10000eee)                                                     */
/*      SPRUCC (0x10000eee)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_2_IIO_PCIEDMI_REG 0x0D010EEE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_2_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_3_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ef0)                                                      */
/*      SPRB0 (0x10000ef0)                                                      */
/*      SPRHBM (0x10000ef0)                                                     */
/*      SPRC0 (0x10000ef0)                                                      */
/*      SPRMCC (0x10000ef0)                                                     */
/*      SPRUCC (0x10000ef0)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_3_IIO_PCIEDMI_REG 0x0D010EF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_3_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_3_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ef2)                                                      */
/*      SPRB0 (0x10000ef2)                                                      */
/*      SPRHBM (0x10000ef2)                                                     */
/*      SPRC0 (0x10000ef2)                                                      */
/*      SPRMCC (0x10000ef2)                                                     */
/*      SPRUCC (0x10000ef2)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_3_IIO_PCIEDMI_REG 0x0D010EF2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_3_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_4_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ef4)                                                      */
/*      SPRB0 (0x10000ef4)                                                      */
/*      SPRHBM (0x10000ef4)                                                     */
/*      SPRC0 (0x10000ef4)                                                      */
/*      SPRMCC (0x10000ef4)                                                     */
/*      SPRUCC (0x10000ef4)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_4_IIO_PCIEDMI_REG 0x0D010EF4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_4_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_4_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ef6)                                                      */
/*      SPRB0 (0x10000ef6)                                                      */
/*      SPRHBM (0x10000ef6)                                                     */
/*      SPRC0 (0x10000ef6)                                                      */
/*      SPRMCC (0x10000ef6)                                                     */
/*      SPRUCC (0x10000ef6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_4_IIO_PCIEDMI_REG 0x0D010EF6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_4_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_5_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000ef8)                                                      */
/*      SPRB0 (0x10000ef8)                                                      */
/*      SPRHBM (0x10000ef8)                                                     */
/*      SPRC0 (0x10000ef8)                                                      */
/*      SPRMCC (0x10000ef8)                                                     */
/*      SPRUCC (0x10000ef8)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_5_IIO_PCIEDMI_REG 0x0D010EF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_5_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_5_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000efa)                                                      */
/*      SPRB0 (0x10000efa)                                                      */
/*      SPRHBM (0x10000efa)                                                     */
/*      SPRC0 (0x10000efa)                                                      */
/*      SPRMCC (0x10000efa)                                                     */
/*      SPRUCC (0x10000efa)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_5_IIO_PCIEDMI_REG 0x0D010EFA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_5_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_6_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000efc)                                                      */
/*      SPRB0 (0x10000efc)                                                      */
/*      SPRHBM (0x10000efc)                                                     */
/*      SPRC0 (0x10000efc)                                                      */
/*      SPRMCC (0x10000efc)                                                     */
/*      SPRUCC (0x10000efc)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_6_IIO_PCIEDMI_REG 0x0D010EFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_6_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_6_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000efe)                                                      */
/*      SPRB0 (0x10000efe)                                                      */
/*      SPRHBM (0x10000efe)                                                     */
/*      SPRC0 (0x10000efe)                                                      */
/*      SPRMCC (0x10000efe)                                                     */
/*      SPRUCC (0x10000efe)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_6_IIO_PCIEDMI_REG 0x0D010EFE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_6_IIO_PCIEDMI_STRUCT;

/* MARGLNCTL_7_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000f00)                                                      */
/*      SPRB0 (0x10000f00)                                                      */
/*      SPRHBM (0x10000f00)                                                     */
/*      SPRC0 (0x10000f00)                                                      */
/*      SPRMCC (0x10000f00)                                                     */
/*      SPRUCC (0x10000f00)                                                     */
/* Register default value on SPRA0: 0x00009C38                                  */
/* Register default value on SPRB0: 0x00009C38                                  */
/* Register default value on SPRHBM: 0x00009C38                                 */
/* Register default value on SPRC0: 0x00009C38                                  */
/* Register default value on SPRMCC: 0x00009C38                                 */
/* Register default value on SPRUCC: 0x00009C38                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Control
*/


#define MARGLNCTL_7_IIO_PCIEDMI_REG 0x0D010F00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000007*/

                            /*
                               The default value is 111b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000009C*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 9Ch.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNCTL_7_IIO_PCIEDMI_STRUCT;

/* MARGLNSTS_7_IIO_PCIEDMI_REG supported on:                                    */
/*      SPRA0 (0x10000f02)                                                      */
/*      SPRB0 (0x10000f02)                                                      */
/*      SPRHBM (0x10000f02)                                                     */
/*      SPRC0 (0x10000f02)                                                      */
/*      SPRMCC (0x10000f02)                                                     */
/*      SPRUCC (0x10000f02)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRB0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRHBM Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRC0 Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst    */
/* SPRMCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* SPRUCC Register File:    sprsp_top/pciernd_sprrnd4x16[0]/dmi0/rcrbbar_inst   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Margining Lane Status
*/


#define MARGLNSTS_7_IIO_PCIEDMI_REG 0x0D010F02

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rcvrnum : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. For Downstream Ports,
                               this field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */
    UINT16 mtype : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 000b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 usagemd : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               The default value is 0b. This field must be
                               reset to the default value if the Port goes to
                               DL_Down status.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mp : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field's value is used in conjunction with
                               the Margin Type field. The default value is 00h.
                               This field must be reset to the default value if
                               the Port goes to DL_Down status.
                            */

  } Bits;
  UINT16 Data;

} MARGLNSTS_7_IIO_PCIEDMI_STRUCT;
#endif /* _IIO_PCIEDMI_h */
