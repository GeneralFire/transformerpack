
/** @file
  M2MEM_MAIN.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _M2MEM_MAIN_h
#define _M2MEM_MAIN_h
#include <Base.h>

/* VID_M2MEM_MAIN_REG supported on:                                             */
/*      SPRA0 (0x11e60000)                                                      */
/*      SPRB0 (0x11e60000)                                                      */
/*      SPRHBM (0x11e60000)                                                     */
/*      SPRC0 (0x11e60000)                                                      */
/*      SPRMCC (0x11e60000)                                                     */
/*      SPRUCC (0x11e60000)                                                     */
/* Register default value on SPRA0: 0x00008086                                  */
/* Register default value on SPRB0: 0x00008086                                  */
/* Register default value on SPRHBM: 0x00008086                                 */
/* Register default value on SPRC0: 0x00008086                                  */
/* Register default value on SPRMCC: 0x00008086                                 */
/* Register default value on SPRUCC: 0x00008086                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Vendor ID Register
*/


#define VID_M2MEM_MAIN_REG 0x06010000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vendor_identification_number : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00008086*/

                            /* The value is assigned by PCI-SIG to Intel. */

  } Bits;
  UINT16 Data;

} VID_M2MEM_MAIN_STRUCT;

/* DID_M2MEM_MAIN_REG supported on:                                             */
/*      SPRA0 (0x11e60002)                                                      */
/*      SPRB0 (0x11e60002)                                                      */
/*      SPRHBM (0x11e60002)                                                     */
/*      SPRC0 (0x11e60002)                                                      */
/*      SPRMCC (0x11e60002)                                                     */
/*      SPRUCC (0x11e60002)                                                     */
/* Register default value on SPRA0: 0x0000324A                                  */
/* Register default value on SPRB0: 0x0000324A                                  */
/* Register default value on SPRHBM: 0x0000324A                                 */
/* Register default value on SPRC0: 0x0000324A                                  */
/* Register default value on SPRMCC: 0x0000324A                                 */
/* Register default value on SPRUCC: 0x0000324A                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Device Identification Number
*/


#define DID_M2MEM_MAIN_REG 0x06010002

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 device_identification_number : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000324A*/

                            /*
                               The value is assigned by each IP/function owner
                               as a unique identifier.
                            */

  } Bits;
  UINT16 Data;

} DID_M2MEM_MAIN_STRUCT;

/* PCICMD_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x11e60004)                                                      */
/*      SPRB0 (0x11e60004)                                                      */
/*      SPRHBM (0x11e60004)                                                     */
/*      SPRC0 (0x11e60004)                                                      */
/*      SPRMCC (0x11e60004)                                                     */
/*      SPRUCC (0x11e60004)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Command Register
*/


#define PCICMD_M2MEM_MAIN_REG 0x06010004

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 io_space_enable : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               Hardwired to 0 since these devices dont decode
                               any IO BARs
                            */
    UINT16 memory_space_enable : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /*
                               Hardwired to 0 since these devices dont decode
                               any memory BARs
                            */
    UINT16 bus_master_enable : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*
                               Hardwired to 0 since these devices dont generate
                               any transactions
                            */
    UINT16 special_cycle_enable : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Not applicable. Hardwired to 0. */
    UINT16 memory_write_and_invalidate_enable : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to internal devices. Hardwired to
                               0.
                            */
    UINT16 vga_palette_snoop_enable : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to internal devices. Hardwired to
                               0.
                            */
    UINT16 parity_error_response : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               This bit has no impact on error reporting from
                               these devices
                            */
    UINT16 idsel_stepping_wait_cycle_control : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to internal devices. Hardwired to
                               0.
                            */
    UINT16 serr_enable : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               This bit has no impact on error reporting from
                               these devices
                            */
    UINT16 fast_back_to_back_enable : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to PCI Express and is hardwired
                               to 0
                            */
    UINT16 intx_disable : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* N/A for these devices */
    UINT16 rsvd : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PCICMD_M2MEM_MAIN_STRUCT;

/* PCISTS_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x11e60006)                                                      */
/*      SPRB0 (0x11e60006)                                                      */
/*      SPRHBM (0x11e60006)                                                     */
/*      SPRC0 (0x11e60006)                                                      */
/*      SPRMCC (0x11e60006)                                                     */
/*      SPRUCC (0x11e60006)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Status Register
*/


#define PCISTS_M2MEM_MAIN_REG 0x06010006

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 intx_status : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /*
                               Reflects the state of the INTA# signal at the
                               input of the enable/disable circuit. This bit is
                               set by HW to 1 when the INTA# is asserted. This
                               bit is reset by HW to 0 after the interrupt is
                               cleared (independent of the state of the
                               Interrupt Disable bit in the PCICMD register).
                               Hardwired to 0 on the processor
                            */
    UINT16 capabilities_list : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000001*/

                            /*
                               This bit indicates the presence of a
                               capabilities list structure. When set to 1,
                               indicates the register at 34h provides an offset
                               into the function.
                            */
    UINT16 x66mhz_capable : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 reserved : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /* Reserved */
    UINT16 fast_back_to_back : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 master_data_parity_error : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /* Hardwired to 0 */
    UINT16 devsel_timing : 2;

                            /* Bits[10:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 signaled_target_abort : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /* Hardwired to 0 */
    UINT16 received_target_abort : 1;

                            /* Bits[12:12], Access Type=RO, default=0x00000000*/

                            /* Hardwired to 0 */
    UINT16 received_master_abort : 1;

                            /* Bits[13:13], Access Type=RO, default=0x00000000*/

                            /* Hardwired to 0 */
    UINT16 signaled_system_error : 1;

                            /* Bits[14:14], Access Type=RO, default=0x00000000*/

                            /* Hardwired to 0 */
    UINT16 detected_parity_error : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               This bit is set when the device receives a
                               packet on the primary side with an uncorrectable
                               data error (including a packet with poison bit
                               set) or an uncorrectable address/control parity
                               error. The setting of this bit is regardless of
                               the Parity Error Response bit (PERRE) in the
                               PCICMD register.
                            */

  } Bits;
  UINT16 Data;

} PCISTS_M2MEM_MAIN_STRUCT;

/* RID_CCR_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e60008)                                                      */
/*      SPRB0 (0x21e60008)                                                      */
/*      SPRHBM (0x21e60008)                                                     */
/*      SPRC0 (0x21e60008)                                                      */
/*      SPRMCC (0x21e60008)                                                     */
/*      SPRUCC (0x21e60008)                                                     */
/* Register default value on SPRA0: 0x11010000                                  */
/* Register default value on SPRB0: 0x11010000                                  */
/* Register default value on SPRHBM: 0x11010000                                 */
/* Register default value on SPRC0: 0x11010000                                  */
/* Register default value on SPRMCC: 0x11010000                                 */
/* Register default value on SPRUCC: 0x11010000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCIe header Revision ID register and Class Code register
*/


#define RID_CCR_M2MEM_MAIN_REG 0x06020008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 revision_id : 8;

                            /* Bits[7:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Reflects the Uncore Revision ID after reset.
                               Reflects the Compatibility Revision ID if BIOS
                               updates.
                            */
    UINT32 register_level_programming_interface : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /* Register Level Programming Interface */
    UINT32 sub_class : 8;

                            /* Bits[23:16], Access Type=RO, default=0x00000001*/

                            /* Sub class code */
    UINT32 base_class : 8;

                            /* Bits[31:24], Access Type=RO, default=0x00000011*/

                            /* Base class code */

  } Bits;
  UINT32 Data;

} RID_CCR_M2MEM_MAIN_STRUCT;

/* CLSR_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x1e6000c)                                                       */
/*      SPRB0 (0x1e6000c)                                                       */
/*      SPRHBM (0x1e6000c)                                                      */
/*      SPRC0 (0x1e6000c)                                                       */
/*      SPRMCC (0x1e6000c)                                                      */
/*      SPRUCC (0x1e6000c)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Cache Line Size Register
*/


#define CLSR_M2MEM_MAIN_REG 0x0600000C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 cacheline_size : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Size of Cacheline */

  } Bits;
  UINT8 Data;

} CLSR_M2MEM_MAIN_STRUCT;

/* PLAT_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x1e6000d)                                                       */
/*      SPRB0 (0x1e6000d)                                                       */
/*      SPRHBM (0x1e6000d)                                                      */
/*      SPRC0 (0x1e6000d)                                                       */
/*      SPRMCC (0x1e6000d)                                                      */
/*      SPRUCC (0x1e6000d)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Latency Timer
*/


#define PLAT_M2MEM_MAIN_REG 0x0600000D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 primary_latency_timer : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 00h. */

  } Bits;
  UINT8 Data;

} PLAT_M2MEM_MAIN_STRUCT;

/* HDR_M2MEM_MAIN_REG supported on:                                             */
/*      SPRA0 (0x1e6000e)                                                       */
/*      SPRB0 (0x1e6000e)                                                       */
/*      SPRHBM (0x1e6000e)                                                      */
/*      SPRC0 (0x1e6000e)                                                       */
/*      SPRMCC (0x1e6000e)                                                      */
/*      SPRUCC (0x1e6000e)                                                      */
/* Register default value on SPRA0: 0x00000080                                  */
/* Register default value on SPRB0: 0x00000080                                  */
/* Register default value on SPRHBM: 0x00000080                                 */
/* Register default value on SPRC0: 0x00000080                                  */
/* Register default value on SPRMCC: 0x00000080                                 */
/* Register default value on SPRUCC: 0x00000080                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Header Type
*/


#define HDR_M2MEM_MAIN_REG 0x0600000E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 configuration_layout : 7;

                            /* Bits[6:0], Access Type=RO, default=0x00000000*/

                            /* Type 0 header */
    UINT8 multi_function_device : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000001*/

                            /*
                               This bit defaults to 1b since all these devices
                               are multi-function
                            */

  } Bits;
  UINT8 Data;

} HDR_M2MEM_MAIN_STRUCT;

/* BIST_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x1e6000f)                                                       */
/*      SPRB0 (0x1e6000f)                                                       */
/*      SPRHBM (0x1e6000f)                                                      */
/*      SPRC0 (0x1e6000f)                                                       */
/*      SPRMCC (0x1e6000f)                                                      */
/*      SPRUCC (0x1e6000f)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI BIST Register
*/


#define BIST_M2MEM_MAIN_REG 0x0600000F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_tests : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Not supported. Hardwired to 00h */

  } Bits;
  UINT8 Data;

} BIST_M2MEM_MAIN_STRUCT;

/* SVID_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x11e6002c)                                                      */
/*      SPRB0 (0x11e6002c)                                                      */
/*      SPRHBM (0x11e6002c)                                                     */
/*      SPRC0 (0x11e6002c)                                                      */
/*      SPRMCC (0x11e6002c)                                                     */
/*      SPRUCC (0x11e6002c)                                                     */
/* Register default value on SPRA0: 0x00008086                                  */
/* Register default value on SPRB0: 0x00008086                                  */
/* Register default value on SPRHBM: 0x00008086                                 */
/* Register default value on SPRC0: 0x00008086                                  */
/* Register default value on SPRMCC: 0x00008086                                 */
/* Register default value on SPRUCC: 0x00008086                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Subsystem Vendor ID Register
*/


#define SVID_M2MEM_MAIN_REG 0x0601002C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 subsystem_vendor_identification_number : 16;

                            /* Bits[15:0], Access Type=RW/O, default=0x00008086*/

                            /*
                               The default value specifies Intel but can be set
                               to any value once after reset.
                            */

  } Bits;
  UINT16 Data;

} SVID_M2MEM_MAIN_STRUCT;

/* SDID_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x11e6002e)                                                      */
/*      SPRB0 (0x11e6002e)                                                      */
/*      SPRHBM (0x11e6002e)                                                     */
/*      SPRC0 (0x11e6002e)                                                      */
/*      SPRMCC (0x11e6002e)                                                     */
/*      SPRUCC (0x11e6002e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Subsystem ID Register
*/


#define SDID_M2MEM_MAIN_REG 0x0601002E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 subsystem_identification_number : 16;

                            /* Bits[15:0], Access Type=RW/O, default=0x00000000*/

                            /*
                               Assigned by the subsystem vendor to uniquely
                               identify the subsystem
                            */

  } Bits;
  UINT16 Data;

} SDID_M2MEM_MAIN_STRUCT;

/* CAPPTR_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x1e60034)                                                       */
/*      SPRB0 (0x1e60034)                                                       */
/*      SPRHBM (0x1e60034)                                                      */
/*      SPRC0 (0x1e60034)                                                       */
/*      SPRMCC (0x1e60034)                                                      */
/*      SPRUCC (0x1e60034)                                                      */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Capability Pointer Register
*/


#define CAPPTR_M2MEM_MAIN_REG 0x06000034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 capability_pointer : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000040*/

                            /*
                               Points to the first capability structure for the
                               device which is the PCIe capability.
                            */

  } Bits;
  UINT8 Data;

} CAPPTR_M2MEM_MAIN_STRUCT;

/* INTL_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x1e6003c)                                                       */
/*      SPRB0 (0x1e6003c)                                                       */
/*      SPRHBM (0x1e6003c)                                                      */
/*      SPRC0 (0x1e6003c)                                                       */
/*      SPRMCC (0x1e6003c)                                                      */
/*      SPRUCC (0x1e6003c)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Interrupt Line Register
*/


#define INTL_M2MEM_MAIN_REG 0x0600003C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 interrupt_line : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* N/A for these devices */

  } Bits;
  UINT8 Data;

} INTL_M2MEM_MAIN_STRUCT;

/* INTPIN_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x1e6003d)                                                       */
/*      SPRB0 (0x1e6003d)                                                       */
/*      SPRHBM (0x1e6003d)                                                      */
/*      SPRC0 (0x1e6003d)                                                       */
/*      SPRMCC (0x1e6003d)                                                      */
/*      SPRUCC (0x1e6003d)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Interrupt Pin Register
*/


#define INTPIN_M2MEM_MAIN_REG 0x0600003D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 interrupt_pin : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               N/A since these devices do not generate any
                               interrupt on their own
                            */

  } Bits;
  UINT8 Data;

} INTPIN_M2MEM_MAIN_STRUCT;

/* MINGNT_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x1e6003e)                                                       */
/*      SPRB0 (0x1e6003e)                                                       */
/*      SPRHBM (0x1e6003e)                                                      */
/*      SPRC0 (0x1e6003e)                                                       */
/*      SPRMCC (0x1e6003e)                                                      */
/*      SPRUCC (0x1e6003e)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Min Grant Register
*/


#define MINGNT_M2MEM_MAIN_REG 0x0600003E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mgv : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               The device does not burst as a PCI compliant
                               master.
                            */

  } Bits;
  UINT8 Data;

} MINGNT_M2MEM_MAIN_STRUCT;

/* MAXLAT_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x1e6003f)                                                       */
/*      SPRB0 (0x1e6003f)                                                       */
/*      SPRHBM (0x1e6003f)                                                      */
/*      SPRC0 (0x1e6003f)                                                       */
/*      SPRMCC (0x1e6003f)                                                      */
/*      SPRUCC (0x1e6003f)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Max Latency Register
*/


#define MAXLAT_M2MEM_MAIN_REG 0x0600003F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mlv : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               The device has no specific requirements for how
                               often it needs to access the PCI bus.
                            */

  } Bits;
  UINT8 Data;

} MAXLAT_M2MEM_MAIN_STRUCT;

/* PXPCAP_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x21e60040)                                                      */
/*      SPRB0 (0x21e60040)                                                      */
/*      SPRHBM (0x21e60040)                                                     */
/*      SPRC0 (0x21e60040)                                                      */
/*      SPRMCC (0x21e60040)                                                     */
/*      SPRUCC (0x21e60040)                                                     */
/* Register default value on SPRA0: 0x00920010                                  */
/* Register default value on SPRB0: 0x00920010                                  */
/* Register default value on SPRHBM: 0x00920010                                 */
/* Register default value on SPRC0: 0x00920010                                  */
/* Register default value on SPRMCC: 0x00920010                                 */
/* Register default value on SPRUCC: 0x00920010                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Express Capability
*/


#define PXPCAP_M2MEM_MAIN_REG 0x06020040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /*
                               Identifies the PCI Express capability assigned
                               by PCI-SIG.
                            */
    UINT32 next_ptr : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability. Set to 0 to
                               indicate there are no more capability
                               structures.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000002*/

                            /*
                               PCI Express Capability is Compliant with Version
                               2.0 of the PCI Express Spec.
                            */
    UINT32 device_port_type : 4;

                            /* Bits[23:20], Access Type=RO, default=0x00000009*/

                            /* Device type is Root Complex Integrated Endpoint */
    UINT32 slot_implemented : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /* Not valid for PCIe integrated Endpoints */
    UINT32 interrupt_message_number : 5;

                            /* Bits[29:25], Access Type=RO, default=0x00000000*/

                            /*
                               Not valid for this device, since the device does
                               not generate interrupts
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PXPCAP_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD0_M2MEM_MAIN_REG supported on:                                      */
/*      SPRA0 (0x21e60044)                                                      */
/*      SPRB0 (0x21e60044)                                                      */
/*      SPRHBM (0x21e60044)                                                     */
/*      SPRC0 (0x21e60044)                                                      */
/*      SPRMCC (0x21e60044)                                                     */
/*      SPRUCC (0x21e60044)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD0_M2MEM_MAIN_REG 0x06020044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD1_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60048)                                                      */
/*      SPRB0 (0x21e60048)                                                      */
/*      SPRHBM (0x21e60048)                                                     */
/*      SPRC0 (0x21e60048)                                                      */
/*      SPRMCC (0x21e60048)                                                     */
/*      SPRUCC (0x21e60048)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD1_N0_M2MEM_MAIN_REG 0x06020048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD1_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD1_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e6004c)                                                      */
/*      SPRB0 (0x21e6004c)                                                      */
/*      SPRHBM (0x21e6004c)                                                     */
/*      SPRC0 (0x21e6004c)                                                      */
/*      SPRMCC (0x21e6004c)                                                     */
/*      SPRUCC (0x21e6004c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD1_N1_M2MEM_MAIN_REG 0x0602004C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD1_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD2_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60050)                                                      */
/*      SPRB0 (0x21e60050)                                                      */
/*      SPRHBM (0x21e60050)                                                     */
/*      SPRC0 (0x21e60050)                                                      */
/*      SPRMCC (0x21e60050)                                                     */
/*      SPRUCC (0x21e60050)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD2_N0_M2MEM_MAIN_REG 0x06020050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD2_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD2_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60054)                                                      */
/*      SPRB0 (0x21e60054)                                                      */
/*      SPRHBM (0x21e60054)                                                     */
/*      SPRC0 (0x21e60054)                                                      */
/*      SPRMCC (0x21e60054)                                                     */
/*      SPRUCC (0x21e60054)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD2_N1_M2MEM_MAIN_REG 0x06020054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD2_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD3_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60058)                                                      */
/*      SPRB0 (0x21e60058)                                                      */
/*      SPRHBM (0x21e60058)                                                     */
/*      SPRC0 (0x21e60058)                                                      */
/*      SPRMCC (0x21e60058)                                                     */
/*      SPRUCC (0x21e60058)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD3_N0_M2MEM_MAIN_REG 0x06020058

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD3_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD3_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e6005c)                                                      */
/*      SPRB0 (0x21e6005c)                                                      */
/*      SPRHBM (0x21e6005c)                                                     */
/*      SPRC0 (0x21e6005c)                                                      */
/*      SPRMCC (0x21e6005c)                                                     */
/*      SPRUCC (0x21e6005c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD3_N1_M2MEM_MAIN_REG 0x0602005C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD3_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD4_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60060)                                                      */
/*      SPRB0 (0x21e60060)                                                      */
/*      SPRHBM (0x21e60060)                                                     */
/*      SPRC0 (0x21e60060)                                                      */
/*      SPRMCC (0x21e60060)                                                     */
/*      SPRUCC (0x21e60060)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD4_N0_M2MEM_MAIN_REG 0x06020060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD4_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD4_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60064)                                                      */
/*      SPRB0 (0x21e60064)                                                      */
/*      SPRHBM (0x21e60064)                                                     */
/*      SPRC0 (0x21e60064)                                                      */
/*      SPRMCC (0x21e60064)                                                     */
/*      SPRUCC (0x21e60064)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD4_N1_M2MEM_MAIN_REG 0x06020064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD4_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD5_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60068)                                                      */
/*      SPRB0 (0x21e60068)                                                      */
/*      SPRHBM (0x21e60068)                                                     */
/*      SPRC0 (0x21e60068)                                                      */
/*      SPRMCC (0x21e60068)                                                     */
/*      SPRUCC (0x21e60068)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD5_N0_M2MEM_MAIN_REG 0x06020068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD5_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD5_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e6006c)                                                      */
/*      SPRB0 (0x21e6006c)                                                      */
/*      SPRHBM (0x21e6006c)                                                     */
/*      SPRC0 (0x21e6006c)                                                      */
/*      SPRMCC (0x21e6006c)                                                     */
/*      SPRUCC (0x21e6006c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD5_N1_M2MEM_MAIN_REG 0x0602006C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD5_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD6_N0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60070)                                                      */
/*      SPRB0 (0x21e60070)                                                      */
/*      SPRHBM (0x21e60070)                                                     */
/*      SPRC0 (0x21e60070)                                                      */
/*      SPRMCC (0x21e60070)                                                     */
/*      SPRUCC (0x21e60070)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD6_N0_M2MEM_MAIN_REG 0x06020070

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD6_N0_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD6_N1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60074)                                                      */
/*      SPRB0 (0x21e60074)                                                      */
/*      SPRHBM (0x21e60074)                                                     */
/*      SPRC0 (0x21e60074)                                                      */
/*      SPRMCC (0x21e60074)                                                     */
/*      SPRUCC (0x21e60074)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD6_N1_M2MEM_MAIN_REG 0x06020074

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD6_N1_M2MEM_MAIN_STRUCT;

/* PCIE_RSVD7_M2MEM_MAIN_REG supported on:                                      */
/*      SPRA0 (0x21e60078)                                                      */
/*      SPRB0 (0x21e60078)                                                      */
/*      SPRHBM (0x21e60078)                                                     */
/*      SPRC0 (0x21e60078)                                                      */
/*      SPRMCC (0x21e60078)                                                     */
/*      SPRUCC (0x21e60078)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Reserved space for PCIE header registers
*/


#define PCIE_RSVD7_M2MEM_MAIN_REG 0x06020078

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* This space is reserved */

  } Bits;
  UINT32 Data;

} PCIE_RSVD7_M2MEM_MAIN_STRUCT;







/* M2M_LB_MCHECK_W_CP_N0_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e600a0)                                                      */
/*      SPRB0 (0x21e600a0)                                                      */
/*      SPRHBM (0x21e600a0)                                                     */
/*      SPRC0 (0x21e600a0)                                                      */
/*      SPRMCC (0x21e600a0)                                                     */
/*      SPRUCC (0x21e600a0)                                                     */
/* Register default value on SPRA0: 0x01000218                                  */
/* Register default value on SPRB0: 0x01000218                                  */
/* Register default value on SPRHBM: 0x01000218                                 */
/* Register default value on SPRC0: 0x01000218                                  */
/* Register default value on SPRMCC: 0x01000218                                 */
/* Register default value on SPRUCC: 0x01000218                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to RAC, WAC and CP registers for LB_MCHECK_W security policy group. This policy group is expected to be used for registers that had LB attribute in prior art and need to be checked by MCHECK. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define M2M_LB_MCHECK_W_CP_N0_M2MEM_MAIN_REG 0x060200A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_CP_N0_M2MEM_MAIN_STRUCT;

/* M2M_LB_MCHECK_W_CP_N1_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e600a4)                                                      */
/*      SPRB0 (0x21e600a4)                                                      */
/*      SPRHBM (0x21e600a4)                                                     */
/*      SPRC0 (0x21e600a4)                                                      */
/*      SPRMCC (0x21e600a4)                                                     */
/*      SPRUCC (0x21e600a4)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to RAC, WAC and CP registers for LB_MCHECK_W security policy group. This policy group is expected to be used for registers that had LB attribute in prior art and need to be checked by MCHECK. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define M2M_LB_MCHECK_W_CP_N1_M2MEM_MAIN_REG 0x060200A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_CP_N1_M2MEM_MAIN_STRUCT;

/* M2M_LB_MCHECK_W_RAC_N0_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e600a8)                                                      */
/*      SPRB0 (0x21e600a8)                                                      */
/*      SPRHBM (0x21e600a8)                                                     */
/*      SPRC0 (0x21e600a8)                                                      */
/*      SPRMCC (0x21e600a8)                                                     */
/*      SPRUCC (0x21e600a8)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the read access to registers in LB_MCHECK_W security policy group. As indicated by the _W in the policy name, the read access for this particular policy includes ALL supported SAI mnemonics. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_LB_MCHECK_W_RAC_N0_M2MEM_MAIN_REG 0x060200A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_RAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_LB_MCHECK_W_RAC_N1_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e600ac)                                                      */
/*      SPRB0 (0x21e600ac)                                                      */
/*      SPRHBM (0x21e600ac)                                                     */
/*      SPRC0 (0x21e600ac)                                                      */
/*      SPRMCC (0x21e600ac)                                                     */
/*      SPRUCC (0x21e600ac)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the read access to registers in LB_MCHECK_W security policy group. As indicated by the _W in the policy name, the read access for this particular policy includes ALL supported SAI mnemonics. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_LB_MCHECK_W_RAC_N1_M2MEM_MAIN_REG 0x060200AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_RAC_N1_M2MEM_MAIN_STRUCT;

/* M2M_LB_MCHECK_W_WAC_N0_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e600b0)                                                      */
/*      SPRB0 (0x21e600b0)                                                      */
/*      SPRHBM (0x21e600b0)                                                     */
/*      SPRC0 (0x21e600b0)                                                      */
/*      SPRMCC (0x21e600b0)                                                     */
/*      SPRUCC (0x21e600b0)                                                     */
/* Register default value on SPRA0: 0x0100021E                                  */
/* Register default value on SPRB0: 0x0100021E                                  */
/* Register default value on SPRHBM: 0x0100021E                                 */
/* Register default value on SPRC0: 0x0100021E                                  */
/* Register default value on SPRMCC: 0x0100021E                                 */
/* Register default value on SPRUCC: 0x0100021E                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to registers in LB_MCHECK_W security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_LB_MCHECK_W_WAC_N0_M2MEM_MAIN_REG 0x060200B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_WAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_LB_MCHECK_W_WAC_N1_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e600b4)                                                      */
/*      SPRB0 (0x21e600b4)                                                      */
/*      SPRHBM (0x21e600b4)                                                     */
/*      SPRC0 (0x21e600b4)                                                      */
/*      SPRMCC (0x21e600b4)                                                     */
/*      SPRUCC (0x21e600b4)                                                     */
/* Register default value on SPRA0: 0x20000400                                  */
/* Register default value on SPRB0: 0x20000400                                  */
/* Register default value on SPRHBM: 0x20000400                                 */
/* Register default value on SPRC0: 0x20000400                                  */
/* Register default value on SPRMCC: 0x20000400                                 */
/* Register default value on SPRUCC: 0x20000400                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to registers in LB_MCHECK_W security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_LB_MCHECK_W_WAC_N1_M2MEM_MAIN_REG 0x060200B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_LB_MCHECK_W_WAC_N1_M2MEM_MAIN_STRUCT;

















/* PXPENHCAP_M2MEM_MAIN_REG supported on:                                       */
/*      SPRA0 (0x21e60100)                                                      */
/*      SPRB0 (0x21e60100)                                                      */
/*      SPRHBM (0x21e60100)                                                     */
/*      SPRC0 (0x21e60100)                                                      */
/*      SPRMCC (0x21e60100)                                                     */
/*      SPRUCC (0x21e60100)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR        */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_PCIE_CSR       */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Express Enhanced Capability
*/


#define PXPENHCAP_M2MEM_MAIN_REG 0x06020100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /* There is no capability at this location */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /* There is no capability at this location. */
    UINT32 next_capability_offset : 12;

                            /* Bits[31:20], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability in the enhanced
                               configuration space. Set to 0 to indicate there
                               are no more capability structures.
                            */

  } Bits;
  UINT32 Data;

} PXPENHCAP_M2MEM_MAIN_STRUCT;

/* M2M_SEAMRR_BASE_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60180)                                                      */
/*      SPRB0 (0x21e60180)                                                      */
/*      SPRHBM (0x21e60180)                                                     */
/*      SPRC0 (0x21e60180)                                                      */
/*      SPRMCC (0x21e60180)                                                     */
/*      SPRUCC (0x21e60180)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SEAMRR region's base system address. Any SEAMRR access should adhere to the following:
        (Addr & M2M_SEAMRR_MASK) == (SEAMRR_Base_Address & M2M_SEAMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_SEAMRR_BASE_N0_M2MEM_MAIN_REG 0x06020180

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* enable bit for the M2M_SEAMRR_BASE register */
    UINT32 rsvd_4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 base_address : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               SEAMRR specifies the secure encrypted region to
                               be handled by the MEE (encryption) engine. This
                               field specifies the system address[51:12] lower
                               limit of the SEAMRR region. Bits [11:0] are
                               always zero. A system address needs to be larger
                               than or equal to this limit in order to be able
                               to belong to the SEAMRR region.
                            */

  } Bits;
  UINT32 Data;

} M2M_SEAMRR_BASE_N0_M2MEM_MAIN_STRUCT;

/* M2M_SEAMRR_BASE_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60184)                                                      */
/*      SPRB0 (0x21e60184)                                                      */
/*      SPRHBM (0x21e60184)                                                     */
/*      SPRC0 (0x21e60184)                                                      */
/*      SPRMCC (0x21e60184)                                                     */
/*      SPRUCC (0x21e60184)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SEAMRR region's base system address. Any SEAMRR access should adhere to the following:
        (Addr & M2M_SEAMRR_MASK) == (SEAMRR_Base_Address & M2M_SEAMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_SEAMRR_BASE_N1_M2MEM_MAIN_REG 0x06020184

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 base_address : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /*
                               SEAMRR specifies the secure encrypted region to
                               be handled by the MEE (encryption) engine. This
                               field specifies the system address[51:12] lower
                               limit of the SEAMRR region. Bits [11:0] are
                               always zero. A system address needs to be larger
                               than or equal to this limit in order to be able
                               to belong to the SEAMRR region.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2M_SEAMRR_BASE_N1_M2MEM_MAIN_STRUCT;

/* M2M_SEAMRR_MASK_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60188)                                                      */
/*      SPRB0 (0x21e60188)                                                      */
/*      SPRHBM (0x21e60188)                                                     */
/*      SPRC0 (0x21e60188)                                                      */
/*      SPRMCC (0x21e60188)                                                     */
/*      SPRUCC (0x21e60188)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SEAMRR Mask.  Any SEAMRR access should adhere to [br]
        (Addr & M2M_SEAMRR_MASK) == (SEAMRR_Base_Address & M2M_SEAMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_SEAMRR_MASK_N0_M2MEM_MAIN_REG 0x06020188

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 10;

                            /* Bits[9:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lock : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               matching on the SEAMRR range is only allowed if
                               the lock bit is 1. If the lock bit is zero the
                               M2M_SEAMRR_BASE range check should always fail
                               to produce a match.
                            */
    UINT32 valid : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               this bit does nothing in the M2MEM. it might
                               only be used by the core copy of the
                               M2M_SEAMRR_MASK register. M2MEM has a copy
                               though because the ucode in the core might use
                               the M2MEM copy of this register to save/restore
                               the core copy of the same register.
                            */
    UINT32 range_mask : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               sets address bits [51:12] of the range mask for
                               all of the SEAMRR range registers. The size
                               alignment requirement on the SEAMRR base
                               addresses enables all SEAMRR range registers to
                               use a single range mask.
                            */

  } Bits;
  UINT32 Data;

} M2M_SEAMRR_MASK_N0_M2MEM_MAIN_STRUCT;

/* M2M_SEAMRR_MASK_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e6018c)                                                      */
/*      SPRB0 (0x21e6018c)                                                      */
/*      SPRHBM (0x21e6018c)                                                     */
/*      SPRC0 (0x21e6018c)                                                      */
/*      SPRMCC (0x21e6018c)                                                     */
/*      SPRUCC (0x21e6018c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SEAMRR Mask.  Any SEAMRR access should adhere to [br]
        (Addr & M2M_SEAMRR_MASK) == (SEAMRR_Base_Address & M2M_SEAMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_SEAMRR_MASK_N1_M2MEM_MAIN_REG 0x0602018C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 range_mask : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /*
                               sets address bits [51:12] of the range mask for
                               all of the SEAMRR range registers. The size
                               alignment requirement on the SEAMRR base
                               addresses enables all SEAMRR range registers to
                               use a single range mask.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2M_SEAMRR_MASK_N1_M2MEM_MAIN_STRUCT;

/* M2MSUMMARY_M2MEM_MAIN_REG supported on:                                      */
/*      SPRA0 (0x21e601a0)                                                      */
/*      SPRB0 (0x21e601a0)                                                      */
/*      SPRHBM (0x21e601a0)                                                     */
/*      SPRC0 (0x21e601a0)                                                      */
/*      SPRMCC (0x21e601a0)                                                     */
/*      SPRUCC (0x21e601a0)                                                     */
/* Register default value on SPRA0: 0x01FF8000                                  */
/* Register default value on SPRB0: 0x01FF8000                                  */
/* Register default value on SPRHBM: 0x01FF8000                                 */
/* Register default value on SPRC0: 0x01FF8000                                  */
/* Register default value on SPRMCC: 0x01FF8000                                 */
/* Register default value on SPRUCC: 0x01FF8000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register gives a summary of different states of queues/error fsm
*/


#define M2MSUMMARY_M2MEM_MAIN_REG 0x060201A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errormstrstate : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /* Error Master State 3'b0: Idle 1-7: Non idle */
    UINT32 errorexestate : 5;

                            /* Bits[7:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               Error Slave State If ErrorMstrState = 0 ->
                               represents error fsm is idle All other
                               errorslave/errormstr combinations indicate an
                               error retry in progress
                            */
    UINT32 errorfsmtag : 7;

                            /* Bits[14:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               Last Fsm Transition 7'd0 : if(ErrorMstr==0) M2M
                               ErrorFsm is always in idle else M2M ErrorFsm
                               transitioned from idle to drain 7'd8 : M2M
                               exited ErrorFsm All other tags indicate an error
                               retry in progress
                            */
    UINT32 cisgrempty : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000001*/

                            /* Cisgress is Empty 1'b1: Empty 1'b0: Not empty */
    UINT32 blegrempty : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000001*/

                            /* BlEgress is Empty 1'b1: Empty 1'b0: Not empty */
    UINT32 akegrempty : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000001*/

                            /* AK Egr is Empty 1'b1: Empty 1'b0: Not empty */
    UINT32 akcegrempty : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000001*/

                            /* AKCEgress is Empty 1'b1: Empty 1'b0: Not empty */
    UINT32 mirrtrkrempty : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000001*/

                            /*
                               Mirror Tracker is Empty 1'b1: Empty 1'b0: Not
                               empty
                            */
    UINT32 wrtrkrempty : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000001*/

                            /*
                               Store Tracker is Empty 1'b1: Empty 1'b0: Not
                               empty
                            */
    UINT32 rdtrkrempty : 1;

                            /* Bits[21:21], Access Type=RO/V, default=0x00000001*/

                            /*
                               Read tracker is empty 1'b1: Empty 1'b0: Not
                               empty
                            */
    UINT32 pfcamempty : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000001*/

                            /* Pf Cam is empty 1'b1: Empty 1'b0: Not empty */
    UINT32 blingrempty : 1;

                            /* Bits[23:23], Access Type=RO/V, default=0x00000001*/

                            /* BL ingress is empty 1'b1: Empty 1'b0: Not empty */
    UINT32 adingrempty : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000001*/

                            /* Ad ingress is Empty 1'b1: Empty 1'b0: Not empty */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2MSUMMARY_M2MEM_MAIN_STRUCT;

/* MCI_MISC_SHADOW_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e601b0)                                                      */
/*      SPRB0 (0x21e601b0)                                                      */
/*      SPRHBM (0x21e601b0)                                                     */
/*      SPRC0 (0x21e601b0)                                                      */
/*      SPRMCC (0x21e601b0)                                                     */
/*      SPRUCC (0x21e601b0)                                                     */
/* Register default value on SPRA0: 0x00000086                                  */
/* Register default value on SPRB0: 0x00000086                                  */
/* Register default value on SPRHBM: 0x00000086                                 */
/* Register default value on SPRC0: 0x00000086                                  */
/* Register default value on SPRMCC: 0x00000086                                 */
/* Register default value on SPRUCC: 0x00000086                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_MISC MSR. This register is under BIOS control while the MCi_MISC MSR  
      is under OS control.
      
*/


#define MCI_MISC_SHADOW_N0_M2MEM_MAIN_REG 0x060201B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addrlsb : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000006*/

                            /*
                               Address LSb (AddrLsb): Recoverable address LSb.
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSb) of the recoverable error address. It
                               is 6 for this implementation.
                            */
    UINT32 addrmode : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000002*/

                            /*
                               Address Mode (AddrMode): Address mode for the
                               address logged in IA32_MCi_ADDR. The supported
                               address modes are: 000 = Segment Offset; 001 =
                               Linear Address; 010 = Physical Address; 011 =
                               Memory Address; 100 to 110 = Reserved; 111 =
                               Generic. It is 2 for this implementation, i.e.
                               the physical (system) address gets logged.
                            */
    UINT32 hbmmemregion : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1: HBM 0: DDR4 Used in conjunction with
                               McMemRegion. If McMemRegion[cacheable] =1 or
                               (McMemRegion[cacheable]=0 &
                               McMemRegion[persistent]=0) then look at this bit
                               to determine HBM or DDR4. Any other combination
                               is a don't care
                            */
    UINT32 resvd_unused2 : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved for future usecd . */
    UINT32 errortype : 10;

                            /* Bits[20:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Error type attribute (ErrorType): Error type
                               determined (as best as possible) by error flow:
                               bits[9:7]: reserved. bit6: Uncorrectable NM$
                               access because persistently uncorrectable meta-
                               data. bit5: Txn caused permanent hardware
                               channel failover during mirroring. bit4: Scrub
                               check rd returned uncorrected data (ECC
                               correction is enabled during scrub check rd);
                               bit3: Scrub check rd returned good data (note
                               that ECC correction is enabled during scrub
                               check rd); bit2: Txn could not be corrected by
                               ECC; bit1: Txn had an ECC corrected error
                               (corrected by ECC during retry); bit0: Txn had a
                               transient error (corrected by retry without
                               ECC). Exception:For UC on original read data
                               return this bit4 and 3 is zero. As the error is
                               trigger before scrubbing poison and reading It
                               is possible for multiple bits to be set in this
                               bitvector.
                            */
    UINT32 trkid : 9;

                            /* Bits[29:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Mesh2mem Tracker Identifier (TrkId): bits[7:6] =
                               physical channel associated with that tracker
                               (i.e. physical channel for initial access).
                               {bit[8],bits[5:0]} = TrkId within that channel.
                            */
    UINT32 resvd_unused1 : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} MCI_MISC_SHADOW_N0_M2MEM_MAIN_STRUCT;

/* MCI_MISC_SHADOW_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e601b4)                                                      */
/*      SPRB0 (0x21e601b4)                                                      */
/*      SPRHBM (0x21e601b4)                                                     */
/*      SPRC0 (0x21e601b4)                                                      */
/*      SPRMCC (0x21e601b4)                                                     */
/*      SPRUCC (0x21e601b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_MISC MSR. This register is under BIOS control while the MCi_MISC MSR  
      is under OS control.
      
*/


#define MCI_MISC_SHADOW_N1_M2MEM_MAIN_REG 0x060201B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 smiopcode : 4;

                            /* Bits[3:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               SMI Opcode (SmiOpcode): Decoding in case of
                               SMIAd==1 and SMIMsgClass==0(Request): 0=MemRd,
                               1=MemSpecRd, 2=MemRdData, 4=MemRdXtoS,
                               5=MemRdXtoI, 6=MemRdXtoA, 8=MemInv,
                               9=MemInvXtoI, 10=MemInvXtoA, 12=MemInvItoX.
                               Decoding in case of SMIBl==1 and
                               SMIMsgClass==5(Writeback): 0=MemWr, 3=MemWrNI,
                               4=MemWrPtl, 7=MemWrPtlNI, 11=MemWrFlush. Any
                               other encodings different from above are
                               illegal/unexpected.
                            */
    UINT32 bankindex : 6;

                            /* Bits[9:4], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank Index (BankIndex) BankIndex of M2mem MCA
                               bank.
                            */
    UINT32 mccmdvld : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Memory Controller Command Valid (McCmdVld):
                               Memory controller command got logged. 0: no
                               McCmd logged, so dont interpret McCmd fields. 1:
                               McCmd logged; can interpret McCmd fields.
                            */
    UINT32 mccmdopcode : 6;

                            /* Bits[16:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Memory Controller Command Opcode (McCmdOpcode):
                               Memory controller command for which the error
                               got asserted (first error during retries):
                               0=MEMRD, 1=MEMSPECRD, 2=MEMRDDATA, 4=MEMRDXTOS,
                               5=MEMRDXTOI, 6=MEMRDXTOA, 8=MEMINV,
                               9=MEMINVXTOI, 10=MEMINVXTOA, 12=MEMINVITOX,
                               16=MEMWR, 19=MEMWRNI, 20=MEMWRPTL,
                               23=MEMWRPTLNI, 21=PATROL, 27=MEMWRFLUSH,
                               46=DEALLOCSBRD, 47=DEALLOCSBPF, 40= FMFILLRD,
                               48=DIRUPD, 49=NMFILLWR, 51=FMWR4NM,
                               55=FMWRPTL4NM, 56=FMEVICTWR, 62=DEALLOCSBWR,
                               63=DEALLOCSBALL.
                            */
    UINT32 mccmdmemregion : 4;

                            /* Bits[20:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Memory region type (McCmdMemRegion): bit 0:
                               block region. bit 1: pmem region. bits [3:2] =
                               {cacheable, persistent}. { cacheable,persistent}
                               encoding: 0 = 1LM DDR4/HBM access, 1 = DDRT
                               access, 2 = DDR4/HBM NM cache access (non-Pmem),
                               3 = DDR4/HBM NM cache access for Pmem. Whether
                               the 1lm or cacheable regions accessed was DDR4
                               or HBM for the error logged refer to
                               HbmMemRegion
                            */
    UINT32 mccmdchnl : 2;

                            /* Bits[22:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Memory channel (McCmdChnl): Physical memory
                               channel which had the error. Determined during
                               retry. If no error on retry then this just
                               captures the channel of the initial retry. If
                               there was an error during the retry then this
                               will hold the physical channel on which the
                               error occured.
                            */
    UINT32 resvd_unused0 : 4;

                            /* Bits[26:23], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved for future use. */
    UINT32 mccmdmirrregion : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               MC command was to a mirror region
                               (McCmdMirrRegion). Which might or might not have
                               failed over (see McCmdMirrFo bit).
                            */
    UINT32 mccmdmirrsec : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Error on secondary mirror channel
                               (McCmdMirrSec).
                            */
    UINT32 mccmdmirrfo : 1;

                            /* Bits[29:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               MC command was to an already permanently failed
                               over channel/region (MirrFo).
                            */
    UINT32 mirrorcorrerr : 1;

                            /* Bits[30:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Mirror Channel Corrected Error (MirrorCorrErr):
                               Error was corrected during mirroring and primary
                               channel scrubbed successfully. A successful
                               mirror scrub implies an error on the primary
                               channel got corrected by reading the data from
                               the secondary, writing that data to the primary
                               channel and successfully reading back the data
                               from the primary channel. Exception:For UC on
                               original read data return this field is zero. As
                               the error is trigger before scrubbing poison and
                               reading
                            */
    UINT32 mirrorfailover : 1;

                            /* Bits[31:31], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Mirror Failover Error (MirrorFailover): An error
                               occured on a memory channel of the mirror
                               channel pair. The error was corrected by channel
                               failover under mirroring. This implies an
                               uncorrectable (i.e. no correctable by mirror
                               scrub) error on a channel. After failover, the
                               complete (failed) channel is no longer available
                               as a mirror back-up. Exception:For UC on
                               original read data return this field is zero. As
                               the error is trigger before scrubbing poison and
                               reading
                            */

  } Bits;
  UINT32 Data;

} MCI_MISC_SHADOW_N1_M2MEM_MAIN_STRUCT;

/* MCI_STATUS_SHADOW_N0_M2MEM_MAIN_REG supported on:                            */
/*      SPRA0 (0x21e601c0)                                                      */
/*      SPRB0 (0x21e601c0)                                                      */
/*      SPRHBM (0x21e601c0)                                                     */
/*      SPRC0 (0x21e601c0)                                                      */
/*      SPRMCC (0x21e601c0)                                                     */
/*      SPRUCC (0x21e601c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_STATUS MSR. This shadow register is under BIOS control while the MCi_STATUS 
      MSR is under OS control.
      Only the OtherInfo field definition is different from the MCi_STATUS MSR definition.
      
*/


#define MCI_STATUS_SHADOW_N0_M2MEM_MAIN_REG 0x060201C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mcacod : 16;

                            /* Bits[15:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bits[15:0] = 0000 0100 0000 0000:
                               Time-out. bits[15:0] = 0000 0100 0000 0101:
                               Parity error on internal Mesh2mem structures.
                               bits[15:0] = 0000 0100 0000 0101: Parity error
                               on CMI bits[15:7] = 0000 0010 0: Near-Memory
                               Cache controller error. Follow below encodings
                               bits[15:7] = 0000 0000 1: Last level memory
                               controller error. Follow below encodings
                               Bits[6:4] and bits[3:0] further sub-classify the
                               cache/memory controller errors: bits[6:4] = 000:
                               Generic undefined request. bits[6:4] = 001:
                               Memory Read Error (MemRd*, MemSpecRd*, MemInv*).
                               bits[6:4] = 010: Memory Write Error. bits[6:4] =
                               011: Address/Command Error (iMC Parity error,
                               iMC BGF error, bucket1 error). bits[6:4] = 100:
                               Memory Scrubbing Error. bits[6:4] = 101-111:
                               reserved. Bits[3:0] expose physical channel
                               information from where the erroneous transaction
                               received error indications: bits[3:0] = Physical
                               Channel Number (0-2). So bits[3:2] always 0 in
                               this implementation. bits[3:0] = 1111: Channel
                               not specified. If both 1st and 2nd levels of
                               memory signaled an error then the channel number
                               logged here is the 1st level channel.
                            */
    UINT32 mscod : 8;

                            /* Bits[23:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0x00 - No
                               error (default) 0x01 - Read ECC error
                               (MemSpecRd, MemRd, MemRdData, MemRdXto*, MemInv,
                               MemInvXto*, MemInvItoX) 0x02 - Bucket1 error
                               0x03 - RdTrkr Parity error 0x04 - Secure
                               mismatch 0x05 - prefetch channel mismatch 0x06 -
                               failover while reset prep 0x07 - read completion
                               parity error 0x08 - response parity error 0x09 -
                               timeout error 0x0a - CMI reserved credit pool
                               error 0x0b - CMI total credit count error 0x0c -
                               CMI credit oversubscription error
                            */
    UINT32 mscodddrtype : 2;

                            /* Bits[25:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               MSCOD bits for DDR4/DDRT specific error
                               (MscodDdrType): This is an attribute to
                               MscodDataRdErr, MscodPtlWrErr, MscodFullWrErr
                               errors. 00: Not logged whether error to DDR4 or
                               DDRT. 01: Error specifically on DDR4. 10: Error
                               specifically on DDRT. 11: Error for this
                               transaction was detected on both DDR4 and DDRT.
                            */
    UINT32 mscodfailoverwhileresetprep : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               MSCOD bit for FailoverWhileResetPrep errors:
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. 0: No
                               FailoverWhileResetPrep error logged 1: Error
                               logged is a FailoverWhileResetPrep error. This
                               is a correctable error type. This error
                               indicates that a failover event happened after
                               the Reset Prep (C-state/ResetEntry) and before
                               the Reset Prep (General).
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCI_STATUS_SHADOW_N0_M2MEM_MAIN_STRUCT;

/* MCI_STATUS_SHADOW_N1_M2MEM_MAIN_REG supported on:                            */
/*      SPRA0 (0x21e601c4)                                                      */
/*      SPRB0 (0x21e601c4)                                                      */
/*      SPRHBM (0x21e601c4)                                                     */
/*      SPRC0 (0x21e601c4)                                                      */
/*      SPRMCC (0x21e601c4)                                                     */
/*      SPRUCC (0x21e601c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_STATUS MSR. This shadow register is under BIOS control while the MCi_STATUS 
      MSR is under OS control.
      Only the OtherInfo field definition is different from the MCi_STATUS MSR definition.
      
*/


#define MCI_STATUS_SHADOW_N1_M2MEM_MAIN_REG 0x060201C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 otherinfo : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Other Info (OtherInfo): The functions of the
                               bits in this field are implementation specific
                               and are not part of the machine check
                               architecture. In this implementation, this
                               bitfield is used to deal with OS-BIOS race cases
                               and logs the previous shadow error type (if the
                               shadow status wasnt cleared by BIOS).
                               Other_Info[5:4] - Unused (2b0) Other_Info[3]:
                               Trigger Event for History of Error: OS-BIOS
                               race. Trigger event is defined as 0 default.
                               Turns to 1 when M2M OS Machine Check bank status
                               register is being updated (more precisely: valid
                               is being set when it wasnt set before) while the
                               M2M BIOS Shadow Machine Check register statuss
                               valid bit is still on (indicating we have not
                               read the previous error info from the shadow
                               register yet) -> a.k.a. triggering event.
                               Other_Info[2]: History of Fatal Error: 0 is
                               default. When triggering event happens, turns to
                               1 if the previous error was a fatal error.
                               Other_Info[1]: History of recoverable Error: 0
                               is default. When triggering event happens, turns
                               to 1 if the previous error was a recoverable
                               error Other Info[0]: History of Corrected Error:
                               0 is default. When triggering event happens,
                               turns to 1 if the previous error was a corrected
                               error.
                            */
    UINT32 corrcount : 15;

                            /* Bits[20:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Corrected error count (CorrCount): A 15 bit
                               counter that is incremented each time a
                               corrected error is observed by the MCA recording
                               bank. Corrected in this context means either of:
                               retry corrected, ECC corrected, mirror scrub
                               corrected. No failover events, nor recoverable
                               events are counted.
                            */
    UINT32 corrstatus : 2;

                            /* Bits[22:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Corrected Error Status Indicator (CorrStatus):
                               Not used by the memory controller to reveal any
                               information in this implementation. Will always
                               get written with zeros (by hardware) in this
                               implementation.
                            */
    UINT32 ar : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Action Required flag(AR): When set, indicates
                               immediate recovery action is required. M2M
                               always sets this bit to 0.
                            */
    UINT32 s : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Signaling flag(S): When set, indicates an
                               MCE/MSMI was generated for a recoverable error;
                               when clear, indicates a CMCI/CSMI was
                               generated.M2M always sets this bit to 0.
                            */
    UINT32 pcc : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible.
                               Interpretation: UC=0: corrected error; UC=1,
                               PCC=0: recoverable error; UC=1, PCC=1: fatal
                               error. Recoverable error: Uncorrectable error
                               from memory when poison enabled. Fatal error:
                               (i) Uncorrectable error from memory when poison
                               disabled, or (ii) Non-poison error (i.e. control
                               error, non-data error) when poison enabled.
                            */
    UINT32 addrv : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This address-valid bit indicates (when set) that
                               the MC5_ADDR register contains the address of
                               the transaction for which the error occured.
                            */
    UINT32 miscv : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This miscellaneous-valid bit indicates (when
                               set) that the MCi_MISC register contains
                               additional information regarding the error.
                            */
    UINT32 en : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for the logged error
                               type was enabled by an associated flag bit of
                               the MCi_CTL register.
                            */
    UINT32 uc : 1;

                            /* Bits[29:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Error logged in this bank is an uncorrected
                               error. UC=0: corrected error; UC=1, PCC=0:
                               recoverable error; UC=1, PCC=1: fatal error.
                            */
    UINT32 over : 1;

                            /* Bits[30:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Overflow occured. Overflow indicates a second
                               machine check error occured while the
                               information from the first error was still
                               (valid) in the machine check register bank.
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/V/P, default=0x00000000*/

                            /* VAL flag: Error logged in this bank is valid. */

  } Bits;
  UINT32 Data;

} MCI_STATUS_SHADOW_N1_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_CP_N0_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e601c8)                                                      */
/*      SPRB0 (0x21e601c8)                                                      */
/*      SPRHBM (0x21e601c8)                                                     */
/*      SPRC0 (0x21e601c8)                                                      */
/*      SPRMCC (0x21e601c8)                                                     */
/*      SPRUCC (0x21e601c8)                                                     */
/* Register default value on SPRA0: 0x01000218                                  */
/* Register default value on SPRB0: 0x01000218                                  */
/* Register default value on SPRHBM: 0x01000218                                 */
/* Register default value on SPRC0: 0x01000218                                  */
/* Register default value on SPRMCC: 0x01000218                                 */
/* Register default value on SPRUCC: 0x01000218                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to RAC, WAC and CP registers for OS_W security policy group. This policy group covers registers set by OS, so all IA agents are allowed access in the WAC
*/


#define M2M_OS_W_CP_N0_M2MEM_MAIN_REG 0x060201C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_CP_N0_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_CP_N1_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e601cc)                                                      */
/*      SPRB0 (0x21e601cc)                                                      */
/*      SPRHBM (0x21e601cc)                                                     */
/*      SPRC0 (0x21e601cc)                                                      */
/*      SPRMCC (0x21e601cc)                                                     */
/*      SPRUCC (0x21e601cc)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to RAC, WAC and CP registers for OS_W security policy group. This policy group covers registers set by OS, so all IA agents are allowed access in the WAC
*/


#define M2M_OS_W_CP_N1_M2MEM_MAIN_REG 0x060201CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_CP_N1_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_RAC_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e601d0)                                                      */
/*      SPRB0 (0x21e601d0)                                                      */
/*      SPRHBM (0x21e601d0)                                                     */
/*      SPRC0 (0x21e601d0)                                                      */
/*      SPRMCC (0x21e601d0)                                                     */
/*      SPRUCC (0x21e601d0)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the read access to registers in OS_W security policy group.
*/


#define M2M_OS_W_RAC_N0_M2MEM_MAIN_REG 0x060201D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_RAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_RAC_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e601d4)                                                      */
/*      SPRB0 (0x21e601d4)                                                      */
/*      SPRHBM (0x21e601d4)                                                     */
/*      SPRC0 (0x21e601d4)                                                      */
/*      SPRMCC (0x21e601d4)                                                     */
/*      SPRUCC (0x21e601d4)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the read access to registers in OS_W security policy group.
*/


#define M2M_OS_W_RAC_N1_M2MEM_MAIN_REG 0x060201D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_RAC_N1_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_WAC_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e601d8)                                                      */
/*      SPRB0 (0x21e601d8)                                                      */
/*      SPRHBM (0x21e601d8)                                                     */
/*      SPRC0 (0x21e601d8)                                                      */
/*      SPRMCC (0x21e601d8)                                                     */
/*      SPRUCC (0x21e601d8)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to registers in OS_W security policy group.
*/


#define M2M_OS_W_WAC_N0_M2MEM_MAIN_REG 0x060201D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_WAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_OS_W_WAC_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e601dc)                                                      */
/*      SPRB0 (0x21e601dc)                                                      */
/*      SPRHBM (0x21e601dc)                                                     */
/*      SPRC0 (0x21e601dc)                                                      */
/*      SPRMCC (0x21e601dc)                                                     */
/*      SPRUCC (0x21e601dc)                                                     */
/* Register default value on SPRA0: 0x20000C00                                  */
/* Register default value on SPRB0: 0x20000C00                                  */
/* Register default value on SPRHBM: 0x20000C00                                 */
/* Register default value on SPRC0: 0x20000C00                                  */
/* Register default value on SPRMCC: 0x20000C00                                 */
/* Register default value on SPRUCC: 0x20000C00                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to registers in OS_W security policy group.
*/


#define M2M_OS_W_WAC_N1_M2MEM_MAIN_REG 0x060201DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_OS_W_WAC_N1_M2MEM_MAIN_STRUCT;

/* PAD0_N0_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601e0)                                                      */
/*      SPRB0 (0x21e601e0)                                                      */
/*      SPRHBM (0x21e601e0)                                                     */
/*      SPRC0 (0x21e601e0)                                                      */
/*      SPRMCC (0x21e601e0)                                                     */
/*      SPRUCC (0x21e601e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 0:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD0_N0_M2MEM_MAIN_REG 0x060201E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable the PAD, i.e. directed pcommits
                               (PADenable): Use PAD[Address] and PAD[Mask] to
                               determine that a Mesh2mem incoming write needs
                               to be interpreted as a directed pcommit. If the
                               PAD is disabled then writes will never get
                               converted to directed pcommits and will just
                               behave like writes to memory. Whenever a write
                               gets converted to a directed pcommit, that write
                               will no longer take place to memory.
                            */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address : 26;

                            /* Bits[31:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */

  } Bits;
  UINT32 Data;

} PAD0_N0_M2MEM_MAIN_STRUCT;

/* PAD0_N1_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601e4)                                                      */
/*      SPRB0 (0x21e601e4)                                                      */
/*      SPRHBM (0x21e601e4)                                                     */
/*      SPRC0 (0x21e601e4)                                                      */
/*      SPRMCC (0x21e601e4)                                                     */
/*      SPRUCC (0x21e601e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 0:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD0_N1_M2MEM_MAIN_REG 0x060201E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */
    UINT32 rsvd : 3;

                            /* Bits[22:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mask : 6;

                            /* Bits[28:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Mask specifying the directed pcommit region size
                               (PADmask): This is a bit mask which tells which
                               bits of the system address [11:6] to mask out
                               when performing the comparison of the system
                               address [45:6] to the PAD[ Address[45:6] ]. A
                               one in a bit position means that bit will not be
                               included in the address comparison. For example,
                               Mask=0x7 results in 8 64B memory blocks mapping
                               to the directed pcommit region, hence, 8
                               directed pcommits can be simultaneously
                               outstanding in the system to this M2M.
                               Basically, Mask+1 is the maximum allowed number
                               of concurrent directed pcommits that are allowed
                               to be outstanding in the system to this M2M. For
                               SPR and beyong MAsk should be programmed to 0x0
                               as only one addres is allowed per channel . Also
                               if DDR4/DDRT flush both are supported Mask
                               shoudl be 0x2 to allow 2 address with bit 7
                               differentiating between ddr4 or ddrt flush
                               address
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PAD0_N1_M2MEM_MAIN_STRUCT;

/* PAD1_N0_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601e8)                                                      */
/*      SPRB0 (0x21e601e8)                                                      */
/*      SPRHBM (0x21e601e8)                                                     */
/*      SPRC0 (0x21e601e8)                                                      */
/*      SPRMCC (0x21e601e8)                                                     */
/*      SPRUCC (0x21e601e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 1:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD1_N0_M2MEM_MAIN_REG 0x060201E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable the PAD, i.e. directed pcommits
                               (PADenable): Use PAD[Address] and PAD[Mask] to
                               determine that a Mesh2mem incoming write needs
                               to be interpreted as a directed pcommit. If the
                               PAD is disabled then writes will never get
                               converted to directed pcommits and will just
                               behave like writes to memory. Whenever a write
                               gets converted to a directed pcommit, that write
                               will no longer take place to memory.
                            */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address : 26;

                            /* Bits[31:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */

  } Bits;
  UINT32 Data;

} PAD1_N0_M2MEM_MAIN_STRUCT;

/* PAD1_N1_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601ec)                                                      */
/*      SPRB0 (0x21e601ec)                                                      */
/*      SPRHBM (0x21e601ec)                                                     */
/*      SPRC0 (0x21e601ec)                                                      */
/*      SPRMCC (0x21e601ec)                                                     */
/*      SPRUCC (0x21e601ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 1:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD1_N1_M2MEM_MAIN_REG 0x060201EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */
    UINT32 rsvd : 3;

                            /* Bits[22:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mask : 6;

                            /* Bits[28:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Mask specifying the directed pcommit region size
                               (PADmask): This is a bit mask which tells which
                               bits of the system address [11:6] to mask out
                               when performing the comparison of the system
                               address [45:6] to the PAD[ Address[45:6] ]. A
                               one in a bit position means that bit will not be
                               included in the address comparison. For example,
                               Mask=0x7 results in 8 64B memory blocks mapping
                               to the directed pcommit region, hence, 8
                               directed pcommits can be simultaneously
                               outstanding in the system to this M2M.
                               Basically, Mask+1 is the maximum allowed number
                               of concurrent directed pcommits that are allowed
                               to be outstanding in the system to this M2M. For
                               SPR and beyong MAsk should be programmed to 0x0
                               as only one addres is allowed per channel . Also
                               if DDR4/DDRT flush both are supported Mask
                               shoudl be 0x2 to allow 2 address with bit 7
                               differentiating between ddr4 or ddrt flush
                               address
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PAD1_N1_M2MEM_MAIN_STRUCT;

/* PAD2_N0_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601f0)                                                      */
/*      SPRB0 (0x21e601f0)                                                      */
/*      SPRHBM (0x21e601f0)                                                     */
/*      SPRC0 (0x21e601f0)                                                      */
/*      SPRMCC (0x21e601f0)                                                     */
/*      SPRUCC (0x21e601f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 2:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD2_N0_M2MEM_MAIN_REG 0x060201F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable the PAD, i.e. directed pcommits
                               (PADenable): Use PAD[Address] and PAD[Mask] to
                               determine that a Mesh2mem incoming write needs
                               to be interpreted as a directed pcommit. If the
                               PAD is disabled then writes will never get
                               converted to directed pcommits and will just
                               behave like writes to memory. Whenever a write
                               gets converted to a directed pcommit, that write
                               will no longer take place to memory.
                            */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address : 26;

                            /* Bits[31:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */

  } Bits;
  UINT32 Data;

} PAD2_N0_M2MEM_MAIN_STRUCT;

/* PAD2_N1_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e601f4)                                                      */
/*      SPRB0 (0x21e601f4)                                                      */
/*      SPRHBM (0x21e601f4)                                                     */
/*      SPRC0 (0x21e601f4)                                                      */
/*      SPRMCC (0x21e601f4)                                                     */
/*      SPRUCC (0x21e601f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      PAD (Pcommit Address Decoder) region 2:
      This register specifies the system address range for which mesh2mem should interpret incoming
      BL writes as directed pcommits. Reads to this address range will just be propagated to memory.

      When the PAD is enabled, any incoming write matching the PAD address region according to expression:
        PAD region hit = (wr_sys_addr[45:6] and ~CONCAT(0,PAD.Mask[11:6]))==(PAD.Address[45:6] and ~CONCAT(0,PAD.Mask[11:6])
      will not write but instead get interpreted as a directed pcommit with the targeted channel provided by the CHA SAD.

      The envisioned usage model is that an address range within the block region would be used as the PAD region.
      
*/


#define PAD2_N1_M2MEM_MAIN_REG 0x060201F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Address specifying the directed pcommit region
                               (PADaddress): PAD region system address [51:6]
                               to compare against the incoming writes system
                               addresses (masked comparison).
                            */
    UINT32 rsvd : 3;

                            /* Bits[22:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mask : 6;

                            /* Bits[28:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Mask specifying the directed pcommit region size
                               (PADmask): This is a bit mask which tells which
                               bits of the system address [11:6] to mask out
                               when performing the comparison of the system
                               address [45:6] to the PAD[ Address[45:6] ]. A
                               one in a bit position means that bit will not be
                               included in the address comparison. For example,
                               Mask=0x7 results in 8 64B memory blocks mapping
                               to the directed pcommit region, hence, 8
                               directed pcommits can be simultaneously
                               outstanding in the system to this M2M.
                               Basically, Mask+1 is the maximum allowed number
                               of concurrent directed pcommits that are allowed
                               to be outstanding in the system to this M2M. For
                               SPR and beyong MAsk should be programmed to 0x0
                               as only one addres is allowed per channel . Also
                               if DDR4/DDRT flush both are supported Mask
                               shoudl be 0x2 to allow 2 address with bit 7
                               differentiating between ddr4 or ddrt flush
                               address
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PAD2_N1_M2MEM_MAIN_STRUCT;







/* TAD_RD_N0_M2MEM_MAIN_REG supported on:                                       */
/*      SPRA0 (0x21e60238)                                                      */
/*      SPRB0 (0x21e60238)                                                      */
/*      SPRHBM (0x21e60238)                                                     */
/*      SPRC0 (0x21e60238)                                                      */
/*      SPRMCC (0x21e60238)                                                     */
/*      SPRUCC (0x21e60238)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      TAD mapping:
      This register allows indirect access to read each of the 20 internal TAD table entries.
      The reset value for all the fields in the internal TAD table is 0, except for AddressLimit, which resets to all-1's.
      This internal TAD table gets reset on a cold reset (pwr pulse) only.


      To read a TAD entry: 
        1. Configure the TAD entry/index field and at the same time set the read-enable bit to 1.
        2. Now read this register which will have its fields populated with the information 
           of the particular TAD entry.
           - When reading this register, check that TadId matches the value which was written in step 2.
             If the value does not match, then another software agent wrote this register between
             steps 1 and 2, and the read results are not valid. Steps 1-2 should be repeated.


      
*/


#define TAD_RD_N0_M2MEM_MAIN_REG 0x06020238

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tadid : 5;

                            /* Bits[4:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               TAD Table SAD Entry/Index (TadId): Specifies
                               what TAD entry in the TAD table to read
                               indirectly through this register. There are 20
                               TAD entries so the legal range is 0-19.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tadrden : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               TAD Read (TadRdEn): Read the TAD table entry.
                               The read information will get stored in this
                               register. Hardware will read the TAD table entry
                               when seeing a zero-to-one transition on this
                               bitfield. Hardware will reset this bit to 0 the
                               cycle after it is written to 1.
                            */
    UINT32 tadvld : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               TAD Table Entry Valid (TadVld): Specifies
                               whether this TAD entry in the TAD table is
                               valid. It is illegal to program TadVld[N]==1 if
                               TadVld[N-1]==0 (for N>0).
                            */
    UINT32 ddrtadid : 4;

                            /* Bits[11:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               DDR TAD entry (DDRtadId): DDR TAD entry
                               associated with this TAD table entry. M2mem puts
                               no restrictions on the values here, but this
                               field should be programmed consistent with the
                               channel's capabilities. There are 12 TAD entries
                               in the channel, hence the current legal range is
                               0-11. DDR4 can only use the first 8 TAD entries,
                               so the legal range is 0-7 for regions with the
                               DDR4 bit set. HBM should only use TAD entry 0.
                            */
    UINT32 rsvd_12 : 3;

                            /* Bits[14:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonpersistentfm : 1;

                            /* Bits[15:15], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Non-Persistent Far Memory (NonPersistentFm):
                               This TAD entry represents a near-memory cached
                               region in which the far-memory is non-
                               persistent. This bit only takes effect when
                               NmCacheableVld for this TAD entry is set, and
                               should only be set if the far-memory being
                               cached by near-memory is not persistent (i.e. is
                               not DDRT). NOTE: This bit only works if the far-
                               memory is on a different MC tile than the near-
                               memory. It is currently not supported where a
                               single MC has both near-memory AND far-memory
                               and the far-memory being cached is not
                               persistent/DDRT
                            */
    UINT32 pmemvld : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               PMem Region Valid (PmemVld): This TAD entry
                               represents a persistent memory region.
                            */
    UINT32 blkvld : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Block Region Valid (BlkVld): This TAD entry
                               represents a block region.
                            */
    UINT32 ddr4 : 1;

                            /* Bits[18:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               DDR4: This TAD entry represents near-memory at
                               NMC or 1LM DDR4. In non-Xtile config: this just
                               represents the 1LM DDR4 region. In Xtile config:
                               this represents NM access at the near-memory
                               controller (or DDR4 access at the FMC). BIOS to
                               calculate as follows: '(!PmemVld & !BlockVld &
                               (!NmCacheableVld | Mode[FmcXtile])) | (PmemVld &
                               DDR4_NVDIMM)'
                            */
    UINT32 nmcacheablevld : 1;

                            /* Bits[19:19], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Near-Memory Cacheable Valid (NmCacheableVld):
                               This TAD entry represents a near-memory cached
                               region, i.e. not a 1LM region.
                            */
    UINT32 mirror : 1;

                            /* Bits[20:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Mirror region: This TAD entry represents a
                               mirroring region.
                            */
    UINT32 secondary1st : 1;

                            /* Bits[21:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Read secondary mirror channel first
                               (Secondary1st): For this memory region, read
                               secondary mirror channel first. Used in
                               mirroring to prevent (non error flow) accesses
                               to a primary mirror channel for a bad primary
                               region/address. Note, if an error flow does get
                               invoked because of an error on secondary for an
                               access to this region then the primary storage
                               will still be accessed (when channel not failed
                               over).
                            */
    UINT32 frcnpwr : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Force Non-Posted Writes (FrcNPWr): This TAD
                               entry represents region that requires NP write
                               semantics on CMI. Only applies to the far-memory
                               region if this is a 2LM region.
                            */
    UINT32 lowbw : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Low Bandwidth Memory (LowBW): This TAD entry
                               represents a region for which CHA uses a low
                               bandwidth credit. Setting this bit causes m2mem
                               to set the ddrt_cdt bit on BL credit returns for
                               writes targeting this region.
                            */
    UINT32 dedupvld : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               DedupRegion (DedupVld) This TAD entry represents
                               a region for which CHA uses Dedup IP to access
                               memory Setting this bit would mean m2mem would
                               use a dedicated VC to issue transactions to the
                               memory controller which will be routed via the
                               Dedup IP to MC
                            */
    UINT32 spare : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /* Spare: Spare bits to describe this TAD entry. */
    UINT32 addresslimit : 6;

                            /* Bits[31:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Limit address Specifies the upper limit
                               (inclusive) for address[51:26] (64MB aligned) to
                               be part of this memory region. An address hits a
                               particular TAD entry if all of the following
                               conditions are true (where 'N' is the TAD entry
                               number): [list] [*]TadVld[N] == 1
                               [*]address[51:26] <= AddressLimit[N]
                               [*]address[51:26] > AddressLimit[N-1] (only for
                               N>0) [/list] System firmware must program the
                               TAD AddressLimit fields such that
                               AddressLimit[N] > AddressLimit[N-1] for all N>0
                               with TadVld[N]==1.
                            */

  } Bits;
  UINT32 Data;

} TAD_RD_N0_M2MEM_MAIN_STRUCT;

/* TAD_RD_N1_M2MEM_MAIN_REG supported on:                                       */
/*      SPRA0 (0x21e6023c)                                                      */
/*      SPRB0 (0x21e6023c)                                                      */
/*      SPRHBM (0x21e6023c)                                                     */
/*      SPRC0 (0x21e6023c)                                                      */
/*      SPRMCC (0x21e6023c)                                                     */
/*      SPRUCC (0x21e6023c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      TAD mapping:
      This register allows indirect access to read each of the 20 internal TAD table entries.
      The reset value for all the fields in the internal TAD table is 0, except for AddressLimit, which resets to all-1's.
      This internal TAD table gets reset on a cold reset (pwr pulse) only.


      To read a TAD entry: 
        1. Configure the TAD entry/index field and at the same time set the read-enable bit to 1.
        2. Now read this register which will have its fields populated with the information 
           of the particular TAD entry.
           - When reading this register, check that TadId matches the value which was written in step 2.
             If the value does not match, then another software agent wrote this register between
             steps 1 and 2, and the read results are not valid. Steps 1-2 should be repeated.


      
*/


#define TAD_RD_N1_M2MEM_MAIN_REG 0x0602023C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addresslimit : 20;

                            /* Bits[19:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Limit address Specifies the upper limit
                               (inclusive) for address[51:26] (64MB aligned) to
                               be part of this memory region. An address hits a
                               particular TAD entry if all of the following
                               conditions are true (where 'N' is the TAD entry
                               number): [list] [*]TadVld[N] == 1
                               [*]address[51:26] <= AddressLimit[N]
                               [*]address[51:26] > AddressLimit[N-1] (only for
                               N>0) [/list] System firmware must program the
                               TAD AddressLimit fields such that
                               AddressLimit[N] > AddressLimit[N-1] for all N>0
                               with TadVld[N]==1.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TAD_RD_N1_M2MEM_MAIN_STRUCT;

/* TAD_WR_N0_M2MEM_MAIN_REG supported on:                                       */
/*      SPRA0 (0x21e60240)                                                      */
/*      SPRB0 (0x21e60240)                                                      */
/*      SPRHBM (0x21e60240)                                                     */
/*      SPRC0 (0x21e60240)                                                      */
/*      SPRMCC (0x21e60240)                                                     */
/*      SPRUCC (0x21e60240)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      TAD mapping:
      This register allows indirect access to write each of the 20 internal TAD table entries.
      The reset value for all the fields in the internal TAD table is 0, except for AddressLimit, which resets to all-1's.
      This internal TAD table gets reset on a cold reset (pwr pulse) only.


      To write a TAD entry: 
        1. Configure all fields and at the same time set the write-enable bit to 1.


      
*/


#define TAD_WR_N0_M2MEM_MAIN_REG 0x06020240

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tadid : 5;

                            /* Bits[4:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               TAD Table SAD Entry/Index (TadId): Specifies
                               what TAD entry in the TAD table to write
                               indirectly through this register. There are 20
                               TAD entries so the legal range is 0-19.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tadwren : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               TAD Write (TadWrEn): Write the TAD table entry
                               with the information contained in this register.
                               Hardware will write the TAD table entry when
                               seeing a zero-to-one transition on this
                               bitfield. Hardware will reset this bit to 0 the
                               cycle after it is written to 1.
                            */
    UINT32 tadvld : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               TAD Table Entry Valid (TadVld): Specifies
                               whether this TAD entry in the TAD table is
                               valid. It is illegal to program TadVld[N]==1 if
                               TadVld[N-1]==0 (for N>0).
                            */
    UINT32 ddrtadid : 4;

                            /* Bits[11:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR TAD entry (DDRtadId): DDR TAD entry
                               associated with this TAD table entry. M2mem puts
                               no restrictions on the values here, but this
                               field should be programmed consistent with the
                               channel's capabilities. There are 12 TAD entries
                               in the channel, hence the current legal range is
                               0-11. DDR4 can only use the first 8 TAD entries,
                               so the legal range is 0-7 for regions with the
                               DDR4 bit set. HBM should only use TAD entry 0.
                            */
    UINT32 rsvd_12 : 3;

                            /* Bits[14:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonpersistentfm : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Non-Persistent Far Memory (NonPersistentFm):
                               This TAD entry represents a near-memory cached
                               region in which the far-memory is non-
                               persistent. This bit only takes effect when
                               NmCacheableVld for this TAD entry is set, and
                               should only be set if the far-memory being
                               cached by near-memory is not persistent (i.e. is
                               not DDRT). NOTE: This bit only works if the far-
                               memory is on a different MC tile than the near-
                               memory. It is currently not supported where a
                               single MC has both near-memory AND far-memory
                               and the far-memory being cached is not
                               persistent/DDRT
                            */
    UINT32 pmemvld : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               PMem Region Valid (PmemVld): This TAD entry
                               represents a persistent memory region.
                            */
    UINT32 blkvld : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Block Region Valid (BlkVld): This TAD entry
                               represents a block region.
                            */
    UINT32 ddr4 : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR4: This TAD entry represents near-memory at
                               NMC or 1LM DDR4. In non-Xtile config: this just
                               represents the 1LM DDR4 region. In Xtile config:
                               this represents NM access at the near-memory
                               controller (or DDR4 access at the FMC). BIOS to
                               calculate as follows: '(!PmemVld & !BlockVld &
                               (!NmCacheableVld | Mode[FmcXtile])) | (PmemVld &
                               DDR4_NVDIMM)'
                            */
    UINT32 nmcacheablevld : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /*
                               Near-Memory Cacheable Valid (NmCacheableVld):
                               This TAD entry represents a near-memory cached
                               region, i.e. not a 1LM region.
                            */
    UINT32 mirror : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Mirror region: This TAD entry represents a
                               mirroring region.
                            */
    UINT32 secondary1st : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               Read secondary mirror channel first
                               (Secondary1st): For this memory region, read
                               secondary mirror channel first. Used in
                               mirroring to prevent (non error flow) accesses
                               to a primary mirror channel for a bad primary
                               region/address. Note, if an error flow does get
                               invoked because of an error on secondary for an
                               access to this region then the primary storage
                               will still be accessed (when channel not failed
                               over).
                            */
    UINT32 frcnpwr : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /*
                               Force Non-Posted Writes (FrcNPWr): This TAD
                               entry represents region that requires NP write
                               semantics on CMI. Only applies to the far-memory
                               region if this is a 2LM region.
                            */
    UINT32 lowbw : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Low Bandwidth Memory (LowBW): This TAD entry
                               represents a region for which CHA uses a low
                               bandwidth credit. Setting this bit causes m2mem
                               to set the ddrt_cdt bit on BL credit returns for
                               writes targeting this region.
                            */
    UINT32 dedupvld : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               DedupRegion (DedupVld) This TAD entry represents
                               a region for which CHA uses Dedup IP to access
                               memory Setting this bit would mean m2mem would
                               use a dedicated VC to issue transactions to the
                               memory controller which will be routed via the
                               Dedup IP to MC
                            */
    UINT32 spare : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /* Spare: Spare bits to describe this TAD entry. */
    UINT32 addresslimit : 6;

                            /* Bits[31:26], Access Type=RW/P, default=0x00000000*/

                            /*
                               Limit address Specifies the upper limit
                               (inclusive) for address[51:26] (64MB aligned) to
                               be part of this memory region. An address hits a
                               particular TAD entry if all of the following
                               conditions are true (where 'N' is the TAD entry
                               number): [list] [*]TadVld[N] == 1
                               [*]address[51:26] <= AddressLimit[N]
                               [*]address[51:26] > AddressLimit[N-1] (only for
                               N>0) [/list] System firmware must program the
                               TAD AddressLimit fields such that
                               AddressLimit[N] > AddressLimit[N-1] for all N>0
                               with TadVld[N]==1.
                            */

  } Bits;
  UINT32 Data;

} TAD_WR_N0_M2MEM_MAIN_STRUCT;

/* TAD_WR_N1_M2MEM_MAIN_REG supported on:                                       */
/*      SPRA0 (0x21e60244)                                                      */
/*      SPRB0 (0x21e60244)                                                      */
/*      SPRHBM (0x21e60244)                                                     */
/*      SPRC0 (0x21e60244)                                                      */
/*      SPRMCC (0x21e60244)                                                     */
/*      SPRUCC (0x21e60244)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      TAD mapping:
      This register allows indirect access to write each of the 20 internal TAD table entries.
      The reset value for all the fields in the internal TAD table is 0, except for AddressLimit, which resets to all-1's.
      This internal TAD table gets reset on a cold reset (pwr pulse) only.


      To write a TAD entry: 
        1. Configure all fields and at the same time set the write-enable bit to 1.


      
*/


#define TAD_WR_N1_M2MEM_MAIN_REG 0x06020244

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addresslimit : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Limit address Specifies the upper limit
                               (inclusive) for address[51:26] (64MB aligned) to
                               be part of this memory region. An address hits a
                               particular TAD entry if all of the following
                               conditions are true (where 'N' is the TAD entry
                               number): [list] [*]TadVld[N] == 1
                               [*]address[51:26] <= AddressLimit[N]
                               [*]address[51:26] > AddressLimit[N-1] (only for
                               N>0) [/list] System firmware must program the
                               TAD AddressLimit fields such that
                               AddressLimit[N] > AddressLimit[N-1] for all N>0
                               with TadVld[N]==1.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TAD_WR_N1_M2MEM_MAIN_STRUCT;

/* VIRAL_N0_M2MEM_MAIN_REG supported on:                                        */
/*      SPRA0 (0x21e60248)                                                      */
/*      SPRB0 (0x21e60248)                                                      */
/*      SPRHBM (0x21e60248)                                                     */
/*      SPRC0 (0x21e60248)                                                      */
/*      SPRMCC (0x21e60248)                                                     */
/*      SPRUCC (0x21e60248)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Allows disabling individual viral sources so that viral would not assert for that error source.
      The programming of this register is only relevant when viral is enabled, i.e. when M2M 
      MCi_MCG_Contain[ViralEnable] is 1.
      
*/


#define VIRAL_N0_M2MEM_MAIN_REG 0x06020248

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 disviralonmcafatal : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on Fatal Memory Access error
                               (DisViralOnMcaFatal): 0: Going viral is enabled
                               for an M2M fatal memory access error (e.g.
                               uncorrectable rd). 1: Going viral is disabled
                               for an M2M fatal memory access error (e.g.
                               uncorrectable rd).
                            */
    UINT32 disviralonmcabucket1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on Bucket1 Mca
                               (DisViralOnMcaBucket1): 0: Going viral is
                               enabled for an M2M bucket1 error. 1: Going viral
                               is disabled for an M2M bucket1 error.
                            */
    UINT32 disviralonmcasecuremismatch : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on SecureMismatch Mca
                               (DisViralOnSecureMismatch): 0: Going viral is
                               enabled for a security misamtch error. 1: Going
                               viral is disabled for a security mismatch error.
                            */
    UINT32 disviralonmcaparity : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on Parity Mca
                               (DisViralOnMcaParity): 0: Going viral is enabled
                               for an M2M address/cmd/state parity error. 1:
                               Going viral is disabled for an M2M
                               address/cmd/state parity error.
                            */
    UINT32 disviralonmcatrkrtimeout : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on Tracker Timeout Mca
                               (DisViralOnMcaTrkrTimeout): 0: Going viral is
                               enabled for an M2M Tracker Timeout. 1: Going
                               viral is disabled for an M2M Tracker Timeout.
                            */
    UINT32 disviralonmcapfchmismatchmca : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on PfChMismatchMCA 0: Going viral
                               is enabled for an M2M prefetch channel mismatch
                               1: Going viral is disabled for an M2M prefetch
                               channel mismatch
                            */
    UINT32 disviralonmcardcplparity : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on RdCplParity 0: Going viral is
                               enabled for an Rd cpl tid paity 1: Going viral
                               is disabled for an rd cpl tid parity
                            */
    UINT32 disviralonmcarspparity : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Viral on RspParity 0: Going viral is
                               enabled for an Rsp tid paity 1: Going viral is
                               disabled for an rsp tid parity
                            */
    UINT32 disviraloncmirsvdpoolerr : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Disable Viral on CMI reserved pool error */
    UINT32 disviraloncmitotalcrediterr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Disable Viral on CMI credit count mismatch */
    UINT32 disviraloncmicreditoversubscription : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Disable Viral on CMI credit over-subscription */
    UINT32 disviralonsairegionerr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Disable Viral on incorrect OOB SAI region */
    UINT32 rsvd : 19;

                            /* Bits[30:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 viralclear : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, clears viral level signal in
                               M2Mem. Clear to 0 to allow viral signal to be
                               set again. After viral has occurred, no
                               functionality is guaranteed, even if this bit is
                               set to 1 to stop viral signaling. In addition,
                               setting this bit to 1 may result in corrupting
                               persistent data, so use at your own risk.
                            */

  } Bits;
  UINT32 Data;

} VIRAL_N0_M2MEM_MAIN_STRUCT;

/* VIRAL_N1_M2MEM_MAIN_REG supported on:                                        */
/*      SPRA0 (0x21e6024c)                                                      */
/*      SPRB0 (0x21e6024c)                                                      */
/*      SPRHBM (0x21e6024c)                                                     */
/*      SPRC0 (0x21e6024c)                                                      */
/*      SPRMCC (0x21e6024c)                                                     */
/*      SPRUCC (0x21e6024c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Allows disabling individual viral sources so that viral would not assert for that error source.
      The programming of this register is only relevant when viral is enabled, i.e. when M2M 
      MCi_MCG_Contain[ViralEnable] is 1.
      
*/


#define VIRAL_N1_M2MEM_MAIN_REG 0x0602024C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} VIRAL_N1_M2MEM_MAIN_STRUCT;

/* CMIRDCPLCREDITCHNLCONFIG_0_M2MEM_MAIN_REG supported on:                      */
/*      SPRA0 (0x21e60258)                                                      */
/*      SPRB0 (0x21e60258)                                                      */
/*      SPRHBM (0x21e60258)                                                     */
/*      SPRC0 (0x21e60258)                                                      */
/*      SPRMCC (0x21e60258)                                                     */
/*      SPRUCC (0x21e60258)                                                     */
/* Register default value on SPRA0: 0x10000010                                  */
/* Register default value on SPRB0: 0x10000010                                  */
/* Register default value on SPRHBM: 0x10000010                                 */
/* Register default value on SPRC0: 0x10000010                                  */
/* Register default value on SPRMCC: 0x10000010                                 */
/* Register default value on SPRUCC: 0x10000010                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI read completion credit configuration -- part 1 of 2.  All credits are 64B granular.  Max(vc0_credits, vc1_credits, vc2_credits) + vc3_credits + shared_vc_credits should not exceed the depth of BL egress minus any entries siphoned off for cisgress.
*/


#define CMIRDCPLCREDITCHNLCONFIG_0_M2MEM_MAIN_REG 0x06020258

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_credits : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000010*/

                            /*
                               Number of read completion credits for VC0. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc1_credits : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC1. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc2_credits : 6;

                            /* Bits[17:12], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC2. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc3_credits : 6;

                            /* Bits[23:18], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC3. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 shared_vc_credits : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000010*/

                            /*
                               Number of shared VC read completion credits.
                               These credits are available to be used by any VC
                               as needed. Reset value is for 1LM DDR4 only
                               config.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMIRDCPLCREDITCHNLCONFIG_0_M2MEM_MAIN_STRUCT;

/* CMIRDCPLCREDITCHNLCONFIG_1_M2MEM_MAIN_REG supported on:                      */
/*      SPRA0 (0x21e6025c)                                                      */
/*      SPRB0 (0x21e6025c)                                                      */
/*      SPRHBM (0x21e6025c)                                                     */
/*      SPRC0 (0x21e6025c)                                                      */
/*      SPRMCC (0x21e6025c)                                                     */
/*      SPRUCC (0x21e6025c)                                                     */
/* Register default value on SPRA0: 0x10000010                                  */
/* Register default value on SPRB0: 0x10000010                                  */
/* Register default value on SPRHBM: 0x10000010                                 */
/* Register default value on SPRC0: 0x10000010                                  */
/* Register default value on SPRMCC: 0x10000010                                 */
/* Register default value on SPRUCC: 0x10000010                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI read completion credit configuration -- part 1 of 2.  All credits are 64B granular.  Max(vc0_credits, vc1_credits, vc2_credits) + vc3_credits + shared_vc_credits should not exceed the depth of BL egress minus any entries siphoned off for cisgress.
*/


#define CMIRDCPLCREDITCHNLCONFIG_1_M2MEM_MAIN_REG 0x0602025C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_credits : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000010*/

                            /*
                               Number of read completion credits for VC0. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc1_credits : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC1. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc2_credits : 6;

                            /* Bits[17:12], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC2. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 vc3_credits : 6;

                            /* Bits[23:18], Access Type=RW, default=0x00000000*/

                            /*
                               Number of read completion credits for VC3. Reset
                               value is for 1LM DDR4 only config.
                            */
    UINT32 shared_vc_credits : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000010*/

                            /*
                               Number of shared VC read completion credits.
                               These credits are available to be used by any VC
                               as needed. Reset value is for 1LM DDR4 only
                               config.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMIRDCPLCREDITCHNLCONFIG_1_M2MEM_MAIN_STRUCT;

/* CMIRDCPLCREDITCHNLCONFIG_2_0_M2MEM_MAIN_REG supported on:                    */
/*      SPRA0 (0x21e60270)                                                      */
/*      SPRB0 (0x21e60270)                                                      */
/*      SPRHBM (0x21e60270)                                                     */
/*      SPRC0 (0x21e60270)                                                      */
/*      SPRMCC (0x21e60270)                                                     */
/*      SPRUCC (0x21e60270)                                                     */
/* Register default value on SPRA0: 0x0000028A                                  */
/* Register default value on SPRB0: 0x0000028A                                  */
/* Register default value on SPRHBM: 0x0000028A                                 */
/* Register default value on SPRC0: 0x0000028A                                  */
/* Register default value on SPRMCC: 0x0000028A                                 */
/* Register default value on SPRUCC: 0x0000028A                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI read completion credit configuration -- part 2 of 2.  All credits are 64B granular.  Fabric and Qdepth credit programming
*/


#define CMIRDCPLCREDITCHNLCONFIG_2_0_M2MEM_MAIN_REG 0x06020270

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 qdepth : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000000A*/

                            /*
                               Read completion queue depth advertised on CMI
                               (64B value, will be expanded to 32B value for
                               CMI transmission). Should generally be
                               max(vc0_credits, vc1_credits, vc2_credits) +
                               vc3_credits.
                            */
    UINT32 fab_credits : 4;

                            /* Bits[9:6], Access Type=RW, default=0x0000000A*/

                            /* Number of fabric credits. */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMIRDCPLCREDITCHNLCONFIG_2_0_M2MEM_MAIN_STRUCT;

/* CMIRDCPLCREDITCHNLCONFIG_2_1_M2MEM_MAIN_REG supported on:                    */
/*      SPRA0 (0x21e60274)                                                      */
/*      SPRB0 (0x21e60274)                                                      */
/*      SPRHBM (0x21e60274)                                                     */
/*      SPRC0 (0x21e60274)                                                      */
/*      SPRMCC (0x21e60274)                                                     */
/*      SPRUCC (0x21e60274)                                                     */
/* Register default value on SPRA0: 0x0000028A                                  */
/* Register default value on SPRB0: 0x0000028A                                  */
/* Register default value on SPRHBM: 0x0000028A                                 */
/* Register default value on SPRC0: 0x0000028A                                  */
/* Register default value on SPRMCC: 0x0000028A                                 */
/* Register default value on SPRUCC: 0x0000028A                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI read completion credit configuration -- part 2 of 2.  All credits are 64B granular.  Fabric and Qdepth credit programming
*/


#define CMIRDCPLCREDITCHNLCONFIG_2_1_M2MEM_MAIN_REG 0x06020274

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 qdepth : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000000A*/

                            /*
                               Read completion queue depth advertised on CMI
                               (64B value, will be expanded to 32B value for
                               CMI transmission). Should generally be
                               max(vc0_credits, vc1_credits, vc2_credits) +
                               vc3_credits.
                            */
    UINT32 fab_credits : 4;

                            /* Bits[9:6], Access Type=RW, default=0x0000000A*/

                            /* Number of fabric credits. */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMIRDCPLCREDITCHNLCONFIG_2_1_M2MEM_MAIN_STRUCT;

/* CMIRSPCREDITCHNLCONFIG_0_M2MEM_MAIN_REG supported on:                        */
/*      SPRA0 (0x21e60278)                                                      */
/*      SPRB0 (0x21e60278)                                                      */
/*      SPRHBM (0x21e60278)                                                     */
/*      SPRC0 (0x21e60278)                                                      */
/*      SPRMCC (0x21e60278)                                                     */
/*      SPRUCC (0x21e60278)                                                     */
/* Register default value on SPRA0: 0x42040810                                  */
/* Register default value on SPRB0: 0x42040810                                  */
/* Register default value on SPRHBM: 0x42040810                                 */
/* Register default value on SPRC0: 0x42040810                                  */
/* Register default value on SPRMCC: 0x42040810                                 */
/* Register default value on SPRUCC: 0x42040810                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI response credit configuration.  Virtual credits do not reflect any actual storage.  Fabric credits reflect input FIFO entries.
*/


#define CMIRSPCREDITCHNLCONFIG_0_M2MEM_MAIN_REG 0x06020278

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_credits : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC0 */
    UINT32 vc1_credits : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC1 */
    UINT32 vc2_credits : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC2 */
    UINT32 vc3_credits : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC3 */
    UINT32 fab_credits : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000004*/

                            /* Number of fabric credits */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bit */

  } Bits;
  UINT32 Data;

} CMIRSPCREDITCHNLCONFIG_0_M2MEM_MAIN_STRUCT;

/* CMIRSPCREDITCHNLCONFIG_1_M2MEM_MAIN_REG supported on:                        */
/*      SPRA0 (0x21e6027c)                                                      */
/*      SPRB0 (0x21e6027c)                                                      */
/*      SPRHBM (0x21e6027c)                                                     */
/*      SPRC0 (0x21e6027c)                                                      */
/*      SPRMCC (0x21e6027c)                                                     */
/*      SPRUCC (0x21e6027c)                                                     */
/* Register default value on SPRA0: 0x42040810                                  */
/* Register default value on SPRB0: 0x42040810                                  */
/* Register default value on SPRHBM: 0x42040810                                 */
/* Register default value on SPRC0: 0x42040810                                  */
/* Register default value on SPRMCC: 0x42040810                                 */
/* Register default value on SPRUCC: 0x42040810                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI response credit configuration.  Virtual credits do not reflect any actual storage.  Fabric credits reflect input FIFO entries.
*/


#define CMIRSPCREDITCHNLCONFIG_1_M2MEM_MAIN_REG 0x0602027C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_credits : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC0 */
    UINT32 vc1_credits : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC1 */
    UINT32 vc2_credits : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC2 */
    UINT32 vc3_credits : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000010*/

                            /* Number of response credits for VC3 */
    UINT32 fab_credits : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000004*/

                            /* Number of fabric credits */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bit */

  } Bits;
  UINT32 Data;

} CMIRSPCREDITCHNLCONFIG_1_M2MEM_MAIN_STRUCT;



/* CMITIDPARITYCHNLCONFIG_0_M2MEM_MAIN_REG supported on:                        */
/*      SPRA0 (0x21e60290)                                                      */
/*      SPRB0 (0x21e60290)                                                      */
/*      SPRHBM (0x21e60290)                                                     */
/*      SPRC0 (0x21e60290)                                                      */
/*      SPRMCC (0x21e60290)                                                     */
/*      SPRUCC (0x21e60290)                                                     */
/* Register default value on SPRA0: 0x0000300B                                  */
/* Register default value on SPRB0: 0x0000300B                                  */
/* Register default value on SPRHBM: 0x0000300B                                 */
/* Register default value on SPRC0: 0x0000300B                                  */
/* Register default value on SPRMCC: 0x0000300B                                 */
/* Register default value on SPRUCC: 0x0000300B                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* CMI TID parity configuration
*/


#define CMITIDPARITYCHNLCONFIG_0_M2MEM_MAIN_REG 0x06020290

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 req_tid_parity_valid : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Request TID parity valid. Controls the
                               req_tid_parity_valid field on the CMI link which
                               indicates whether the req_tid_parity field
                               contains a valid value.
                            */
    UINT32 req_err_inj_seed : 10;

                            /* Bits[10:1], Access Type=RW, default=0x00000005*/

                            /*
                               Request TID parity error injection LFSR seed.
                               Must have at least one bit set in active width.
                            */
    UINT32 req_err_inj_width : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000006*/

                            /*
                               Request TID parity error injection LFSR width.
                               Must be between 5 and 10.
                            */
    UINT32 req_err_inj_one_shot : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Request TID parity error injection one-shot
                               mode. Only one error will be injected. After an
                               error has been injected, the enable bit will
                               need to be cleared and set again for another
                               error to be injected
                            */
    UINT32 req_config_done : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Request TID parity error injection LFSR config
                               done
                            */
    UINT32 random_req_err_inj_enable : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Random TID parity error injection enable for
                               requests
                            */
    UINT32 force_req_err_inj : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Force TID parity error injection on requests.
                               Parity errors will be injected while this bit is
                               set.
                            */
    UINT32 rsvd : 13;

                            /* Bits[31:19], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMITIDPARITYCHNLCONFIG_0_M2MEM_MAIN_STRUCT;

/* CMITIDPARITYCHNLCONFIG_1_M2MEM_MAIN_REG supported on:                        */
/*      SPRA0 (0x21e60294)                                                      */
/*      SPRB0 (0x21e60294)                                                      */
/*      SPRHBM (0x21e60294)                                                     */
/*      SPRC0 (0x21e60294)                                                      */
/*      SPRMCC (0x21e60294)                                                     */
/*      SPRUCC (0x21e60294)                                                     */
/* Register default value on SPRA0: 0x0000300B                                  */
/* Register default value on SPRB0: 0x0000300B                                  */
/* Register default value on SPRHBM: 0x0000300B                                 */
/* Register default value on SPRC0: 0x0000300B                                  */
/* Register default value on SPRMCC: 0x0000300B                                 */
/* Register default value on SPRUCC: 0x0000300B                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* CMI TID parity configuration
*/


#define CMITIDPARITYCHNLCONFIG_1_M2MEM_MAIN_REG 0x06020294

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 req_tid_parity_valid : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Request TID parity valid. Controls the
                               req_tid_parity_valid field on the CMI link which
                               indicates whether the req_tid_parity field
                               contains a valid value.
                            */
    UINT32 req_err_inj_seed : 10;

                            /* Bits[10:1], Access Type=RW, default=0x00000005*/

                            /*
                               Request TID parity error injection LFSR seed.
                               Must have at least one bit set in active width.
                            */
    UINT32 req_err_inj_width : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000006*/

                            /*
                               Request TID parity error injection LFSR width.
                               Must be between 5 and 10.
                            */
    UINT32 req_err_inj_one_shot : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Request TID parity error injection one-shot
                               mode. Only one error will be injected. After an
                               error has been injected, the enable bit will
                               need to be cleared and set again for another
                               error to be injected
                            */
    UINT32 req_config_done : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Request TID parity error injection LFSR config
                               done
                            */
    UINT32 random_req_err_inj_enable : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Random TID parity error injection enable for
                               requests
                            */
    UINT32 force_req_err_inj : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Force TID parity error injection on requests.
                               Parity errors will be injected while this bit is
                               set.
                            */
    UINT32 rsvd : 13;

                            /* Bits[31:19], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMITIDPARITYCHNLCONFIG_1_M2MEM_MAIN_STRUCT;

/* CMIMISCCONFIG_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e602a4)                                                      */
/*      SPRB0 (0x21e602a4)                                                      */
/*      SPRHBM (0x21e602a4)                                                     */
/*      SPRC0 (0x21e602a4)                                                      */
/*      SPRMCC (0x21e602a4)                                                     */
/*      SPRUCC (0x21e602a4)                                                     */
/* Register default value on SPRA0: 0x000000C0                                  */
/* Register default value on SPRB0: 0x000000C0                                  */
/* Register default value on SPRHBM: 0x000000C0                                 */
/* Register default value on SPRC0: 0x000000C0                                  */
/* Register default value on SPRMCC: 0x000000C0                                 */
/* Register default value on SPRUCC: 0x000000C0                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* CMI miscellaneous configuration
*/


#define CMIMISCCONFIG_M2MEM_MAIN_REG 0x060202A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 chnl0_credit_config_done : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Channel 0 credit config done */
    UINT32 chnl1_credit_config_done : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Channel 1 credit config done */
    UINT32 chnl0_credits_initialized : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /* Channel 0 credits initialized */
    UINT32 chnl1_credits_initialized : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /* Channel 1 credits initialized */
    UINT32 chnl0_idle_req_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Channel 0 normal ACTIVE->IDLE_REQ ISM transition
                               enabled
                            */
    UINT32 chnl1_idle_req_enable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Channel 1 normal ACTIVE->IDLE_REQ ISM transition
                               enabled
                            */
    UINT32 chnl0_force_active : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Channel 0 force IDLE->ACTIVE_REQ when possible
                               1: By default the link remains in active state.
                               will only go to idle if one of the idle_req is
                               pulled up (default) 0: If ingress goes idle link
                               will go to idle. (better for power. But
                               penalizes idle latency as initial bypass wont be
                               taken when the link is idle)
                            */
    UINT32 chnl1_force_active : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Channel 1 force IDLE->ACTIVE_REQ when possible
                               1: By default the link remains in active state.
                               will only go to idle if one of the idle_req is
                               pulled up (default) 0: If ingress goes idle link
                               will go to idle. (better for power. But
                               penalizes idle latency as initial bypass wont be
                               taken when the link is idle)
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RW, default=0x00000000*/

                            /* Reserved, but implemented, bits */

  } Bits;
  UINT32 Data;

} CMIMISCCONFIG_M2MEM_MAIN_STRUCT;

/* ERR_CNTR_M2MEM_MAIN_REG supported on:                                        */
/*      SPRA0 (0x21e602ac)                                                      */
/*      SPRB0 (0x21e602ac)                                                      */
/*      SPRHBM (0x21e602ac)                                                     */
/*      SPRC0 (0x21e602ac)                                                      */
/*      SPRMCC (0x21e602ac)                                                     */
/*      SPRUCC (0x21e602ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Exposes the M2M internal error counts as they get indirectly read through the ERR_CNTR_CTL CR.
      The ACntrNonZero and AThresholdReached are continuously kept up-to-date by hardware and do not 
      need to get read indirectly through the ERR_CNTR_CTL CR.

What we want to call out here specifically are the vastly differing interpretations of the MC DDR4 vs MC DDRT error counts for the transient/ecc-corrected types.
Note that on SNR, ICX, and later product generations, M2M has no notion of transient errors so any description regarding transient error counts do not apply.

Interpretation of the transient count: transient from an MC perspective, in that a retry (might be without even applying MC ECC) resulted in good data.
  DDR4: It implies a transient error e.g. most likely a link transient error. 
  DDRT: It might imply that the DDRT controller on the DDRT dimm fixed the data by ECC so in that case the DDRT controller itself might hold more accurate error information w.r.t. the DDRT storage devices.
Interpretation of the ECC corrected count: ECC in the MC was applied to correct the data.
  DDR4: Implies a persistent (stored or simple link) error because a retry without ECC didnt correct the error and ECC was needed to get correct the data.
  DDRT: Implies a (persistent and simple) link error because a simple retry to the DDRT controller did not correct the data (Note, the DDRT controller on the DDRT dimm would apply ECC internally, invisible to the MC).

      
*/


#define ERR_CNTR_M2MEM_MAIN_REG 0x060202AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntrchnl0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Chnl0 count associated with
                               ERR_CNTR_CTL.CntrIdx.
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cntrchnl1 : 6;

                            /* Bits[13:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Chnl1 count associated with
                               ERR_CNTR_CTL.CntrIdx.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cntrchnl2 : 6;

                            /* Bits[21:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Chnl2 count associated with
                               ERR_CNTR_CTL.CntrIdx.
                            */
    UINT32 rsvd_22 : 8;

                            /* Bits[29:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 acntrnonzero : 1;

                            /* Bits[30:30], Access Type=RW/V, default=0x00000000*/

                            /*
                               At least one of the M2M internal error counters
                               is non-zero. This field is continuously updated
                               by hardware. Clear by writing a 1 to
                               ERR_CNTR_CTL.ClrCntrs.
                            */
    UINT32 athresholdreached : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /*
                               At least one of the M2M internal error counters
                               hit the threshold 1<<ERR_CNTR_CTL.ThresholdLog2.
                               Clear by writing a 1 to ERR_CNTR_CTL.ClrCntrs.
                            */

  } Bits;
  UINT32 Data;

} ERR_CNTR_M2MEM_MAIN_STRUCT;

/* ERR_CNTR_CTL_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e602b0)                                                      */
/*      SPRB0 (0x21e602b0)                                                      */
/*      SPRHBM (0x21e602b0)                                                     */
/*      SPRC0 (0x21e602b0)                                                      */
/*      SPRMCC (0x21e602b0)                                                     */
/*      SPRUCC (0x21e602b0)                                                     */
/* Register default value on SPRA0: 0x00001401                                  */
/* Register default value on SPRB0: 0x00001401                                  */
/* Register default value on SPRHBM: 0x00001401                                 */
/* Register default value on SPRC0: 0x00001401                                  */
/* Register default value on SPRMCC: 0x00001401                                 */
/* Register default value on SPRUCC: 0x00001401                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      Saturating error counters (6b) in the M2M, track the number of transactions which had a memory controller error.
      A transaction in this context is an SMI3 transaction from the mesh (NOT commands to iMC). So even if multiple 
      retries are sent to the memory controller, the retried commands to the iMC are not counted individually.
      Note that on SNR, ICX, and later product generations, M2M has no notion of transient errors nor errors corrected by ECC, so any description regarding 
      transient/ECC corrected error counts do not apply.

      This control register allows indirect access to these M2M txn error counters: Reading the counters of a particular 
      error type, or clearing all the counters. ERR_CNTR_CTL.CntrIdx maps to following error types:
        DDR4_CHNLS_LINK_TRANSIENT_ERR_CNTR  = 0;
        DDR4_CHNLS_ECC_CORRECTED_ERR_CNTR   = 1;
        DDR4_CHNLS_UNCORRECTABLE_ERR_CNTR   = 2;
        DDRT_CHNLS_LINK_TRANSIENT_ERR_CNTR  = 3;
        DDRT_CHNLS_ECC_CORRECTED_ERR_CNTR   = 4;
        DDRT_CHNLS_UNCORRECTABLE_ERR_CNTR   = 5;
        CHNLS_PRI_MIRRSCRUBRD_NOERR_CNTR    = 6;
        CHNLS_SEC_MIRRSCRUBRD_NOERR_CNTR    = 7;
        CHNLS_PRI_MIRRSCRUBRD_ERR_CNTR      = 8;
        CHNLS_SEC_MIRRSCRUBRD_ERR_CNTR      = 9;
      When performing a mirror scrub read, it can either return with (uncorrectable) error or no/corrected error and 
      hence will be counted as either a MIRRSCRUBRD_NOERR or MIRRSCRUBRD_ERR type. 
      Whatever led to the mirror scrub will also be counted as either LINK_TRANSIENT, ECC_CORRECTED or UNCORRECTABLE type.
      Because our mirroring implementation goes to the mirrored channel and gets the data from that channel (to minimize 
      the probability for miscorrections) even on an ECC correctable error, the ECC_CORRECTED type needs to be interpreted 
      as an ecc correctable type (as long as channel not failed over yet).

      A typical usage model would be for BIOS, on an SMI, to read the ERR_CNTR.ACntrNonZero or the ERR_CNTR.AThresholdReached 
      CR bit and when e.g. the AThresholdReached bit is set then use ERR_CNTR_CTL to read all the counters and add them to 
      BIOS internal cumulative (possibly leaky) error counts. Once that is done, BIOS clears all the counters.

      BIOS can use these counters to gauge the health of the DDR4/DDRT-link, or the DDR4 DRAM. Especially under mirroring 
      when BIOS takes on the responsibility of the primary/secondary-swap versus failover decision, the mirror scrub counters
      become relevant to determine when a link is dead or very unreliable and hence a failover should be forced.

      Note, to determine which DDR4 dimm or rank is problematic, the iMC rank error counters should be consulted.
      Similarly, to determine DDRT ECC errors, CRs need to be consulted. DDRT_ECC_CORRECTED error type in the M2M 
      only provides information w.r.t. the DDRT bus health.
      
*/


#define ERR_CNTR_CTL_M2MEM_MAIN_REG 0x060202B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntena : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Enable counting by all the M2M internal error
                               counters.
                            */
    UINT32 clrcntrs : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               When written with a 1, will clear all the M2M
                               internal error counters. M2M hardware will
                               automatically clear this bit a cycle after it is
                               written.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cntridx : 4;

                            /* Bits[6:3], Access Type=RW, default=0x00000000*/

                            /* Index of the counter type to read. */
    UINT32 rsvd_7 : 2;

                            /* Bits[8:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 smionthreshold : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Signal an SMI when the
                               ERR_CNTR.AThresholdReached bit gets set by
                               hardware.
                            */
    UINT32 thresholdlog2 : 3;

                            /* Bits[12:10], Access Type=RW/V, default=0x00000005*/

                            /*
                               1<<ThresholdLog2 defines the internal threshold
                               2ThresholdLog2 at which the
                               ERR_CNTR.AThresholdReached bit will be set, if
                               at least one of the internal counters reaches
                               this threshold. The threshold is per error type
                               and writing/reading the threshold is through
                               indirect access through ThresholdRd, ThresholdWr
                               and ThresholdIdx field. When ThresholdWr=1 then
                               this ThesholdLog2 value will get written to the
                               internal threshold. When ThresholdRd=1 then this
                               ThresholdLog2 will contain the value read from
                               the internal ThresholdLog2 bits. On cold reset,
                               the internal ThresholdLog2 get set to 5.
                            */
    UINT32 thresholdidx : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               Index of the internal ThresholdLog2 type to
                               read/write: 0=RSVD 1=ECC_CORRECTED_ERR_TYPE,
                               =>also includes corrected by
                               mirror/nmcachecheckflow
                               2=UNCORRECTABLE_ERR_TYPE,
                               3=MIRRSCRUBRD_NOERR_TYPE, 4=MIRRSCRUBRD_ERR_TYPE
                            */
    UINT32 thresholdwr : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write the internal ThresdholdLog2 value for
                               error type specified by ThresholdIdx, with the
                               value specified by the ThresholdLog2 field of
                               this register. This bit will automatically reset
                               a cycle after it gets set.
                            */
    UINT32 thresholdrd : 1;

                            /* Bits[17:17], Access Type=RW/V, default=0x00000000*/

                            /*
                               Read the internal ThresdholdLog2 value for error
                               type specified by ThresholdIdx, and store the
                               result in the ThresholdLog2 field of this
                               register. This bit will automatically reset a
                               cycle after it gets set.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reservedforeco : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Reserved for future usage up to and including
                               possible ECO.
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERR_CNTR_CTL_M2MEM_MAIN_STRUCT;


/* DEFEATURES0_M2MEM_MAIN_REG supported on:                                     */
/*      SPRA0 (0x21e602c0)                                                      */
/*      SPRB0 (0x21e602c0)                                                      */
/*      SPRHBM (0x21e602c0)                                                     */
/*      SPRC0 (0x21e602c0)                                                      */
/*      SPRMCC (0x21e602c0)                                                     */
/*      SPRUCC (0x21e602c0)                                                     */
/* Register default value on SPRA0: 0xFFC80800                                  */
/* Register default value on SPRB0: 0xFFC80800                                  */
/* Register default value on SPRHBM: 0xFFC80800                                 */
/* Register default value on SPRC0: 0xFFC80800                                  */
/* Register default value on SPRMCC: 0xFFC80800                                 */
/* Register default value on SPRUCC: 0xFFC80800                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      This register contains m2m BIOS visible defeatures which are useful for system debug.
      
*/


#define DEFEATURES0_M2MEM_MAIN_REG 0x060202C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 discritchunk : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable DDR4 critical data chunk return
                               (DisCritChunk): 0: critical chunk return
                               enabled. 1: disable critical chunk return. When
                               critical chunk return is enabled, address[5]
                               indicates which 32B half cache line to return
                               first. Critical chunk can only be returned from
                               DDR4, when not enabled as NMC. BIOS has to
                               disable critical chunk return if NMC enabled on
                               the m2m. It is illegal to enable critical chunk
                               return when NMC is enabled on that m2m.
                            */
    UINT32 wait4bothhalves : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Wait for both Halves (Wait4BothHalves): Wait for
                               error indication on 2nd half of the cache line
                               before sending out the first half. 0: Send 1st
                               cache line half to the mesh as soon as it
                               arrives from MC (default). 1: Hold on to 1st
                               cache line half and wait for 2nd half of cache
                               line. Some of the MC ECC schemes only provide an
                               error indication on the 2nd half of the cache
                               line. In that case need to set this bit to 1.
                               Not doing so is illegal. If NMC enabled then
                               need to set this bit to 1.
                            */
    UINT32 ingbypdis : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Ingress Bypass Disable (IngBypDis): CHA/Mesh
                               read requests to DDR4 can bypass the m2m ingress
                               if all m2m ingressQs to that DDR4 channel are
                               empty. 0: Enable ingress bypass (default). 1:
                               Disable DDR4 ingress bypass (debug).
                            */
    UINT32 egrbypdis : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Egress Bypass Disable (EgrBypDis): DDR4 data to
                               mesh can bypass the m2m egress if the egressQs
                               are empty. 0: Enable egress bypass (default). 1:
                               Disable egress bypass (debug).
                            */
    UINT32 wciloptdis : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wcil optimization Disable (WcilOptDis): Wcil
                               optimization was not supported in the SKX
                               product (because not validated by CHA). Wcil
                               optimization is supported on 10nm. The reset
                               value in 10nm is 0 (Wcil optimization is
                               enabled) Wcil optimization consists of dropping
                               the MemInvXtoI memory tag/dir NM update (in case
                               of a NM miss except when victim dir=A) and not
                               reading data from FM. 0: Drop NM tag/dir wr on
                               NM miss (defeature). 1: Follow normal NM miss
                               flow (default).
                            */
    UINT32 d2k4cisgrdis : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable D2K returns for cisgress requests
                               (D2k4CisgrDis): In cross-tile 2LM flows, on an
                               NM miss, when fill data returns from the FM tile
                               the NM tile can attempt to perform D2K return.
                               Setting this bit disables that and NM tile will
                               only attempt to perform D2K on NM hits or 1LM
                               transactions. Note that this bit only takes
                               effect if Mode[NMCMode]=0x1 and
                               Sysfeatures0[D2kDisable]=0x0. 0: Enable D2K
                               returns for cisgress (default). 1: Disable D2K
                               returns for cisgress (debug).
                            */
    UINT32 wrcmpfromnm : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               In Xtile flows if WRNI miss is seen the FMWR4NM
                               is issued to the other tile There on a
                               completion can be either sent by NM or FM can
                               generate two completions(one to NM and one to
                               FM) 1: WrCmp is sent by NM to CHA 0: WrCmp is
                               sent by FM to NM and FM to CHA
                            */
    UINT32 earlywrcmp : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               For All SB allocating writes send earlycmp 1:
                               WrCmp is sent early 0: WrCmp is sent on late
                               completion
                            */
    UINT32 nmcleandis : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 2LM Directory Optimization is enabled
                               (SysFeatures0[Enable2LMDirOpt]), set this bit to
                               disable the NM clean flow where M2M indicates to
                               CHA that the data in NM is unmodified, and
                               subsequently CHA can send directory only writes
                               to M2M, which keep the NM line in CLEAN state.
                               1: NMClean flow is disabled, all writes to NM
                               from CHA will move the NM cachestate to DIRTY 0:
                               NMClean flow is enabled, directory only writes
                               from CHA do not move the NM cachestate to DIRTY
                            */
    UINT32 wrni4memwrdironly : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When 2LM Directory Optimization is enabled
                               (SysFeatures0[Enable2LMDirOpt]) with the NMClean
                               flow, CHA can send directory only writes to M2M
                               (i.e. MemWrDirOnly), which keep the NM line in
                               CLEAN state. Set this bit to 0x1 to force all
                               directory only writes from CHA to be WrNI. This
                               is intended only as a debug mode since all
                               directory only writes are expected to be
                               inclusive in the NM cache 1: Force all directory
                               only writes from CHA to be WrNI 0: Directory
                               only writes from CHA are assumed to be inclusive
                               and NM cachestate will not first be checked
                               prior to issuing the write
                            */
    UINT32 rsvd : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 akccredonbothports : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               1: Use both ADD port 1 and port 0 for AKC 0: Use
                               ADD port 0 only for AKC
                            */
    UINT32 pfdeallocondirupd : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               1: Use dirupd to deallocate pfcam in 1lm 0: Use
                               CMS data message to CHA to deallocate pfcam in
                               1lm Possible values:(cr_mm_2lm_enb ==0 |
                               xtile_nm==1): PfDeallocDirUpd can be 0 or 1
                               (cr_mm_2lm_enb ==1) and partial caching(aka
                               1lmprefetch + 2lm prefetch): PfDeallocDirUpd = 0
                               (cr_mm_2lm_enb ==1) and full caching(aka only
                               2lm prefetch): PfDeallocDirUpd can be 0 or 1
                            */
    UINT32 remsktspecrdcritchunkdissquash : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable squashing of the Critical Chunk bit
                               (Addr[5]) on remote socket speculative reads
                               (ie. prefetches from UPI).
                            */
    UINT32 remsktdmdrdcritchunkdissquash : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable squashing of the Critical Chunk bit
                               (Addr[5]) on remote socket demand reads (ie.
                               demand reads from local CHA on behalf of a UPI
                               read request).
                            */
    UINT32 spare : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* Spare bit for ECO use. */
    UINT32 allowdirupdtoblock : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               1: Allow directory updates to the block region
                               (including PAD). 0: Do not allow directory
                               updates to the block region (including PAD).
                               Consequently, all block region accesses will be
                               treated as DIR=SNPALL, and thus, D2C/D2K will be
                               also be prevented from occuring for such reads.
                               Must be set consistently with
                               mc_2lmcntl.SbDefeatures.AllowDirUpdToBlock.
                               NOTE: In single socket configs, if
                               SysFeatures0.AkEarlyCmpEn is set to 0x1, then
                               AllowDirUpdToBlock should also be set to 0x1.
                               Since directory updates do not occur in single
                               socket, setting this will have no effect on
                               directory, however, SysFeatures0.AkEarlyCmpEn
                               relies on D2C to occur so AllowDirUpdToBlock
                               needs to be set to prevent D2C from getting
                               squashed.
                            */
    UINT32 diswrflush : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               1: Do not convert writes to the PAD region to
                               MemWrFlush, returning a cmp as soon as the write
                               posts to MC. 0: Convert writes to the PAD region
                               to MemWrFlush, so that they do not return a cmp
                               until prior writes are issued Disable Pcommit ->
                               Diswrflush = 1 DDRT only config and pcommit ->
                               DisWrFlush = 0 DisDDRWrFlush = 1 BlockExists=1
                               DDR4 only config and pcommit -> DisWrFlush = 0
                               DisDDRWrFlush = 0 BlockExists=0 DDR4+DDRt
                               configs and DDRT only pcommit->DisWrFlush = 0
                               DisDDRWrFlush=1 BlockExists=1 DDR4+DDRt configs
                               and DDR4 only pcommit->DisWrFlush = 0
                               DisDDRWrFlush=0 BlockExists=0 While last configs
                               redirect ddr4 address pcommits to ddrt and
                               viceversa, to specifically target ddr4/ddrt
                               flush use addr[7]
                            */
    UINT32 diswarmresetquiesce : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               1: Do not block ingress on Warm reset 0: Block
                               igress to allow quiesce on warm reset
                            */
    UINT32 disddrwrflush : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               1: Ignore address bit 7 and issue MemWrFlush to
                               ddrt 0: If address bit 7 is 0 issue memwrflush
                               to ddr4 otherwise issue to ddrt
                            */
    UINT32 demandscrubwrdis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Demand Scrub Disable (DemandScrubWrDis): -- Not
                               applicable to SNR/ICX Disable demand scrub write
                               on a read error. Note that explicit writes or
                               directory writes will still happen. 0: Demand
                               scrub writes enabled (default). 1: Demand scrub
                               writes disabled (debug). On a demand scrub
                               write, in case of a correctable error, the
                               corrected data will be written back to memory,
                               and in case of an uncorrectable error, a poison
                               indication will be written to memory (no matter
                               what the system poison mode setting is). This
                               disable gets only honored in 1LM DDR4 mode, as
                               soon as for example DDRT or 2LM are enabled this
                               defeature will not be honored.
                            */
    UINT32 scrubcheckrddis : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Scrub Check Read Disable (ScrubCheckRdDis):
                               Disable scrub check read: 0: Scrub check read
                               enabled (default). 1: Scrub check read disabled
                               (debug). After a scrub write, the default flow
                               is to perform a check read to determine that the
                               scrub write was successful. This is relevant in
                               the context of mirroring. During mirroring
                               (before failover), on an uncorrectable/poison on
                               channel A, the data will be read from the mirror
                               channel B and written back to both channels. The
                               mirror scrub has to write the good data read
                               from channel B to the erroneous channel A and
                               then read it back from channel A to check that
                               the data is no longer uncorrectable. In case the
                               data is still uncorrectable, as determined by
                               the check read, a (permanent) failover to
                               channel B might take place and channel A, which
                               has the persistently uncorrectable error, will
                               no longer be accessible.
                            */
    UINT32 usecmiidleforpkgc : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               If pma signal for pkgc entry is asserted ; 1:
                               assert idle_req and wait for cmi to go idle +
                               mcdrained. this implies mee drained 0: do not
                               assert idle_req and declare Idle on mcdrained +
                               all vc credits back to init. This does not cover
                               Dedup drained and is a fail-safe and not a por
                            */
    UINT32 useemptyforcmiidle : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               IF 1 Request idle only when m2mem is empty If 0
                               Request idle when ingress is idle In 2LM mode,
                               this bit must be set to 1 NOTE: Value of 1 has
                               power implications as it delays cmi idle
                               behavior.
                            */
    UINT32 pedowngradethresh : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000FF*/

                            /*
                               If RPQ proxy occupancy is less than threshold
                               dont suppress priority encoding
                            */

  } Bits;
  UINT32 Data;

} DEFEATURES0_M2MEM_MAIN_STRUCT;

/* DEFEATURES1_M2MEM_MAIN_REG supported on:                                     */
/*      SPRA0 (0x21e602c4)                                                      */
/*      SPRB0 (0x21e602c4)                                                      */
/*      SPRHBM (0x21e602c4)                                                     */
/*      SPRC0 (0x21e602c4)                                                      */
/*      SPRMCC (0x21e602c4)                                                     */
/*      SPRUCC (0x21e602c4)                                                     */
/* Register default value on SPRA0: 0x00004502                                  */
/* Register default value on SPRB0: 0x00004502                                  */
/* Register default value on SPRHBM: 0x00004502                                 */
/* Register default value on SPRC0: 0x00004502                                  */
/* Register default value on SPRMCC: 0x00004502                                 */
/* Register default value on SPRUCC: 0x00004502                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      This register contains m2m BIOS visible defeatures which are useful for system debug.
      
*/


#define DEFEATURES1_M2MEM_MAIN_REG 0x060202C4

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 disingbypwindowmaximization : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable AD ingress bypass window maximization:
                               By default, M2M blocks BL ingressQ an extra 15
                               cycles when it goes from empty to a BL txn being
                               pushed onto BL ingressQ. This increases the
                               window during which AD ingress bypass can be
                               taken (can only be taken when BL does not arb).
                               1: Disable block of BL ingress (on BL txn that
                               comes in into an empty BL ingress). 0: An empty
                               BL ingress gets blocked 15 cycles (from arbing
                               to CMI) after a BL txn comes in (default).
                            */
    UINT32 add1fuseflatmode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               How to decode Fuse to Add1Lut 1: Flat mode
                               (default): Fuse is directly dumped to Add1Lut.
                               This means irrespective of fuse name the
                               following concatenation:
                               {fuse_addr1_kti,fuse_addr1_trg,fuse_add1_cha}
                               should be indexed based on stopid 0: Partitioned
                               mode (not supported on SNR/ICX): Fuse is
                               directly dumped to Add1Lut. But its decoded as
                               the fuse was intended fuse_add1_cha[i] is add1
                               for cha with meshstop as i (assumes chaids are
                               from 0 to 44) if FmcTile: fuse_add1_trg[i] is
                               add1 for NMC[i] with meshstop of NMC[i]
                               programmed in Credits reg. if Nmctile:
                               fuse_add1_trg[i] is add1 for FMC[i] with
                               meshstop of Fmc0 and Fmc1 programmed in
                               MeshStopID reg. fuse_add1_kti[i] is add1 for
                               KTI[i] programmed in MeshStopId2KTI reg. getting
                               the data from Far-Memory in case of clean NM
                               cache state, or by poisoning the data in case of
                               modified NM cache state (default).
                            */
    UINT32 uconnmcacherducdata : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Go fatal/recov for uncorrectable from Near-
                               Memory Cache read (UcOnNmCacheRdUcData): 1: In
                               case of Near-Memory uncorrectable error, go
                               fatal/recov(depending on
                               IgnorePoisonOnNmCacheUcData). 0: If Near-Memory
                               data-only uncorrectable error then try to
                               recover from that by either getting the data
                               from Far-Memory in case of clean NM cache state,
                               or by poisoning the data in case of modified NM
                               cache state (default).
                            */
    UINT32 singlegrant : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               On a given cycle issue only one grant 1: One
                               grant 0: Two grants
                            */
    UINT32 rsvd : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrtmirrscrubwrdis : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable mirror scrub write to DDRT
                               (DdrtMirrScrubWrDis): 1: Dont scrub write the
                               corrected data back to the bad channel. Hence
                               stored data still stays bad on that channel till
                               a write comes back from CHA. 0: Scrub write the
                               corrected data back to the bad channel and then
                               perform a scrub check read to determine whether
                               corrected data is now correct as stored on the
                               previously bad channel (default).
                            */
    UINT32 skipbadchnlforrd : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Skip bad mirror channel read/meminv retries
                               (SkipBadChnl): 1: Skip the bad channel retry=1
                               state in the mirror error FSM. 0: Do take the
                               bad channel retry=1 state after the good channel
                               states in the mirror error FSM (default). For
                               non-mirror regions, this register setting will
                               have no effect. BadChnlFirstForRd==1 takes
                               priority over this bit.
                            */
    UINT32 blockdeallocforearlycmp : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               This register dictates when a SB retry entry
                               deallocates (only functionally required for
                               EarlyCmp mode): 1: SB entry deallocates only
                               when everything has drained. This guarantees any
                               inflight wr that can conflict will be rejected
                               0: SB entry deallocates as soon as error is seen
                               (could possibly cause a race case between an
                               inflight wr and Sb deallocate if the wr is stuck
                               in CMI when the CMI stall for stop/stopack
                               mechanism is in use)
                            */
    UINT32 fmtileforkedreturn : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set FMtile returns the data to
                               CHA instead for 2lm fillrd data returns
                            */
    UINT32 ignorepoisononnmcacheucdata : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Go fatal for nmcacheucdata 1: In case of Near-
                               Memory uncorrectable error, go fatal 0: If 0
                               means PCC will be based poison Is ignored if
                               UcOnNmCacheRdUcData is not set
                            */
    UINT32 cfgfailoveronscrubchkrdcorr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set allow failover on every scrub read
                               following a scrub write. Has to be set with
                               CfgImmediateFailoverActionEna to allow failover
                            */
    UINT32 npmirrwrite : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               0: For Non-posted Mirrored writes, ignore the
                               CMI compliant Non-posted write flows 1: For Non-
                               posted Mirrored writes, follow the CMI compliant
                               Non-posted write flows Default value should be 0
                               for performance. The setting of 0 enables M2M to
                               complete non-posted mirrored write transactions
                               more quickly
                            */
    UINT32 earlycmpwarfixen : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               0: EarlyCmpWAR fix is not enabled 1. Enabled
                               Default value is 0. Enable this if required for
                               WAR hazard protection when EarlyCmp is enabled
                            */
    UINT32 twoearlycmpsamecycle : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Allow allocation of two early cmps on same
                               cycle(prefetch and non prefetch)
                            */
    UINT32 splitallocearlycmpsamecycle : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Allow allocation of two early cmps on same cycle
                               vbut with split resource. Look at entries
                               available in AkEarlyPfMerge reg
                            */
    UINT32 ingeco : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Ingress ECO defeatures (IngEco): 8 configuration
                               bits reserved for ingress ECOs.
                            */
    UINT32 egreco : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Egress ECO defeatures (EgrEco): 8 configuration
                               bits reserved for egress ECOs.
                            */

  } Bits;
  UINT32 Data;

} DEFEATURES1_M2MEM_MAIN_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 disingbypwindowmaximization : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable AD ingress bypass window maximization:
                               By default, M2M blocks BL ingressQ an extra 15
                               cycles when it goes from empty to a BL txn being
                               pushed onto BL ingressQ. This increases the
                               window during which AD ingress bypass can be
                               taken (can only be taken when BL does not arb).
                               1: Disable block of BL ingress (on BL txn that
                               comes in into an empty BL ingress). 0: An empty
                               BL ingress gets blocked 15 cycles (from arbing
                               to CMI) after a BL txn comes in (default).
                            */
    UINT32 add1fuseflatmode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               How to decode Fuse to Add1Lut 1: Flat mode
                               (default): Fuse is directly dumped to Add1Lut.
                               This means irrespective of fuse name the
                               following concatenation:
                               {fuse_addr1_kti,fuse_addr1_trg,fuse_add1_cha}
                               should be indexed based on stopid 0: Partitioned
                               mode (not supported on SNR/ICX): Fuse is
                               directly dumped to Add1Lut. But its decoded as
                               the fuse was intended fuse_add1_cha[i] is add1
                               for cha with meshstop as i (assumes chaids are
                               from 0 to 44) if FmcTile: fuse_add1_trg[i] is
                               add1 for NMC[i] with meshstop of NMC[i]
                               programmed in Credits reg. if Nmctile:
                               fuse_add1_trg[i] is add1 for FMC[i] with
                               meshstop of Fmc0 and Fmc1 programmed in
                               MeshStopID reg. fuse_add1_kti[i] is add1 for
                               KTI[i] programmed in MeshStopId2KTI reg. getting
                               the data from Far-Memory in case of clean NM
                               cache state, or by poisoning the data in case of
                               modified NM cache state (default).
                            */
    UINT32 uconnmcacherducdata : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Go fatal/recov for uncorrectable from Near-
                               Memory Cache read (UcOnNmCacheRdUcData): 1: In
                               case of Near-Memory uncorrectable error, go
                               fatal/recov(depending on
                               IgnorePoisonOnNmCacheUcData). 0: If Near-Memory
                               data-only uncorrectable error then try to
                               recover from that by either getting the data
                               from Far-Memory in case of clean NM cache state,
                               or by poisoning the data in case of modified NM
                               cache state (default).
                            */
    UINT32 singlegrant : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               On a given cycle issue only one grant 1: One
                               grant 0: Two grants
                            */
    UINT32 rsvd : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrtmirrscrubwrdis : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable mirror scrub write to DDRT
                               (DdrtMirrScrubWrDis): 1: Dont scrub write the
                               corrected data back to the bad channel. Hence
                               stored data still stays bad on that channel till
                               a write comes back from CHA. 0: Scrub write the
                               corrected data back to the bad channel and then
                               perform a scrub check read to determine whether
                               corrected data is now correct as stored on the
                               previously bad channel (default).
                            */
    UINT32 skipbadchnlforrd : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Skip bad mirror channel read/meminv retries
                               (SkipBadChnl): 1: Skip the bad channel retry=1
                               state in the mirror error FSM. 0: Do take the
                               bad channel retry=1 state after the good channel
                               states in the mirror error FSM (default). For
                               non-mirror regions, this register setting will
                               have no effect. BadChnlFirstForRd==1 takes
                               priority over this bit.
                            */
    UINT32 blockdeallocforearlycmp : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               This register dictates when a SB retry entry
                               deallocates (only functionally required for
                               EarlyCmp mode): 1: SB entry deallocates only
                               when everything has drained. This guarantees any
                               inflight wr that can conflict will be rejected
                               0: SB entry deallocates as soon as error is seen
                               (could possibly cause a race case between an
                               inflight wr and Sb deallocate if the wr is stuck
                               in CMI when the CMI stall for stop/stopack
                               mechanism is in use)
                            */
    UINT32 fmtileforkedreturn : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set FMtile returns the data to
                               CHA instead for 2lm fillrd data returns
                            */
    UINT32 ignorepoisononnmcacheucdata : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Go fatal for nmcacheucdata 1: In case of Near-
                               Memory uncorrectable error, go fatal 0: If 0
                               means PCC will be based poison Is ignored if
                               UcOnNmCacheRdUcData is not set
                            */
    UINT32 cfgfailoveronscrubchkrdcorr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set allow failover on every scrub read
                               following a scrub write. Has to be set with
                               CfgImmediateFailoverActionEna to allow failover
                            */
    UINT32 npmirrwrite : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               0: For Non-posted Mirrored writes, ignore the
                               CMI compliant Non-posted write flows 1: For Non-
                               posted Mirrored writes, follow the CMI compliant
                               Non-posted write flows Default value should be 0
                               for performance. The setting of 0 enables M2M to
                               complete non-posted mirrored write transactions
                               more quickly
                            */
    UINT32 earlycmpwarfixen : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               0: EarlyCmpWAR fix is not enabled 1. Enabled
                               Default value is 0. Enable this if required for
                               WAR hazard protection when EarlyCmp is enabled
                            */
    UINT32 twoearlycmpsamecycle : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Allow allocation of two early cmps on same
                               cycle(prefetch and non prefetch)
                            */
    UINT32 splitallocearlycmpsamecycle : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Allow allocation of two early cmps on same cycle
                               vbut with split resource. Look at entries
                               available in AkEarlyPfMerge reg
                            */
    UINT32 ingeco : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Ingress ECO defeatures (IngEco): 8 configuration
                               bits reserved for ingress ECOs.
                            */
    UINT32 cisgrnmfillwrthreshold : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               In NM tile Mode in a 2LM cross-tile
                               configuration, this threshold represents the
                               maximum number of allowed NM fill write
                               transactions, generated by NM read miss, that
                               can consume the egress entries reserved for
                               Cisgress txns (as specified by
                               SysFeatures0.NumEgrEntries4Cisgr). Any number of
                               entries beyond this threshold will be reserved
                               for FM Writes generated by WRNIMisses. 0:
                               default - half of the Egress Entries reserved
                               for Cisgress are reserved for WRNIMisses n: 'n'
                               number of Egress Entries reserved for Cisgress
                               are allowed to be consumed by NM read misses,
                               the remaining are reserved for WrNIMisses. If
                               'n' is greater than
                               SysFeatures0.NumEgrEntries4Cisgr*2, then the
                               threshold is disabled and NM Fill Writes may
                               consume all of the Egress Entries reserved for
                               Cisgress.
                            */
    UINT32 egreco : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000000*/

                            /*
                               Egress ECO defeatures (EgrEco): 8 configuration
                               bits reserved for egress ECOs.
                            */

  } Bits;
  UINT32 Data;

} DEFEATURES1_M2MEM_MAIN_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 disingbypwindowmaximization : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable AD ingress bypass window maximization:
                               By default, M2M blocks BL ingressQ an extra 15
                               cycles when it goes from empty to a BL txn being
                               pushed onto BL ingressQ. This increases the
                               window during which AD ingress bypass can be
                               taken (can only be taken when BL does not arb).
                               1: Disable block of BL ingress (on BL txn that
                               comes in into an empty BL ingress). 0: An empty
                               BL ingress gets blocked 15 cycles (from arbing
                               to CMI) after a BL txn comes in (default).
                            */
    UINT32 add1fuseflatmode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               How to decode Fuse to Add1Lut 1: Flat mode
                               (default): Fuse is directly dumped to Add1Lut.
                               This means irrespective of fuse name the
                               following concatenation:
                               {fuse_addr1_kti,fuse_addr1_trg,fuse_add1_cha}
                               should be indexed based on stopid 0: Partitioned
                               mode (not supported on SNR/ICX): Fuse is
                               directly dumped to Add1Lut. But its decoded as
                               the fuse was intended fuse_add1_cha[i] is add1
                               for cha with meshstop as i (assumes chaids are
                               from 0 to 44) if FmcTile: fuse_add1_trg[i] is
                               add1 for NMC[i] with meshstop of NMC[i]
                               programmed in Credits reg. if Nmctile:
                               fuse_add1_trg[i] is add1 for FMC[i] with
                               meshstop of Fmc0 and Fmc1 programmed in
                               MeshStopID reg. fuse_add1_kti[i] is add1 for
                               KTI[i] programmed in MeshStopId2KTI reg. getting
                               the data from Far-Memory in case of clean NM
                               cache state, or by poisoning the data in case of
                               modified NM cache state (default).
                            */
    UINT32 uconnmcacherducdata : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Go fatal/recov for uncorrectable from Near-
                               Memory Cache read (UcOnNmCacheRdUcData): 1: In
                               case of Near-Memory uncorrectable error, go
                               fatal/recov(depending on
                               IgnorePoisonOnNmCacheUcData). 0: If Near-Memory
                               data-only uncorrectable error then try to
                               recover from that by either getting the data
                               from Far-Memory in case of clean NM cache state,
                               or by poisoning the data in case of modified NM
                               cache state (default).
                            */
    UINT32 singlegrant : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               On a given cycle issue only one grant 1: One
                               grant 0: Two grants
                            */
    UINT32 rsvd : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrtmirrscrubwrdis : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable mirror scrub write to DDRT
                               (DdrtMirrScrubWrDis): 1: Dont scrub write the
                               corrected data back to the bad channel. Hence
                               stored data still stays bad on that channel till
                               a write comes back from CHA. 0: Scrub write the
                               corrected data back to the bad channel and then
                               perform a scrub check read to determine whether
                               corrected data is now correct as stored on the
                               previously bad channel (default).
                            */
    UINT32 skipbadchnlforrd : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Skip bad mirror channel read/meminv retries
                               (SkipBadChnl): 1: Skip the bad channel retry=1
                               state in the mirror error FSM. 0: Do take the
                               bad channel retry=1 state after the good channel
                               states in the mirror error FSM (default). For
                               non-mirror regions, this register setting will
                               have no effect. BadChnlFirstForRd==1 takes
                               priority over this bit.
                            */
    UINT32 blockdeallocforearlycmp : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               This register dictates when a SB retry entry
                               deallocates (only functionally required for
                               EarlyCmp mode): 1: SB entry deallocates only
                               when everything has drained. This guarantees any
                               inflight wr that can conflict will be rejected
                               0: SB entry deallocates as soon as error is seen
                               (could possibly cause a race case between an
                               inflight wr and Sb deallocate if the wr is stuck
                               in CMI when the CMI stall for stop/stopack
                               mechanism is in use)
                            */
    UINT32 fmtileforkedreturn : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set FMtile returns the data to
                               CHA instead for 2lm fillrd data returns
                            */
    UINT32 ignorepoisononnmcacheucdata : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Go fatal for nmcacheucdata 1: In case of Near-
                               Memory uncorrectable error, go fatal 0: If 0
                               means PCC will be based poison Is ignored if
                               UcOnNmCacheRdUcData is not set
                            */
    UINT32 cfgfailoveronscrubchkrdcorr : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set allow failover on every scrub read
                               following a scrub write. Has to be set with
                               CfgImmediateFailoverActionEna to allow failover
                            */
    UINT32 npmirrwrite : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               0: For Non-posted Mirrored writes, ignore the
                               CMI compliant Non-posted write flows 1: For Non-
                               posted Mirrored writes, follow the CMI compliant
                               Non-posted write flows Default value should be 0
                               for performance. The setting of 0 enables M2M to
                               complete non-posted mirrored write transactions
                               more quickly
                            */
    UINT32 earlycmpwarfixen : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               0: EarlyCmpWAR fix is not enabled 1. Enabled
                               Default value is 0. Enable this if required for
                               WAR hazard protection when EarlyCmp is enabled
                            */
    UINT32 twoearlycmpsamecycle : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Allow allocation of two early cmps on same
                               cycle(prefetch and non prefetch)
                            */
    UINT32 splitallocearlycmpsamecycle : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Allow allocation of two early cmps on same cycle
                               vbut with split resource. Look at entries
                               available in AkEarlyPfMerge reg
                            */
    UINT32 ingeco : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Ingress ECO defeatures (IngEco): 8 configuration
                               bits reserved for ingress ECOs.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DEFEATURES1_M2MEM_MAIN_STRUCT;



/* M2MBIOSQUIESCE_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e602d4)                                                      */
/*      SPRB0 (0x21e602d4)                                                      */
/*      SPRHBM (0x21e602d4)                                                     */
/*      SPRC0 (0x21e602d4)                                                      */
/*      SPRMCC (0x21e602d4)                                                     */
/*      SPRUCC (0x21e602d4)                                                     */
/* Register default value on SPRA0: 0x00060040                                  */
/* Register default value on SPRB0: 0x00060040                                  */
/* Register default value on SPRHBM: 0x00060040                                 */
/* Register default value on SPRC0: 0x00060040                                  */
/* Register default value on SPRMCC: 0x00060040                                 */
/* Register default value on SPRUCC: 0x00060040                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      This register supports a Lite Quiesce, i.e. a local temporary quiesce of the Mesh2mem transactions to its connected memory controllers.

      The required usage sequence is a follows:
         1. BIOS writes ForceQuiesceM2m = 1,
         2. BIOS waits for IsQuiesced==1,
         3. BIOS executes whatever sequence of operations it needs to execute under this mesh2mem quiesce,
         4. BIOS writes ForceQuiesceM2m = 0.
      During all these steps, it is forbidden for BIOS to access memory (even for fetching code) as this could lead to deadlock.
      Also blocking for a very long time might lead to time-outs, so if a copious number of operations needs to be performed during step 3 then BIOS will have to time slice these operations and execute above sequence for each time slice.
      It should be noted that only mesh2mem traffic to its connected memory controllers gets blocked. Patrol scrubs, rank sparing and memory maintenance commands (e.g. refreshed, closing pages) can still take place during this quiesce as they originate in MC. The heads of the ingress queues get blocked so transactions can still enter mesh2mem ingress till ingress fills up (and prefetches from core/Intel UPI can enter prefetchCAM till it fills up).

      Typical usage model for this mechanism is when some feature needs to get dynamically switched on/off in M2M or MC. It will be used for ADDDC, +1 sparing and rank sparing flows.

      
*/


#define M2MBIOSQUIESCE_M2MEM_MAIN_REG 0x060202D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 forcequiescem2m : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Force Quiesce in Mesh2mem control bit
                               (ForceQuiesceM2m): 0: Do not quiesce M2m/Memory-
                               controllers (default). 1: Force quiesce of this
                               mesh2mem and its connected memory controllers.
                               Transactions from mesh2mem to its connected
                               memory controllers will get blocked in mesh2mem
                               till this bit is 0. Note, forcing quiesce for
                               too long a time continuously could result in
                               time-outs in the system (e.g. CHA time-outs or
                               core 3-strike). So if a copious amount of
                               operations are required during quiesce then BIOS
                               time-sliced quiescing might become necessary.
                            */
    UINT32 isquiesced : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Is Quiesced status bit (IsQuiesced0): 0: Quiesce
                               for this mesh2mem or its connected memory
                               controllers has not been reached yet. 1: Quiesce
                               for this mesh2mem and its connected memory
                               controllers has been reached. That means Egress,
                               Transgress, Score-boards, Read Pending Queues
                               and Write Pending Queues are empty. It should be
                               noted that only mesh2mem commands are being
                               blocked. So mc originating transactions like
                               patrol reads or rank sparing or dimm maintenance
                               traffic (e.g. refreshes) might still take place.
                            */
    UINT32 drainrttimer : 14;

                            /* Bits[15:2], Access Type=RW, default=0x00000010*/

                            /*
                               MC round-trip-fifo drainage time (DrainRTtimer):
                               Number of 32 TSVs (Time-Slot-Valids, i.e.
                               slowest clock of M2M/MC) to wait after MC
                               RPQ/WPQ and M2M transgress empty till asserting
                               IsQuiesced0. This to guarantee no in-flight
                               data/acks from the memory controller when
                               IsQuiesced0 gets signalled.
                            */
    UINT32 rsvd : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 usecmiidlefordrain : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               When set, this bit ensures waiting for CMI to go
                               idle before signaling quiesce. This is used in
                               conjunction with ForceQuiesce and
                               idle_req_enable for CMI. If this bit is not set
                               then M2M won't account for CMI idle, which means
                               it will not guarantee that all subsystems behind
                               CMI are drained. 0: Use only Memory controller
                               drained indication and M2M inflight txns=0 to
                               signal quiesce 1: Use CMI idle, Memory
                               controller drained indication, and M2M inflight
                               txns=0 to quiesce (default)
                            */
    UINT32 waitonclear : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               1: Wait on Clearing of FrcQuiesce bit to exit
                               Quiesce state. 0: As soon as quiesce is achieved
                               exit quiesce (SV only) Note: This bit applies
                               also to DfxQuiesce0 registers. DfxQuiesce1 uses
                               internally generated quiesce nad is always
                               waitonClear=1, DfxQuiesce 2 is locrsp so doesnt
                               follow waitonclear
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2MBIOSQUIESCE_M2MEM_MAIN_STRUCT;

/* M2MDFXQUIESCE_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e602d8)                                                      */
/*      SPRB0 (0x21e602d8)                                                      */
/*      SPRHBM (0x21e602d8)                                                     */
/*      SPRC0 (0x21e602d8)                                                      */
/*      SPRMCC (0x21e602d8)                                                     */
/*      SPRUCC (0x21e602d8)                                                     */
/* Register default value on SPRA0: 0x00100000                                  */
/* Register default value on SPRB0: 0x00100000                                  */
/* Register default value on SPRHBM: 0x00100000                                 */
/* Register default value on SPRC0: 0x00100000                                  */
/* Register default value on SPRMCC: 0x00100000                                 */
/* Register default value on SPRUCC: 0x00100000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      This register supports a Lite Quiesce, i.e. a local temporary quiesce of the Mesh2mem transactions to its connected memory controllers.

      Typical usage model for this mechanism is when some feature needs to get dynamically switched on/off, or to induce stress or to break a deadlock case.

      There are 3 independent groups of quiesce knobs available here (besides the BIOS knob in CSR M2mBiosQuiesce). The intention is that following usage model gets enforced:
        - Triple (ForceQuiesce1M2m, WaitForDrainTimer1, IsQuiesced1) is available for ucode/pcode (Intel reserved).
        - Triple (ForceQuiesce2M2m, WaitForDrainTimer2, IsQuiesced2) is available for DFD: e.g. volume exercising of defeatures/features/stress knobs (Intel reserved).
        - Triple (ForceQuiesceOnLocRspRise, WaitForDrainTimerWhenLocRspRise, IsQuiescedFromLocRsp) is available for local response control LocalRspCntlEgr0[FrcQuiesce (Intel reserved).

      ForceQuiesce will result in the M2M/MC interface getting quiesced and MC structures (RPQ/WPQ/Score-board/RT-fifo) getting drained. Once that happened and WaitForDrainTimer is set then DrainTimer TSVs (slowest(uncore-clk, mc-clk) pulses) need to be observed before IsQuiesced gets asserted. The M2M/MC interface will get blocked till ForceQuiesce becomes 0 again (except for the ForceQuiesceOnLocRspRise case).
      
*/


#define M2MDFXQUIESCE_M2MEM_MAIN_REG 0x060202D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 forcequiesce1m2m : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Force Quiesce in Mesh2mem control bit
                               (ForceQuiesce1M2m): 0: Do not quiesce
                               M2m/Memory-controllers (default). 1: Force
                               quiesce of this mesh2mem and its connected
                               memory controllers. Transactions from mesh2mem
                               to its connected memory controllers will get
                               blocked in mesh2mem till this bit is 0. Note,
                               forcing quiesce for too long a time continuously
                               could result in time-outs in the system (e.g.
                               CHA time-outs or core 3-strike). So if a copious
                               amount of operations are required during quiesce
                               then BIOS time-sliced quiescing might become
                               necessary.
                            */
    UINT32 waitfordraintimer1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Wait for drain timer (WaitForDrainTimer1): 0:
                               Dont wait for drain timer, declare IsQuiesed as
                               soon as drained. 1: After reaching drained
                               state, wait extra time specified by DrainTimer
                               before declaring IsQuiesced.
                            */
    UINT32 isquiesced1 : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Is Quiesced status bit (IsQuiesced1): 0: Quiesce
                               for this mesh2mem or its connected memory
                               controllers has not been reached yet. 1: Quiesce
                               for this mesh2mem and its connected memory
                               controllers has been reached. That means Egress,
                               Transgress, Score-boards, Read Pending Queues
                               and Write Pending Queues are empty. It should be
                               noted that only mesh2mem commands are being
                               blocked. So mc originating transactions like
                               patrol reads or rank sparing or dimm maintenance
                               traffic (e.g. refreshes) might still take place.
                               In case of WaitForDrainTimer1 set, after
                               draining, an extra time specified by DrainTimer
                               is enforced before asserting IsQuiesced1.
                            */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 forcequiesce2m2m : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Force Quiesce in Mesh2mem control bit
                               (ForceQuiesce2M2m) set by NoRetry logic for
                               patrol deadlock: 0: Do not quiesce M2m/Memory-
                               controllers (default). 1: Force quiesce of this
                               mesh2mem and its connected memory controllers.
                               Transactions from mesh2mem to its connected
                               memory controllers will get blocked in mesh2mem
                               till this bit is 0. Note, forcing quiesce for
                               too long a time continuously could result in
                               time-outs in the system (e.g. CHA time-outs or
                               core 3-strike). So if a copious amount of
                               operations are required during quiesce then BIOS
                               time-sliced quiescing might become necessary.
                            */
    UINT32 waitfordraintimer2 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Wait for drain timer (WaitForDrainTimer2): 0:
                               Dont wait for drain timer, declare IsQuiesed as
                               soon as drained. 1: After reaching drained
                               state, wait extra time specified by DrainTimer
                               before declaring IsQuiesced.
                            */
    UINT32 isquiesced2 : 1;

                            /* Bits[10:10], Access Type=RW/V, default=0x00000000*/

                            /*
                               Is Quiesced status bit (IsQuiesced2): 0: Quiesce
                               for this mesh2mem or its connected memory
                               controllers has not been reached yet. 1: Quiesce
                               for this mesh2mem and its connected memory
                               controllers has been reached. That means Egress,
                               Transgress, Score-boards, Read Pending Queues
                               and Write Pending Queues are empty. It should be
                               noted that only mesh2mem commands are being
                               blocked. So mc originating transactions like
                               patrol reads or rank sparing or dimm maintenance
                               traffic (e.g. refreshes) might still take place.
                               In case of WaitForDrainTimer2 set, after
                               draining, an extra time specified by DrainTimer
                               is enforced before asserting IsQuiesced2.
                            */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 forcequiesceonlocrsprise : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Force Quiesce in Mesh2mem on rising edge of
                               local response FrcQuiesce
                               (ForceQuiesceOnLocRspRise): 0: Use level of
                               FrcQuiesce local response signal to force
                               quiesce (default). 1: Use rising edge of
                               FrcQuiesce local response signal to force
                               quiesce (till IsQuiescedFromLocRsp asserts).
                               This bit only selects whether to look at signal
                               level or rising edge of signal. It will have no
                               effect as long as LocalRspCntlEgr0[FrcQuiesce]
                               is not set.
                            */
    UINT32 waitfordraintimerwhenlocrsprise : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Wait for drain timer
                               (WaitForDrainTimerWhenLocRspRise): 0: Dont wait
                               for drain timer, declare IsQuiesed as soon as
                               drained. 1: After reaching drained state, wait
                               extra time specified by DrainTimer before
                               declaring IsQuiesced.
                            */
    UINT32 isquiescedfromlocrsp : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Is Quiesced status bit (IsQuiescedFromLocRsp):
                               0: Quiesce for this mesh2mem or its connected
                               memory controllers has not been reached yet. 1:
                               Quiesce for this mesh2mem and its connected
                               memory controllers has been reached. That means
                               Egress, Transgress, Score-boards, Read Pending
                               Queues and Write Pending Queues are empty. It
                               should be noted that only mesh2mem commands are
                               being blocked. So mc originating transactions
                               like patrol reads or rank sparing or dimm
                               maintenance traffic (e.g. refreshes) might still
                               take place. In case of
                               WaitForDrainTimerWhenLocRspRise set, after
                               draining, an extra time specified by DrainTimer
                               is enforced before asserting
                               IsQuiescedFromLocRsp.
                            */
    UINT32 draintimer : 13;

                            /* Bits[31:19], Access Type=RW, default=0x00000002*/

                            /*
                               Extra drainage time (DrainTimer): Number of 32
                               TSVs (Time-Slot-Valid, i.e. slowest clock of
                               M2M/MC) to wait after MC RPQ/WPQ and M2M
                               transgress empty till asserting IsQuiesced1/2.
                               This to guarantee no in-flight data/acks from
                               the memory controller when IsQuiesced1/2 gets
                               signalled.
                            */

  } Bits;
  UINT32 Data;

} M2MDFXQUIESCE_M2MEM_MAIN_STRUCT;

/* AKEARLYPFMERGE_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e602dc)                                                      */
/*      SPRB0 (0x21e602dc)                                                      */
/*      SPRHBM (0x21e602dc)                                                     */
/*      SPRC0 (0x21e602dc)                                                      */
/*      SPRMCC (0x21e602dc)                                                     */
/*      SPRUCC (0x21e602dc)                                                     */
/* Register default value on SPRA0: 0x00000007                                  */
/* Register default value on SPRB0: 0x00000007                                  */
/* Register default value on SPRHBM: 0x00000007                                 */
/* Register default value on SPRC0: 0x00000007                                  */
/* Register default value on SPRMCC: 0x00000007                                 */
/* Register default value on SPRUCC: 0x00000007                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register controls how pfmerge akearlycmp allocates if split allocation is used i.e. Defeatures1.TwoEarlyCmpSameCycle=1 and DEfeatures1.SplitAllocEarlyCmpSameCycle=1 
*/


#define AKEARLYPFMERGE_M2MEM_MAIN_REG 0x060202DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefetchmergeearlycmpalloc : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000007*/

                            /*
                               Determines which entries are available for
                               prefetch merge allocation. Inverse are available
                               for non-prefetch earlycmp. A value of 0x1 for a
                               given bit position indicates that particular
                               egress entry is available for early cmp
                               allocation for prefetch merges
                            */

  } Bits;
  UINT32 Data;

} AKEARLYPFMERGE_M2MEM_MAIN_STRUCT;

/* MCI_ADDR_SHADOW0_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e602e4)                                                      */
/*      SPRB0 (0x21e602e4)                                                      */
/*      SPRHBM (0x21e602e4)                                                     */
/*      SPRC0 (0x21e602e4)                                                      */
/*      SPRMCC (0x21e602e4)                                                     */
/*      SPRUCC (0x21e602e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_ADDR MSR (bits [31:0]). This register is under BIOS control while the MCi_ADDR 
      MSR is under OS control.
      
*/


#define MCI_ADDR_SHADOW0_M2MEM_MAIN_REG 0x060202E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reserved : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved for future use. */
    UINT32 lophyaddr : 26;

                            /* Bits[31:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Low-order Bits of the Physical Address
                               (LoPhyAddr): Contains 26 bits of physical
                               address [31:6] of the cache line.
                            */

  } Bits;
  UINT32 Data;

} MCI_ADDR_SHADOW0_M2MEM_MAIN_STRUCT;

/* MCI_ADDR_SHADOW1_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e602e8)                                                      */
/*      SPRB0 (0x21e602e8)                                                      */
/*      SPRHBM (0x21e602e8)                                                     */
/*      SPRC0 (0x21e602e8)                                                      */
/*      SPRMCC (0x21e602e8)                                                     */
/*      SPRUCC (0x21e602e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* 
      Contains information similar to MCi_ADDR MSR (bits [45:32]). This register is under BIOS control while the MCi_ADDR 
      MSR is under OS control.
      
*/


#define MCI_ADDR_SHADOW1_M2MEM_MAIN_REG 0x060202E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hiphyaddr : 20;

                            /* Bits[19:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               High-order Bits of the Physical Address
                               (HiPhyAddr): Contains 20 bits of physical
                               address [51:32] of the cache line.
                            */
    UINT32 reserved : 12;

                            /* Bits[31:20], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} MCI_ADDR_SHADOW1_M2MEM_MAIN_STRUCT;

/* MEMORY_M2MEM_MAIN_REG supported on:                                          */
/*      SPRA0 (0x21e602f0)                                                      */
/*      SPRB0 (0x21e602f0)                                                      */
/*      SPRHBM (0x21e602f0)                                                     */
/*      SPRC0 (0x21e602f0)                                                      */
/*      SPRMCC (0x21e602f0)                                                     */
/*      SPRUCC (0x21e602f0)                                                     */
/* Register default value on SPRA0: 0x00000F00                                  */
/* Register default value on SPRB0: 0x00000F00                                  */
/* Register default value on SPRHBM: 0x00000F00                                 */
/* Register default value on SPRC0: 0x00000F00                                  */
/* Register default value on SPRMCC: 0x00000F00                                 */
/* Register default value on SPRUCC: 0x00000F00                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Information w.r.t. the memory population on the channels.
      
*/


#define MEMORY_M2MEM_MAIN_REG 0x060202F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddr4chnlpopulation : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR4 population channel bitvector
                               (DDR4ChnlPopulation): Specifies for each channel
                               2...0 whether that physical channel has DDR4 on
                               it.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrtchnlpopulation : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDRT population channel bitvector
                               (DDRTChnlPopulation): Specifies for each channel
                               2...0 (corresponding to bit 6...4) whether that
                               physical channel has DDRT on it.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 chnlenabled : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000007*/

                            /*
                               BIOS on cmi initialization should program this
                               field accordingly 1: Indicates cmi link on
                               channel is enabled. Do not program 1 for a non
                               populated channel;ChnlEnabled[x] =1 and
                               (DDR4ChnlPopulated[x] |DDRtChnlPopulated[x]) = 0
                               is not allowed where x is channel no 0:
                               Indicates cmi link on channle is disabled and
                               not initialized. HBM 0 instance shoudl always
                               have channel 2 disabled as there is no channel 2
                               on hbm0 instance
                            */
    UINT32 blockexists : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               If BlockExists is 0 then PAD addresses belongto
                               DDR4 tad
                            */
    UINT32 rsvd_12 : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_M2MEM_MAIN_STRUCT;

/* MIRRORCHNLS_M2MEM_MAIN_REG supported on:                                     */
/*      SPRA0 (0x21e602f4)                                                      */
/*      SPRB0 (0x21e602f4)                                                      */
/*      SPRHBM (0x21e602f4)                                                     */
/*      SPRC0 (0x21e602f4)                                                      */
/*      SPRMCC (0x21e602f4)                                                     */
/*      SPRUCC (0x21e602f4)                                                     */
/* Register default value on SPRA0: 0x00000249                                  */
/* Register default value on SPRB0: 0x00000249                                  */
/* Register default value on SPRHBM: 0x00000249                                 */
/* Register default value on SPRC0: 0x00000249                                  */
/* Register default value on SPRMCC: 0x00000249                                 */
/* Register default value on SPRUCC: 0x00000249                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Configuration register specifying the paired physical mirror channels.
      Only used for mirroring.
      In case of 3 channel interleave, only one map is legal:
        primary chnl0 -> secondary chnl1
        primary chnl1 -> secondary chnl2
        primary chnl2 -> secondary chnl0
      For an unpopulated or non mirrored channel primary and secondary channel should be the same
      For Mirrored channels, Mapping the primary and secondary channels to the same channel is unvalidated hence not supported.
      
*/


#define MIRRORCHNLS_M2MEM_MAIN_REG 0x060202F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddr4chnl0secondary : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000001*/

                            /*
                               DDR4 Channel 0 secondary (Ddr4Chnl0Secondary):
                               Secondary channel associated with primary
                               channel 0. If Channel 0 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 ddr4chnl1secondary : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000002*/

                            /*
                               DDR4 Channel 1 secondary (Ddr4Chnl1Secondary):
                               Secondary channel associated with primary
                               channel 1. If Channel 1 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 ddr4chnl2secondary : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4 Channel 2 secondary (Ddr4Chnl2Secondary):
                               Secondary channel associated with primary
                               channel 2. If Channel 2 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 ddrtchnl0secondary : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000001*/

                            /*
                               DDRT Channel 0 secondary (DdrtChnl0Secondary):
                               Secondary channel associated with primary
                               channel 0. If Channel 0 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 ddrtchnl1secondary : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000002*/

                            /*
                               DDRT Channel 1 secondary (DdrtChnl1Secondary):
                               Secondary channel associated with primary
                               channel 1. If Channel 1 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 ddrtchnl2secondary : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT Channel 2 secondary (DDRTChnl2Secondary):
                               Secondary channel associated with primary
                               channel 2. If Channel 2 is unpopulated program
                               the secondary channel to itself
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MIRRORCHNLS_M2MEM_MAIN_STRUCT;

/* MIRRORFAILOVER_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e60300)                                                      */
/*      SPRB0 (0x21e60300)                                                      */
/*      SPRHBM (0x21e60300)                                                     */
/*      SPRC0 (0x21e60300)                                                      */
/*      SPRMCC (0x21e60300)                                                     */
/*      SPRUCC (0x21e60300)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      Configuration register providing observability and control as to which mirror channels failed
      over. The granularity of a failover is all the DDR4 (mirror region) memory associated with a channel, 
      or all the DDRT (mirror region) memory associated with a channel.
      
*/


#define MIRRORFAILOVER_M2MEM_MAIN_REG 0x06020300

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddr4chnlfailed : 3;

                            /* Bits[2:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               DDR4 Channel Failed (Ddr4ChnlFailed): Each bit
                               is an status and control bit for a channel
                               indicating whether the DDR4 memory associated
                               with that channel failed over. Bits 2...0 map to
                               channels 2...0. Channel failed over semantics:
                               (i) reads will no longer access this channel,
                               (ii) writes will no longer go to this channel
                               (unless ForceWrsToFailed is set). Writing a bit
                               to 1 will force that DDR4 channel to go to
                               failed over state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrtchnlfailed : 3;

                            /* Bits[6:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               DDRT Channel Failed (DdrtChnlFailed): Each bit
                               is a status and control bit for a channel
                               indicating whether DDRT memory associated with
                               that channel failed over. Bits 6...4 map to
                               channels 2...0. Channel failed over semantics:
                               (i) reads will no longer access this channel,
                               (ii) writes will no longer go to this channel
                               (unless ForceWrsToFailed is set). Writing a bit
                               to 1 will force that DDR4 channel to go to
                               failed over state.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4frcmirrwrstofailed : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4 Force Mirror Writes to Failed Channel
                               (Ddr4FrcMirrWrsToFailed): Description is
                               identical to above field, but in this case
                               applicable to DDR4 mirror channels.
                            */
    UINT32 ddrt4frcmirrwrstofailed : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT Force Mirror Writes to Failed Channel
                               (DDRT4FrcMirrWrsToFailed): When set, it forces
                               channel mirror writes to both mirroring channels
                               even after failover. This should only be set
                               during system quiesce, i.e. when no mesh2mem
                               traffic. 0: Dont send writes to the failover
                               channel. This is the default production setting.
                               1: Force writes to also go to the failover
                               channel. This is a debug mode. The usage model
                               is to facilitate post silicon exercising of
                               channel mirroring while injection uncorrectables
                               on one channel. This will keep writes going to
                               the failed channel so that later on one can undo
                               the failover and continue testing channel
                               mirroring with failover events.
                            */
    UINT32 rsvd_10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MIRRORFAILOVER_M2MEM_MAIN_STRUCT;

/* DISTRESSSIGNALLING_N0_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e60308)                                                      */
/*      SPRB0 (0x21e60308)                                                      */
/*      SPRHBM (0x21e60308)                                                     */
/*      SPRC0 (0x21e60308)                                                      */
/*      SPRMCC (0x21e60308)                                                     */
/*      SPRUCC (0x21e60308)                                                     */
/* Register default value on SPRA0: 0x41040808                                  */
/* Register default value on SPRB0: 0x41040808                                  */
/* Register default value on SPRHBM: 0x41040808                                 */
/* Register default value on SPRC0: 0x41040808                                  */
/* Register default value on SPRMCC: 0x41040808                                 */
/* Register default value on SPRUCC: 0x41040808                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      2LM QoS for ICX.
      This register is used for enabling/disabling Distress signaling and setting the thresholds for Hystersis for QoS. 
      This provides controls for enabling Distress Signalling on D2C, Data Response, and Completion messages; Queue occupancy thresholds (Low and High)    
      provide hystersis capabilities, allowing M2M to assert or de-assert distress based on the occupancy of certain queues. The distress signal gets consumed
      by Source agents indicating them to temporarily stop sending txns targetted to the DDRT address regions (i.e. 2LM, AppDirect, Block).
    
Refer DistressSignallingEhancement Register description for more details  
*/


#define DISTRESSSIGNALLING_N0_M2MEM_MAIN_REG 0x06020308

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 distressd2csignalen : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling for D2C response read
                               request. 1 : Enable 0 : Disable
                            */
    UINT32 distressdatasignalen : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling for D2CHA or D2K
                               response of read request. 1 : Enable 0 : Disable
                            */
    UINT32 distresscmpsignalen : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling on non-data
                               completion message. 1 : Enable 0 : Disable
                            */
    UINT32 distressdetection2lmonly : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Used to select between 2LM or Clx mode of
                               distress signalling. 1 : Signal distress for 2LM
                               mode (i.e. based on AD and BL egress occupancy
                               mechanism) 0 : Signal distress for DDRT mode
                               (i.e. based on Rpq and Wpq occupancy mechanism)
                               This shouldn't be set to 1 when M2m is in FMC
                               mode i.e. when Mode.FMCMode=1; then this should
                               always be 0. We do not do 2lmDistress Signalling
                               mechanism when in FMC mode.
                            */
    UINT32 localrpqoccupancythresholdlow : 7;

                            /* Bits[10:4], Access Type=RW, default=0x00000000*/

                            /*
                               The lower threshold of Rpq occupancy for Local
                               transactions. If RPQ occupancy drops below this
                               value, then distress can be de-asserted (if Wpq
                               occupancy is also below its lower threshold, for
                               all channels). Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b0.
                               RpqOccupancyThresholdLow should always be a non
                               zero value. Distress is deasserted if the Rpq
                               count drops below the lower threshold. If
                               RpqOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence RpqOccupancyThresholdLow should
                               always be be greater than zero.
                            */
    UINT32 localrpqoccupancythresholdhigh : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of Rpq occupancy for
                               Local(same socket) requests. If RPQ occupancy
                               goes above this value, then distress will be
                               asserted(if Ddrt/CLX mode of distress signalling
                               is chosen). This value should be greater than or
                               equal to RpqOccupancyThresholdLow value. Note:
                               For this to be used, DistressDetection2lmOnly
                               has to be set to 1'b0. The maximum possible
                               number of Rpq entries per channel is 80. Hence
                               the maximum value this config bit can have is
                               79(i.e. 6'h2E). Setting
                               RpqOccupancyThresholdHigh value greter than 79
                               would mean, distress never gets asserted, as the
                               logic will check if the Rpq entry count is
                               greater than this value for distress detection.
                            */
    UINT32 localwpqoccupancythresholdlow : 6;

                            /* Bits[23:18], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of Wpq occupancy for local
                               requests. If WPQ occupancy drops below this
                               value, then distress can be de-asserted (if Rpq
                               occupancy is also below its lower threshold, for
                               all channels). Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b0.
                               WpqOccupancyThresholdLow should always be a non
                               zero value. Distress is deasserted if the Wpq
                               count drops below the lower threshold. If
                               WpqOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence WpqOccupancyThresholdLow should
                               always be be greater than zero.
                            */
    UINT32 localwpqoccupancythresholdhigh : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of Wpq occupancy for
                               Local requests. If WPQ occupancy goes above this
                               value, then distress will be asserted (if
                               Ddrt/CLX mode of distress signalling is chosen).
                               This value should be greater than or equal to
                               WpqOccupancyThresholdLow. Note: For this to be
                               used, DistressDetection2lmOnly has to be set to
                               1'b0. The maximum number Wpq entries allocated
                               per channel is 16. Hence
                               WpqOccupancyThresholdHigh can have a maximum
                               value of 15 (4'hF).
                            */
    UINT32 adegressoccupancythresholdlow : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of AD Egress Occupancy(per
                               channel). If AD Egress occupancy(per channel)
                               drops below this value, then distress can be de-
                               asserted (if BL Egress occupancy(all channels)
                               is also below its lower threshold.) Note: For
                               this to be used, DistressDetection2lmOnly has to
                               be set to 1'b1. AdEgressOccupancyThresholdLow
                               should always be a non zero value. Distress is
                               deasserted if the Ad egress count drops below
                               the lower threshold. If
                               AdEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence AdEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */

  } Bits;
  UINT32 Data;

} DISTRESSSIGNALLING_N0_M2MEM_MAIN_STRUCT;

/* DISTRESSSIGNALLING_N1_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e6030c)                                                      */
/*      SPRB0 (0x21e6030c)                                                      */
/*      SPRHBM (0x21e6030c)                                                     */
/*      SPRC0 (0x21e6030c)                                                      */
/*      SPRMCC (0x21e6030c)                                                     */
/*      SPRUCC (0x21e6030c)                                                     */
/* Register default value on SPRA0: 0x00002108                                  */
/* Register default value on SPRB0: 0x00002108                                  */
/* Register default value on SPRHBM: 0x00002108                                 */
/* Register default value on SPRC0: 0x00002108                                  */
/* Register default value on SPRMCC: 0x00002108                                 */
/* Register default value on SPRUCC: 0x00002108                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      2LM QoS for ICX.
      This register is used for enabling/disabling Distress signaling and setting the thresholds for Hystersis for QoS. 
      This provides controls for enabling Distress Signalling on D2C, Data Response, and Completion messages; Queue occupancy thresholds (Low and High)    
      provide hystersis capabilities, allowing M2M to assert or de-assert distress based on the occupancy of certain queues. The distress signal gets consumed
      by Source agents indicating them to temporarily stop sending txns targetted to the DDRT address regions (i.e. 2LM, AppDirect, Block).
    
Refer DistressSignallingEhancement Register description for more details  
*/


#define DISTRESSSIGNALLING_N1_M2MEM_MAIN_REG 0x0602030C

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adegressoccupancythresholdlow : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The lower threshold of AD Egress Occupancy(per
                               channel). If AD Egress occupancy(per channel)
                               drops below this value, then distress can be de-
                               asserted (if BL Egress occupancy(all channels)
                               is also below its lower threshold.) Note: For
                               this to be used, DistressDetection2lmOnly has to
                               be set to 1'b1. AdEgressOccupancyThresholdLow
                               should always be a non zero value. Distress is
                               deasserted if the Ad egress count drops below
                               the lower threshold. If
                               AdEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence AdEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 adegressoccupancythresholdhigh : 5;

                            /* Bits[7:3], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of AD Egress
                               occupancy(per channel). If Ad Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               AdEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 blegressoccupancythresholdlow : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of BL Egress Occupancy(per
                               channel). If BL Egress occupancy drops below(for
                               all channels) this value, then distress can be
                               de-asserted (if AD Egress occupancy(for all
                               channels) is also below its lower threshold.)
                               Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b1.
                               BlEgressOccupancyThresholdLow should always be a
                               non zero value. Distress is deasserted if the Bl
                               egress count drops below the lower threshold. If
                               BlEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence BlEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 blegressoccupancythresholdhigh : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of BL Egress
                               occupancy(per channel). If BL Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               BlEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 distresscmpsignalen4appdirect : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling on non-data
                               completion message for AppDirect transactions.
                               This includes D2C/D2K reads, MemInv* operations,
                               and writes. Default is 0 (disabled). 1 : Enable
                               0 : Disable
                            */
    UINT32 distressglobalhalfdieselector : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               This bit determines which half of the die we
                               signal global distress on. Added as part of HSD:
                               220790938 0 : Signal distress on SNC 0 global
                               distress 1 : Signal distress on SNC 1 global
                               distress Default value is 0.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DISTRESSSIGNALLING_N1_M2MEM_MAIN_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adegressoccupancythresholdlow : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The lower threshold of AD Egress Occupancy(per
                               channel). If AD Egress occupancy(per channel)
                               drops below this value, then distress can be de-
                               asserted (if BL Egress occupancy(all channels)
                               is also below its lower threshold.) Note: For
                               this to be used, DistressDetection2lmOnly has to
                               be set to 1'b1. AdEgressOccupancyThresholdLow
                               should always be a non zero value. Distress is
                               deasserted if the Ad egress count drops below
                               the lower threshold. If
                               AdEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence AdEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 adegressoccupancythresholdhigh : 5;

                            /* Bits[7:3], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of AD Egress
                               occupancy(per channel). If Ad Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               AdEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 blegressoccupancythresholdlow : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of BL Egress Occupancy(per
                               channel). If BL Egress occupancy drops below(for
                               all channels) this value, then distress can be
                               de-asserted (if AD Egress occupancy(for all
                               channels) is also below its lower threshold.)
                               Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b1.
                               BlEgressOccupancyThresholdLow should always be a
                               non zero value. Distress is deasserted if the Bl
                               egress count drops below the lower threshold. If
                               BlEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence BlEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 blegressoccupancythresholdhigh : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of BL Egress
                               occupancy(per channel). If BL Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               BlEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 distresscmpsignalen4appdirect : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling on non-data
                               completion message for AppDirect transactions.
                               This includes D2C/D2K reads, MemInv* operations,
                               and writes. Default is 0 (disabled). 1 : Enable
                               0 : Disable
                            */
    UINT32 distressglobalhalfdieselector : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               This bit determines which half of the die we
                               signal global distress on. Added as part of HSD:
                               220790938 0 : Signal distress on SNC 0 global
                               distress 1 : Signal distress on SNC 1 global
                               distress Default value is 0.
                            */
    UINT32 enabledramqos : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables Qos between DDR and HBM 0 :
                               Local DDRT counters will count local DDRT
                               transactions and Remote DDRT counters will count
                               remote DDRT transactions 1 : Local DDRT counters
                               will count all DDRT transactions and Remote DDRT
                               counters will count all DRAM transactions
                               Default value is 0. An SoC with DDR* and HBM
                               memory should always set EnableDRAMQos to 0 in
                               the HBM M2M. It may choose to set EnableDRAMQos
                               to 1 in the DDR M2M to enable QoS between DRAM
                               and HBM. An SoC with only DDR* memory must set
                               EnableDRAMQos to 0 in all instances of M2M.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DISTRESSSIGNALLING_N1_M2MEM_MAIN_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adegressoccupancythresholdlow : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The lower threshold of AD Egress Occupancy(per
                               channel). If AD Egress occupancy(per channel)
                               drops below this value, then distress can be de-
                               asserted (if BL Egress occupancy(all channels)
                               is also below its lower threshold.) Note: For
                               this to be used, DistressDetection2lmOnly has to
                               be set to 1'b1. AdEgressOccupancyThresholdLow
                               should always be a non zero value. Distress is
                               deasserted if the Ad egress count drops below
                               the lower threshold. If
                               AdEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence AdEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 adegressoccupancythresholdhigh : 5;

                            /* Bits[7:3], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of AD Egress
                               occupancy(per channel). If Ad Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               AdEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 blegressoccupancythresholdlow : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of BL Egress Occupancy(per
                               channel). If BL Egress occupancy drops below(for
                               all channels) this value, then distress can be
                               de-asserted (if AD Egress occupancy(for all
                               channels) is also below its lower threshold.)
                               Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b1.
                               BlEgressOccupancyThresholdLow should always be a
                               non zero value. Distress is deasserted if the Bl
                               egress count drops below the lower threshold. If
                               BlEgressOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence BlEgressOccupancyThresholdLow
                               should always be be greater than zero.
                            */
    UINT32 blegressoccupancythresholdhigh : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of BL Egress
                               occupancy(per channel). If BL Egress
                               occupancy(for any channel) goes above this
                               value, then distress will be asserted (if 2LM
                               mode of distress signalling is chosen). This
                               value should be greater than or equal to
                               BlEgressOccupancyThresholdLow. Note: For this to
                               be used, DistressDetection2lmOnly has to be set
                               to 1'b1.
                            */
    UINT32 distresscmpsignalen4appdirect : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable distress signalling on non-data
                               completion message for AppDirect transactions.
                               This includes D2C/D2K reads, MemInv* operations,
                               and writes. Default is 0 (disabled). 1 : Enable
                               0 : Disable
                            */
    UINT32 distressglobalhalfdieselector : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               This bit determines which half of the die we
                               signal global distress on. Added as part of HSD:
                               220790938 0 : Signal distress on SNC 0 global
                               distress 1 : Signal distress on SNC 1 global
                               distress Default value is 0.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DISTRESSSIGNALLING_N1_M2MEM_MAIN_STRUCT;

/* MODE_M2MEM_MAIN_REG supported on:                                            */
/*      SPRA0 (0x21e60318)                                                      */
/*      SPRB0 (0x21e60318)                                                      */
/*      SPRHBM (0x21e60318)                                                     */
/*      SPRC0 (0x21e60318)                                                      */
/*      SPRMCC (0x21e60318)                                                     */
/*      SPRUCC (0x21e60318)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Configuration register for the main m2m modes.
      Important configuration restrictions:
        - Isoch is not supported by the m2m if DDRT is present on a channel.
        - DDRT scheduling and Isoch mode need to be mutually exclusive within the m2m.
        - Isoch is not supported if any channel gets serviced by FNV.
        - Mirroring and Isoch mode are mutually exclusive.
      Whenever mirroring is enabled on a mesh2mem, then also following bits need to get set on that mesh2mem:
           - Defeatures0[IngBypDis]=1             (functional requirement )
       - Sysfeatures0[PrefDisable]=1  (functional requirement )
             
*/


#define MODE_M2MEM_MAIN_REG 0x06020318

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dedup : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Memory Deduplication Engine (DEDUP) Memory
                               Deduplication Engine enable. Set this bit to 1
                               if transactions destined for the Memory
                               Deduplication Engine (Dedup) might come in.
                            */
    UINT32 mee : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Memory Encryption Engine (MEE): Memory
                               Encryption Engine enable. Set this bit to 1 if
                               transactions destined for the Memory Encryption
                               Engine (MEE) might come in.
                            */
    UINT32 isoch : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Isochronous Flows (Isoch): Enable Isochronous
                               flows. It is forbidden to enable isochronous
                               flows, as it might result in system hangs, when
                               either mirror is enabled, or when DDRT is
                               populated, e.g. DDRT is present.
                            */
    UINT32 blockregion : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Block Region (BlockRegion): Enable block region
                               memory flows. Furthermore,
                               MmCapabilities[CapBlockRegionEn], Mode[PMem] and
                               MmCapabilities[CapPMemEn] need to be 1 for block
                               region support.
                            */
    UINT32 pmem : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Persistent Memory (PMem): Enable persistent
                               memory flows. Furthermore,
                               MmCapabilities[CapPMemEn] needs to be 1 for PMem
                               support.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nmcaching : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Near Memory Caching (NMCaching): Enable Near
                               Memory caching, i.e. two level memory with the
                               first level (i.e. the near memory) having the
                               capability to cache second level memory (i.e.
                               far memory). Setting this bit also implies there
                               is a second memory level present. Furthermore,
                               in this implementation, near memory accesses get
                               scheduled by the DDR4 scheduler while the far
                               memory gets serviced by the DDRT scheduler.
                               Note, also MmCapabilities[CapNMcachingEn] needs
                               to be 1 for Near Memory Caching.
                            */
    UINT32 mirrorddr4 : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR4 Mirroring (MirrorDDR4): Enable DDR4
                               mirroring. It is illegal to set this bit when
                               Near Memory Caching is enabled.
                               MmCapabilities[CapMirrorEn] needs to be 1 for
                               mirroring.
                            */
    UINT32 mirrorddrt : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDRT Mirroring (MirrorDDRT): Enable DDRT
                               mirroring. MmCapabilities[CapMirrorEn] needs to
                               be 1 for mirroring.
                            */
    UINT32 adddc : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /* Unused: available for ECO if necessary. */
    UINT32 fmcmode : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Far Memory Controller mode: When set, this
                               indicates that the M2M is in an HBM
                               configuration where 2LM is enabled and this
                               Memory controller handles the Far Memory(DDR).
                               This should only be set on the M2M in the DDR
                               tile, and not on the M2M in the HBM tile. Do not
                               set this if not in 2LM mode or not an HBM
                               product where cross-tile 2LM flows are
                               applicable. 0: This M2M is not a Far Memory
                               controller in cross-tile 2LM. 1: This M2M is a
                               Far Memory controller in cross-tile 2LM.
                            */
    UINT32 nmcmode : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Near Memory Controller mode: When set, this
                               indicates that the M2M is in an HBM
                               configuration where the HBMtile is configured to
                               handle route through or xtile 2lm NM
                               transactions This should only be set on the M2M
                               in the HBM tile. Do not set this if not in 2LM
                               mode or not an HBM product where cross-tile 2LM
                               or route through flows are applicable. 0: This
                               M2M is not a HBM controller in cross-tile 2LM or
                               route through 1: This M2M is a HBM controller in
                               cross-tile 2LM or route through.
                            */
    UINT32 rsvd_14 : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MODE_M2MEM_MAIN_STRUCT;

/* UPIROUTINGCONFIG_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60320)                                                      */
/*      SPRB0 (0x21e60320)                                                      */
/*      SPRHBM (0x21e60320)                                                     */
/*      SPRC0 (0x21e60320)                                                      */
/*      SPRMCC (0x21e60320)                                                     */
/*      SPRUCC (0x21e60320)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Selects the index bits used for indexing into the UpiRoutingTable.LogicalUpiTarget. The register supports defining up to 16 different indexing/interleave modes to UPI. Currently only 3 modes are used, the remaining are reserved for future.
*/


#define UPIROUTINGCONFIG_M2MEM_MAIN_REG 0x06020320

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 upiinterleavemode : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               0 : Index = {NID[2:0],PA[12]^PA[6]} (interleaves
                               1 to 2 UPI links between 8 nodes) 1 : Index =
                               {NID[1:0], MOD3[1:0]} (interleaves 1 to 3 UPI
                               links between 4 nodes) 2 : Index = {NID[1:0],
                               PA[13:12]^PA[7:6]} (interleaves 1 to 4 UPI links
                               between 4 nodes) 3-15 : RSVD
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} UPIROUTINGCONFIG_M2MEM_MAIN_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 upiinterleavemode : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               0 : Index = {NID[2:0],PA[12]^PA[6]} (interleaves
                               1 to 2 UPI links between 8 nodes) 1 : Index =
                               {NID[1:0], MOD3[1:0]} (interleaves 1 to 3 UPI
                               links between 4 nodes) 2 : Index = {NID[1:0],
                               PA[13:12]^PA[7:6]} (interleaves 1 to 4 UPI links
                               between 4 nodes) 3-15 : RSVD
                            */
    UINT32 bypassupiroutetable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bypasses the programming in the UpiRouteTable
                               and instead the target UPI agent is determined
                               by the procid identifier from the read request.
                               This also implies that the UpiInterleaveMode is
                               ignored. 0: Do not bypass the UpiRouteTable
                               (default). The target UPI link will be a result
                               of the UpiRouteTable lookup based on the
                               UpiInterleaveMode. 1: Ignore the
                               UpiRouteTable/UpiInterleaveMode. Target UPI link
                               is based on information from the read request.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} UPIROUTINGCONFIG_M2MEM_MAIN_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 upiinterleavemode : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               0 : Index = {NID[2:0],PA[12]^PA[6]} (interleaves
                               1 to 2 UPI links between 8 nodes) 1 : Index =
                               {NID[1:0], MOD3[1:0]} (interleaves 1 to 3 UPI
                               links between 4 nodes) 2 : Index = {NID[1:0],
                               PA[13:12]^PA[7:6]} (interleaves 1 to 4 UPI links
                               between 4 nodes) 3-15 : RSVD
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} UPIROUTINGCONFIG_M2MEM_MAIN_STRUCT;

/* UPIROUTINGTABLE_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60328)                                                      */
/*      SPRB0 (0x21e60328)                                                      */
/*      SPRHBM (0x21e60328)                                                     */
/*      SPRC0 (0x21e60328)                                                      */
/*      SPRMCC (0x21e60328)                                                     */
/*      SPRUCC (0x21e60328)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* The 48 bit vector defined in this register captures 16 UPI ID values (supporting up to 8 UPI links). The index bit scheme selected by UpiRoutingConfig.UpiInterleaveMode is used to index to this UPI Routing Table.  
Note : If the number of UPI links supported between the nodes is less than the max number of UPI links supported by UpiRoutingConfig.UpiInterleaveMode, then the LogicalUpiTarget entries need to be replicated appropriately (ie. aliasing).
*/


#define UPIROUTINGTABLE_N0_M2MEM_MAIN_REG 0x06020328

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 logicalupitarget : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               This 48 bit vector captures 16 UPI ID values,
                               each ID being 3 bits (supporting up to 8 UPI
                               links). The index bit scheme selected by
                               UpiRoutingConfig.UpiInterleaveMode is used to
                               index to this UPI Routing Table. Bits [2:0]
                               correspond to the UPI ID selected by Index==0,
                               bits[5:3] correspond to the UPI ID selected by
                               Index==1, etc.
                            */

  } Bits;
  UINT32 Data;

} UPIROUTINGTABLE_N0_M2MEM_MAIN_STRUCT;

/* UPIROUTINGTABLE_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e6032c)                                                      */
/*      SPRB0 (0x21e6032c)                                                      */
/*      SPRHBM (0x21e6032c)                                                     */
/*      SPRC0 (0x21e6032c)                                                      */
/*      SPRMCC (0x21e6032c)                                                     */
/*      SPRUCC (0x21e6032c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* The 48 bit vector defined in this register captures 16 UPI ID values (supporting up to 8 UPI links). The index bit scheme selected by UpiRoutingConfig.UpiInterleaveMode is used to index to this UPI Routing Table.  
Note : If the number of UPI links supported between the nodes is less than the max number of UPI links supported by UpiRoutingConfig.UpiInterleaveMode, then the LogicalUpiTarget entries need to be replicated appropriately (ie. aliasing).
*/


#define UPIROUTINGTABLE_N1_M2MEM_MAIN_REG 0x0602032C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 logicalupitarget : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               This 48 bit vector captures 16 UPI ID values,
                               each ID being 3 bits (supporting up to 8 UPI
                               links). The index bit scheme selected by
                               UpiRoutingConfig.UpiInterleaveMode is used to
                               index to this UPI Routing Table. Bits [2:0]
                               correspond to the UPI ID selected by Index==0,
                               bits[5:3] correspond to the UPI ID selected by
                               Index==1, etc.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} UPIROUTINGTABLE_N1_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE1_EGR_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60330)                                                      */
/*      SPRB0 (0x21e60330)                                                      */
/*      SPRHBM (0x21e60330)                                                     */
/*      SPRC0 (0x21e60330)                                                      */
/*      SPRMCC (0x21e60330)                                                     */
/*      SPRUCC (0x21e60330)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* spare
*/


#define CRDEFEATURE1_EGR_M2MEM_MAIN_REG 0x06020330

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE1_EGR_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE1_ING_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60334)                                                      */
/*      SPRB0 (0x21e60334)                                                      */
/*      SPRHBM (0x21e60334)                                                     */
/*      SPRC0 (0x21e60334)                                                      */
/*      SPRMCC (0x21e60334)                                                     */
/*      SPRUCC (0x21e60334)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* spare
*/


#define CRDEFEATURE1_ING_M2MEM_MAIN_REG 0x06020334

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE1_ING_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE2_EGR_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60338)                                                      */
/*      SPRB0 (0x21e60338)                                                      */
/*      SPRHBM (0x21e60338)                                                     */
/*      SPRC0 (0x21e60338)                                                      */
/*      SPRMCC (0x21e60338)                                                     */
/*      SPRUCC (0x21e60338)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* spare
*/


#define CRDEFEATURE2_EGR_M2MEM_MAIN_REG 0x06020338

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE2_EGR_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE2_ING_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e6033c)                                                      */
/*      SPRB0 (0x21e6033c)                                                      */
/*      SPRHBM (0x21e6033c)                                                     */
/*      SPRC0 (0x21e6033c)                                                      */
/*      SPRMCC (0x21e6033c)                                                     */
/*      SPRUCC (0x21e6033c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* spare
*/


#define CRDEFEATURE2_ING_M2MEM_MAIN_REG 0x0602033C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE2_ING_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE3_EGR_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60340)                                                      */
/*      SPRB0 (0x21e60340)                                                      */
/*      SPRHBM (0x21e60340)                                                     */
/*      SPRC0 (0x21e60340)                                                      */
/*      SPRMCC (0x21e60340)                                                     */
/*      SPRUCC (0x21e60340)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* spare
*/


#define CRDEFEATURE3_EGR_M2MEM_MAIN_REG 0x06020340

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE3_EGR_M2MEM_MAIN_STRUCT;

/* CRDEFEATURE3_ING_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60344)                                                      */
/*      SPRB0 (0x21e60344)                                                      */
/*      SPRHBM (0x21e60344)                                                     */
/*      SPRC0 (0x21e60344)                                                      */
/*      SPRMCC (0x21e60344)                                                     */
/*      SPRUCC (0x21e60344)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* spare
*/


#define CRDEFEATURE3_ING_M2MEM_MAIN_REG 0x06020344

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} CRDEFEATURE3_ING_M2MEM_MAIN_STRUCT;

/* PREFETCHSADCONFIG_0_M2MEM_MAIN_REG supported on:                             */
/*      SPRA0 (0x21e60354)                                                      */
/*      SPRB0 (0x21e60354)                                                      */
/*      SPRHBM (0x21e60354)                                                     */
/*      SPRC0 (0x21e60354)                                                      */
/*      SPRMCC (0x21e60354)                                                     */
/*      SPRUCC (0x21e60354)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register specifies how the memory channel is calculated for an XPT/UPI prefetch.
      PrefetchSADconfig[0] specifies the channel decode for PrefetchSADstartAddr.PrefetchSADuseIntlv==0.  For scf_mem HBM, PrefetchSADconfig[0] is by default unused, but can be enabled by setting PrefetchSADoverride.HbmEnableConfig0 to 1 (intended only for debug purposes). [br]
      PrefetchSADconfig[1] specifies the channel decode for PrefetchSADstartAddr.PrefetchSADuseIntlv==1.  For scf_mem HBM, the HBM hashing algorithm is used (Addr[10:8] ^ Addr[16:14] ^ Addr[24:22]) and is then fed through the config[1].PrefSADconfigLogical2PhysicalChnl mapping (the other config[1] fields are unused in HBM).  However, if PrefetchSADoverride.HbmDefeatureXor is set to 1, the Addr[10:8] is passed through directly to the logical-to-physical mapping (config[1]) without XORing. [br]

      Typically PrefetchSADchnl[0] would be mapped to 1LM DDR4 or 1LM IPM.

      The usage scenario's where *both* interleave configs would get used are:[br]
        ICX: 1LM DDR4 + 2LM NmCache DDR4, i.e. a hybrid DDR4 config, or [br]
        KNH (IPM Mesh2Mem): None. [br]
            (OPM Mesh2Mem): None. [br]

      By convention lets assign above pairs in this order: PrefetchSADchnl[0] + PrefetchSADchnl[1]. [br]
      Prefetching to 2LM FM is not supported, nor is prefetching to 1LM DDRT supported, by the hardware implementation. [br]

      Supported prefetching: [br]
        ICX: Only supported prefetch destination is DDR4. That is for all supported product modes, i.e: 1LM DDR4, 1LM DDR4 + 1LM DDRT,
             2LM, 1LM DDR4 + 2LM (=hybrid DDR4 mode). [br]
        KNH IPM (HBM) Mesh2Mem: the only supported prefetch destination is IPM (HBM). Supported for following modes: 1LM IPM, 
             2LM, 1LM IPM + 2LM (=hybrid IPM mode). [br]
        KNH OPM (DDR4/DDRT) Mesh2Mem:  (i) Prefetches to 1LM DDR4 are only allowed in 1LM IPM + 1LM DDR4 mode (=flat memory mode), even when 1LM DDRT is present. [br]
                                      (ii) Prefetches to 1LM DDRT (AppDirect and/or Block Region) are only allowed in 1LM IPM + 1LM DDRT mode (=flat memory mode). [br]
                                     (iii) Prefetches to 1LM DDRT are NOT allowed when DDR4 is present.
      
*/


#define PREFETCHSADCONFIG_0_M2MEM_MAIN_REG 0x06020354

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefsadconfigintlv : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Specifies what address bits to use as the
                               logical channel (only lower 3b of result is
                               used): 0: Addr[10:8] ^ AddrH[16:14] ^
                               Addr[24:22] (256 byte 2/4/8-way interleave)
                               (ICX) 1: Addr[15:6]>>PrefSadPower2ShiftRight
                               (power-of-2 interleave) (SKX/ICX) 2:
                               Addr[51:8]%3 (256 byte 3/6-way interleave)
                               (SKX/ICX) 3: Addr[51:6]%3 ( 64 byte 3/6-way
                               interleave) (SKX) (Reserved) 4:
                               Concat(Addr[51:8]%3, Addr[8]) (Reserved) 5:
                               Concat(Addr[51:6]%3, Addr[6]) (Reserved) 6:
                               Addr[51:8]%5 (Reserved) 7: Addr[51:6]%5
                               (Reserved) Note: for scf_mem HBM, this field is
                               unused for config[1] and only used in config[0]
                               if PrefetchSADoverride.HbmEnableConfig0 it set
                               to 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefsadconfigpower2shiftright : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Specifies what address bits to use as the
                               logical channel (only lower 3b of result is
                               used): Addr[15:6]>>PrefSadPower2ShiftRight Only
                               relevant when PrefSadInterlv is 0. For ICX used
                               to specify Addr[8], or Addr[6] as two-way
                               channel interleave bits: Program to 2, 0
                               respectively. For KNH used to specify Addr[8]
                               (DDR4/DDRT), or Addr[N+2,N] (HBM) (with
                               N=6...13) as channel interleave bits. Program to
                               2, N respectively. Note: for scf_mem HBM, this
                               field is unused for config[1] and only used in
                               config[0] if
                               PrefetchSADoverride.HbmEnableConfig0 it set to
                               1.
                            */
    UINT32 rsvd_7 : 9;

                            /* Bits[15:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefsadconfiglogical2physicalchnl : 16;

                            /* Bits[31:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Maps logical to physical chnl. Value of
                               bits[2*i, 2*i+1] (i=0...7) defines the physical
                               channel number of logical channel i. Proper
                               programming of this register depends on the SAD
                               interleave in the CHA and must consistent with
                               the CHA Route tables. The logical channel ID is
                               determined based on the address mode of
                               interleave (PrefSADconfigIntlv) and must also be
                               set consistently with the CHA. For example: - If
                               PrefSADconfigIntlv=0x0, then the logical channel
                               ID = Addr[10:8] ^ Addr[16:14] ^ Addr[24:22]. If
                               the CHA Route tables are setup to be the
                               following: Logical channel 0 maps to MC0 Channel
                               0 Logical Channel 1 maps to MC1 Channel 0
                               Logical Channel 2 maps to MC2 Channel 0 Logical
                               Channel 3 maps to MC3 Channel 0 Logical Channel
                               4 maps to MC0 Channel 1 Logical Channel 5 maps
                               to MC1 Channel 1 Logical Channel 6 maps to MC2
                               Channel 1 Logical Channel 7 maps to MC3 Channel
                               1 -Then the programming of
                               PrefSADconfigLogical2PhysicalChnl should be
                               0x5500
                            */

  } Bits;
  UINT32 Data;

} PREFETCHSADCONFIG_0_M2MEM_MAIN_STRUCT;

/* PREFETCHSADCONFIG_1_M2MEM_MAIN_REG supported on:                             */
/*      SPRA0 (0x21e60358)                                                      */
/*      SPRB0 (0x21e60358)                                                      */
/*      SPRHBM (0x21e60358)                                                     */
/*      SPRC0 (0x21e60358)                                                      */
/*      SPRMCC (0x21e60358)                                                     */
/*      SPRUCC (0x21e60358)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register specifies how the memory channel is calculated for an XPT/UPI prefetch.
      PrefetchSADconfig[0] specifies the channel decode for PrefetchSADstartAddr.PrefetchSADuseIntlv==0.  For scf_mem HBM, PrefetchSADconfig[0] is by default unused, but can be enabled by setting PrefetchSADoverride.HbmEnableConfig0 to 1 (intended only for debug purposes). [br]
      PrefetchSADconfig[1] specifies the channel decode for PrefetchSADstartAddr.PrefetchSADuseIntlv==1.  For scf_mem HBM, the HBM hashing algorithm is used (Addr[10:8] ^ Addr[16:14] ^ Addr[24:22]) and is then fed through the config[1].PrefSADconfigLogical2PhysicalChnl mapping (the other config[1] fields are unused in HBM).  However, if PrefetchSADoverride.HbmDefeatureXor is set to 1, the Addr[10:8] is passed through directly to the logical-to-physical mapping (config[1]) without XORing. [br]

      Typically PrefetchSADchnl[0] would be mapped to 1LM DDR4 or 1LM IPM.

      The usage scenario's where *both* interleave configs would get used are:[br]
        ICX: 1LM DDR4 + 2LM NmCache DDR4, i.e. a hybrid DDR4 config, or [br]
        KNH (IPM Mesh2Mem): None. [br]
            (OPM Mesh2Mem): None. [br]

      By convention lets assign above pairs in this order: PrefetchSADchnl[0] + PrefetchSADchnl[1]. [br]
      Prefetching to 2LM FM is not supported, nor is prefetching to 1LM DDRT supported, by the hardware implementation. [br]

      Supported prefetching: [br]
        ICX: Only supported prefetch destination is DDR4. That is for all supported product modes, i.e: 1LM DDR4, 1LM DDR4 + 1LM DDRT,
             2LM, 1LM DDR4 + 2LM (=hybrid DDR4 mode). [br]
        KNH IPM (HBM) Mesh2Mem: the only supported prefetch destination is IPM (HBM). Supported for following modes: 1LM IPM, 
             2LM, 1LM IPM + 2LM (=hybrid IPM mode). [br]
        KNH OPM (DDR4/DDRT) Mesh2Mem:  (i) Prefetches to 1LM DDR4 are only allowed in 1LM IPM + 1LM DDR4 mode (=flat memory mode), even when 1LM DDRT is present. [br]
                                      (ii) Prefetches to 1LM DDRT (AppDirect and/or Block Region) are only allowed in 1LM IPM + 1LM DDRT mode (=flat memory mode). [br]
                                     (iii) Prefetches to 1LM DDRT are NOT allowed when DDR4 is present.
      
*/


#define PREFETCHSADCONFIG_1_M2MEM_MAIN_REG 0x06020358

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefsadconfigintlv : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Specifies what address bits to use as the
                               logical channel (only lower 3b of result is
                               used): 0: Addr[10:8] ^ AddrH[16:14] ^
                               Addr[24:22] (256 byte 2/4/8-way interleave)
                               (ICX) 1: Addr[15:6]>>PrefSadPower2ShiftRight
                               (power-of-2 interleave) (SKX/ICX) 2:
                               Addr[51:8]%3 (256 byte 3/6-way interleave)
                               (SKX/ICX) 3: Addr[51:6]%3 ( 64 byte 3/6-way
                               interleave) (SKX) (Reserved) 4:
                               Concat(Addr[51:8]%3, Addr[8]) (Reserved) 5:
                               Concat(Addr[51:6]%3, Addr[6]) (Reserved) 6:
                               Addr[51:8]%5 (Reserved) 7: Addr[51:6]%5
                               (Reserved) Note: for scf_mem HBM, this field is
                               unused for config[1] and only used in config[0]
                               if PrefetchSADoverride.HbmEnableConfig0 it set
                               to 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefsadconfigpower2shiftright : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Specifies what address bits to use as the
                               logical channel (only lower 3b of result is
                               used): Addr[15:6]>>PrefSadPower2ShiftRight Only
                               relevant when PrefSadInterlv is 0. For ICX used
                               to specify Addr[8], or Addr[6] as two-way
                               channel interleave bits: Program to 2, 0
                               respectively. For KNH used to specify Addr[8]
                               (DDR4/DDRT), or Addr[N+2,N] (HBM) (with
                               N=6...13) as channel interleave bits. Program to
                               2, N respectively. Note: for scf_mem HBM, this
                               field is unused for config[1] and only used in
                               config[0] if
                               PrefetchSADoverride.HbmEnableConfig0 it set to
                               1.
                            */
    UINT32 rsvd_7 : 9;

                            /* Bits[15:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefsadconfiglogical2physicalchnl : 16;

                            /* Bits[31:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Maps logical to physical chnl. Value of
                               bits[2*i, 2*i+1] (i=0...7) defines the physical
                               channel number of logical channel i. Proper
                               programming of this register depends on the SAD
                               interleave in the CHA and must consistent with
                               the CHA Route tables. The logical channel ID is
                               determined based on the address mode of
                               interleave (PrefSADconfigIntlv) and must also be
                               set consistently with the CHA. For example: - If
                               PrefSADconfigIntlv=0x0, then the logical channel
                               ID = Addr[10:8] ^ Addr[16:14] ^ Addr[24:22]. If
                               the CHA Route tables are setup to be the
                               following: Logical channel 0 maps to MC0 Channel
                               0 Logical Channel 1 maps to MC1 Channel 0
                               Logical Channel 2 maps to MC2 Channel 0 Logical
                               Channel 3 maps to MC3 Channel 0 Logical Channel
                               4 maps to MC0 Channel 1 Logical Channel 5 maps
                               to MC1 Channel 1 Logical Channel 6 maps to MC2
                               Channel 1 Logical Channel 7 maps to MC3 Channel
                               1 -Then the programming of
                               PrefSADconfigLogical2PhysicalChnl should be
                               0x5500
                            */

  } Bits;
  UINT32 Data;

} PREFETCHSADCONFIG_1_M2MEM_MAIN_STRUCT;

/* PREFETCHSADLIMITADDR_0_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e6035c)                                                      */
/*      SPRB0 (0x21e6035c)                                                      */
/*      SPRHBM (0x21e6035c)                                                     */
/*      SPRC0 (0x21e6035c)                                                      */
/*      SPRMCC (0x21e6035c)                                                     */
/*      SPRUCC (0x21e6035c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADLIMITADDR_0_M2MEM_MAIN_REG 0x0602035C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadlimitaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the system address[51:26]
                               upper limit of this particular prefetch region.
                               The system address needs to be less than or
                               equal to this value in order to be even
                               considered for eligibility to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADLIMITADDR_0_M2MEM_MAIN_STRUCT;

/* PREFETCHSADLIMITADDR_1_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e60360)                                                      */
/*      SPRB0 (0x21e60360)                                                      */
/*      SPRHBM (0x21e60360)                                                     */
/*      SPRC0 (0x21e60360)                                                      */
/*      SPRMCC (0x21e60360)                                                     */
/*      SPRUCC (0x21e60360)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADLIMITADDR_1_M2MEM_MAIN_REG 0x06020360

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadlimitaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the system address[51:26]
                               upper limit of this particular prefetch region.
                               The system address needs to be less than or
                               equal to this value in order to be even
                               considered for eligibility to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADLIMITADDR_1_M2MEM_MAIN_STRUCT;

/* PREFETCHSADLIMITADDR_2_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e60364)                                                      */
/*      SPRB0 (0x21e60364)                                                      */
/*      SPRHBM (0x21e60364)                                                     */
/*      SPRC0 (0x21e60364)                                                      */
/*      SPRMCC (0x21e60364)                                                     */
/*      SPRUCC (0x21e60364)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADLIMITADDR_2_M2MEM_MAIN_REG 0x06020364

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadlimitaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the system address[51:26]
                               upper limit of this particular prefetch region.
                               The system address needs to be less than or
                               equal to this value in order to be even
                               considered for eligibility to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADLIMITADDR_2_M2MEM_MAIN_STRUCT;

/* PREFETCHSADSTARTADDR_0_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e60368)                                                      */
/*      SPRB0 (0x21e60368)                                                      */
/*      SPRHBM (0x21e60368)                                                     */
/*      SPRC0 (0x21e60368)                                                      */
/*      SPRMCC (0x21e60368)                                                     */
/*      SPRUCC (0x21e60368)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADSTARTADDR_0_M2MEM_MAIN_REG 0x06020368

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefetchsaduseintlv : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               For XPT/UPI prefetch:[br] 0 (default): Use
                               channel interleave config 0, i.e. the interleave
                               specified by PrefetchSADchnl[0].[br] 1 : Use
                               channel interleave config 1, i.e. the interleave
                               specified by PrefetchSADchnl[1].[br]
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadregionenable : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               0 (default): Region is disabled. 1 : Region is
                               enabled.
                            */
    UINT32 prefetchsadstartaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the start system
                               address[51:26] (i.e. lower limit) of this
                               particular prefetch region. The system address
                               needs to be larger than or equal to this value
                               in order to be even considered for eligibility
                               to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADSTARTADDR_0_M2MEM_MAIN_STRUCT;

/* PREFETCHSADSTARTADDR_1_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e6036c)                                                      */
/*      SPRB0 (0x21e6036c)                                                      */
/*      SPRHBM (0x21e6036c)                                                     */
/*      SPRC0 (0x21e6036c)                                                      */
/*      SPRMCC (0x21e6036c)                                                     */
/*      SPRUCC (0x21e6036c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADSTARTADDR_1_M2MEM_MAIN_REG 0x0602036C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefetchsaduseintlv : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               For XPT/UPI prefetch:[br] 0 (default): Use
                               channel interleave config 0, i.e. the interleave
                               specified by PrefetchSADchnl[0].[br] 1 : Use
                               channel interleave config 1, i.e. the interleave
                               specified by PrefetchSADchnl[1].[br]
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadregionenable : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               0 (default): Region is disabled. 1 : Region is
                               enabled.
                            */
    UINT32 prefetchsadstartaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the start system
                               address[51:26] (i.e. lower limit) of this
                               particular prefetch region. The system address
                               needs to be larger than or equal to this value
                               in order to be even considered for eligibility
                               to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADSTARTADDR_1_M2MEM_MAIN_STRUCT;

/* PREFETCHSADSTARTADDR_2_M2MEM_MAIN_REG supported on:                          */
/*      SPRA0 (0x21e60370)                                                      */
/*      SPRB0 (0x21e60370)                                                      */
/*      SPRHBM (0x21e60370)                                                     */
/*      SPRC0 (0x21e60370)                                                      */
/*      SPRMCC (0x21e60370)                                                     */
/*      SPRUCC (0x21e60370)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Up to 3 XPT/UPI prefetch regions can be specified in the Mesh2Mem. Any prefetch with system address 
      outside these regions will be dropped by Mesh2Mem. So an XPT/UPI prefetch (for it to be considered) needs 
      to adhere to (i=0...2): [br]
        PrefetchSAD_start_addr_region[i] <= Addr < PrefetchSAD_limit_addr_region[i]
      For each region, the TAD_ID and the IsNMcache attribute needs to be specified. Any unused regions should 
      keep all these fields, including start and limit address, at 0.
      
*/


#define PREFETCHSADSTARTADDR_2_M2MEM_MAIN_REG 0x06020370

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefetchsaduseintlv : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               For XPT/UPI prefetch:[br] 0 (default): Use
                               channel interleave config 0, i.e. the interleave
                               specified by PrefetchSADchnl[0].[br] 1 : Use
                               channel interleave config 1, i.e. the interleave
                               specified by PrefetchSADchnl[1].[br]
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefetchsadregionenable : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               0 (default): Region is disabled. 1 : Region is
                               enabled.
                            */
    UINT32 prefetchsadstartaddr : 26;

                            /* Bits[28:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field specifies the start system
                               address[51:26] (i.e. lower limit) of this
                               particular prefetch region. The system address
                               needs to be larger than or equal to this value
                               in order to be even considered for eligibility
                               to this region.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADSTARTADDR_2_M2MEM_MAIN_STRUCT;

/* PREFETCHSADOVERRIDE_M2MEM_MAIN_REG supported on:                             */
/*      SPRA0 (0x21e6037c)                                                      */
/*      SPRB0 (0x21e6037c)                                                      */
/*      SPRHBM (0x21e6037c)                                                     */
/*      SPRC0 (0x21e6037c)                                                      */
/*      SPRMCC (0x21e6037c)                                                     */
/*      SPRUCC (0x21e6037c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register provides overrides to the default memory channel interleave calculations.
      
*/


#define PREFETCHSADOVERRIDE_M2MEM_MAIN_REG 0x0602037C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hbmenableconfig0 : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set to 1, the HBM tile will enable the
                               regular prefetch SAD config from
                               PrefetchSADconfig[0] instead of using the HBM
                               Hashed XOR calculation. This is intended for
                               debug purposes only. The non-HBM tiles will
                               ignore this field.
                            */
    UINT32 hbmdefeaturexor : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set to 1, the HBM tile will disable the XOR
                               into Addr[10:8] (ie. Addr[10:8] ^ Addr[16:14] ^
                               Addr[24:22]) and will simply pass through
                               Addr[10:8] into the PrefetchSADconfig[1]
                               logical-to-physical mapping. This is intended
                               for debug purposes only. The non-HBM tiles will
                               ignore this field.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHSADOVERRIDE_M2MEM_MAIN_STRUCT;

/* CREDITS_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e60384)                                                      */
/*      SPRB0 (0x21e60384)                                                      */
/*      SPRHBM (0x21e60384)                                                     */
/*      SPRC0 (0x21e60384)                                                      */
/*      SPRMCC (0x21e60384)                                                     */
/*      SPRUCC (0x21e60384)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      This register is used to initialize and/or read current credit values of non-CMI credits in M2M. Example credits are M2M trangress (ingress) credits, 
      M2M cross-tile (ingress) credits, UPI agent credits (for D2K data from M2M) and XPT prefetch (ingress) credits.
      Note that the programmer of this register when initializing credits must select credit values such that the total number of ingress credits (ingress credits given to CHA + M2M cross-tile ingress credits + M2M transgress (ingress) credits + XPT prefetch (ingress) credits)
      doesn't exceed the ingressQ size. AD ingressQ size is 104. BL ingressQ size is 112.
      
*/


#define CREDITS_M2MEM_MAIN_REG 0x06020384

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 crdtcnt : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Credit Count (CrdtCnt): Credit value to be
                               written into the credit counter (if CrdtWrEn),
                               or credit value read from the credit counter (if
                               CrdtRdEn).
                            */
    UINT32 rsvd : 2;

                            /* Bits[9:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crdttype : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000000*/

                            /*
                               Credit Type (CrdtType): Credit type to be
                               written/read. CrdtType[6]: 0: Register use is to
                               program credits. 1: Register use is to program
                               NMC logical IDs (relevant in the FMC tile to
                               program MeshStopIds of the NMC tiles in cross-
                               tile mode). Not applicable to SNR/ICX
                               If(CrdtType[6] == 1): -- Not applicable to
                               SNR/ICX CrdtType[5:4] bits are irrelevant;
                               CrdtType[3:0] = NM logical id (0...11).
                               Credits.CrdtCnt needs to be set up with the
                               physical MeshStopId of that NMC. If(CrdtType[6]
                               == 0): In general the upper 2 bits indicate the
                               physical memory channel except encoding 11 The
                               four lsb's encode the credit type.
                               If(CrdtType[5:4] == 11): -- Not applicable to
                               SNR/ICX XTILE_NM_BL credits on this FMCTILE for
                               each NMC xtile target: CrdtType[3:0] is the
                               logical NMC id (0...11). If(CrdtType[5:4] !=
                               11): CrdtType[5:4] determines which KTI/Chnl/FMC
                               are we programming the credit for 00: Physical
                               Memory Channel 0 / Intel UPI 0 / FMC 0 01:
                               Physical Memory Channel 1 / Intel UPI 1 / FMC 1
                               10: Physical Memory Channel 2 / Intel UPI 2
                               CrdtType[3:0] (* = minimum 2 credits): 0000:
                               RSVD 0001: RSVD 0010: BLCRD (M2M internal AKC
                               egress credits) : Program minimum 1 credit.
                               0011: BLCMP (M2M internal AK wr-Cmp egress
                               credits) : program minimum 1 credit. Max is 63
                               on NM tile max, and max is 62 on FM tile (2
                               entries reserved for fmmiss dual completion).
                               0100: RSVD 0101: XTILE_BL_LOW_BW. BL low_bw
                               xtile credits (program this NMC for each FMC)
                               per FMC. Not applicable to SNR/ICX 0110:
                               XTILE_AD credits (program this NMC for each FMC)
                               per FMC. Not applicable to SNR/ICX 0111:
                               XTILE_BL credits (program this NMC for each FMC)
                               per FMC. Not applicable to SNR/ICX 1000: ST_TRK.
                               Store Tracker credits * (shared between DDR4 and
                               DDRT) per channel. 1001: RSVD 1010: RSVD 1011:
                               PREF. Ingress PrefetchQ * (min 2 credits). 1100:
                               AD_TGR. AD Ingress TransgressedQ. 1101: BL
                               Ingress TransgressedQ. 1110: RSVD 1111: UPI_BL.
                               Intel UPI agent per UPI (for D2K data to UPI
                               agent).
                            */
    UINT32 crdtrden : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Credit Read Enable (CrdtRdEn): Read the credit
                               counter as specified by the Credit Type field.
                               The result of the read is available in the
                               Credit Count field.
                            */
    UINT32 crdtwren : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Credit Write Enable (CrdtWrEn): Write the credit
                               counter as specified by the Credit Type field
                               with the value from the Credit Count field.
                               Software must ensure that this MC tile is
                               quiesced (i.e. all credits were returned to the
                               credit counter) when setting this Write Enable
                               bit. If not quiesced then queue overflows and
                               queue state corruption can potentially occur.
                            */
    UINT32 crdtinitorcurr : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used on a along with a read to
                               determine if the values read are the initial
                               values or the current values. 0- read initial
                               values 1- read current values Has no effect on
                               writes.
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CREDITS_M2MEM_MAIN_STRUCT;

/* CREDITTHRESHOLDS_M2MEM_MAIN_REG supported on:                                */
/*      SPRA0 (0x21e60394)                                                      */
/*      SPRB0 (0x21e60394)                                                      */
/*      SPRHBM (0x21e60394)                                                     */
/*      SPRC0 (0x21e60394)                                                      */
/*      SPRMCC (0x21e60394)                                                     */
/*      SPRUCC (0x21e60394)                                                     */
/* Register default value on SPRA0: 0x00010000                                  */
/* Register default value on SPRB0: 0x00010000                                  */
/* Register default value on SPRHBM: 0x00010000                                 */
/* Register default value on SPRC0: 0x00010000                                  */
/* Register default value on SPRMCC: 0x00010000                                 */
/* Register default value on SPRUCC: 0x00010000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      This register contains the thresholds for commands sent by Mesh2Mem to a memory channel.
      It contains both thresholds for isochronous transactions, as well as BGF thresholds.
      The isochronous thresholds are required to provide isochronous latency guarantees. 
      The BGF thresholds are required to prevent BGF overflows and might need to be set slightly 
      different for certain clock ratios.

      Isoch is not supported if DDRT is present on a channel. DDRT scheduling and Isoch enabling are 
      mutually exclusive.
      
*/


#define CREDITTHRESHOLDS_M2MEM_MAIN_REG 0x06020394

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 forkedreturna0thresh : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mesh A0 threshold for forked data return :
                               FmTile issues a forked data return on A0 add
                               interface only if mesh credits are above this
                               threshold
                            */
    UINT32 forkedreturna1thresh : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000000*/

                            /*
                               Mesh A1 threshold for forked data return :
                               FmTile issues a forked data return on A1 add
                               interface only if mesh credits are above this
                               threshold
                            */
    UINT32 bgfmultiplier : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               BGF level signals need to be asserted for
                               X*2^(BGFMultiplier) cycles before we consume
                               them M2mMcBgfEmpty : X=5 ->used to deremine all
                               sbdeallocs/wrcmps have been issued McDrained :
                               X=32 -> used to determine mc is drained after a
                               req has been issued from m2mem to mc
                            */
    UINT32 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 critd2kthresh : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000001*/

                            /*
                               Critical Priority D2K Threshold (CritD2KThresh):
                               This field defines the critical priority D2K
                               credit threshold. If the number of Intel UPI
                               credits for a channel is lower than or equal to
                               the threshold those credits (and buffer entries)
                               are reserved for critical priority D2K messages
                               and cannot be used by regular D2K messages.
                            */
    UINT32 d2kmeshcreditthresh : 5;

                            /* Bits[22:18], Access Type=RW, default=0x00000000*/

                            /*
                               D2K Mesh Credit threshold: The number of
                               available CMS egress credits must be larger than
                               the value programmed in this threshold in order
                               to allow D2K data responses to be issued. This
                               can be used to prevent overcongestion on the
                               mesh due to heavy D2K traffic all targeting one
                               particular row. The CMS egress credits on both
                               AddPorts must be larger than this threshold to
                               issue D2K, otherwise, the data response will go
                               to CHA. If programmed to 0x0 (default), D2K will
                               not be throttled due to CMS credits
                            */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CREDITTHRESHOLDS_M2MEM_MAIN_STRUCT;

/* PREFETCHTUNING0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e603b8)                                                      */
/*      SPRB0 (0x21e603b8)                                                      */
/*      SPRHBM (0x21e603b8)                                                     */
/*      SPRC0 (0x21e603b8)                                                      */
/*      SPRMCC (0x21e603b8)                                                     */
/*      SPRUCC (0x21e603b8)                                                     */
/* Register default value on SPRA0: 0x01000A0A                                  */
/* Register default value on SPRB0: 0x01000A0A                                  */
/* Register default value on SPRHBM: 0x01000A0A                                 */
/* Register default value on SPRC0: 0x01000A0A                                  */
/* Register default value on SPRMCC: 0x01000A0A                                 */
/* Register default value on SPRUCC: 0x01000A0A                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      These prefetch tuning registers (PrefetchTuning0 and PrefetchTuning1) contain the thresholds to limit
      allocation of available bandwidth to local (XPT) prefetches and remote (Intel UPI) prefetches and
      guarantee a minimal bandwidth allocation to non-speculative reads and writes. A prefetch in this context maps to  
      a MemSpecRd command.

      Both XPT and Intel UPI prefetch flows aim to save latency at the possible expense of fetching 
      unneeded data from memory.  An Intel UPI/XPT prefetch will prefetch a cache line from memory before 
      even knowing whether there might be a cache hit in the cache associated with the home agent CHA.
      The M2M prefetch CAM accomodates a maximum of 30 prefetches per M2M (split into 3 equal fixed chunks of 10
      per iMC channel).  Each 10 entries of the CAM is shared across XPT, Intel UPI MemSpecRds.

      It is allowed to reprogram this register on-the-fly, while memory traffic is flowing.  In order to disable
      one or more of the thresholds, simply program a given threshold to all ones (which will ensure the threshold
      will never be exceeded).  The PfTuningEn will disable all prefetch tuning (regardless of thresholds).
      
*/


#define PREFETCHTUNING0_M2MEM_MAIN_REG 0x060203B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefkticamthreshold : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000000A*/

                            /*
                               Intel UPI Prefetch CAM Threshold
                               (PrefKTICamThreshold) per-channel: Prefetch CAM
                               valid entries threshold for dropping Intel UPI
                               prefetches. The prefetch CAM can only support up
                               to 10 entries per channel so any value greater
                               than 10 will disable all Intel UPI prefetches
                               across all 3 channels. This threshold prevents
                               too many Intel UPI prefetches from being
                               outstanding (i.e. throttle back speculative,
                               unnecessary read bandwidth) and hence allows a
                               trade-off to be made between power and
                               performance. Also, by setting the XPT and Intel
                               UPI thresholds differently, one can allow a
                               slight bias of one versus the other. If the
                               number of occupied CAM entries is larger than or
                               equal to the threshold then Intel UPI prefetches
                               will not allocate in the prefetch CAM and get
                               dropped instead. If power is the primary
                               optimization vector (instead of performance)
                               then it is suggested to program this threshold
                               to a low value (e.g. in the range 0...3). For
                               absolute performance (at the cost of power) a
                               value of 10 might be good.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 prefxptcamthreshold : 5;

                            /* Bits[12:8], Access Type=RW, default=0x0000000A*/

                            /*
                               XPT Prefetch CAM Threshold (PrefXPTCamThreshold)
                               per-channel: Prefetch CAM valid entries
                               threshold for dropping local (=XPT) prefetches.
                               The prefetch CAM can only support up to 10
                               entries per channel so any value greater than 10
                               will disable all XPT prefetches across all 3
                               channels. This threshold prevents too many XPT
                               prefetches from being outstanding (i.e. throttle
                               back speculative, unnecessary read bandwidth)
                               and hence allows a trade-off to be made between
                               power and performance. Also, by setting the XPT
                               and Intel UPI thresholds differently, one can
                               allow a slight bias of one versus the other. If
                               the number of occupied CAM entries is larger
                               than or equal to the threshold then XPT
                               prefetches will not allocate in the prefetch CAM
                               and get dropped instead. If power is the primary
                               optimization vector (instead of performance)
                               then it is suggested to program this threshold
                               to a low value (e.g. in the range 0...3). For
                               absolute performance (at the cost of power) a
                               value of 10 might be good.
                            */
    UINT32 rsvd_13 : 11;

                            /* Bits[23:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pftuningen : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /* Enable bit for prefetch tuning thresholds. */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHTUNING0_M2MEM_MAIN_STRUCT;

/* PREFETCHTUNING1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e603bc)                                                      */
/*      SPRB0 (0x21e603bc)                                                      */
/*      SPRHBM (0x21e603bc)                                                     */
/*      SPRC0 (0x21e603bc)                                                      */
/*      SPRMCC (0x21e603bc)                                                     */
/*      SPRUCC (0x21e603bc)                                                     */
/* Register default value on SPRA0: 0x000C1840                                  */
/* Register default value on SPRB0: 0x000C1840                                  */
/* Register default value on SPRHBM: 0x000C1840                                 */
/* Register default value on SPRC0: 0x000C1840                                  */
/* Register default value on SPRMCC: 0x000C1840                                 */
/* Register default value on SPRUCC: 0x000C1840                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      See PrefetchTuning0 for description of these registers.
      
*/


#define PREFETCHTUNING1_M2MEM_MAIN_REG 0x060203BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prefrpqproxythreshold : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000040*/

                            /*
                               Prefetch RPQ Proxy Threshold
                               (PrefRPQProxyThreshold): RPQ buffer entries
                               threshold for dropping prefetches. Prevents
                               prefetches from grabbing bandwidth if read
                               bandwidth is already high. If the number of RPQ
                               entries occupied in (at least) one memory
                               channel is equal to or greater than this
                               threshold then incoming prefetch commands get
                               dropped. This specifies the threshold of the RPQ
                               Proxy count over which prefetches will be
                               dropped. This is accomplished by taking a sum of
                               the read tracker entries targetting a given
                               channel plus the number of prefetch tracker
                               entries targetting the same channel plus AD
                               Ingress entries targeting the same channel. If
                               the sum ever exceeds this threshold, then
                               MemSpecRd requests will be dropped. This
                               prevents prefetches from grabbing bandwidth if
                               read bandwidth is high.
                            */
    UINT32 prefwpqproxythresholdblingr : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000018*/

                            /*
                               Prefetch WPQ Proxy Threshold for BL Ingress
                               (PrefWPQProxyThresholdBlIngr): This specifies
                               the threshold of the WPQ Proxy for BL Ingress
                               count over which prefetches will be dropped.
                               This is accomplished by taking a sum of the
                               write store tracker entries targetting a given
                               channel plus the number of BL Ingress Linked-
                               List entries targeting the same channel. If the
                               sum ever exceeds this threshold, then MemSpecRd
                               requests will be dropped. This prevents
                               prefetches from grabbing bandwidth if write
                               bandwidth is high.
                            */
    UINT32 prefwpqproxythresholdcmi : 5;

                            /* Bits[20:16], Access Type=RW, default=0x0000000C*/

                            /*
                               Prefetch WPQ Proxy Threshold for BL CMI Writes
                               (PrefWPQProxyThresholdCmi): This specifies the
                               threshold of the WPQ Proxy for CMI Writes count
                               over which prefetches will be dropped. This is
                               accomplished by tracking the number of writes
                               sent to CMI over a sliding 64-cycle window. If
                               the count ever exceeds this threshold, then
                               MemSpecRd requests will be dropped. Note that a
                               write to CMI can only occur once every 4 clocks,
                               so the maximum number of writes in a 64-cycle
                               window is 16. This prevents prefetches from
                               grabbing bandwidth if write bandwidth is high.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PREFETCHTUNING1_M2MEM_MAIN_STRUCT;

/* SYSFEATURES0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e603c8)                                                      */
/*      SPRB0 (0x21e603c8)                                                      */
/*      SPRHBM (0x21e603c8)                                                     */
/*      SPRC0 (0x21e603c8)                                                      */
/*      SPRMCC (0x21e603c8)                                                     */
/*      SPRUCC (0x21e603c8)                                                     */
/* Register default value on SPRA0: 0x02880091                                  */
/* Register default value on SPRB0: 0x02880091                                  */
/* Register default value on SPRHBM: 0x02880091                                 */
/* Register default value on SPRC0: 0x02880091                                  */
/* Register default value on SPRMCC: 0x02880091                                 */
/* Register default value on SPRUCC: 0x02880091                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
      This register contains m2m features which BIOS might need to set differently based on 
      either the system topology/configuration or for performance/power reasons.

      A single socket system is expected to at least configure following (different from reset values):
        CHA HA_COH_CFG[Dis_Directory] = 1 (functionality)
        M2M SysFeatures[FrcDirI]      = 1 (functionality)
        M2M SysFeatures[DirWrDisable] = 1 (performance)

      A multi-socket directory disabled system is expected to at least configure following (different from reset values):
        CHA HA_COH_CFG[Dis_Directory] = 1 (functionality)
        M2M SysFeatures[D2kDisable]   = 1 (functionality)
        M2M SysFeatures[D2cDisable]   = 1 (functionality)
        M2M SysFeatures[DirWrDisable] = 1 (performance)
      
*/


#define SYSFEATURES0_M2MEM_MAIN_REG 0x060203C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fminsametile : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               This bit is used to indicate whether far memory
                               is available in same/local tile or is available
                               in some other tile. 0 : indicates far memory is
                               in a different tile. 1: indicates far memory is
                               in the same tile.
                            */
    UINT32 d2cdisable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Direct-to-core disable (D2cDisable): 0: D2C
                               enabled. 1: Disable direct-to-core data return.
                               Data is sent to CHA instead, even if CHA set the
                               d2c bit on the incoming request. BIOS has to
                               disable D2C in multi-socket systems with dir-
                               disabled (for functionality). It is illegal to
                               enable D2C in multi-socket systems with dir-
                               disabled.
                            */
    UINT32 d2kdisable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Direct-to-Intel UPI disable (D2kDisable): 0: D2K
                               enabled. 1: Disable direct-to-Intel UPI data
                               return. Data is sent to CHA instead, even if CHA
                               set the d2k bit on the incoming request. BIOS
                               has to disable D2K in multi-socket systems with
                               dir-disabled (for functionality). It is illegal
                               to enable D2K in multi-socket systems with dir-
                               disabled.
                            */
    UINT32 prefdisable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Prefetch disable (PrefDisable): Disable
                               prefetching in M2M/MC: 0: Prefetching enabled,
                               i.e. MemSpecRd handling enabled. 1: An incoming
                               MemSpecRd will be dropped. For performance,
                               especially latency reduction, prefetch should be
                               enabled. For any M2M that is in mirror mode,
                               prefetching should be disabled by setting this
                               bit to 1 If power is more important than this
                               incremental performance improvement then disable
                               this feature.
                            */
    UINT32 dirwrdisable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Disable directory writes (DirWrDisable): 0: MC
                               directory writes are enabled. 1: MC directory
                               writes are disabled (default). Only legal
                               configs where MC directory writes can be
                               disabled are: - when single socket system, or -
                               when directory disabled in the system. BIOS
                               should set this bit to 1 for above configs (for
                               performance).
                            */
    UINT32 frcdiri : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Force dirI (FrcDirI): Force the directory state
                               read from memory to Invalid, for new dir
                               calculation (exception: poison/uncorr stays
                               poison) and for dir delivery to CHA (here
                               Invalid will override poison). 0: interpret
                               directory from memory as-is. 1: override
                               directory S/A/(P) read from memory with I. BIOS
                               needs to set this bit to 1 if single socket.
                            */
    UINT32 mapdirstodira : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Map dirS to dirA (MapDirStoDirA): Upgrade dirS
                               to memory to dirA. It also prevents DataC_S_CmpO
                               D2K (when dirS no longer present in memory). 0:
                               dont override dirS with dirA (default). 1: dirS
                               wr to memory gets replaced with dirA wr.
                               Guideline is to keep at 0 for performance. Note
                               that taking out directory shared state might
                               result in less directory writes. Some usage
                               models might prefer less directory writes.
                            */
    UINT32 immediatefailoveractionena : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Immediately Failover Action Enable
                               (ImmediateFailoverActionEna): 0: Do not failover
                               a channel when mirror scrub read returns
                               uncorrectable data. Instead BIOS has the smarts
                               and decision power to either (i) do nothing, or
                               to (ii) failover the complete channel through
                               the MirrorFailover register. 1: Hardware will
                               permanently failover the channel when a mirror
                               scrub read returns uncorrectable data. Hardware
                               will set the appropriate failover bit in
                               MirrorFailover. When this bit is set, also
                               XPT/Intel UPI prefetch needs to be disabled in
                               the core and at the Intel UPI agent
                               respectively, and Defeatures0[IngBypDis] need to
                               be set. In other words, in mirroring hardware
                               failover mode, both XPT prefetch and ingress
                               bypass need to be disabled.
                            */
    UINT32 ptlwrfailoverlogdis : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Partial writes failover logging disable
                               (PtlWrFailoverLogDis): Disable failover error
                               logging and signaling in case of a partial
                               write. 0: Allow m2m failover error logging and
                               signaling for a partial write. 1: Disable m2m
                               failover error logging and signaling for a
                               partial write. Usage model: BIOS can choose to
                               set this disable when
                               ImmediateFailoverActionEna==0 and
                               TAD.Secondary1st==1. In this config, partial
                               writes would still go to both mirror channels
                               even though reads go to secondary channel. If
                               BIOS determines there is a frequent and
                               undesired signaling and logging storm of (known)
                               failover events from partial writes accessing
                               the bad primary region, then BIOS can set this
                               defeature bit. Note, no partial write errors on
                               ANY of the channels associated with the m2m will
                               be signaled nor logged from that point onwards
                               in m2m. This defeature is failover event
                               specific; other partial write errors like
                               uncorrectables will still get signaled.
                            */
    UINT32 frcwrni : 1;

                            /* Bits[9:9], Access Type=RW/V, default=0x00000000*/

                            /*
                               Blindly forces inclusive writes to behave as
                               non-inclusive writes, i.e. forces a read of the
                               NMC state to determine whether NMC hit or miss
                               before performing the write. No error is
                               generated if there is a miss for the inclusive
                               write. BIOS needs to set this bit after certain
                               memory errors. If the patrol scrubber reports an
                               uncorrectable error in NMC then this bit needs
                               to be set.
                            */
    UINT32 d2cinvertncpolarityen : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Invert Non-critical Chunk Polarity for
                               Direct-2-Core: When direct-to-core data return
                               is enabled (i.e. D2C), the D2C traffic can be
                               optimized to utilize more of the mesh bandwidth
                               when there is an imbalance on the number of
                               destination cores behind the two Add ports. This
                               imbalance would typically be seen if cores are
                               being disabled on the chip, thus, causing a
                               reduction in overall mesh utilization if one
                               port has more D2C traffic than the other.
                               Enabling this feature allows the 2nd-half
                               cacheline (i.e. non-critical 32B chunk) to be
                               sent on the opposite polarity of the 1st-half
                               (i.e. critical 32B chunk) to provide improved
                               mesh bandwidth utilization. 1: Invert the non-
                               critical chunk polarity for D2C. 0: Optimization
                               is disabled: non-critical chunk will use the
                               same polarity as critical chunk.
                            */
    UINT32 immediatefailoveractionenaddrt : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Immediately Failover Action Enable for DDRT
                               (ImmediateFailoverActionEnaDdrt): 0: Do not
                               failover a channel when mirror scrub read
                               returns uncorrectable data on DDRT. Instead BIOS
                               has the smarts and decision power to either (i)
                               do nothing, or to (ii) failover the complete
                               channel through the MirrorFailover register. 1:
                               Hardware will permanently failover the channel
                               when a mirror scrub read returns uncorrectable
                               data. Hardware will set the appropriate failover
                               bit in MirrorFailover. When this bit is set,
                               also XPT/Intel UPI prefetch needs to be disabled
                               in the core and at the Intel UPI agent
                               respectively, and Defeatures0[IngBypDis] need to
                               be set. In other words, in mirroring hardware
                               failover mode, both XPT prefetch and ingress
                               bypass need to be disabled. Note: this register
                               will only take effect if
                               SysFeatures0[ImmediateFailoverActionEna] is also
                               enabled.
                               SysFeatures0[ImmediateFailoverActionEna] alone
                               will enable HW failover on DDR4 channels,
                               setting this register enables HW failover for
                               both DDR4 and DDRT mirrored channels.
                            */
    UINT32 ddr4npwren : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4 Non-Posted Write Enable (DDR4NPWrEn): Send
                               writes bound for the DDR4 dstid that do not
                               require a CMI response for any reason other than
                               GO tracking as non-posted. 0: Send DDR4 writes
                               as posted if applicable. 1: Send all DDR4 writes
                               as non-posted.
                            */
    UINT32 ddrtnpwren : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT Non-Posted Write Enable (DDRTNPWrEn): Send
                               writes bound for the DDRT dstid that do not
                               require a CMI response for any reason other than
                               GO tracking as non-posted. 0: Send DDRT writes
                               as posted if applicable. 1: Send all DDRT writes
                               as non-posted.
                            */
    UINT32 twolmnpwren : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               2LM Non-Posted Write Enable (TwoLMNPWrEn): Send
                               writes bound for the 2LM dstid that do not
                               require a CMI response for any reason other than
                               GO tracking as non-posted. 0: Send 2LM writes as
                               posted if applicable. 1: Send all 2LM writes as
                               non-posted.
                            */
    UINT32 dedupnpwren : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Dedup Non-Posted Write Enable (DedupNPWrEn):
                               Send writes bound for the Dedup dstid that do
                               not require a CMI response for any reason other
                               than GO tracking as non-posted. 0: Send Dedup
                               writes as posted if applicable. 1: Send all
                               Dedup writes as non-posted.
                            */
    UINT32 ddrt_exists : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* This bit is used to indicate if DDRT exists. */
    UINT32 numegrentries4cisgr : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000004*/

                            /*
                               HBM Memory Controller mode: When this is set to
                               a non-zero value, this indicates that the M2M is
                               in an HBM configuration and this Memory
                               controller handles the Near Memory(HBM). Setting
                               this to a non-zero value has no effect if this
                               Memory controller is the Far Memory (DDR) tile
                               or if this is a non-HBM product. The value
                               programmed in this register indicates the number
                               of egress credits reserved for HBM cisgress
                               traffic such as Route-through requests to Far
                               Memory and other requests in 2LM flows. The
                               maximum legal value is 8. 0: This M2M is not a
                               Near Memory controller in cross-tile 2LM. 1-8:
                               This M2M is a Near Memory controller in cross-
                               tile 2LM and this is the number of reserved
                               egress credits for cisgress.
                            */
    UINT32 akearlycmpen : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               AK early cmp enable: Only for 1S configs, when
                               set M2M will send AK completions to CHA for
                               reads with D2C set or MemInv transactions
                               without waiting for data to return from MC. For
                               2LM/DDRT reads, M2M will send the cmp out as
                               soon as it has received the accept response from
                               scoreboard. For reads that do not allocate into
                               the scoreboard, the cmp will be sent out as soon
                               as the read command has been sent to MC.
                            */
    UINT32 cmipriorityen : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               CMI Priority Enable: Only for systems that
                               support priority transactions (such as FXR),
                               when set M2M will look at the priority encoding
                               (PE) on the mesh for a given transaction. This
                               PE bit will be set by CHA for transactions that
                               require priority, and when set, M2M send the
                               request to CMI with the priority level
                               programmed in the Sysfeatures0[CMIRd/WrPriority]
                               CSR. This feature should not be enabled together
                               with ISOCH. If this is disabled, but ISOCH is
                               enabled, then ISOCH transactions will be sent
                               with to CMI with the priority encodings
                               programmed in Sysfeatures0[CMIRd/WrPriority].
                            */
    UINT32 cmirdpriority : 2;

                            /* Bits[24:23], Access Type=RW, default=0x00000001*/

                            /*
                               CMI Rd Priority Level: Send read transactions
                               that had priority indication (PE) set, such as
                               ISOCH or FXR txns, to CMI with the following
                               priority encodings such that MC will prioritize
                               the request accordingly: 00 - low priority 01 -
                               med priority 10 - high priority 11 - critical
                               priority
                            */
    UINT32 cmiwrpriority : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000001*/

                            /*
                               CMI Wr Priority Level: Send write transactions
                               that had priority indication (PE) set, such as
                               ISOCH or FXR txns, to CMI with the following
                               priority encodings such that MC will prioritize
                               the request accordingly: 00 - low priority 01 -
                               med priority 10 - high priority 11 - critical
                               priority
                            */
    UINT32 buriedm : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               XNC BuriedM mode: When this bit is set to 1, it
                               indicates to M2M that the system is in an XNC
                               configuration with the possibility of BuriedM.
                               On receiving a MemRdXtoS request, M2M will
                               transition directory state from A to S only if
                               this bit is not set.
                            */
    UINT32 cfg2sd2kopten : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               2 Socket Direct-to-Intel UPI Optimization: When
                               direct-to-Intel UPI data return is enabled (i.e.
                               D2K), data can be sent directly to UPI as long
                               as it is allowed by the results of the directory
                               lookup. Enabling this optimization allows for 2S
                               systems to perform D2K regardless of the
                               directory lookup results. 1: 2S D2K optimization
                               enabled. No effect if D2K is disabled. Note:
                               this is only intended for 2S configurations. It
                               is illegal to enable this optimization in > 2S
                               systems. 0: 2S D2K optimization disabled.
                            */
    UINT32 egrcmirdpriorityen : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CMI Priority for reads in Egress: For
                               systems with CMI priority enabled, M2M will send
                               any read request that came from the mesh with
                               priority bit set (such as FXR transactions) to
                               MC with the priority encoding programmed in
                               SysFeatures0[CMIRdPriority]. M2M continues to
                               use the appropriate VC (non-isoch) virtual
                               channel to schedule these requests, however, M2M
                               egress can prioritize the request when sending
                               responses to the mesh. Setting this bit enables
                               prioritization for such reads in egress.
                            */
    UINT32 disabledir4appdirect : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Directory for 1LM App Direct ranges.
                               Setting this bit the entire App Direct DDRT
                               region into snoopy mode rather than the
                               directory based protocol. The result is that all
                               read accesses to this region will ignore the
                               directory bits returned from MC, SNP_ALL is sent
                               to CHA, and no directory update would occur.
                               Consequently, D2C/D2K will be prevented from
                               occurring for such reads. All other memory
                               ranges may still be in directory mode 1: Disable
                               Directory for 1LM App Direct region 0: 1LM App
                               Direct region follows the directory enabled or
                               disabled mode of the system NOTE: In single
                               socket configs, if SysFeatures0.AkEarlyCmpEn is
                               set to 0x1, then DisableDir4AppDirect should
                               also be set to 0x0. Since directory updates do
                               not occur in single socket, setting this will
                               have no effect on directory, however,
                               SysFeatures0.AkEarlyCmpEn relies on D2C to occur
                               so DisableDir4AppDirect needs to be set to 0x0
                               prevent D2C from getting squashed.
                            */
    UINT32 enable2lmdiropt : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 2LM directory optimization. Setting this
                               bit will enable a directory optimization in 2LM
                               mode where directory-only writes to the near
                               memory cache will be written as cachestate
                               CLEAN, rather than DIRTY or METADATA_DIRTY. By
                               doing this, any time a line is being evicted
                               from the cache and only the directory has
                               changed and no change to the data, the cacheline
                               will be silently dropped (i.e. clean eviction)
                               in order to save DDRT write BW. Anytime the line
                               is being refetched from far memory, the
                               directory state will be treated as SNOOP_ALL in
                               order to maintain coherency. 1: Enable 2LM
                               Directory optimization 0: 2LM Directory
                               optimization is disabled
                            */

  } Bits;
  UINT32 Data;

} SYSFEATURES0_M2MEM_MAIN_STRUCT;

/* TIMEOUT_M2MEM_MAIN_REG supported on:                                         */
/*      SPRA0 (0x21e603d0)                                                      */
/*      SPRB0 (0x21e603d0)                                                      */
/*      SPRHBM (0x21e603d0)                                                     */
/*      SPRC0 (0x21e603d0)                                                      */
/*      SPRMCC (0x21e603d0)                                                     */
/*      SPRUCC (0x21e603d0)                                                     */
/* Register default value on SPRA0: 0x0000002D                                  */
/* Register default value on SPRB0: 0x0000002D                                  */
/* Register default value on SPRHBM: 0x0000002D                                 */
/* Register default value on SPRC0: 0x0000002D                                  */
/* Register default value on SPRMCC: 0x0000002D                                 */
/* Register default value on SPRUCC: 0x0000002D                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      Allows setting of time-out values. The timeout thresholds are set here by BIOS, and if a timeout is detected they will be reported in the MCA MSRs to the OS and the MCA shadow registers to OS.
      It is suggested to set the time-out values to the highest possible values while respecting the time-out hierarchy: 
        core 3-strike time-out > Caching Agent CHA > Home Agent CHA > Memory Controller
      As a rule of thumb, it is suggested to scale the absolute time-out values with a factor of 2 when moving by a level through the hierarchy. 
      Highest possible values are suggested to prevent false time-outs from happening in extreme conditions like extremely high error rates or compound error cases (e.g. Intel UPI and MC errors) in combination with very high memory bandwidths.
      
*/


#define TIMEOUT_M2MEM_MAIN_REG 0x060203D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 timeouten : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Timeout Enable bit (TimeoutEn): 1: Enabled; 0:
                               Timeouts are disabled. When time-out detection
                               is disabled, it also implies that timeout
                               signaling (MCA/SMI/CMCI) is disabled including
                               its usage as a debug event/trigger.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 timeoutbase : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000003*/

                            /*
                               Tracker Timeout Base Unit (TimeoutBase): 0: Time
                               base is 24=32 uncore cycles. A tracker that
                               exceeds (TimeoutMult+1)*24 cycles will timeout,
                               but may not be detected until
                               (TimeoutMult+1)*2(4+1) cycles later. Max
                               programmable time-out of 33K uncore cycles. 1:
                               Time base is 212=8K uncore cycles. A tracker
                               that exceeds (TimeoutMult+1)*212 cycles will
                               timeout, but may not be detected until
                               (TimeoutMult+1)*2(12+1) cycles later. Max
                               programmable time-out of 8.4M uncore cycles). 2:
                               Time base is 220=2.1M uncore cycles. A tracker
                               that exceeds (TimeoutMult+1)*220 cycles will
                               timeout, but may not be detected until
                               (TimeoutMult+1)*2(20+1) cycles later. Max
                               programmable time-out of 2.1G uncore cycles. 3:
                               Time base is 228=537M uncore cycles. A tracker
                               that exceeds (TimeoutMult+1)*228 cycles will
                               timeout, but may not be detected until
                               (TimeoutMult+1)*2(28+1) cycles later. Max
                               programmable time-out of 549G uncore cycles.
                            */
    UINT32 timeoutmult : 9;

                            /* Bits[12:4], Access Type=RW, default=0x00000002*/

                            /*
                               Timeout Multiplier (TimeoutMult): The absolute
                               time-out value (in seconds) will be: Multiplier
                               x Base (in cycles) / mesh frequency (in Hz).
                               There is variability in this absolute time
                               because of dynamic frequency changes (Turbo).
                               Because of implementation details there is also
                               an uncertainty of plus a Base Unit on the
                               transaction that times out. All transactions
                               timing out within this Base Unit interval are
                               treated as timing out at the same time and only
                               one of them will be reported (the one with the
                               lowest tracker index). The equation above
                               presents the lower bound of the time-out.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TIMEOUT_M2MEM_MAIN_STRUCT;

/* TOPOLOGY_M2MEM_MAIN_REG supported on:                                        */
/*      SPRA0 (0x21e603d8)                                                      */
/*      SPRB0 (0x21e603d8)                                                      */
/*      SPRHBM (0x21e603d8)                                                     */
/*      SPRC0 (0x21e603d8)                                                      */
/*      SPRMCC (0x21e603d8)                                                     */
/*      SPRUCC (0x21e603d8)                                                     */
/* Register default value on SPRA0: 0x00000FC0                                  */
/* Register default value on SPRB0: 0x00000FC0                                  */
/* Register default value on SPRHBM: 0x00000FC0                                 */
/* Register default value on SPRC0: 0x00000FC0                                  */
/* Register default value on SPRMCC: 0x00000FC0                                 */
/* Register default value on SPRUCC: 0x00000FC0                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      Configuration register related to system/socket topology.
      The socket topology information is needed for PRE info in direct-to-core (D2C), and 
      PCLS info in BL MemData. More specifically, the PRE and PCLS fields 
      in data packets carry information about SNC cluster remoteness.
      
*/


#define TOPOLOGY_M2MEM_MAIN_REG 0x060203D8

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mynid : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               My NID (MyNID): NodeID of this MC (more
                               accurately, this mesh2mem).
                            */
    UINT32 sncluster : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               NOT USED ANYMORE. SNC cluster (SNCluster): SNC
                               cluster this m2m belongs to: cluster 1 or 0.
                            */
    UINT32 basecluster1 : 7;

                            /* Bits[12:6], Access Type=RW, default=0x0000003F*/

                            /*
                               < Base of Cluster 1 (BaseCluster1): Core ID of
                               the first core of cluster 1. Core IDs are
                               assigned contiguously within a cluster. Cluster
                               0: 0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster2 : 7;

                            /* Bits[19:13], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 2 (BaseCluster2): Core ID of the
                               first core of cluster 2. Core IDs are assigned
                               contiguously within a cluster. Cluster 0:
                               0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster3 : 7;

                            /* Bits[26:20], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 3 (BaseCluster3): NOT USED
                               ANYMORE. Core ID of the first core of cluster 3.
                               Core IDs are assigned contiguously within a
                               cluster. Cluster 0: 0...M-1, cluster 1: M...N.
                               In this case this field should be set to the
                               value M.
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TOPOLOGY_M2MEM_MAIN_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mynid : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               My NID (MyNID): NodeID of this MC (more
                               accurately, this mesh2mem).
                            */
    UINT32 sncluster : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               NOT USED ANYMORE. SNC cluster (SNCluster): SNC
                               cluster this m2m belongs to: cluster 1 or 0.
                            */
    UINT32 basecluster1 : 7;

                            /* Bits[12:6], Access Type=RW, default=0x0000003F*/

                            /*
                               < Base of Cluster 1 (BaseCluster1): Core ID of
                               the first core of cluster 1. Core IDs are
                               assigned contiguously within a cluster. Cluster
                               0: 0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster2 : 7;

                            /* Bits[19:13], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 2 (BaseCluster2): Core ID of the
                               first core of cluster 2. Core IDs are assigned
                               contiguously within a cluster. Cluster 0:
                               0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster3 : 7;

                            /* Bits[26:20], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 3 (BaseCluster3): NOT USED
                               ANYMORE. Core ID of the first core of cluster 3.
                               Core IDs are assigned contiguously within a
                               cluster. Cluster 0: 0...M-1, cluster 1: M...N.
                               In this case this field should be set to the
                               value M.
                            */
    UINT32 clusteronpkg : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Cluster On Package Mode (SPR+ CoP): Set this
                               register to 0x1 to enable SPR+ CoP (aka SPR UCC
                               topology) in M2M. This is required to allow D2K
                               to be sent to UPIMDF agents, otherwise, D2K will
                               not occur to the UPIMDFs.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TOPOLOGY_M2MEM_MAIN_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mynid : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               My NID (MyNID): NodeID of this MC (more
                               accurately, this mesh2mem).
                            */
    UINT32 sncluster : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               NOT USED ANYMORE. SNC cluster (SNCluster): SNC
                               cluster this m2m belongs to: cluster 1 or 0.
                            */
    UINT32 basecluster1 : 7;

                            /* Bits[12:6], Access Type=RW, default=0x0000003F*/

                            /*
                               < Base of Cluster 1 (BaseCluster1): Core ID of
                               the first core of cluster 1. Core IDs are
                               assigned contiguously within a cluster. Cluster
                               0: 0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster2 : 7;

                            /* Bits[19:13], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 2 (BaseCluster2): Core ID of the
                               first core of cluster 2. Core IDs are assigned
                               contiguously within a cluster. Cluster 0:
                               0...M-1, cluster 1: M...N. In this case this
                               field should be set to the value M.
                            */
    UINT32 basecluster3 : 7;

                            /* Bits[26:20], Access Type=RW, default=0x00000000*/

                            /*
                               Base of Cluster 3 (BaseCluster3): NOT USED
                               ANYMORE. Core ID of the first core of cluster 3.
                               Core IDs are assigned contiguously within a
                               cluster. Cluster 0: 0...M-1, cluster 1: M...N.
                               In this case this field should be set to the
                               value M.
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TOPOLOGY_M2MEM_MAIN_STRUCT;

/* WRTRKRALLOC_M2MEM_MAIN_REG supported on:                                     */
/*      SPRA0 (0x21e603e8)                                                      */
/*      SPRB0 (0x21e603e8)                                                      */
/*      SPRHBM (0x21e603e8)                                                     */
/*      SPRC0 (0x21e603e8)                                                      */
/*      SPRMCC (0x21e603e8)                                                     */
/*      SPRUCC (0x21e603e8)                                                     */
/* Register default value on SPRA0: 0x40004800                                  */
/* Register default value on SPRB0: 0x40004800                                  */
/* Register default value on SPRHBM: 0x40004800                                 */
/* Register default value on SPRC0: 0x40004800                                  */
/* Register default value on SPRMCC: 0x40004800                                 */
/* Register default value on SPRUCC: 0x40004800                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
         Hooks for controlling the reservation of store and mirror tracker entries for anti-deadlock purposes.
      
*/


#define WRTRKRALLOC_M2MEM_MAIN_REG 0x060203E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wrtrkrpwrthresh : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of partial writes allowed per channel
                               store tracker. Must be less than 14. A value of
                               0 disables this check.For 10nm this shoudl be
                               disabled
                            */
    UINT32 wrtrkrddrtthresh : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of DDRT writes allowed per channel
                               store tracker. A value of 0 disables this check.
                            */
    UINT32 mirrtrkrthresh : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000012*/

                            /*
                               Max number of non-TGR mirror writes allowed.
                               Should be less than 30 - {BL transgress credits
                               (set via Credits CSR)} - {FakeTgrThresh}. A
                               value of 0 disables this check.
                            */
    UINT32 mirrtrkrpwrthresh : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of partial mirror writes allowed.
                               Should be less than MirrTrkrThresh. A value of 0
                               disables this check.For 10nm this shoudl be
                               disabled
                            */
    UINT32 rsvd : 8;

                            /* Bits[27:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirrtrkrfaketgrthresh : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000004*/

                            /*
                               WRNIMISS are preallocated in mirror tracker.
                               This sets the no of entries in mirror tracker
                               for WrNIMISS
                            */

  } Bits;
  UINT32 Data;

} WRTRKRALLOC_M2MEM_MAIN_STRUCT;

/* DFXINJECTION_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e603f0)                                                      */
/*      SPRB0 (0x21e603f0)                                                      */
/*      SPRHBM (0x21e603f0)                                                     */
/*      SPRC0 (0x21e603f0)                                                      */
/*      SPRMCC (0x21e603f0)                                                     */
/*      SPRUCC (0x21e603f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* 
      This register contains m2m customer visible error injection hooks.
      
*/


#define DFXINJECTION_M2MEM_MAIN_REG 0x060203F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errorinjtrkparity : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Single shot error injection for tracker parity.
                               1: Inject error on tracker parity.Bit will be
                               cleared when error injection is done. 0: No
                               error injection.
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DFXINJECTION_M2MEM_MAIN_STRUCT;

/* M2M_PRMRR_BASE_N0_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e60410)                                                      */
/*      SPRB0 (0x21e60410)                                                      */
/*      SPRHBM (0x21e60410)                                                     */
/*      SPRC0 (0x21e60410)                                                      */
/*      SPRMCC (0x21e60410)                                                     */
/*      SPRUCC (0x21e60410)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* PRMRR region's base system address. Any PRMRR access should adhere to the following:
        (Addr & M2M_PRMRR_MASK) == (PRMRR_Base_Address & M2M_PRMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_PRMRR_BASE_N0_M2MEM_MAIN_REG 0x06020410

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* enable bit for the M2M_PRMRR_BASE register */
    UINT32 rsvd_4 : 8;

                            /* Bits[11:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 base_address : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               PRMRR specifies the secure encrypted region to
                               be handled by the MEE (encryption) engine. This
                               field specifies the system address[51:12] lower
                               limit of the PRMRR region. Bits [11:0] are
                               always zero. A system address needs to be larger
                               than or equal to this limit in order to be able
                               to belong to the PRMRR region.
                            */

  } Bits;
  UINT32 Data;

} M2M_PRMRR_BASE_N0_M2MEM_MAIN_STRUCT;

/* M2M_PRMRR_BASE_N1_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e60414)                                                      */
/*      SPRB0 (0x21e60414)                                                      */
/*      SPRHBM (0x21e60414)                                                     */
/*      SPRC0 (0x21e60414)                                                      */
/*      SPRMCC (0x21e60414)                                                     */
/*      SPRUCC (0x21e60414)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* PRMRR region's base system address. Any PRMRR access should adhere to the following:
        (Addr & M2M_PRMRR_MASK) == (PRMRR_Base_Address & M2M_PRMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_PRMRR_BASE_N1_M2MEM_MAIN_REG 0x06020414

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 base_address : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /*
                               PRMRR specifies the secure encrypted region to
                               be handled by the MEE (encryption) engine. This
                               field specifies the system address[51:12] lower
                               limit of the PRMRR region. Bits [11:0] are
                               always zero. A system address needs to be larger
                               than or equal to this limit in order to be able
                               to belong to the PRMRR region.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2M_PRMRR_BASE_N1_M2MEM_MAIN_STRUCT;

/* M2M_PRMRR_MASK_N0_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e60418)                                                      */
/*      SPRB0 (0x21e60418)                                                      */
/*      SPRHBM (0x21e60418)                                                     */
/*      SPRC0 (0x21e60418)                                                      */
/*      SPRMCC (0x21e60418)                                                     */
/*      SPRUCC (0x21e60418)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* PRMRR Mask.  Any PRMRR access should adhere to [br]
        (Addr & M2M_PRMRR_MASK) == (PRMRR_Base_Address & M2M_PRMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_PRMRR_MASK_N0_M2MEM_MAIN_REG 0x06020418

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 10;

                            /* Bits[9:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lock : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               matching on the PRMRR range is only allowed if
                               the lock bit is 1. If the lock bit is zero the
                               M2M_PRMRR_BASE range check should always fail to
                               produce a match.
                            */
    UINT32 valid : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               this bit does nothing in the M2MEM. it might
                               only be used by the core copy of the
                               M2M_PRMRR_MASK register. M2MEM has a copy though
                               because the ucode in the core might use the
                               M2MEM copy of this register to save/restore the
                               core copy of the same register.
                            */
    UINT32 range_mask : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /*
                               sets address bits [51:12] of the range mask for
                               all of the PRMRR range registers. The size
                               alignment requirement on the PRMRR base
                               addresses enables all PRMRR range registers to
                               use a single range mask.
                            */

  } Bits;
  UINT32 Data;

} M2M_PRMRR_MASK_N0_M2MEM_MAIN_STRUCT;

/* M2M_PRMRR_MASK_N1_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e6041c)                                                      */
/*      SPRB0 (0x21e6041c)                                                      */
/*      SPRHBM (0x21e6041c)                                                     */
/*      SPRC0 (0x21e6041c)                                                      */
/*      SPRMCC (0x21e6041c)                                                     */
/*      SPRUCC (0x21e6041c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* PRMRR Mask.  Any PRMRR access should adhere to [br]
        (Addr & M2M_PRMRR_MASK) == (PRMRR_Base_Address & M2M_PRMRR_MASK)
      This register gets only used by XPT/UPI prefetches.
      
*/


#define M2M_PRMRR_MASK_N1_M2MEM_MAIN_REG 0x0602041C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 range_mask : 20;

                            /* Bits[19:0], Access Type=RW, default=0x00000000*/

                            /*
                               sets address bits [51:12] of the range mask for
                               all of the PRMRR range registers. The size
                               alignment requirement on the PRMRR base
                               addresses enables all PRMRR range registers to
                               use a single range mask.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2M_PRMRR_MASK_N1_M2MEM_MAIN_STRUCT;







/* PMONUNITCTRL_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60438)                                                      */
/*      SPRB0 (0x21e60438)                                                      */
/*      SPRHBM (0x21e60438)                                                     */
/*      SPRC0 (0x21e60438)                                                      */
/*      SPRMCC (0x21e60438)                                                     */
/*      SPRUCC (0x21e60438)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Performance monitor (counter) control register.
*/


#define PMONUNITCTRL_M2MEM_MAIN_REG 0x06020438

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 freezecounters : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               If set to 1 the counters in this box will be
                               frozen.
                            */
    UINT32 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 resetcounterconfigs : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /*
                               Reset Counter Configs (ResetCounterConfigs):
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters. To reset
                               the counters, this bit need only be set by one
                               of the unit control registers.
                            */
    UINT32 resetcounters : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /*
                               Reset Counters (ResetCounters): When this bit is
                               written to, the counters data fields will be
                               reset. The configuration values will not be
                               reset. To reset the counters, this bit need only
                               be set by one of the unit control registers.
                            */
    UINT32 rsvd_10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONUNITCTRL_M2MEM_MAIN_STRUCT;

/* PMONCNTR0_N0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60440)                                                      */
/*      SPRB0 (0x21e60440)                                                      */
/*      SPRHBM (0x21e60440)                                                     */
/*      SPRC0 (0x21e60440)                                                      */
/*      SPRMCC (0x21e60440)                                                     */
/*      SPRUCC (0x21e60440)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR0_N0_M2MEM_MAIN_REG 0x06020440

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTR0_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTR0_N1_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60444)                                                      */
/*      SPRB0 (0x21e60444)                                                      */
/*      SPRHBM (0x21e60444)                                                     */
/*      SPRC0 (0x21e60444)                                                      */
/*      SPRMCC (0x21e60444)                                                     */
/*      SPRUCC (0x21e60444)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR0_N1_M2MEM_MAIN_REG 0x06020444

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR0_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTR1_N0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60448)                                                      */
/*      SPRB0 (0x21e60448)                                                      */
/*      SPRHBM (0x21e60448)                                                     */
/*      SPRC0 (0x21e60448)                                                      */
/*      SPRMCC (0x21e60448)                                                     */
/*      SPRUCC (0x21e60448)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR1_N0_M2MEM_MAIN_REG 0x06020448

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTR1_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTR1_N1_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e6044c)                                                      */
/*      SPRB0 (0x21e6044c)                                                      */
/*      SPRHBM (0x21e6044c)                                                     */
/*      SPRC0 (0x21e6044c)                                                      */
/*      SPRMCC (0x21e6044c)                                                     */
/*      SPRUCC (0x21e6044c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR1_N1_M2MEM_MAIN_REG 0x0602044C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR1_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTR2_N0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60450)                                                      */
/*      SPRB0 (0x21e60450)                                                      */
/*      SPRHBM (0x21e60450)                                                     */
/*      SPRC0 (0x21e60450)                                                      */
/*      SPRMCC (0x21e60450)                                                     */
/*      SPRUCC (0x21e60450)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR2_N0_M2MEM_MAIN_REG 0x06020450

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTR2_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTR2_N1_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60454)                                                      */
/*      SPRB0 (0x21e60454)                                                      */
/*      SPRHBM (0x21e60454)                                                     */
/*      SPRC0 (0x21e60454)                                                      */
/*      SPRMCC (0x21e60454)                                                     */
/*      SPRUCC (0x21e60454)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR2_N1_M2MEM_MAIN_REG 0x06020454

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR2_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTR3_N0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60458)                                                      */
/*      SPRB0 (0x21e60458)                                                      */
/*      SPRHBM (0x21e60458)                                                     */
/*      SPRC0 (0x21e60458)                                                      */
/*      SPRMCC (0x21e60458)                                                     */
/*      SPRUCC (0x21e60458)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR3_N0_M2MEM_MAIN_REG 0x06020458

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTR3_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTR3_N1_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e6045c)                                                      */
/*      SPRB0 (0x21e6045c)                                                      */
/*      SPRHBM (0x21e6045c)                                                     */
/*      SPRC0 (0x21e6045c)                                                      */
/*      SPRMCC (0x21e6045c)                                                     */
/*      SPRUCC (0x21e6045c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR3_N1_M2MEM_MAIN_REG 0x0602045C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR3_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTR4_N0_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60460)                                                      */
/*      SPRB0 (0x21e60460)                                                      */
/*      SPRHBM (0x21e60460)                                                     */
/*      SPRC0 (0x21e60460)                                                      */
/*      SPRMCC (0x21e60460)                                                     */
/*      SPRUCC (0x21e60460)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR4_N0_M2MEM_MAIN_REG 0x06020460

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTR4_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTR4_N1_M2MEM_MAIN_REG supported on:                                    */
/*      SPRA0 (0x21e60464)                                                      */
/*      SPRB0 (0x21e60464)                                                      */
/*      SPRHBM (0x21e60464)                                                     */
/*      SPRC0 (0x21e60464)                                                      */
/*      SPRMCC (0x21e60464)                                                     */
/*      SPRUCC (0x21e60464)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      This register is a perfmon counter. Software can both read it and write it.
      
*/


#define PMONCNTR4_N1_M2MEM_MAIN_REG 0x06020464

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Counter Value (CounterValue): Current value of
                               the counter.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR4_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG0_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60468)                                                      */
/*      SPRB0 (0x21e60468)                                                      */
/*      SPRHBM (0x21e60468)                                                     */
/*      SPRC0 (0x21e60468)                                                      */
/*      SPRMCC (0x21e60468)                                                     */
/*      SPRUCC (0x21e60468)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG0_N0_M2MEM_MAIN_REG 0x06020468

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Event Select (EventSelect): This field is used
                               to decode the PerfMon event which is selected.
                               If EventSelect is all zero's it means count
                               nothing (meaning count nothing). If any of the
                               EventSelect bits is set, that means the counter
                               is enabled.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Unit Mask (UnitMask): This mask selects the sub-
                               events to be selected for creation of the event.
                               The selected sub-events are bitwise OR-ed
                               together to create event. At least one sub-event
                               must be selected otherwise the PerfMon event
                               signals will not ever get asserted. Events with
                               no sub-events listed effectively have only one
                               sub-event; bit 8 must be set to 1 in this case.
                            */
    UINT32 queoccupreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Queue Occupancy Reset (QueOccupReset): This
                               write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Counter Reset (CounterReset): When this bit is
                               set, the corresponding counter will be reset to
                               0. This allows for a quick reset of the counter
                               when changing event encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect (EdgeDetect): Edge Detect allows one
                               to count either 0 to 1 or 1 to 0 transitions of
                               a given event. For example, we have an event
                               that counts the number of cycles in L0s mode in
                               Intel UPI. By using edge detect, one can count
                               the number of times that we entered L0s mode (by
                               detecting the rising edge). Edge detect only
                               works in conjunction with threshholding. This is
                               true even for events that can only increment by
                               1 in a given cycle (like the L0s example above).
                               In this case, one should set a threshhold of 1.
                               One can also use Edge Detect with queue
                               occupancy events. For example, if one wanted to
                               count the number of times when the TOR occupancy
                               was larger than 5, one would selet the TOR
                               occupancy event with a threshold of 5 and set
                               the Edge Detect bit. Edge detect can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will either be
                               the same or differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 freezeonoverflow : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               When an overflow is detected from this register,
                               a PMON overflow message is sent to the global
                               control. This bit will tell the global control
                               whether it should assert the global freeze for
                               all counters in the same domain
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG0_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG0_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e6046c)                                                      */
/*      SPRB0 (0x21e6046c)                                                      */
/*      SPRHBM (0x21e6046c)                                                     */
/*      SPRC0 (0x21e6046c)                                                      */
/*      SPRMCC (0x21e6046c)                                                     */
/*      SPRUCC (0x21e6046c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG0_N1_M2MEM_MAIN_REG 0x0602046C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitmaskext : 24;

                            /* Bits[23:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is an extension for the unit mask
                               field. It is used if more sub-events are needed
                               on Pmon events. HSD fix:1407073151. Since M2m is
                               running out of event ID's and is bleeding onto
                               CMS event ID space. We use bit 55 of UnitMaskExt
                               to determine if a particular event ID belongs to
                               CMS or M2m. If bit 55 = 0 --> M2m event ID If
                               bit 55 = 1 --> CMS event ID
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG0_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG1_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60470)                                                      */
/*      SPRB0 (0x21e60470)                                                      */
/*      SPRHBM (0x21e60470)                                                     */
/*      SPRC0 (0x21e60470)                                                      */
/*      SPRMCC (0x21e60470)                                                     */
/*      SPRUCC (0x21e60470)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG1_N0_M2MEM_MAIN_REG 0x06020470

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Event Select (EventSelect): This field is used
                               to decode the PerfMon event which is selected.
                               If EventSelect is all zero's it means count
                               nothing (meaning count nothing). If any of the
                               EventSelect bits is set, that means the counter
                               is enabled.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Unit Mask (UnitMask): This mask selects the sub-
                               events to be selected for creation of the event.
                               The selected sub-events are bitwise OR-ed
                               together to create event. At least one sub-event
                               must be selected otherwise the PerfMon event
                               signals will not ever get asserted. Events with
                               no sub-events listed effectively have only one
                               sub-event; bit 8 must be set to 1 in this case.
                            */
    UINT32 queoccupreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Queue Occupancy Reset (QueOccupReset): This
                               write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Counter Reset (CounterReset): When this bit is
                               set, the corresponding counter will be reset to
                               0. This allows for a quick reset of the counter
                               when changing event encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect (EdgeDetect): Edge Detect allows one
                               to count either 0 to 1 or 1 to 0 transitions of
                               a given event. For example, we have an event
                               that counts the number of cycles in L0s mode in
                               Intel UPI. By using edge detect, one can count
                               the number of times that we entered L0s mode (by
                               detecting the rising edge). Edge detect only
                               works in conjunction with threshholding. This is
                               true even for events that can only increment by
                               1 in a given cycle (like the L0s example above).
                               In this case, one should set a threshhold of 1.
                               One can also use Edge Detect with queue
                               occupancy events. For example, if one wanted to
                               count the number of times when the TOR occupancy
                               was larger than 5, one would selet the TOR
                               occupancy event with a threshold of 5 and set
                               the Edge Detect bit. Edge detect can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will either be
                               the same or differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 freezeonoverflow : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               When an overflow is detected from this register,
                               a PMON overflow message is sent to the global
                               control. This bit will tell the global control
                               whether it should assert the global freeze for
                               all counters in the same domain
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG1_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG1_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60474)                                                      */
/*      SPRB0 (0x21e60474)                                                      */
/*      SPRHBM (0x21e60474)                                                     */
/*      SPRC0 (0x21e60474)                                                      */
/*      SPRMCC (0x21e60474)                                                     */
/*      SPRUCC (0x21e60474)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG1_N1_M2MEM_MAIN_REG 0x06020474

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitmaskext : 24;

                            /* Bits[23:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is an extension for the unit mask
                               field. It is used if more sub-events are needed
                               on Pmon events. HSD fix:1407073151. Since M2m is
                               running out of event ID's and is bleeding onto
                               CMS event ID space. We use bit 55 of UnitMaskExt
                               to determine if a particular event ID belongs to
                               CMS or M2m. If bit 55 = 0 --> M2m event ID If
                               bit 55 = 1 --> CMS event ID
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG1_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG2_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60478)                                                      */
/*      SPRB0 (0x21e60478)                                                      */
/*      SPRHBM (0x21e60478)                                                     */
/*      SPRC0 (0x21e60478)                                                      */
/*      SPRMCC (0x21e60478)                                                     */
/*      SPRUCC (0x21e60478)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG2_N0_M2MEM_MAIN_REG 0x06020478

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Event Select (EventSelect): This field is used
                               to decode the PerfMon event which is selected.
                               If EventSelect is all zero's it means count
                               nothing (meaning count nothing). If any of the
                               EventSelect bits is set, that means the counter
                               is enabled.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Unit Mask (UnitMask): This mask selects the sub-
                               events to be selected for creation of the event.
                               The selected sub-events are bitwise OR-ed
                               together to create event. At least one sub-event
                               must be selected otherwise the PerfMon event
                               signals will not ever get asserted. Events with
                               no sub-events listed effectively have only one
                               sub-event; bit 8 must be set to 1 in this case.
                            */
    UINT32 queoccupreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Queue Occupancy Reset (QueOccupReset): This
                               write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Counter Reset (CounterReset): When this bit is
                               set, the corresponding counter will be reset to
                               0. This allows for a quick reset of the counter
                               when changing event encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect (EdgeDetect): Edge Detect allows one
                               to count either 0 to 1 or 1 to 0 transitions of
                               a given event. For example, we have an event
                               that counts the number of cycles in L0s mode in
                               Intel UPI. By using edge detect, one can count
                               the number of times that we entered L0s mode (by
                               detecting the rising edge). Edge detect only
                               works in conjunction with threshholding. This is
                               true even for events that can only increment by
                               1 in a given cycle (like the L0s example above).
                               In this case, one should set a threshhold of 1.
                               One can also use Edge Detect with queue
                               occupancy events. For example, if one wanted to
                               count the number of times when the TOR occupancy
                               was larger than 5, one would selet the TOR
                               occupancy event with a threshold of 5 and set
                               the Edge Detect bit. Edge detect can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will either be
                               the same or differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 freezeonoverflow : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               When an overflow is detected from this register,
                               a PMON overflow message is sent to the global
                               control. This bit will tell the global control
                               whether it should assert the global freeze for
                               all counters in the same domain
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG2_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG2_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e6047c)                                                      */
/*      SPRB0 (0x21e6047c)                                                      */
/*      SPRHBM (0x21e6047c)                                                     */
/*      SPRC0 (0x21e6047c)                                                      */
/*      SPRMCC (0x21e6047c)                                                     */
/*      SPRUCC (0x21e6047c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG2_N1_M2MEM_MAIN_REG 0x0602047C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitmaskext : 24;

                            /* Bits[23:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is an extension for the unit mask
                               field. It is used if more sub-events are needed
                               on Pmon events. HSD fix:1407073151. Since M2m is
                               running out of event ID's and is bleeding onto
                               CMS event ID space. We use bit 55 of UnitMaskExt
                               to determine if a particular event ID belongs to
                               CMS or M2m. If bit 55 = 0 --> M2m event ID If
                               bit 55 = 1 --> CMS event ID
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG2_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG3_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60480)                                                      */
/*      SPRB0 (0x21e60480)                                                      */
/*      SPRHBM (0x21e60480)                                                     */
/*      SPRC0 (0x21e60480)                                                      */
/*      SPRMCC (0x21e60480)                                                     */
/*      SPRUCC (0x21e60480)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG3_N0_M2MEM_MAIN_REG 0x06020480

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Event Select (EventSelect): This field is used
                               to decode the PerfMon event which is selected.
                               If EventSelect is all zero's it means count
                               nothing (meaning count nothing). If any of the
                               EventSelect bits is set, that means the counter
                               is enabled.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Unit Mask (UnitMask): This mask selects the sub-
                               events to be selected for creation of the event.
                               The selected sub-events are bitwise OR-ed
                               together to create event. At least one sub-event
                               must be selected otherwise the PerfMon event
                               signals will not ever get asserted. Events with
                               no sub-events listed effectively have only one
                               sub-event; bit 8 must be set to 1 in this case.
                            */
    UINT32 queoccupreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Queue Occupancy Reset (QueOccupReset): This
                               write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Counter Reset (CounterReset): When this bit is
                               set, the corresponding counter will be reset to
                               0. This allows for a quick reset of the counter
                               when changing event encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect (EdgeDetect): Edge Detect allows one
                               to count either 0 to 1 or 1 to 0 transitions of
                               a given event. For example, we have an event
                               that counts the number of cycles in L0s mode in
                               Intel UPI. By using edge detect, one can count
                               the number of times that we entered L0s mode (by
                               detecting the rising edge). Edge detect only
                               works in conjunction with threshholding. This is
                               true even for events that can only increment by
                               1 in a given cycle (like the L0s example above).
                               In this case, one should set a threshhold of 1.
                               One can also use Edge Detect with queue
                               occupancy events. For example, if one wanted to
                               count the number of times when the TOR occupancy
                               was larger than 5, one would selet the TOR
                               occupancy event with a threshold of 5 and set
                               the Edge Detect bit. Edge detect can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will either be
                               the same or differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 freezeonoverflow : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               When an overflow is detected from this register,
                               a PMON overflow message is sent to the global
                               control. This bit will tell the global control
                               whether it should assert the global freeze for
                               all counters in the same domain
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG3_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG3_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60484)                                                      */
/*      SPRB0 (0x21e60484)                                                      */
/*      SPRHBM (0x21e60484)                                                     */
/*      SPRC0 (0x21e60484)                                                      */
/*      SPRMCC (0x21e60484)                                                     */
/*      SPRUCC (0x21e60484)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG3_N1_M2MEM_MAIN_REG 0x06020484

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitmaskext : 24;

                            /* Bits[23:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is an extension for the unit mask
                               field. It is used if more sub-events are needed
                               on Pmon events. HSD fix:1407073151. Since M2m is
                               running out of event ID's and is bleeding onto
                               CMS event ID space. We use bit 55 of UnitMaskExt
                               to determine if a particular event ID belongs to
                               CMS or M2m. If bit 55 = 0 --> M2m event ID If
                               bit 55 = 1 --> CMS event ID
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG3_N1_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG4_N0_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e60488)                                                      */
/*      SPRB0 (0x21e60488)                                                      */
/*      SPRHBM (0x21e60488)                                                     */
/*      SPRC0 (0x21e60488)                                                      */
/*      SPRMCC (0x21e60488)                                                     */
/*      SPRUCC (0x21e60488)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG4_N0_M2MEM_MAIN_REG 0x06020488

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Event Select (EventSelect): This field is used
                               to decode the PerfMon event which is selected.
                               If EventSelect is all zero's it means count
                               nothing (meaning count nothing). If any of the
                               EventSelect bits is set, that means the counter
                               is enabled.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Unit Mask (UnitMask): This mask selects the sub-
                               events to be selected for creation of the event.
                               The selected sub-events are bitwise OR-ed
                               together to create event. At least one sub-event
                               must be selected otherwise the PerfMon event
                               signals will not ever get asserted. Events with
                               no sub-events listed effectively have only one
                               sub-event; bit 8 must be set to 1 in this case.
                            */
    UINT32 queoccupreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Queue Occupancy Reset (QueOccupReset): This
                               write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               Counter Reset (CounterReset): When this bit is
                               set, the corresponding counter will be reset to
                               0. This allows for a quick reset of the counter
                               when changing event encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect (EdgeDetect): Edge Detect allows one
                               to count either 0 to 1 or 1 to 0 transitions of
                               a given event. For example, we have an event
                               that counts the number of cycles in L0s mode in
                               Intel UPI. By using edge detect, one can count
                               the number of times that we entered L0s mode (by
                               detecting the rising edge). Edge detect only
                               works in conjunction with threshholding. This is
                               true even for events that can only increment by
                               1 in a given cycle (like the L0s example above).
                               In this case, one should set a threshhold of 1.
                               One can also use Edge Detect with queue
                               occupancy events. For example, if one wanted to
                               count the number of times when the TOR occupancy
                               was larger than 5, one would selet the TOR
                               occupancy event with a threshold of 5 and set
                               the Edge Detect bit. Edge detect can also be
                               used with the invert. This is generally not
                               particularly useful, as the count of falling
                               edges compared to rising edges will either be
                               the same or differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 freezeonoverflow : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               When an overflow is detected from this register,
                               a PMON overflow message is sent to the global
                               control. This bit will tell the global control
                               whether it should assert the global freeze for
                               all counters in the same domain
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshhold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshhold to 1.
                            */
    UINT32 threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG4_N0_M2MEM_MAIN_STRUCT;

/* PMONCNTRCFG4_N1_M2MEM_MAIN_REG supported on:                                 */
/*      SPRA0 (0x21e6048c)                                                      */
/*      SPRB0 (0x21e6048c)                                                      */
/*      SPRHBM (0x21e6048c)                                                     */
/*      SPRC0 (0x21e6048c)                                                      */
/*      SPRMCC (0x21e6048c)                                                     */
/*      SPRUCC (0x21e6048c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  Perfmon Counter Control Register.  
*/


#define PMONCNTRCFG4_N1_M2MEM_MAIN_REG 0x0602048C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitmaskext : 24;

                            /* Bits[23:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is an extension for the unit mask
                               field. It is used if more sub-events are needed
                               on Pmon events. HSD fix:1407073151. Since M2m is
                               running out of event ID's and is bleeding onto
                               CMS event ID space. We use bit 55 of UnitMaskExt
                               to determine if a particular event ID belongs to
                               CMS or M2m. If bit 55 = 0 --> M2m event ID If
                               bit 55 = 1 --> CMS event ID
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG4_N1_M2MEM_MAIN_STRUCT;

/* PMONADDRMATCH0_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e60490)                                                      */
/*      SPRB0 (0x21e60490)                                                      */
/*      SPRHBM (0x21e60490)                                                     */
/*      SPRC0 (0x21e60490)                                                      */
/*      SPRMCC (0x21e60490)                                                     */
/*      SPRUCC (0x21e60490)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Address match register: For each address bit which is not masked out, compare the incoming 
      (BL/AD) physical transaction address from the mesh and generate an event if a match. 
      This event can then be used as a pmon event or a debug trigger event.
      
*/


#define PMONADDRMATCH0_M2MEM_MAIN_REG 0x06020490

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 6;

                            /* Bits[5:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lophyaddr : 26;

                            /* Bits[31:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Lower Bits of the Physical Address (LoPhyAddr):
                               Low physical address bits [31:6] to match on.
                               Only those bits for which the corresponding
                               maskout bit is zero will be compared.
                            */

  } Bits;
  UINT32 Data;

} PMONADDRMATCH0_M2MEM_MAIN_STRUCT;

/* PMONADDRMATCH1_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e60494)                                                      */
/*      SPRB0 (0x21e60494)                                                      */
/*      SPRHBM (0x21e60494)                                                     */
/*      SPRC0 (0x21e60494)                                                      */
/*      SPRMCC (0x21e60494)                                                     */
/*      SPRUCC (0x21e60494)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Address match register: For each address bit which is not masked out, compare the incoming 
      (BL/AD) transaction address from the mesh and generate an event. This event can be selected as a pmon 
      event, a debug trigger event or as a trace filtering event.
      
*/


#define PMONADDRMATCH1_M2MEM_MAIN_REG 0x06020494

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hiphyaddr : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               High Bits of the Physical Address (HiPhyAddr):
                               High physical address bits [45:32] to match on.
                               Only those bits for which the corresponding
                               maskout bit is zero will be compared.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONADDRMATCH1_M2MEM_MAIN_STRUCT;

/* PMONADDRMASK0_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e60498)                                                      */
/*      SPRB0 (0x21e60498)                                                      */
/*      SPRHBM (0x21e60498)                                                     */
/*      SPRC0 (0x21e60498)                                                      */
/*      SPRMCC (0x21e60498)                                                     */
/*      SPRUCC (0x21e60498)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Maskout bits used in conjunction with the address match register.
      
*/


#define PMONADDRMASK0_M2MEM_MAIN_REG 0x06020498

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 6;

                            /* Bits[5:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lophyaddrmask : 26;

                            /* Bits[31:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Lower Maskout Bits of the Physical Address
                               (LoPhyAddrMask): Maskout bits for physical
                               address bits [31:6]. When a maskout bit is set,
                               the corresponding address match bit will be
                               masked out, i.e. will not be compared against.
                            */

  } Bits;
  UINT32 Data;

} PMONADDRMASK0_M2MEM_MAIN_STRUCT;

/* PMONADDRMASK1_M2MEM_MAIN_REG supported on:                                   */
/*      SPRA0 (0x21e6049c)                                                      */
/*      SPRB0 (0x21e6049c)                                                      */
/*      SPRHBM (0x21e6049c)                                                     */
/*      SPRC0 (0x21e6049c)                                                      */
/*      SPRMCC (0x21e6049c)                                                     */
/*      SPRUCC (0x21e6049c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Maskout bits used in conjunction with the address match register.
      
*/


#define PMONADDRMASK1_M2MEM_MAIN_REG 0x0602049C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hiphyaddrmask : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               High Maskout Bits of the Physical Address
                               (HiPhyAddrMask): Maskout bits for physical
                               address bits [45:32]. When a maskout bit is set,
                               the corresponding address match bit will be
                               masked out, i.e. will not be compared against.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONADDRMASK1_M2MEM_MAIN_STRUCT;

/* PMONOPCODEMASKMATCH_M2MEM_MAIN_REG supported on:                             */
/*      SPRA0 (0x21e604a0)                                                      */
/*      SPRB0 (0x21e604a0)                                                      */
/*      SPRHBM (0x21e604a0)                                                     */
/*      SPRC0 (0x21e604a0)                                                      */
/*      SPRMCC (0x21e604a0)                                                     */
/*      SPRUCC (0x21e604a0)                                                     */
/* Register default value on SPRA0: 0x000000F0                                  */
/* Register default value on SPRB0: 0x000000F0                                  */
/* Register default value on SPRHBM: 0x000000F0                                 */
/* Register default value on SPRC0: 0x000000F0                                  */
/* Register default value on SPRMCC: 0x000000F0                                 */
/* Register default value on SPRUCC: 0x000000F0                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Opcode and message class mask/match register. For each opcode and message class bit which 
      is not masked out, compare the incoming (BL/AD) physical transaction address from the mesh 
      and generate an event if a match. This event can then be used as a pmon event or a debug trigger event. 
M2mem uses it's own internal opcode mapping rather than using the IAL encoding (to allow m2m design independent of opcode changes). For using the MeshPkt match pmon event, you will need to use m2mem internal mappings mentioned below

IAL Opcode            IAL Dir Upd             IAL Dir State            M2m Opcode                Opcode Value
IAL_REQ_MEMRD,        IAL_MF_NOOP,               2'b??               SMI3_REQ_MemRd                 4'b0000
IAL_REQ_MEMSPECRD,    IAL_MF_NOOP,               2'b??               SMI3_REQ_MemSpecRd             4'b0001
IAL_REQ_MEMRDDATA,    IAL_MF_NOOP,               2'b??               SMI3_REQ_MemRdData             4'b0010 
IAL_REQ_MEMINV,       IAL_MF_NOOP,               2'b??               SMI3_REQ_MemInv                4'b1000 
IAL_REQ_MEMINVNOFILL, IAL_MF_NOOP,               2'b??               SMI3_REQ_MemInvItoX            4'b1100
IAL_REQ_MEMRD,        IAL_MF_DIR,                MM_DIR_INVALID      SMI3_REQ_MemRdXtoI             4'b0101
IAL_REQ_MEMRD,        IAL_MF_DIR,                MM_DIR_SNPALL       SMI3_REQ_MemRdXtoA             4'b0110 
IAL_REQ_MEMRD,        IAL_MF_DIR,                MM_DIR_SHARED       SMI3_REQ_MemRdXtoS             4'b0100 
IAL_REQ_MEMINV,       IAL_MF_DIR,                MM_DIR_INVALID      SMI3_REQ_MemInvXtoI            4'b1001 
IAL_REQ_MEMINV,       IAL_MF_DIR,                MM_DIR_SNPALL       SMI3_REQ_MemInvXtoA            4'b1010 
IAL_REQ_MEMRDFILLONLY,IAL_MF_NOOP,               2'b??               SMI3_REQ_MemInv                4'b1000 
IAL_WB_MEMWRDIRONLY                                                  SMI3_WB_MemWrDirOnly           4'b0001  
IAL_WB_MEMWR                                                         SMI3_WB_MemWr                  4'b0000 
IAL_WB_MEMWRPTL                                                      SMI3_WB_MemWrPtl               4'b0100 
IAL_WB_MEMWRNI                                                       SMI3_WB_MemWrNI                4'b0011
IAL_WB_MEMWRPTLNI                                                    SMI3_WB_MemWrPtlNI             4'b0111 
IAL_WB_MEMWRBYPENC                                                   SMI3_WB_MemWrBypEnc            4'b0010
*/


#define PMONOPCODEMASKMATCH_M2MEM_MAIN_REG 0x060204A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 opcode : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Opcode to match one of the incoming transaction
                               from mesh. We have standardized the parameters
                               inside M2m to avoid rework whenever mesh related
                               parameters change. The following IAL opcodes
                               will be remapped to M2mem internal
                               opcodes(inside the RTL) as follows. You need to
                               use the m2mem internal opcode encoding for
                               programmingt this register IAL Wr Opcode M2M
                               Internal Opcode M2mem Internal Opcode Encoding
                               IAL_WB_MEMWRDIRONLY SMI3_WB_MemWrDirOnly 4'b0001
                               IAL_WB_MEMWR SMI3_WB_MemWr 4'b0000
                               IAL_WB_MEMWRPTL SMI3_WB_MemWrPtl 4'b0100
                               IAL_WB_MEMWRNI SMI3_WB_MemWrNI 4'b0011
                               IAL_WB_MEMWRPTLNI SMI3_WB_MemWrPtlNI 4'b0111 IAL
                               Read Opcode IAL DIR IAL DIR STATE M2mem Internal
                               Opcode M2mem Internal Opcode Encoding
                               IAL_REQ_MEMRD, IAL_MF_NOOP, 2'b?? SMI3_REQ_MemRd
                               4'b0000 IAL_REQ_MEMSPECRD, IAL_MF_NOOP, 2'b??
                               SMI3_REQ_MemSpecRd 4'b0001 IAL_REQ_MEMRDDATA,
                               IAL_MF_NOOP, 2'b?? SMI3_REQ_MemRdData 4'b0010
                               IAL_REQ_MEMINV, IAL_MF_NOOP, 2'b?? SMI3
                               _REQ_MemInv 4'b1000 IAL_REQ_MEMINVNOFILL,
                               IAL_MF_NOOP, 2'b?? SMI3 _ REQ_MemInvItoX 4'b1100
                               IAL_REQ_MEMRD, IAL_MF_DIR, MM_DIR_INVALID
                               SMI3_REQ_MemRdXtoI 4'b0101 IAL_REQ_MEMRD,
                               IAL_MF_DIR, MM_DIR_SNPALL SMI3_REQ_MemRdXtoA
                               4'b0110 IAL_REQ_MEMRD, IAL_MF_DIR, MM_DIR_SHARED
                               SMI3_REQ_MemRdXtoS 4'b0100 IAL_REQ_MEMINV,
                               IAL_MF_DIR, MM_DIR_INVALID SMI3_REQ_MemInvXtoI
                               4'b1001 IAL_REQ_MEMINV, IAL_MF_DIR,
                               MM_DIR_SNPALL SMI3_REQ_MemInvXtoA 4'b1010
                               IAL_REQ_MEMRDFILLONLY,IAL_MF_NOOP, 2'b??
                               SMI3_REQ_MemInv 4'b1000
                            */
    UINT32 opcodemask : 4;

                            /* Bits[7:4], Access Type=RW/P, default=0x0000000F*/

                            /*
                               Opcode Mask (OpcodeMask): Mask-out bits for the
                               opcode match. When a maskout bit is set, the
                               corresponding opcode match bit will be masked
                               out, i.e. will not be compared against.
                            */
    UINT32 msgclass : 4;

                            /* Bits[11:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Message Class (MsgClass): Message class to match
                               on in the incoming transaction from mesh. We
                               have standardized the parameters inside M2m to
                               avoid rework whenever mesh related parameters
                               change. The following IAL msg class encodings
                               will be remapped to M2mem internal msg class
                               encodings(inside the RTL) as follows. You need
                               to use the m2mem internal msg class encoding for
                               programming this register Message class
                               encodings: IAL Encoding M2mem Internal Msg Class
                               M2mem Internal Encoding 4b0000: REQ (AD)
                               SMI3_REQ_MsgClass 3'b000 4b0010: RSP (AD)
                               4b1010: NCB (BL) SMI3_NCB_MsgClass 3'b110
                               4b1011: NCS (BL) SMI3_NCS_MsgClass 3'b111
                               4b1100: WB (BL) SMI3_WB_MsgClass 3'b100
                            */
    UINT32 msgclassmask : 4;

                            /* Bits[15:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Message Class Mask (MsgClassMask): Mask-out bits
                               for the message class match. When a maskout bit
                               is set, the corresponding message match bit will
                               be masked out, i.e. will not be compared
                               against.
                            */
    UINT32 mcopcode : 6;

                            /* Bits[21:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               MC Opcode: Opcode to match on of the outgoing
                               transaction to MC. The opcode encoding follows
                               the MC encodings from the MC MAS.
                            */
    UINT32 mcopcodemask : 6;

                            /* Bits[27:22], Access Type=RW/P, default=0x00000000*/

                            /*
                               MC Opcode Mask (MCOpcodeMask): Mask-out bits for
                               the MC opcode match. When a maskout bit is set,
                               the corresponding opcode match bit will be
                               masked out, i.e. will not be compared against.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONOPCODEMASKMATCH_M2MEM_MAIN_STRUCT;

/* PMONUNITSTATUS_M2MEM_MAIN_REG supported on:                                  */
/*      SPRA0 (0x21e604a8)                                                      */
/*      SPRB0 (0x21e604a8)                                                      */
/*      SPRHBM (0x21e604a8)                                                     */
/*      SPRC0 (0x21e604a8)                                                      */
/*      SPRMCC (0x21e604a8)                                                     */
/*      SPRUCC (0x21e604a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Performance monitor (counter) status register.
*/


#define PMONUNITSTATUS_M2MEM_MAIN_REG 0x060204A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counteroverflowbitmask : 5;

                            /* Bits[4:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Counter Overflow Bitmask
                               (CounterOverflowBitmask): This is a bitmask that
                               specifies which counter (or counters) have
                               overflowed.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONUNITSTATUS_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_BLOCK_IDENTIFIER_N0_M2MEM_MAIN_REG supported on:                  */
/*      SPRA0 (0x21e604b0)                                                      */
/*      SPRB0 (0x21e604b0)                                                      */
/*      SPRHBM (0x21e604b0)                                                     */
/*      SPRC0 (0x21e604b0)                                                      */
/*      SPRMCC (0x21e604b0)                                                     */
/*      SPRUCC (0x21e604b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Block Identifier
*/


#define M2MEM_PMON_BLOCK_IDENTIFIER_N0_M2MEM_MAIN_REG 0x060204B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 blockidentifier : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Local PMON Block Identifier */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_BLOCK_IDENTIFIER_N0_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_BLOCK_IDENTIFIER_N1_M2MEM_MAIN_REG supported on:                  */
/*      SPRA0 (0x21e604b4)                                                      */
/*      SPRB0 (0x21e604b4)                                                      */
/*      SPRHBM (0x21e604b4)                                                     */
/*      SPRC0 (0x21e604b4)                                                      */
/*      SPRMCC (0x21e604b4)                                                     */
/*      SPRUCC (0x21e604b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Block Identifier
*/


#define M2MEM_PMON_BLOCK_IDENTIFIER_N1_M2MEM_MAIN_REG 0x060204B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_BLOCK_IDENTIFIER_N1_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY0_N0_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604b8)                                                      */
/*      SPRB0 (0x21e604b8)                                                      */
/*      SPRHBM (0x21e604b8)                                                     */
/*      SPRC0 (0x21e604b8)                                                      */
/*      SPRMCC (0x21e604b8)                                                     */
/*      SPRUCC (0x21e604b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 0
*/


#define M2MEM_PMON_UNIT_DISCOVERY0_N0_M2MEM_MAIN_REG 0x060204B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numctrlregs : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Number of Control Registers */
    UINT32 ctrctrl0addr : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* Counter Ctrl 0 Addr */
    UINT32 counterwidth : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* Counter Width */
    UINT32 counter0addr : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /* Counter 0 Address */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY0_N0_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY0_N1_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604bc)                                                      */
/*      SPRB0 (0x21e604bc)                                                      */
/*      SPRHBM (0x21e604bc)                                                     */
/*      SPRC0 (0x21e604bc)                                                      */
/*      SPRMCC (0x21e604bc)                                                     */
/*      SPRUCC (0x21e604bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 0
*/


#define M2MEM_PMON_UNIT_DISCOVERY0_N1_M2MEM_MAIN_REG 0x060204BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitstatusaddr : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Unit Status Address */
    UINT32 rsvd2levftbits : 16;

                            /* Bits[23:8], Access Type=RW, default=0x00000000*/

                            /* Reserved 2 level feature bits */
    UINT32 rsvd : 6;

                            /* Bits[29:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 acctype : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Access Type */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY0_N1_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY1_N0_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604c0)                                                      */
/*      SPRB0 (0x21e604c0)                                                      */
/*      SPRHBM (0x21e604c0)                                                     */
/*      SPRC0 (0x21e604c0)                                                      */
/*      SPRMCC (0x21e604c0)                                                     */
/*      SPRUCC (0x21e604c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 1
*/


#define M2MEM_PMON_UNIT_DISCOVERY1_N0_M2MEM_MAIN_REG 0x060204C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitctrctrladdr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unit Counter Control Address serves as Base
                               Address
                            */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY1_N0_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY1_N1_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604c4)                                                      */
/*      SPRB0 (0x21e604c4)                                                      */
/*      SPRHBM (0x21e604c4)                                                     */
/*      SPRC0 (0x21e604c4)                                                      */
/*      SPRMCC (0x21e604c4)                                                     */
/*      SPRUCC (0x21e604c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 1
*/


#define M2MEM_PMON_UNIT_DISCOVERY1_N1_M2MEM_MAIN_REG 0x060204C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitctrctrladdr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unit Counter Control Address serves as Base
                               Address
                            */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY1_N1_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY2_N0_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604c8)                                                      */
/*      SPRB0 (0x21e604c8)                                                      */
/*      SPRHBM (0x21e604c8)                                                     */
/*      SPRC0 (0x21e604c8)                                                      */
/*      SPRMCC (0x21e604c8)                                                     */
/*      SPRUCC (0x21e604c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 2
*/


#define M2MEM_PMON_UNIT_DISCOVERY2_N0_M2MEM_MAIN_REG 0x060204C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unittype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Unit Type */
    UINT32 unitid : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Unit ID */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY2_N0_M2MEM_MAIN_STRUCT;

/* M2MEM_PMON_UNIT_DISCOVERY2_N1_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e604cc)                                                      */
/*      SPRB0 (0x21e604cc)                                                      */
/*      SPRHBM (0x21e604cc)                                                     */
/*      SPRC0 (0x21e604cc)                                                      */
/*      SPRMCC (0x21e604cc)                                                     */
/*      SPRUCC (0x21e604cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 2
*/


#define M2MEM_PMON_UNIT_DISCOVERY2_N1_M2MEM_MAIN_REG 0x060204CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 glstsposition : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Global Status Postion */
    UINT32 rsvd1levftbits : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved 1 Level Feature Bits */

  } Bits;
  UINT32 Data;

} M2MEM_PMON_UNIT_DISCOVERY2_N1_M2MEM_MAIN_STRUCT;

/* TWOWAYCACHE_M2MEM_MAIN_REG supported on:                                     */
/*      SPRA0 (0x21e604d8)                                                      */
/*      SPRB0 (0x21e604d8)                                                      */
/*      SPRHBM (0x21e604d8)                                                     */
/*      SPRC0 (0x21e604d8)                                                      */
/*      SPRMCC (0x21e604d8)                                                     */
/*      SPRUCC (0x21e604d8)                                                     */
/* Register default value on SPRA0: 0x01017800                                  */
/* Register default value on SPRB0: 0x0104F800                                  */
/* Register default value on SPRHBM: 0x0104F800                                 */
/* Register default value on SPRC0: 0x0104F800                                  */
/* Register default value on SPRMCC: 0x0104F800                                 */
/* Register default value on SPRUCC: 0x0104F800                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
      Controls for two way cache:
        This registers contains the controls to enable biased two way cache implementation
        This also contains the lfsr or direct ratio based allocation schemes 
        Two way cache is enabled at boot time. Once enabled NM sets are halved and each cacheline can be cached in two ways aka physical locations
        Once enabled/disabled it cannot be disabled/enabled on the fly
        
*/


#define TWOWAYCACHE_M2MEM_MAIN_REG 0x060204D8

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable: 1: 2way cache is enabled 0: 2way cache
                               is disabled (aka direct mapped cache)
                            */
    UINT32 nonpreferredwaymask : 10;

                            /* Bits[10:1], Access Type=RW, default=0x00000000*/

                            /*
                               NonPreferredWayMask: This is a 10-bit mask. Bit
                               0 applies to 1st miss, Bit 1 applies to 2nd
                               miss....Bit 9 applies to 10th miss and it
                               repeats (Bit 0 applies to 11th miss and so on)
                               If Bit X is 1: (n*10 + X + 1 )th miss should be
                               allocated in non preferred way 0: (n*10 + X + 1
                               )th miss should be allocated in preferred way
                            */
    UINT32 preferredreadfirst : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               PreferredReadFirst: 1: Always issue read to the
                               preferred way firt 0: Always issue read to the
                               non preferred way first
                            */
    UINT32 usevc1forsecondway : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1ForSecondWay: 1: USe Isoch LL for
                               SEcondWay 0: Use NMTgr LL for SecondWay
                            */
    UINT32 usevc1creditforsecondway : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1CreditForSecondWay: 1: USe VC1 credit 0:
                               Use VC0 Credit
                            */
    UINT32 adingcrdforsecondway : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000001*/

                            /* No Of Credits hidden from secondway 2^x-1 */
    UINT32 ingreco : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /*
                               Ingress Eco bits for Lb_MCHECK_W type of
                               register
                            */
    UINT32 egreco : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               Ingress Eco bits for Lb_MCHECK_W type of
                               register
                            */

  } Bits;
  UINT32 Data;

} TWOWAYCACHE_M2MEM_MAIN_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable: 1: 2way cache is enabled 0: 2way cache
                               is disabled (aka direct mapped cache)
                            */
    UINT32 nonpreferredwaymask : 10;

                            /* Bits[10:1], Access Type=RW, default=0x00000000*/

                            /*
                               NonPreferredWayMask: This is a 10-bit mask. Bit
                               0 applies to 1st miss, Bit 1 applies to 2nd
                               miss....Bit 9 applies to 10th miss and it
                               repeats (Bit 0 applies to 11th miss and so on)
                               If Bit X is 1: (n*10 + X + 1 )th miss should be
                               allocated in non preferred way 0: (n*10 + X + 1
                               )th miss should be allocated in preferred way
                            */
    UINT32 preferredreadfirst : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               PreferredReadFirst: 1: Always issue read to the
                               preferred way firt 0: Always issue read to the
                               non preferred way first
                            */
    UINT32 usevc1forsecondway : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1ForSecondWay: 1: USe Isoch LL for
                               SEcondWay 0: Use NMTgr LL for SecondWay
                            */
    UINT32 usevc1creditforsecondway : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1CreditForSecondWay: 1: USe VC1 credit 0:
                               Use VC0 Credit
                            */
    UINT32 adingcrdforsecondway : 4;

                            /* Bits[17:14], Access Type=RW, default=0x00000003*/

                            /*
                               Number of AD Transgress credits reserved for
                               second way read returns to send Fill reads to FM
                            */
    UINT32 ingreco : 6;

                            /* Bits[23:18], Access Type=RW, default=0x00000001*/

                            /*
                               Ingress Eco bits for Lb_MCHECK_W type of
                               register
                            */
    UINT32 egreco : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               Ingress Eco bits for Lb_MCHECK_W type of
                               register
                            */

  } Bits;
  UINT32 Data;

} TWOWAYCACHE_M2MEM_MAIN_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable: 1: 2way cache is enabled 0: 2way cache
                               is disabled (aka direct mapped cache)
                            */
    UINT32 nonpreferredwaymask : 10;

                            /* Bits[10:1], Access Type=RW, default=0x00000000*/

                            /*
                               NonPreferredWayMask: This is a 10-bit mask. Bit
                               0 applies to 1st miss, Bit 1 applies to 2nd
                               miss....Bit 9 applies to 10th miss and it
                               repeats (Bit 0 applies to 11th miss and so on)
                               If Bit X is 1: (n*10 + X + 1 )th miss should be
                               allocated in non preferred way 0: (n*10 + X + 1
                               )th miss should be allocated in preferred way
                            */
    UINT32 preferredreadfirst : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               PreferredReadFirst: 1: Always issue read to the
                               preferred way firt 0: Always issue read to the
                               non preferred way first
                            */
    UINT32 usevc1forsecondway : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1ForSecondWay: 1: USe Isoch LL for
                               SEcondWay 0: Use NMTgr LL for SecondWay
                            */
    UINT32 usevc1creditforsecondway : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               UseVC1CreditForSecondWay: 1: USe VC1 credit 0:
                               Use VC0 Credit
                            */
    UINT32 rsvd : 10;

                            /* Bits[23:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 egreco : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               Ingress Eco bits for Lb_MCHECK_W type of
                               register
                            */

  } Bits;
  UINT32 Data;

} TWOWAYCACHE_M2MEM_MAIN_STRUCT;

/* TWOWAYCACHELFSRCTL_N0_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e604e0)                                                      */
/*      SPRB0 (0x21e604e0)                                                      */
/*      SPRHBM (0x21e604e0)                                                     */
/*      SPRC0 (0x21e604e0)                                                      */
/*      SPRMCC (0x21e604e0)                                                     */
/*      SPRUCC (0x21e604e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Controls for two way cache lfsr:
        This registers contains the controls to enable two way cache lfsr 

It provides for two sets of 8 bit LFSRs and their assocaited seeds 

It provides for a mask/match for each of these masks to control the probability of a hit 

Also based on each masks's output we can either or/and/xor each of the outputs to have the final decision of allocating in a preferred or a non preferred way 

*/


#define TWOWAYCACHELFSRCTL_N0_M2MEM_MAIN_REG 0x060204E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lfsr_seed_0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Seed for LFSR 0 */
    UINT32 lfsr_seed_1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* Seed for LFSR 1 */
    UINT32 lfsr_mask_0 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* Mask for LFSR 0 */
    UINT32 lfsr_mask_1 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /* Mask for LFSR 1 */

  } Bits;
  UINT32 Data;

} TWOWAYCACHELFSRCTL_N0_M2MEM_MAIN_STRUCT;

/* TWOWAYCACHELFSRCTL_N1_M2MEM_MAIN_REG supported on:                           */
/*      SPRA0 (0x21e604e4)                                                      */
/*      SPRB0 (0x21e604e4)                                                      */
/*      SPRHBM (0x21e604e4)                                                     */
/*      SPRC0 (0x21e604e4)                                                      */
/*      SPRMCC (0x21e604e4)                                                     */
/*      SPRUCC (0x21e604e4)                                                     */
/* Register default value on SPRA0: 0x00010000                                  */
/* Register default value on SPRB0: 0x00010000                                  */
/* Register default value on SPRHBM: 0x00010000                                 */
/* Register default value on SPRC0: 0x00010000                                  */
/* Register default value on SPRMCC: 0x00010000                                 */
/* Register default value on SPRUCC: 0x00010000                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 
      Controls for two way cache lfsr:
        This registers contains the controls to enable two way cache lfsr 

It provides for two sets of 8 bit LFSRs and their assocaited seeds 

It provides for a mask/match for each of these masks to control the probability of a hit 

Also based on each masks's output we can either or/and/xor each of the outputs to have the final decision of allocating in a preferred or a non preferred way 

*/


#define TWOWAYCACHELFSRCTL_N1_M2MEM_MAIN_REG 0x060204E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lfsr_match_0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Match for LFSR 0 */
    UINT32 lfsr_match_1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* Match for LFSR 1 */
    UINT32 opselect : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000001*/

                            /*
                               Operation on final result of both lfsr masks : 0
                               = A&B 1 = A|B 2 = A^ B 3= RSVD
                            */
    UINT32 rsvd : 13;

                            /* Bits[30:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Enable for LFSR If you want to reload the seeds
                               clear Enable and set Enable again :
                            */

  } Bits;
  UINT32 Data;

} TWOWAYCACHELFSRCTL_N1_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_CP_N0_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e60500)                                                      */
/*      SPRB0 (0x21e60500)                                                      */
/*      SPRHBM (0x21e60500)                                                     */
/*      SPRC0 (0x21e60500)                                                      */
/*      SPRMCC (0x21e60500)                                                     */
/*      SPRUCC (0x21e60500)                                                     */
/* Register default value on SPRA0: 0x0100021E                                  */
/* Register default value on SPRB0: 0x0100021E                                  */
/* Register default value on SPRHBM: 0x0100021E                                 */
/* Register default value on SPRC0: 0x0100021E                                  */
/* Register default value on SPRMCC: 0x0100021E                                 */
/* Register default value on SPRUCC: 0x0100021E                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to RAC, WAC and CP registers for COR_CNT security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define M2M_COR_CNT_CP_N0_M2MEM_MAIN_REG 0x06020500

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_CP_N0_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_CP_N1_M2MEM_MAIN_REG supported on:                               */
/*      SPRA0 (0x21e60504)                                                      */
/*      SPRB0 (0x21e60504)                                                      */
/*      SPRHBM (0x21e60504)                                                     */
/*      SPRC0 (0x21e60504)                                                      */
/*      SPRMCC (0x21e60504)                                                     */
/*      SPRUCC (0x21e60504)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to RAC, WAC and CP registers for COR_CNT security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define M2M_COR_CNT_CP_N1_M2MEM_MAIN_REG 0x06020504

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_CP_N1_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_RAC_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60508)                                                      */
/*      SPRB0 (0x21e60508)                                                      */
/*      SPRHBM (0x21e60508)                                                     */
/*      SPRC0 (0x21e60508)                                                      */
/*      SPRMCC (0x21e60508)                                                     */
/*      SPRUCC (0x21e60508)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the read access to registers in COR_CNT security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_COR_CNT_RAC_N0_M2MEM_MAIN_REG 0x06020508

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_RAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_RAC_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e6050c)                                                      */
/*      SPRB0 (0x21e6050c)                                                      */
/*      SPRHBM (0x21e6050c)                                                     */
/*      SPRC0 (0x21e6050c)                                                      */
/*      SPRMCC (0x21e6050c)                                                     */
/*      SPRUCC (0x21e6050c)                                                     */
/* Register default value on SPRA0: 0x20000D00                                  */
/* Register default value on SPRB0: 0x20000D00                                  */
/* Register default value on SPRHBM: 0x20000D00                                 */
/* Register default value on SPRC0: 0x20000D00                                  */
/* Register default value on SPRMCC: 0x20000D00                                 */
/* Register default value on SPRUCC: 0x20000D00                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the read access to registers in COR_CNT security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_COR_CNT_RAC_N1_M2MEM_MAIN_REG 0x0602050C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_RAC_N1_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_WAC_N0_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60510)                                                      */
/*      SPRB0 (0x21e60510)                                                      */
/*      SPRHBM (0x21e60510)                                                     */
/*      SPRC0 (0x21e60510)                                                      */
/*      SPRMCC (0x21e60510)                                                     */
/*      SPRUCC (0x21e60510)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to registers in COR_CNT security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_COR_CNT_WAC_N0_M2MEM_MAIN_REG 0x06020510

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_WAC_N0_M2MEM_MAIN_STRUCT;

/* M2M_COR_CNT_WAC_N1_M2MEM_MAIN_REG supported on:                              */
/*      SPRA0 (0x21e60514)                                                      */
/*      SPRB0 (0x21e60514)                                                      */
/*      SPRHBM (0x21e60514)                                                     */
/*      SPRC0 (0x21e60514)                                                      */
/*      SPRMCC (0x21e60514)                                                     */
/*      SPRUCC (0x21e60514)                                                     */
/* Register default value on SPRA0: 0x20000C00                                  */
/* Register default value on SPRB0: 0x20000C00                                  */
/* Register default value on SPRHBM: 0x20000C00                                 */
/* Register default value on SPRC0: 0x20000C00                                  */
/* Register default value on SPRMCC: 0x20000C00                                 */
/* Register default value on SPRUCC: 0x20000C00                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to registers in COR_CNT security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define M2M_COR_CNT_WAC_N1_M2MEM_MAIN_REG 0x06020514

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} M2M_COR_CNT_WAC_N1_M2MEM_MAIN_STRUCT;

/* DISTRESSSIGNALLINGENHANCEMENT_M2MEM_MAIN_REG supported on:                   */
/*      SPRA0 (0x21e60518)                                                      */
/*      SPRB0 (0x21e60518)                                                      */
/*      SPRHBM (0x21e60518)                                                     */
/*      SPRC0 (0x21e60518)                                                      */
/*      SPRMCC (0x21e60518)                                                     */
/*      SPRUCC (0x21e60518)                                                     */
/* Register default value on SPRA0: 0x00104080                                  */
/* Register default value on SPRB0: 0x00104080                                  */
/* Register default value on SPRHBM: 0x00104080                                 */
/* Register default value on SPRC0: 0x00104080                                  */
/* Register default value on SPRMCC: 0x00104080                                 */
/* Register default value on SPRUCC: 0x00104080                                 */
/* SPRA0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRB0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRHBM Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRC0 Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR             */
/* SPRMCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* SPRUCC Register File:    sprsp_top/m2mem_reg[0]/m2m/CFG_M2MEM_CSR            */
/* Struct generated from SPRA0 BDF: 30_12_0                                     */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is an extension of the DistressSignalling register. It was added in SPR wave3 time frame to accomodate for the enhancements for QoS mechanism.
HSD:2205369145 details out the need to have seperate thresholds for Local and Remote requests. 
Following are the set of behaviours that can be achieved 

DisableQoSEnhancement=1 --> Wave1 (ICX implementation). Local counters in RTL will count all txn's (both local and remote) and compared with Local Wpq/Rpq thresholds. In this case Remote Wpq/Rpq thgresholds are dont cares.

DisableQosEnhancement=0 --> Local and Remote counters will be compared with local and remote Rpq/Wpq thresholds respectively.

DisableQoSEnhancement=0, LocalThresholdLow/High=MAX Value --> Signal distress for remote txn's 

DisableQoSEnhancement=0, RemoteThresholdLow/High=MAX Value --> Signal distress for local txn's
*/


#define DISTRESSSIGNALLINGENHANCEMENT_M2MEM_MAIN_REG 0x06020518

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 remoterpqoccupancythresholdlow : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               The lower threshold of Rpq occupancy for Remote
                               transactions. If RPQ occupancy drops below this
                               value, then distress can be de-asserted (if Wpq
                               occupancy is also below its lower threshold, for
                               all channels). Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b0.
                               RpqOccupancyThresholdLow should always be a non
                               zero value. Distress is deasserted if the Rpq
                               count drops below the lower threshold. If
                               RpqOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence RpqOccupancyThresholdLow should
                               always be be greater than zero.
                            */
    UINT32 remoterpqoccupancythresholdhigh : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of Rpq occupancy for
                               Remote(same socket) requests. If RPQ occupancy
                               goes above this value, then distress will be
                               asserted(if Ddrt/CLX mode of distress signalling
                               is chosen). This value should be greater than or
                               equal to RpqOccupancyThresholdLow value. Note:
                               For this to be used, DistressDetection2lmOnly
                               has to be set to 1'b0. The maximum possible
                               number of Rpq entries per channel is 80. Hence
                               the maximum value this config bit can have is
                               79(i.e. 7'h4E). Setting
                               RpqOccupancyThresholdHigh value greter than
                               7'h4E would mean, distress never gets asserted,
                               as the logic will check if the Rpq entry count
                               is greater than this value for distress
                               detection.
                            */
    UINT32 remotewpqoccupancythresholdlow : 6;

                            /* Bits[19:14], Access Type=RW, default=0x00000001*/

                            /*
                               The lower threshold of Wpq occupancy for lremote
                               requests. If WPQ occupancy drops below this
                               value, then distress can be de-asserted (if Rpq
                               occupancy is also below its lower threshold, for
                               all channels). Note: For this to be used,
                               DistressDetection2lmOnly has to be set to 1'b0.
                               WpqOccupancyThresholdLow should always be a non
                               zero value. Distress is deasserted if the Wpq
                               count drops below the lower threshold. If
                               WpqOccupancyThresholdLow is set to 0, then
                               distress will never get de-asserted once
                               asserted. Hence WpqOccupancyThresholdLow should
                               always be be greater than zero.
                            */
    UINT32 remotewpqoccupancythresholdhigh : 6;

                            /* Bits[25:20], Access Type=RW, default=0x00000001*/

                            /*
                               The upper/higher threshold of Wpq occupancy for
                               Remote requests. If WPQ occupancy goes above
                               this value, then distress will be asserted (if
                               Ddrt/CLX mode of distress signalling is chosen).
                               This value should be greater than or equal to
                               WpqOccupancyThresholdLow. Note: For this to be
                               used, DistressDetection2lmOnly has to be set to
                               1'b0. The maximum number Wpq entries allocated
                               per channel is 16. Hence
                               WpqOccupancyThresholdHigh can have a maximum
                               value of 15 (4'hF).
                            */
    UINT32 disableqosenhancement : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to disable the enhancement that
                               was made for QoS in SPR. The behaviour is as
                               follows: Value 0 --> Local and remote requests
                               are compared against their own thresholds and
                               distress is signalled based on it. Value 1 -->
                               We revert back to ICX behaviour. We dont
                               distinguish between local and remote reads. Any
                               read or write going to DDRT will incremement the
                               proxy Local counters in ingress. When this bit
                               is set; the threshold for signalling distress
                               needs to be set for Local thresholds i.e. Remote
                               Thresholds are immaterial in this case
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DISTRESSSIGNALLINGENHANCEMENT_M2MEM_MAIN_STRUCT;
#endif /* _M2MEM_MAIN_h */
