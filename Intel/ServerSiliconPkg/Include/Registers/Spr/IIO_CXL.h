
/** @file
  IIO_CXL.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BOOT_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* BTSMM_W                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX1                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX2                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _IIO_CXL_h
#define _IIO_CXL_h
#include <Base.h>

/* NECH_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x20000000)                                                      */
/*      SPRB0 (0x20000000)                                                      */
/*      SPRHBM (0x20000000)                                                     */
/*      SPRC0 (0x20000000)                                                      */
/*      SPRMCC (0x20000000)                                                     */
/*      SPRUCC (0x20000000)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Null Extended Capability Header
*/


#define NECH_IIO_CXL_REG 0x23020000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               PCI Express Extended Capability ID for the
                               Secondary PCI Express Extended Capability is
                               0019h
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Extended Capability structure or 000h if
                               no other items exist in the linked list of
                               Capabilities. Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} NECH_IIO_CXL_STRUCT;

/* PCICMD_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000004)                                                      */
/*      SPRB0 (0x10000004)                                                      */
/*      SPRHBM (0x10000004)                                                     */
/*      SPRC0 (0x10000004)                                                      */
/*      SPRMCC (0x10000004)                                                     */
/*      SPRUCC (0x10000004)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls how the device behaves on the primary interface (PCI Express).
*/


#define PCICMD_IIO_CXL_REG 0x23010004

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 iose : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0 - Respond to all I/O Requests on the primary
                               interface with an Unsupported Request
                               Completion. Forward all I/O transactions from
                               the secondary interface to the primary interface
                               (if supported). 1 - Enable forwarding of I/O
                               Requests to the secondary interface.
                            */
    UINT16 mse : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               0 - Respond to all Memory Requests on the
                               primary interface as Unsupported Request
                               Received. Forward all memory requests from the
                               secondary interface to the primary interface. 1
                               - Enable forwarding of memory transactions to
                               the secondary interface and any internal
                               function.
                            */
    UINT16 bme : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the ability of the Function to
                               issue Memory and I/O read or write requests, and
                               the ability of Root or Switch port to forward
                               memory and I/O read or write requests in the
                               upstream direction. When this bit is 0b, memory
                               and I/O requests received at the root port or
                               downstream side of a switch port (secondary
                               side) must be handled as an Unsupported Request
                               (UR). For Non-posted requests, a completion with
                               UR completion status must be returned. For an
                               endpoint, when this bit is Set, the PCI Express
                               Function is allowed to issue Memory or I/O
                               Requests. When this bit is Clear, the PCI
                               Express Function is not allowed to issue any
                               Memory or I/O Requests. The forwarding of
                               requests other than memory or I/O requests is
                               not controlled by this bit. AtomicOp Requester
                               Enable bit in Device Control 2 register must
                               also be set in order for an AtomicOp Requests to
                               be forwarded. MSI interrupts are inband memory
                               writes and are blocked when this bit is 0b.
                            */
    UINT16 sce : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 mwie : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 vga_pse : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 pere : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the setting of the master data
                               parity error bit in the Status Register ('PCI
                               Status Register (PCISTS)' on page 186) in
                               response to a parity error received on the PCI
                               Express interface (either internal queue errors
                               or a poisoned TLP).
                            */
    UINT16 wcc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 see : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables reporting of Non-
                               Fatal and Fatal errors detected by the Function
                               of the Root Complex. For Type 1 Configuration
                               Space headers, this bit controls transmission by
                               the primary interface of ERR_NONFATAL and
                               ERR_FATAL error messages forwarded from the
                               secondary interface. ERR_COR messages are not
                               affected by this bit. Errors are reported when
                               enabled either through this bit or through the
                               PCI Express-specific bits in the Device Control
                               Register ('Device Control Register (DEVCTL)' on
                               page 228).
                            */
    UINT16 fbe : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI-Express. Hardwired to 0. */
    UINT16 intxd : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the ability of the PCI-Express
                               Function to generate legacy INTx interrupt
                               message. When set, functions are prevented from
                               asserting INTx interrupt messages. Any INTx
                               emulation interrupts already asserted by the
                               function must be deasserted when this bit is set
                               by generating a Deassert_INTx message(s). This
                               bit does not affect the ability to route
                               interrupt messages received at the PCI-Express
                               port. However, this bit controls the generation
                               of legacy interrupts for PCI-Express errors
                               detected internally in this port (e.g. Malformed
                               TLP, CRC error, completion time out etc.) or
                               when receiving root port error messages or
                               interrupts due to HP/PM events generated in
                               legacy mode. This bit has no effect on
                               interrupts that pass through the port from the
                               secondary side of root ports, switch ports, and
                               bridges.
                            */
    UINT16 rsvd : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PCICMD_IIO_CXL_STRUCT;

/* PCISTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000006)                                                      */
/*      SPRB0 (0x10000006)                                                      */
/*      SPRHBM (0x10000006)                                                     */
/*      SPRC0 (0x10000006)                                                      */
/*      SPRMCC (0x10000006)                                                     */
/*      SPRUCC (0x10000006)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCI Status
*/


#define PCISTS_IIO_CXL_REG 0x23010006

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 3;

                            /* Bits[2:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 ints : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               When set, this bit indicates that an INTx
                               emulation interrupt is pending internally in
                               this function. For Type 1 configuration header
                               functions, forwarded INTx messages are not
                               reflected in this bit. unless the INTx messages
                               is being generated from the Type 1 configuration
                               header function.
                            */
    UINT16 cape : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000001*/

                            /*
                               This bit indicates the presence of an Extended
                               capabilities list items. Offset 34H indicates
                               the offset for the first entry in the linked
                               list of capabilities. All PCI Express Functions
                               are required to have a PCI Express Capability
                               Structure. So this bit must be hardwired to 1b.
                            */
    UINT16 c66 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* This bit has no meaning on PCI Express. */
    UINT16 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 fbc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* This bit has no meaning on PCI Express. */
    UINT16 mdpd : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by a requester (primary side for
                               type1 configuration header functions) if the
                               parity error response enable bit (PERE) in the
                               Command Register ('PCI Command Register
                               (PCICMD)' on page 181) is set and either of the
                               following two conditions occur: Requester
                               receives a completion marked poisoned. Requester
                               sends a poisoned request (includes writes and
                               messages) If the parity error bit is 0b, this
                               bit is never set.
                            */
    UINT16 dvt : 2;

                            /* Bits[10:9], Access Type=RO, default=0x00000000*/

                            /*
                               These bits have no meaning on PCI Express. Fast
                               decode timing is reported.
                            */
    UINT16 sta : 1;

                            /* Bits[11:11], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is Set when the port completes a Posted
                               or Non-Posted Request as a Completer Abort
                               error. This applies to a Function with a Type 1
                               Configuration header when the Completer Abort
                               was generated by its Primary Side. If the given
                               Configuration or MMIO access to the PCIe
                               internal resource does not follow formation
                               rule, then it is completed with CA status and is
                               logged as PCISTS.STA. Refer to Section 1.11.5,
                               'Master/Target abort Logging in
                               Primary/Secondary Status registers' on page 40
                               of the PCIe Gen3 Chapter.
                            */
    UINT16 rta : 1;

                            /* Bits[12:12], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a requester receives a CA
                               completions status. On Type 1 configuration
                               header functions, the bit is set when a
                               'Completer Abort' is received on the primary
                               side.
                            */
    UINT16 rma : 1;

                            /* Bits[13:13], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the requester receives a
                               completion with an UR completion status. On Type
                               1 configuration header functions, the bit is set
                               when a UR completions status is received on the
                               primary side.
                            */
    UINT16 sse : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when ERR_FATAL or ERR_NONFATAL
                               messages are sent to the root complex and the
                               SERR enable bit in the PCICMD Register ('PCI
                               Command Register (PCICMD)' on page 181) is set.
                            */
    UINT16 dpe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a poisoned TLP is received
                               from PCIe or IOSF. This bit is set even when the
                               parity error response enable bit (bit[6] of the
                               PCICMD Register'PCI Command Register (PCICMD)'
                               on page 181) is not set. On Type 1 configuration
                               header functions, the bit is set when the
                               poisoned TLP is received on the primary side.
                            */

  } Bits;
  UINT16 Data;

} PCISTS_IIO_CXL_STRUCT;

/* RID_IIO_CXL_REG supported on:                                                */
/*      SPRA0 (0x8)                                                             */
/*      SPRB0 (0x8)                                                             */
/*      SPRHBM (0x8)                                                            */
/*      SPRC0 (0x8)                                                             */
/*      SPRMCC (0x8)                                                            */
/*      SPRUCC (0x8)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Revision ID
*/


#define RID_IIO_CXL_REG 0x23000008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 rid : 8;

                            /* Bits[7:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field specifies the specific revision of
                               this function and should be viewed as a
                               extension to the Device ID. Default values will
                               be determined by soft strap or SetIDValue or
                               fuses if supported.
                            */

  } Bits;
  UINT8 Data;

} RID_IIO_CXL_STRUCT;

/* CCRPI_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x9)                                                             */
/*      SPRB0 (0x9)                                                             */
/*      SPRHBM (0x9)                                                            */
/*      SPRC0 (0x9)                                                             */
/*      SPRMCC (0x9)                                                            */
/*      SPRUCC (0x9)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Class Code Programming Interface
*/


#define CCRPI_IIO_CXL_REG 0x23000009

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 rlpi : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               This field identifies a specific register level
                               programming interface (if any) so that device
                               independent software can interact with the
                               Function. Encodings for interface are provided
                               in the PCI Code and ID Assignment Specification.
                               All unspecified encodings are Reserved. This
                               variable needs to be customized for the end
                               project requirements as the functionality and
                               type of end point is not known at this point.
                            */

  } Bits;
  UINT8 Data;

} CCRPI_IIO_CXL_STRUCT;

/* CCRSCC_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0xa)                                                             */
/*      SPRB0 (0xa)                                                             */
/*      SPRHBM (0xa)                                                            */
/*      SPRC0 (0xa)                                                             */
/*      SPRMCC (0xa)                                                            */
/*      SPRUCC (0xa)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Class Code Sub-Class Code
*/


#define CCRSCC_IIO_CXL_REG 0x2300000A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 sc : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Specifies a base class sub-class, which
                               identifies more specifically the operation of
                               the Function. Encodings for sub-class are
                               provided in the PCI Code and ID Assignment
                               Specification. All unspecified encodings are
                               Reserved. This 8-bit value indicates that this
                               device is a PCI-to-PCI Bridge.
                            */

  } Bits;
  UINT8 Data;

} CCRSCC_IIO_CXL_STRUCT;

/* CCRBCC_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0xb)                                                             */
/*      SPRB0 (0xb)                                                             */
/*      SPRHBM (0xb)                                                            */
/*      SPRC0 (0xb)                                                             */
/*      SPRMCC (0xb)                                                            */
/*      SPRUCC (0xb)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* The CCR register has an attribute of RW-L PRST to allow configuration software to modify and lock the register from further update. Lock Key bit is located in the Personality Lock Key Control Register ('PLKCTL').
*/


#define CCRBCC_IIO_CXL_REG 0x2300000B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bc : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               A code that broadly classifies the type of
                               operation the Function performs. Encodings for
                               base class, are provided in the PCI Code and ID
                               Assignment Specification. All unspecified
                               encodings are Reserved. The value of 06h
                               indicates that this is a bridge device.
                            */

  } Bits;
  UINT8 Data;

} CCRBCC_IIO_CXL_STRUCT;

/* CLS_IIO_CXL_REG supported on:                                                */
/*      SPRA0 (0xc)                                                             */
/*      SPRB0 (0xc)                                                             */
/*      SPRHBM (0xc)                                                            */
/*      SPRC0 (0xc)                                                             */
/*      SPRMCC (0xc)                                                            */
/*      SPRUCC (0xc)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Cacheline Size
*/


#define CLS_IIO_CXL_REG 0x2300000C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 cls : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               These bits specify the system cache-line size in
                               units of DWords. This field is implemented by
                               PCI Express devices but has no effect on device
                               behavior.
                            */

  } Bits;
  UINT8 Data;

} CLS_IIO_CXL_STRUCT;

/* PLAT_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0xd)                                                             */
/*      SPRB0 (0xd)                                                             */
/*      SPRHBM (0xd)                                                            */
/*      SPRC0 (0xd)                                                             */
/*      SPRMCC (0xd)                                                            */
/*      SPRUCC (0xd)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register denotes the maximum time slice for a burst transaction in legacy PCI 2.3 on the primary interface. It does not affect/influence PCI-Express functionality.
*/


#define PLAT_IIO_CXL_REG 0x2300000D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 prim_lat_timer : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               Not applicable to PCI-Express. Hardwired to 00h.
                               This register is typically called as 'latency
                               Timer' for Endpoints in PCI 3.0 specification
                            */

  } Bits;
  UINT8 Data;

} PLAT_IIO_CXL_STRUCT;

/* HDR_IIO_CXL_REG supported on:                                                */
/*      SPRA0 (0xe)                                                             */
/*      SPRB0 (0xe)                                                             */
/*      SPRHBM (0xe)                                                            */
/*      SPRC0 (0xe)                                                             */
/*      SPRMCC (0xe)                                                            */
/*      SPRUCC (0xe)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Header Type
*/


#define HDR_IIO_CXL_REG 0x2300000E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 htype : 7;

                            /* Bits[6:0], Access Type=RW/L, default=None*/

                            /*
                               These bits define the layout of addresses 10h
                               through 3Fh in the configuration space. These
                               bits read as 01h to indicate that the register
                               layout conforms to the standard PCI-to-PCI
                               Bridge layout.
                            */
    UINT8 mfd : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               The root port, DMI/R-Link in RC, Virtual Root
                               port/switch port and downstream ports are single
                               function only.
                            */

  } Bits;
  UINT8 Data;

} HDR_IIO_CXL_STRUCT;

/* BIST_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0xf)                                                             */
/*      SPRB0 (0xf)                                                             */
/*      SPRHBM (0xf)                                                            */
/*      SPRC0 (0xf)                                                             */
/*      SPRMCC (0xf)                                                            */
/*      SPRUCC (0xf)                                                            */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register is used for reporting control and status information of BIST checks within a PCIExpress port. It is not supported in this implementation.
*/


#define BIST_IIO_CXL_REG 0x2300000F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_tst : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /* Not supported. Hardwired to 0h */

  } Bits;
  UINT8 Data;

} BIST_IIO_CXL_STRUCT;

/* EXPPTMBAR_N0_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x20000010)                                                      */
/*      SPRB0 (0x20000010)                                                      */
/*      SPRHBM (0x20000010)                                                     */
/*      SPRC0 (0x20000010)                                                      */
/*      SPRMCC (0x20000010)                                                     */
/*      SPRUCC (0x20000010)                                                     */
/* Register default value on SPRA0: 0x00000004                                  */
/* Register default value on SPRB0: 0x00000004                                  */
/* Register default value on SPRHBM: 0x00000004                                 */
/* Register default value on SPRC0: 0x00000004                                  */
/* Register default value on SPRMCC: 0x00000004                                 */
/* Register default value on SPRUCC: 0x00000004                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Express Port Memory Base Address
*/


#define EXPPTMBAR_N0_IIO_CXL_REG 0x23020010

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 msi : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /* 0b: Memory space 1b: IO space */
    UINT32 type : 2;

                            /* Bits[2:1], Access Type=RO, default=0x00000002*/

                            /*
                               The memory mapped space can be placed anywhere
                               within the 64-bit addressable region of the
                               device.
                            */
    UINT32 pref : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Not prefetchable Memory Space. */
    UINT32 rsvd : 13;

                            /* Bits[16:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 baddr : 15;

                            /* Bits[31:17], Access Type=RW, default=0x00000000*/

                            /* Base Address */

  } Bits;
  UINT32 Data;

} EXPPTMBAR_N0_IIO_CXL_STRUCT;

/* EXPPTMBAR_N1_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x20000014)                                                      */
/*      SPRB0 (0x20000014)                                                      */
/*      SPRHBM (0x20000014)                                                     */
/*      SPRC0 (0x20000014)                                                      */
/*      SPRMCC (0x20000014)                                                     */
/*      SPRUCC (0x20000014)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Express Port Memory Base Address
*/


#define EXPPTMBAR_N1_IIO_CXL_REG 0x23020014

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 baddr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* Base Address */

  } Bits;
  UINT32 Data;

} EXPPTMBAR_N1_IIO_CXL_STRUCT;

/* PRIBUS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x18)                                                            */
/*      SPRB0 (0x18)                                                            */
/*      SPRHBM (0x18)                                                           */
/*      SPRC0 (0x18)                                                            */
/*      SPRMCC (0x18)                                                           */
/*      SPRUCC (0x18)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Primary Bus Number
*/


#define PRIBUS_IIO_CXL_REG 0x23000018

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 pbn : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               These bits indicate the PCI Express bus number.
                               Any Type 1 configuration cycle with a bus number
                               less than this number is not accepted by this
                               bridge (in other words, it may still match the
                               other bridge).
                            */

  } Bits;
  UINT8 Data;

} PRIBUS_IIO_CXL_STRUCT;

/* SECBUS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x19)                                                            */
/*      SPRB0 (0x19)                                                            */
/*      SPRHBM (0x19)                                                           */
/*      SPRC0 (0x19)                                                            */
/*      SPRMCC (0x19)                                                           */
/*      SPRUCC (0x19)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Secondary Bus Number
*/


#define SECBUS_IIO_CXL_REG 0x23000019

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 scbn : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               These bits indicate the bus number of the PCI
                               device to which the secondary interface is
                               connected. Any Type 1 configuration cycle
                               matching this bus number is translated to a Type
                               0 configuration cycle and run on the PCI bus.
                            */

  } Bits;
  UINT8 Data;

} SECBUS_IIO_CXL_STRUCT;

/* SUBBUS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1a)                                                            */
/*      SPRB0 (0x1a)                                                            */
/*      SPRHBM (0x1a)                                                           */
/*      SPRC0 (0x1a)                                                            */
/*      SPRMCC (0x1a)                                                           */
/*      SPRUCC (0x1a)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Subordinate Bus Number
*/


#define SUBBUS_IIO_CXL_REG 0x2300001A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 sbbn : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               These bits indicate the highest PCI bus number
                               downstream of this bridge. Every Type 1
                               configuration cycle on PCI Express with a bus
                               number greater than the secondary bus number and
                               less than or equal to the subordinate bus number
                               is forwarded as a Type 1 configuration cycle to
                               the secondary PCI bus.
                            */

  } Bits;
  UINT8 Data;

} SUBBUS_IIO_CXL_STRUCT;

/* IOBASE_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1c)                                                            */
/*      SPRB0 (0x1c)                                                            */
/*      SPRHBM (0x1c)                                                           */
/*      SPRC0 (0x1c)                                                            */
/*      SPRMCC (0x1c)                                                           */
/*      SPRUCC (0x1c)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The I/O Base and I/O Limit registers define an address range that is used by the PCI-Express port to determine when to forward I/O transactions from one interface to the other using the following formula:
IO_BASE <= A[15:12]<=IO_LIMIT
Only the upper 4 bits are programmable. For the purpose of address decode, address bits A[11:0] are treated as 0. The bottom of the defined I/O address range will be aligned to a 4KB boundary while the top of the region specified by IO_LIMIT will be one less than a 4 KB multiple.
*/


#define IOBASE_IIO_CXL_REG 0x2300001C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 iobc : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000000*/

                            /*
                               Each of these bits is hard-wired to 0,
                               indicating support for 16-bit I/O addressing
                               only.
                            */
    UINT8 ioba : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits define the bottom address of an
                               address range to determine when to forward I/O
                               transactions from one interface to another.
                               These bits correspond to address lines[15:12]
                               for 4 KB alignment. Bits[11:0] are assumed to be
                               000h.
                            */

  } Bits;
  UINT8 Data;

} IOBASE_IIO_CXL_STRUCT;

/* IOLIMIT_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x1d)                                                            */
/*      SPRB0 (0x1d)                                                            */
/*      SPRHBM (0x1d)                                                           */
/*      SPRC0 (0x1d)                                                            */
/*      SPRMCC (0x1d)                                                           */
/*      SPRUCC (0x1d)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The I/O Base and I/O Limit registers define an address range that is used by the PCI-Express bridge to determine when to forward I/O transactions from one interface to the other using the following formula:
IO_BASE <= A[15:12] <=IO_LIMIT
Only the upper 4 bits are programmable. For the purpose of address decode, address bits A[11:0] of
the IO limit register is treated as FFFh.
*/


#define IOLIMIT_IIO_CXL_REG 0x2300001D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 iolc : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000000*/

                            /*
                               Each of these bits is hard-wired to 0,
                               indicating support for 16-bit I/O addressing
                               only.
                            */
    UINT8 iola : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits define the top address of an address
                               range to determine when to forward I/O
                               transactions from PCI Express to PCI. These bits
                               correspond to address lines[15:12] for 4 KB
                               aligned window. Bits[11:0] are assumed to be
                               FFFh.
                            */

  } Bits;
  UINT8 Data;

} IOLIMIT_IIO_CXL_STRUCT;

/* SECSTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1000001e)                                                      */
/*      SPRB0 (0x1000001e)                                                      */
/*      SPRHBM (0x1000001e)                                                     */
/*      SPRC0 (0x1000001e)                                                      */
/*      SPRMCC (0x1000001e)                                                     */
/*      SPRUCC (0x1000001e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Secondary Status
*/


#define SECSTS_IIO_CXL_REG 0x2301001E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 5;

                            /* Bits[4:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 c66 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 fbc : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 mdpd : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side requester
                               if the Parity Error Response Enable (PERE) bit
                               in the Bridge Control Register (BCTL) is set and
                               either of the following conditions occurs:
                               Requester receives completion marked poisoned
                               Requester sends a poisoned request (includes
                               writes and messages) If the PERE bit in the
                               Bridge Control Register (BCTL) is clear, this
                               bit is never set.
                            */
    UINT16 dvt : 2;

                            /* Bits[10:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sta : 1;

                            /* Bits[11:11], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 configuration space header function (for
                               requests completed by type 1 header functions
                               itself) completes a Posted or Non-posted request
                               as a Completer Abort error.
                            */
    UINT16 rta : 1;

                            /* Bits[12:12], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 Configuration Space Header Function (for
                               Requests initiated by the Type 1 header Function
                               itself) receives a completion with Completer
                               About Completion Status.
                            */
    UINT16 rma : 1;

                            /* Bits[13:13], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the secondary side for Type
                               1 configuration space header function (for
                               requests initiated by the Type 1 header function
                               itself) receives a completion with Unsupported
                               Requests Completion Status.
                            */
    UINT16 rse : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side for a Type
                               1 Configuration Space header function whenever
                               it receives an ERR_FATAL or ERR_NONFATAL
                               message.
                            */
    UINT16 dpe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by the secondary side for a Type
                               1 Configuration Space header function whenever
                               it receives a Poisoned TLP, regardless of the
                               state in the Parity Error Response Enable (PERE)
                               field of the Bridge Control Register (BCTL).
                            */

  } Bits;
  UINT16 Data;

} SECSTS_IIO_CXL_STRUCT;

/* MEMBASE_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000020)                                                      */
/*      SPRB0 (0x10000020)                                                      */
/*      SPRHBM (0x10000020)                                                     */
/*      SPRC0 (0x10000020)                                                      */
/*      SPRMCC (0x10000020)                                                     */
/*      SPRUCC (0x10000020)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Memory Base and Memory Limit registers define a memory mapped I/O non-prefetchable address range (32-bit addresses) and direct the accesses in this range to the PCI-Express port based on the following formula:
MEMORY_BASE <= A[31:20] <= MEMORY_LIMIT
The upper 12 bits of both the Memory Base and Memory Limit registers are read/write and corresponds to the upper 12 address bits, AD[31:20], of 32-bit addresses. For the purpose of address decoding, the bridge assumes that the lower 20 address bits, AD[19:0], of the memory base address are zero. Similarly, the bridge assumes that the lower 20 address bits, AD[19:0], of the memory limit address (not implemented in the Memory Limit register) are FFFFFh. Thus, the bottom of the defined memory address range will be aligned to a 1 MB boundary and the top of the defined memory address range will be one less than a 1 MB boundary
*/


#define MEMBASE_IIO_CXL_REG 0x23010020

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mb : 12;

                            /* Bits[15:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are compared with bits[31:20] of the
                               incoming address to determine the lower 1 MB-
                               aligned value (inclusive) of the range. The
                               incoming address must be greater than or equal
                               to this value.
                            */

  } Bits;
  UINT16 Data;

} MEMBASE_IIO_CXL_STRUCT;

/* MEMLIMIT_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x10000022)                                                      */
/*      SPRB0 (0x10000022)                                                      */
/*      SPRHBM (0x10000022)                                                     */
/*      SPRC0 (0x10000022)                                                      */
/*      SPRMCC (0x10000022)                                                     */
/*      SPRUCC (0x10000022)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the processor to PCI-Express non-prefetchable memory access routing based on the following formula as described above:
MEMORY_BASE <= A[31:20] <= MEMORY_LIMIT
The upper 12 bits of the register are read/write and correspond to the upper 12 address bits A[31:20] of the 32 bit address. The bottom 4 bits of this register are read-only and return zeros when read. This register must be initialized by the configuration software. For the purpose of address decode address bits A[19:0] are assumed to be FFFFFh.
Memory range covered by MEMBASE and MEMLIM registers, are used to map non-prefetchable PCIExpress address ranges (typically where control/status memory-mapped I/O data structures reside) and PFBASE and PFLIMIT are used to map prefetchable address ranges. This segregation allows application of USWC space attribute to be performed in a true plug-and-play manner to the prefetchable address range for improved PCI-Express memory access performance.
Note also that configuration software is responsible for programming all address range registers such as MEMLIM, MEMBASE, IOLIM, IOBASE, PFBASE, PFLIMIT, PFBASEU, PFLIMITU (coherent, MMIO, prefetchable, non-prefetchable, I/O) with the values that provide exclusive address ranges i.e. prevent overlap with each other and/or with the ranges covered with the main memory. There is no provision in the EIP PCIe macro to enforce prevention of overlap and operations of the system in the case of overlap are not guaranteed
*/


#define MEMLIMIT_IIO_CXL_REG 0x23010022

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 ml : 12;

                            /* Bits[15:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are compared with bits[31:20] of the
                               incoming address to determine the upper limit of
                               the range of memory accesses that will be passed
                               by the port. The incoming address must be less
                               than or equal to this value as described in the
                               formula in Section 1.5.1.33, 'Memory Base
                               Register (MEMBASE)' on page 207.
                            */

  } Bits;
  UINT16 Data;

} MEMLIMIT_IIO_CXL_STRUCT;

/* PFBASE_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000024)                                                      */
/*      SPRB0 (0x10000024)                                                      */
/*      SPRHBM (0x10000024)                                                     */
/*      SPRC0 (0x10000024)                                                      */
/*      SPRMCC (0x10000024)                                                     */
/*      SPRUCC (0x10000024)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Prefetchable Memory Base and Memory Limit registers define a memory mapped  I/O prefetchable address range (32-bit addresses) which is used by the PCI-Express bridge to determine when to forward memory transactions based on the following formula:
PREFETCH_MEMORY_BASE <= A[31:20] <= PREFETCH_MEMORY_LIMIT
The upper 12 bits of both the Prefetchable Memory Base and Memory Limit registers are read/ write and corresponds to the upper 12 address bits, A[31:20], of 32-bit addresses. For the purpose of address decoding, the bridge assumes that the lower 20 address bits, A[19:0], of the memory base address are zero. Similarly, the bridge assumes that the lower 20 address bits, A[19:0], of the memory limit address (not implemented in the Memory Limit register) are FFFFFh. Thus, the bottom of the defined memory address range will be aligned to a 1 MB boundary and the top of the defined memory address range will be one less than a 1 MB boundary.The bottom 4 bits of both the Prefetchable Memory Base and Prefetchable Memory Limit registers are read-only, contain the same value, and encode whether or not the bridge supports 64-bit addresses. If these four bits have the value 0h, then the bridge supports only 32 bit addresses. If these four bits have the value 01h, then the port supports 64-bit addresses and the Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers hold the rest of the 64-bit prefetchable base and limit addresses respectively.
*/


#define PFBASE_IIO_CXL_REG 0x23010024

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pfmcap : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000001*/

                            /*
                               0: 32-bit Prefetchable Memory addressing. 1:
                               64-bit Prefetchable Memory addressing,. This
                               field indicates that 64-bit addressing is
                               supported for the limit.
                            */
    UINT16 pmb : 12;

                            /* Bits[15:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are compared with bits[31:20] of the
                               incoming address to determine the lower 1 MB-
                               aligned value (inclusive) of the range. The
                               incoming address must be greater than or equal
                               to this value.
                            */

  } Bits;
  UINT16 Data;

} PFBASE_IIO_CXL_STRUCT;

/* PFLIMIT_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000026)                                                      */
/*      SPRB0 (0x10000026)                                                      */
/*      SPRHBM (0x10000026)                                                     */
/*      SPRC0 (0x10000026)                                                      */
/*      SPRMCC (0x10000026)                                                     */
/*      SPRUCC (0x10000026)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the processor to PCI-Express prefetchable memory access routing based on the following formula as described above:
PREFETCH_MEMORY_BASE <= A[31:20] <= PREFTCH_MEMORY_LIMIT
The upper 12 bits of the register are read/write and correspond to the upper 12 address bits A[31:20] of the 32 bit address. This register must be initialized by the configuration software. For the purpose of address decode address bits A[19:0] are assumed to be FFFFFh.
*/


#define PFLIMIT_IIO_CXL_REG 0x23010026

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pmlc : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000001*/

                            /*
                               This field indicates that 64-bit addressing is
                               supported for the limit.
                            */
    UINT16 pml : 12;

                            /* Bits[15:4], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are compared with bits[31:20] of the
                               incoming address to determine the upper limit of
                               the prefetchable memory range. The incoming
                               address must be less than or equal to this value
                               as described in the formula in Section 1.5.1.36,
                               'Prefetchable Memory Limit Register (PFLIMIT)'
                               on page 210
                            */

  } Bits;
  UINT16 Data;

} PFLIMIT_IIO_CXL_STRUCT;

/* PFBASEU_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000028)                                                      */
/*      SPRB0 (0x20000028)                                                      */
/*      SPRHBM (0x20000028)                                                     */
/*      SPRC0 (0x20000028)                                                      */
/*      SPRMCC (0x20000028)                                                     */
/*      SPRUCC (0x20000028)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers. 
If a 64-bit prefetchable memory address range is supported, the Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers specify the upper 32-bits, corresponding to A[63:32], of the 64-bit base and limit addresses which specify the prefetchable memory address range.
PREFETCH_MEMORY_BASE_UPPER <= A[63:32] <= PREFETCH_MEMORY_BASE_LIMIT_UPPER
*/


#define PFBASEU_IIO_CXL_REG 0x23020028

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmbu : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Corresponds to A[63:32] of the memory address
                               that maps to the upper base of the prefetchable
                               range of memory accesses that will be passed by
                               the PCI-Express bridge. OS should program these
                               bits based on the available physical limits of
                               the system
                            */

  } Bits;
  UINT32 Data;

} PFBASEU_IIO_CXL_STRUCT;

/* PFLIMITU_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x2000002c)                                                      */
/*      SPRB0 (0x2000002c)                                                      */
/*      SPRHBM (0x2000002c)                                                     */
/*      SPRC0 (0x2000002c)                                                      */
/*      SPRMCC (0x2000002c)                                                     */
/*      SPRUCC (0x2000002c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Prefetchable Memory Limit Upper 32 Bits
*/


#define PFLIMITU_IIO_CXL_REG 0x2302002C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmlu : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Corresponds to A[63:32] of the memory address
                               that maps to the upper limit of the prefetchable
                               range of memory accesses that will be passed by
                               the PCI-Express bridge. The incoming address
                               must be less than or equal to this value as
                               described in the formula in Section 1.5.1.37,
                               'Prefetchable Memory Base Upper 32 Bits Register
                               (PFBASEU)' on page 210
                            */

  } Bits;
  UINT32 Data;

} PFLIMITU_IIO_CXL_STRUCT;

/* CAPPTR_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x34)                                                            */
/*      SPRB0 (0x34)                                                            */
/*      SPRHBM (0x34)                                                           */
/*      SPRC0 (0x34)                                                            */
/*      SPRMCC (0x34)                                                           */
/*      SPRUCC (0x34)                                                           */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Capabilities Pointer
*/


#define CAPPTR_IIO_CXL_REG 0x23000034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 cptr : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000040*/

                            /*
                               Contains the offset of the first item in the
                               list of capabilities. (EXPCAPLST)
                            */

  } Bits;
  UINT8 Data;

} CAPPTR_IIO_CXL_STRUCT;

/* INTL_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x3c)                                                            */
/*      SPRB0 (0x3c)                                                            */
/*      SPRHBM (0x3c)                                                           */
/*      SPRC0 (0x3c)                                                            */
/*      SPRMCC (0x3c)                                                           */
/*      SPRUCC (0x3c)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Interrupt Line
*/


#define INTL_IIO_CXL_REG 0x2300003C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 intl : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This register is used to communicate interrupt
                               line routing information. The device itself does
                               not use this value, rather it is used by device
                               drivers and operating systems. (compatibility)
                            */

  } Bits;
  UINT8 Data;

} INTL_IIO_CXL_STRUCT;

/* INTP_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x3d)                                                            */
/*      SPRB0 (0x3d)                                                            */
/*      SPRHBM (0x3d)                                                           */
/*      SPRC0 (0x3d)                                                            */
/*      SPRMCC (0x3d)                                                           */
/*      SPRUCC (0x3d)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Interrupt Pin
*/


#define INTP_IIO_CXL_REG 0x2300003D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 intp : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               This register tells which interrupt pin the
                               function uses. 01h: Generate INTA 02h: Generate
                               INTB 03h: Generate INTC 04h: Generate INTD
                               Others: Reserved BIOS has the ability to write
                               this register once during boot to setup the
                               correct interrupt for the Function.
                            */

  } Bits;
  UINT8 Data;

} INTP_IIO_CXL_STRUCT;

/* BCTL_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x1000003e)                                                      */
/*      SPRB0 (0x1000003e)                                                      */
/*      SPRHBM (0x1000003e)                                                     */
/*      SPRC0 (0x1000003e)                                                      */
/*      SPRMCC (0x1000003e)                                                     */
/*      SPRUCC (0x1000003e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register provides extensions to the Command Register ('PCI Command Register (PCICMD)' on page 181) that are specific to a bridge. The Bridge Control Register provides many of the same controls for the secondary interface that are provided by the Command Register for the primary interface. Some bits affect operation of both interfaces of the bridge.
*/


#define BCTL_IIO_CXL_REG 0x2301003E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the response to poisoned TLPs
                               in the PCI Express port. 1: Enables reporting of
                               poisoned TLP errors. 0: Disables reporting of
                               poisoned TLP errors.
                            */
    UINT16 se : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the forwarding of PCI Express
                               ERR_COR, ERR_NONFATAL and ERR_FATAL messages to
                               the primary side. 1: Enables forwarding of
                               ERR_COR, ERR_NONFATAL, ERR_FATAL messages. 0:
                               Disables forwarding of ERR_COR, ERR_NONFATAL,
                               ERR_FATAL messages.
                            */
    UINT16 ie : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit modifies the response by the bridge to
                               ISA I/O addresses. This field applies only to
                               I/O addresses that are enabled by the I/O base
                               and I/O limit registers and are in the first 64
                               KB of PCI I/O space. When this bit is set, the
                               bridge blocks all forwarding from primary to
                               secondary of I/O transactions addressing the
                               last 768 bytes in each 1 KB block (offsets 100h
                               to 3FFh). In the opposite direction (secondary
                               to primary), I/O transactions will be forwarded
                               if they address the last 768B in each 1 KB
                               block. 1: Forward upstream ISA I/O addresses in
                               the address range defined by the I/O Base and
                               I/O Limit registers that are in the firsts 64KB
                               of PCI I/O address space (Top 768B of each 1K
                               block). 0: Forward downstream all I/O addresses
                               in the address range defined by the I/O Base and
                               I/O Limit registers.
                            */
    UINT16 vgae : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit modifies the response to VGA-compatible
                               addresses. When set to 1b, the bridge positively
                               decodes and forwards the following transactions
                               from primary side to secondary side regardless
                               of the value of the I/O base and limit
                               registers. The transactions are qualified by the
                               memory enable and I/O enable in the command
                               register. Memory addresses: 000A 0000h-000B
                               FFFFh I/O addresses: 3B0h-3BBh and 3C0h-3DFh in
                               first 64 KB of I/O address space (Inclusive of
                               ISA address aliases when IO address bits[15:10]
                               are not decoded)
                            */
    UINT16 vga16bd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the bridge to provide 16-bit
                               decoding of VGA I/O address precluding the
                               decoding of VGA alias addresses every 1 KB. This
                               bit requires the VGA enable bit (bit 3 of this
                               register) to be set to 1. 0: execute 10-bit
                               address decode on VGA I/O accesses 1: execute
                               16-bit address decode on VGA I/O accesses
                            */
    UINT16 mam : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sbr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit triggers a hot reset on the
                               downstream link for the corresponding PCIe
                               Express port and the PCI Express hierarchy
                               domain subordinate to the port. Software must
                               ensure a minimum reset duration of 1us as
                               defined in the PCI Local Bus Specification,
                               Revision 3.0. Hardware will continue to maintain
                               the hot reset state as long as the SBR bit is
                               set. For Root Ports, it is recommended that
                               software assert this field for a minimum of 2 ms
                               to ensure that all downstream links enters hot
                               reset state. A secondary bus reset will not
                               reset any register of a Type 1 configuration
                               space header function.
                            */
    UINT16 fbe : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 pdt : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 sdt : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 dts : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 dtse : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /* Not applicable to PCI Express. Hardwired to 0. */
    UINT16 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} BCTL_IIO_CXL_STRUCT;

/* EXPCAPLST_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x10000040)                                                      */
/*      SPRB0 (0x10000040)                                                      */
/*      SPRHBM (0x10000040)                                                     */
/*      SPRC0 (0x10000040)                                                      */
/*      SPRMCC (0x10000040)                                                     */
/*      SPRUCC (0x10000040)                                                     */
/* Register default value on SPRA0: 0x0000A010                                  */
/* Register default value on SPRB0: 0x0000A010                                  */
/* Register default value on SPRHBM: 0x0000A010                                 */
/* Register default value on SPRC0: 0x0000A010                                  */
/* Register default value on SPRMCC: 0x0000A010                                 */
/* Register default value on SPRUCC: 0x0000A010                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PCI Express Capability List
*/


#define EXPCAPLST_IIO_CXL_REG 0x23010040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /* Identifies the function as PCI Express capable. */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RO, default=0x000000A0*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list. (PMCAPLST)
                            */

  } Bits;
  UINT16 Data;

} EXPCAPLST_IIO_CXL_STRUCT;

/* EXPCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000042)                                                      */
/*      SPRB0 (0x10000042)                                                      */
/*      SPRHBM (0x10000042)                                                     */
/*      SPRC0 (0x10000042)                                                      */
/*      SPRMCC (0x10000042)                                                     */
/*      SPRUCC (0x10000042)                                                     */
/* Register default value on SPRA0: 0x00000042                                  */
/* Register default value on SPRB0: 0x00000042                                  */
/* Register default value on SPRHBM: 0x00000042                                 */
/* Register default value on SPRC0: 0x00000042                                  */
/* Register default value on SPRMCC: 0x00000042                                 */
/* Register default value on SPRUCC: 0x00000042                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register stores the version number of the capability item and other base information contained in the capability structure.
*/


#define EXPCAP_IIO_CXL_REG 0x23010042

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vn : 4;

                            /* Bits[3:0], Access Type=RO, default=0x00000002*/

                            /*
                               These bits indicate the version number of the
                               PCI Express capability structure.
                            */
    UINT16 dt : 4;

                            /* Bits[7:4], Access Type=RO, default=0x00000004*/

                            /* 4h: Root Port of a PCIe Root Complex */
    UINT16 si : 1;

                            /* Bits[8:8], Access Type=RW/L, default=None*/

                            /*
                               1: Indicates the PCI Express link associated
                               with this port is connected to a slot. 0:
                               Indicates no slot is connected to this port.
                               Applies only to root and downstream ports. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT16 imn : 5;

                            /* Bits[13:9], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates the interrupt message
                               number that is generated from the PCI Express
                               port. When there is more than one MSI interrupt
                               number, this register is required to contain the
                               offset between the base Message Data and the MSI
                               Message that is generated when the status bits
                               in the slot status register or root port status
                               registers are set. The Chipset is required to
                               update this field if the number of MSI messages
                               change. Applies only to Root ports. The PCIe
                               macro assigns the first vector for PM/HP events
                               and so this field is set to 0.
                            */
    UINT16 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} EXPCAP_IIO_CXL_STRUCT;

/* DEVCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000044)                                                      */
/*      SPRB0 (0x20000044)                                                      */
/*      SPRHBM (0x20000044)                                                     */
/*      SPRC0 (0x20000044)                                                      */
/*      SPRMCC (0x20000044)                                                     */
/*      SPRUCC (0x20000044)                                                     */
/* Register default value on SPRA0: 0x00008000                                  */
/* Register default value on SPRB0: 0x00008000                                  */
/* Register default value on SPRHBM: 0x00008000                                 */
/* Register default value on SPRC0: 0x00008000                                  */
/* Register default value on SPRMCC: 0x00008000                                 */
/* Register default value on SPRUCC: 0x00008000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Device Capabilities
*/


#define DEVCAP_IIO_CXL_REG 0x23020044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mpss : 3;

                            /* Bits[2:0], Access Type=RW/L, default=None*/

                            /*
                               The PCIe SIP can tolerate upto 512-byte packets
                               as maximum payload for project specific. Defined
                               encodings are: 000b 128 bytes max payload size
                               001b 256 bytes max payload size 010b 512 bytes
                               max payload size 011b 1024 bytes max payload
                               size 100b 2048 bytes max payload size 101b 4096
                               bytes max payload size 110b Reserved 111b
                               Reserved Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 pfs : 2;

                            /* Bits[4:3], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the number of most
                               significant bits of the function number portion
                               of Requester ID in a TLP that are logically
                               combined with the Tag identifier. The PCIe
                               cluster does not support phantom functions
                            */
    UINT32 etfg : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This bit, in combination with the 10-Bit Tag
                               Requester Supported bit in the Device
                               Capabilities 2 register, indicates the maximum
                               supported size of the Tag field as a Requester.
                               This bit must be Set if the 10-Bit Tag Requester
                               Supported bit is Set. Defined encodings are: 0b
                               5-bit Tag field supported 1b 8-bit Tag field
                               supported Note that 8-bit Tag field generation
                               must be enabled by the Extended Tag Field Enable
                               bit in the Device Control register of the
                               Requester Function before 8-bit Tags can be
                               generated by the Requester. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 epl0al : 3;

                            /* Bits[8:6], Access Type=RO, default=0x00000000*/

                            /*
                               This field only applies to Endpoint and is
                               hardwired to 0 for other types such as root
                               ports, upstream/downstream ports
                            */
    UINT32 epl1al : 3;

                            /* Bits[11:9], Access Type=RO, default=0x00000000*/

                            /*
                               This field only applies to Endpoint and is
                               hardwired to 0 for other types such as root
                               ports, upstream/downstream ports
                            */
    UINT32 undefined : 3;

                            /* Bits[14:12], Access Type=RO, default=0x00000000*/

                            /* Undefined */
    UINT32 rber : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000001*/

                            /*
                               The PCIe cluster supports Role-based Error
                               Reporting.
                            */
    UINT32 rsvd : 2;

                            /* Bits[17:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 csplv : 8;

                            /* Bits[25:18], Access Type=RO, default=0x00000000*/

                            /*
                               In combination with the Slot Power Limit Scale
                               value (bits[27:26]), this field specifies the
                               upper limit of the power supplied by slot. The
                               power limit (in Watts) is calculated by
                               multiplying the value in this field by the value
                               in the Slot Power Limit Scale field. This value
                               is set by the Set_Slot_Power_Limit message. Does
                               not apply to root ports or integrated devices or
                               downstream ports or Virtual Root Port/switch
                               ports
                            */
    UINT32 cspls : 2;

                            /* Bits[27:26], Access Type=RO, default=0x00000000*/

                            /*
                               In combination with the Slot Power Limit value
                               (bits[25:18], this field specifies the upper
                               limit of the power supplied by slot. The power
                               limit (in Watts) is calculated by multiplying
                               the value in this field by the value in the Slot
                               Power Limit Value field. This value is set by
                               the Set_Slot_Power_Limit message. Does not apply
                               to root ports or integrated devices or
                               downstream ports or Virtual Root Port/switch
                               port
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DEVCAP_IIO_CXL_STRUCT;

/* DEVCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000048)                                                      */
/*      SPRB0 (0x10000048)                                                      */
/*      SPRHBM (0x10000048)                                                     */
/*      SPRC0 (0x10000048)                                                      */
/*      SPRMCC (0x10000048)                                                     */
/*      SPRUCC (0x10000048)                                                     */
/* Register default value on SPRA0: 0x00002010                                  */
/* Register default value on SPRB0: 0x00002010                                  */
/* Register default value on SPRHBM: 0x00002010                                 */
/* Register default value on SPRC0: 0x00002010                                  */
/* Register default value on SPRMCC: 0x00002010                                 */
/* Register default value on SPRUCC: 0x00002010                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Control
*/


#define DEVCTL_IIO_CXL_REG 0x23010048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the ERR_CORR
                               message is enabled.
                            */
    UINT16 nfere : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the
                               ERR_NONFATAL message is enabled.
                            */
    UINT16 fere : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, generation of the
                               ERR_FATAL message is enabled.
                            */
    UINT16 urre : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit controls the enabling of ERR_CORR,
                               ERR_NONFATAL or ERR_FATAL messages on PCI
                               Express for reporting 'Unsupported Request'
                               errors.
                            */
    UINT16 enro : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000001*/

                            /*
                               If this bit is Set, the Function is permitted to
                               set the Relaxed Ordering bit in the Attributes
                               field of transactions it initiates that do not
                               require strong write ordering. A Function is
                               permitted to hardwire this bit to 0b if it never
                               sets the Relaxed Ordering attribute in
                               transactions it initiates as a Requester.
                               Default value of this bit is 1b.
                            */
    UINT16 mps : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets maximum TLP payload size for the
                               function. As a receiver, the function must
                               handle TLPs as large as the set value. As a
                               Transmitter, the function must not generate TLPs
                               exceeding the set value. 000b: 128 bytes maximum
                               payload size (default) 001b: 256 bytes maximum
                               payload size 010b: 512 bytes maximum payload
                               size 011b: 1024 bytes maximum payload size 100b:
                               2048 bytes maximum payload size 101b: 4096 bytes
                               maximum payload size Others: Reserved
                            */
    UINT16 etfe : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables a function to use an
                               8-bit tag field as a Requester. Functions that
                               do not implement this capability hardwire this
                               bit to 0b.
                            */
    UINT16 pfe : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, in combination with the 10-Bit Tag
                               Requester Enable bit in the Device Control 2
                               register, determines how many Tag field bits a
                               Requester is permitted to use. When the 10-Bit
                               Tag Requester Enable bit is Clear, the following
                               paragraph applies. See PCIe Spec. Section
                               2.2.6.2 for complete details. When Set, this bit
                               enables a Function to use unclaimed Functions as
                               Phantom Functions to extend the number of
                               outstanding transaction identifiers. If the bit
                               is Clear, the Function is not allowed to use
                               Phantom Functions. Software should not change
                               the value of this bit while the Function has
                               outstanding Non-Posted Requests, otherwise, the
                               result is undefined. Functions that do not
                               implement this capability hardwire this bit to
                               0b. Default value of this bit is 0b.
                            */
    UINT16 auxpme : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 enosnp : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               If this bit this is set, the function is
                               permitted to set the No Snoop bit in the
                               Requester attributes of transactions it
                               initiates that do not require hardware enforced
                               cache coherency. This bit is permitted to be
                               hardwired to 0b if a function would never set
                               the No Snoop attribute in transactions it
                               initiates.
                            */
    UINT16 mrrs : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000002*/

                            /*
                               This field sets the maximum Read Requests size
                               of the function as a requester. The Function
                               must not generate read requests with size
                               exceeding the set value. 000b: 128 bytes maximum
                               Read Request size 001b: 256 bytes maximum Read
                               Request size 010b: 512 bytes maximum Read
                               Request size 011b: 1024 bytes maximum Read
                               Request size 100b: 2048 bytes maximum Read
                               Request size 101b: 4096 bytes maximum Read
                               Request size Others: Reserved Functions that do
                               not generate Read Requests larger than 128B and
                               functions that do not generate Read Requests on
                               their own behalf are permitted to implement this
                               field as Read Only (RO) with a value of 000b.
                            */
    UINT16 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DEVCTL_IIO_CXL_STRUCT;

/* DEVSTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1000004a)                                                      */
/*      SPRB0 (0x1000004a)                                                      */
/*      SPRHBM (0x1000004a)                                                     */
/*      SPRC0 (0x1000004a)                                                      */
/*      SPRMCC (0x1000004a)                                                     */
/*      SPRUCC (0x1000004a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Status
*/


#define DEVSTS_IIO_CXL_REG 0x2301004A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ced : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Correctable error. Errors are logged
                               in this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 nfed : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Non-Fatal error. Errors are logged in
                               this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 fed : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function has
                               detected a Fatal error. Errors are logged in
                               this register regardless of whether error
                               reporting is enabled or not in the Device
                               Control register.
                            */
    UINT16 urd : 1;

                            /* Bits[3:3], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates that this function received
                               an unsupported request from PCI Express link.
                               Errors are logged in this register regardless of
                               whether error reporting is enabled or not in the
                               Device Control register.
                            */
    UINT16 apd : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /* Auxiliary Power is not supported. */
    UINT16 tp : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit indicates that the function
                               has issued Non-Posted Requests that have not
                               been completed. For Root or Switch port, it
                               applies to Non-Posted Requests the port has
                               issued on its own behalf (Port's Request ID). A
                               function reports this bit cleared only when all
                               outstanding Non-Posted Requests have completed.
                               Functions that do not issue Non-Posted requests
                               on their own behalf should hardwire this bit to
                               0b. The implementation may set this bit based on
                               internal Request-Completion Tracking Table if
                               not empty for any outstanding/valid outbound or
                               inbound NP request (including split request).
                               Currently, it's only applicable to Root Ports.
                            */
    UINT16 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DEVSTS_IIO_CXL_STRUCT;

/* LINKCAP_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x2000004c)                                                      */
/*      SPRB0 (0x2000004c)                                                      */
/*      SPRHBM (0x2000004c)                                                     */
/*      SPRC0 (0x2000004c)                                                      */
/*      SPRMCC (0x2000004c)                                                     */
/*      SPRUCC (0x2000004c)                                                     */
/* Register default value on SPRA0: 0x00000105                                  */
/* Register default value on SPRB0: 0x00000105                                  */
/* Register default value on SPRHBM: 0x00000105                                 */
/* Register default value on SPRC0: 0x00000105                                  */
/* Register default value on SPRMCC: 0x00000105                                 */
/* Register default value on SPRUCC: 0x00000105                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Link Capabilities
*/


#define LINKCAP_IIO_CXL_REG 0x2302004C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mls : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000005*/

                            /*
                               This field indicates the maximum Link speed of
                               the associated Port. The encoded value specifies
                               a bit location in the Supported Link Speeds
                               Vector (in the Link Capabilities 2 register)
                               that corresponds to the maximum Link speed.
                               Defined encodings are: 0001b Supported Link
                               Speeds Vector field bit 0 0010b Supported Link
                               Speeds Vector field bit 1 0011b Supported Link
                               Speeds Vector field bit 2 0100b Supported Link
                               Speeds Vector field bit 3 0101b Supported Link
                               Speeds Vector field bit 4 0110b Supported Link
                               Speeds Vector field bit 5 0111b Supported Link
                               Speeds Vector field bit 6 All other encodings
                               are reserved. Multi-Function Devices associated
                               with an Upstream Port must report the same value
                               in this field for all Functions.
                            */
    UINT32 mlw : 6;

                            /* Bits[9:4], Access Type=RO/V, default=0x00000010*/

                            /*
                               This field indicates the maximum link width
                               implemented by the given PCI Express Link. 00h:
                               Reserved 01h: x1 02h: x2 04h: x4 08h: x8 10h:
                               x16 20h: x32 (Unsupported) Others Reserved
                               Default value is determined by HW after port
                               training is initiated for ports that bifurcate.
                               Hence effective MLW can be smaller than
                               indicated by default
                            */
    UINT32 aspmsup : 2;

                            /* Bits[11:10], Access Type=RW/V/L, default=None*/

                            /*
                               This field indicates the level of ASPM supported
                               on the given PCI Express Link. 00b: No ASPM
                               Support 01b: L0s Supported 10b: L1 Supported
                               11b: L0s and L1 Supported Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . New PCIe Gen3 ECN provides additional
                               encoding of ASPMSUP field to provide optional
                               support of L0s and L1 Software must not enable
                               L0s in either direction on a given Link unless
                               components on both sides of the Link each
                               support L0s. L0s should not be advertised when
                               operating with SRIS.
                            */
    UINT32 l0sel : 3;

                            /* Bits[14:12], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the L0s exit latency for
                               the given PCI-Express Link. It indicates the
                               length of time this port requires to complete
                               transition from L0s to L0. 000b: Less than 64ns
                               001b: 64ns to less than 128ns 010b: 128ns to
                               less than 256ns 011b: 256ns to less than 512ns
                               100b 512 ns to less than 1 us 101b: 1us to less
                               than 2us 110b: 2us to less than 4us 111b: More
                               than 4us Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . If L0s
                               is not supported, the value is undefined.
                            */
    UINT32 l1el : 3;

                            /* Bits[17:15], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the L1 exit latency for the
                               given PCI-Express Link. It indicates the length
                               of time this port requires to complete
                               transition from L1 to L0. 000: Less than 1us
                               001: 1us to less than 2us 010: 2us to less than
                               4us 011: 4us to less than 8us 100: 8us to less
                               than 16us 101: 16us to less than 32us 110: 32us
                               to less than 64us 111: More than 64us Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register . If L1 is not supported, the
                               value is undefined.
                            */
    UINT32 cpmc : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               For Upstream Ports, a value of 1b in this bit
                               indicates that the component tolerates the
                               removal of any reference clock(s) via the 'clock
                               request' (CLKREQ#) mechanism when the Link is in
                               the L1 and L2/L3 Ready Link states. A value of
                               0b indicates the component does not have this
                               capability and that reference clock(s) must not
                               be removed in these Link states. L1 PM Substates
                               defines other semantics for the CLKREQ# signal,
                               which are managed independently of Clock Power
                               Management. This Capability is applicable only
                               in form factors that support 'clock request'
                               (CLKREQ#) capability. For a multi-Function
                               device associated with an Upstream Port, each
                               Function indicates its capability independently.
                               Power Management configuration software must
                               only permit reference clock removal if all
                               Functions of the multi-Function device indicate
                               a 1b in this bit. For ARI Devices, all Functions
                               must indicate the same value in this bit. For
                               Downstream Ports, this bit must be hardwired to
                               0b.
                            */
    UINT32 slderc : 1;

                            /* Bits[19:19], Access Type=RW/L, default=None*/

                            /*
                               For a Downstream Port, this bit must be Set if
                               the component supports the optional capability
                               of detecting and reporting a Surprise Down error
                               condition. For Upstream Ports and components
                               that do not support this optional capability,
                               this bit must be hardwired to 0b. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 dllerc : 1;

                            /* Bits[20:20], Access Type=RW/L, default=None*/

                            /*
                               For a Downstream Port, this bit must be
                               hardwired to 1b if the component supports the
                               optional capability of reporting the DL_Active
                               state of the Data Link Control and Management
                               State Machine. For a hot-plug capable Downstream
                               Port (as indicated by the Hot-Plug Capable bit
                               of the Slot Capabilities register) or a
                               Downstream Port that supports Link speeds
                               greater than 5 GT/s, this bit must be hardwired
                               to 1b. For Upstream Ports and components that do
                               not support this optional capability, this bit
                               must be hardwired to 0b. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 lbnc : 1;

                            /* Bits[21:21], Access Type=RW/L, default=None*/

                            /*
                               A value of 1b indicates support for the Link
                               Bandwidth Notification status and interrupt
                               mechanisms. This capability is required for all
                               Root Ports and Switch Downstream Ports
                               supporting Links wider than x1 and/or multiple
                               Link speeds. This field is not applicable and is
                               reserved for Endpoints, PCI Express to PCI/PCI-X
                               bridges, and Upstream Ports of Switches. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 aspmopcmp : 1;

                            /* Bits[22:22], Access Type=RW/L, default=None*/

                            /*
                               The ASPM Optionality Compliance bit was created
                               as a tool to set clear expectations for hardware
                               and software interaction. This bit is Set to
                               indicate hardware that conforms to the current
                               specification. Software is permitted to use the
                               value of this bit to help determine whether to
                               enable ASPM or whether to run ASPM compliance
                               tests. System software as well as compliance
                               software can assume that if this bit is Set,
                               that the associated hardware conforms to the
                               current specification. Hardware should be fully
                               capable of supporting ASPM configuration
                               management by system software without needing
                               component-specific treatment. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rsvd : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pn : 8;

                            /* Bits[31:24], Access Type=RW/V/L, default=None*/

                            /*
                               This field indicates the PCI Express port number
                               assigned to this link. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} LINKCAP_IIO_CXL_STRUCT;

/* LINKCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000050)                                                      */
/*      SPRB0 (0x10000050)                                                      */
/*      SPRHBM (0x10000050)                                                     */
/*      SPRC0 (0x10000050)                                                      */
/*      SPRMCC (0x10000050)                                                     */
/*      SPRUCC (0x10000050)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Control
*/


#define LINKCTL_IIO_CXL_REG 0x23010050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 aspmctl : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls the level of ASPM enabled on
                               a given PCI Express Link. 00b: Disabled 01b: L0s
                               Entry Enabled 10b: L1 Entry Enabled 11b: L0s and
                               L1 Entry Enabled ''L0s Entry Enabled' enables
                               the Transmitter to enter L0s. If L0s is
                               supported, the Receiver must be capable of
                               entering L0s even when the Transmitter is
                               disabled from entering L0s (00b or 10b).
                            */
    UINT16 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 rcb : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /*
                               This bit indicates the RCB value for Root Port,
                               Endpoints and Bridges. 0b: 64 byte 1b: 128 byte
                               Configuration software must only set this bit if
                               the Root Port Upstream from the Endpoint or
                               Bridge reports an RCB value of 128 bytes (Root
                               Port only)
                            */
    UINT16 ld : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit disables the Link by directing the
                               LTSSM to the Disabled state when Set, This is
                               used by the downstream ports, Root ports or DMI
                               EP in RC only. For the upstream port or virtual
                               switch port, it is Read-only.
                            */
    UINT16 rl : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, this bit initiates link retraining by
                               directing the physical layer LTSSM to recovery
                               state. If the LTSSM is already in REcovery or
                               configuration, re-entering Recovery is permitted
                               but not required. Reads of this bit always
                               return 0b. This is used by the downstream ports,
                               Root ports or DMI EP in RC only. For the
                               upstream port or virtual switch port, it is
                               Read-only.
                            */
    UINT16 cccfg : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit indicates that this component
                               and the component at the opposite end of this
                               link are operating with distributed common
                               reference clocks. A value of 0b indicates that
                               this component and the component at the opposite
                               end of this link are operating with asynchronous
                               reference clock. After changing the value in
                               this bit in both components on a link, software
                               must trigger the link to retrain by writing a 1b
                               to the Retrain Link bit of the Downstream Port.
                            */
    UINT16 es : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit forces extended transmission
                               of 4096 FTS ordered sets in FTS and an extra
                               1024 TS1 at exit from L1 prior to entering L0.
                               This mode provides external devices monitoring
                               the link time to achieve bit and symbol lock
                               before the link enters L0 state and resumes
                               communication. Default value for this bit is 0.
                            */
    UINT16 ecpm : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               Applicable only for Upstream Ports and with form
                               factors that support a 'Clock Request' (CLKREQ#)
                               mechanism, this bit operates as follows: 0b
                               Clock power management is disabled and device
                               must hold CLKREQ# signal low. 1b When this bit
                               is Set, the device is permitted to use CLKREQ#
                               signal to power manage Link clock according to
                               protocol defined in appropriate form factor
                               specification. For a non-ARI multi-Function
                               device, power-management-configuration software
                               must only Set this bit if all Functions of the
                               multi-Function device indicate a 1b in the Clock
                               Power Management bit of the Link Capabilities
                               register. The component is permitted to use the
                               CLKREQ# signal to power manage Link clock only
                               if this bit is Set for all Functions. For ARI
                               Devices, Clock Power Management is enabled
                               solely by the setting in Function 0. The
                               settings in the other Functions always return
                               whatever value software programmed for each, but
                               otherwise are ignored by the component. The
                               CLKREQ# signal may also be controlled via the L1
                               PM Substates mechanism. Such control is not
                               affected by the setting of this bit. Downstream
                               Ports and components that do not support Clock
                               Power Management (as indicated by a 0b value in
                               the Clock Power Management bit of the Link
                               Capabilities register) must hardwire this bit to
                               0b. Default value of this bit is 0b, unless
                               specified otherwise by the form factor
                               specification. The value of this field will be
                               reflected by CAPSR.LINKCTL_ECPM.
                            */
    UINT16 hawd : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set, this bit disables hardware from changing
                               the Link width for reasons other than attempting
                               to correct unreliable Link operation by reducing
                               Link width. For a Multi-Function device
                               associated with an Upstream Port, the bit in
                               Function 0 is of type RW, and only Function 0
                               controls the components Link behavior. In all
                               other Functions of that device, this bit is of
                               type RsvdP. Components that do not implement the
                               ability autonomously to change Link width are
                               permitted to hardwire this bit to 0b. Default
                               value of this bit is 0b.
                            */
    UINT16 lbmie : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt to indicate that the Link Bandwidth
                               Management Status bit has been set. This bit is
                               not applicable and is reserved for Endpoints,
                               PCI Express-to-PCI/PCI-X bridges, and Upstream
                               Ports of Switches.
                            */
    UINT16 labie : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of an
                               interrupt to indicate that the Link Autonomous
                               Bandwidth Status bit has been set. Functions
                               that do not implement the Link Bandwidth
                               Notification Capability must hardwire this bit
                               to 0b.
                            */
    UINT16 rsvd_12 : 2;

                            /* Bits[13:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 drs : 2;

                            /* Bits[15:14], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the mechanism used to report reception
                               of a DRS message. Must be implemented for
                               Downstream Ports with the DRS Supported bit Set
                               in the Link Capabilities 2 Register. Encodings
                               are: 00b DRS not Reported: If DRS Supported is
                               Set, receiving a DRS Message will set DRS
                               Message Received in the Link Status 2 Register
                               but will otherwise have no effect 01b DRS
                               Interrupt Enabled: If the DRS Message Received
                               bit in the Link Status 2 Register transitions
                               from 0 to 1, and either MSI or MSI-X is enabled,
                               an MSI or MSI-X interrupt is generated using the
                               vector in Interrupt Message Number 10b DRS to
                               FRS Signaling Enabled: If the DRS Message
                               Received bit in the Link Status 2 Register
                               transitions from 0 to 1, the Port must send an
                               FRS Message Upstream with the FRS Reason field
                               set to DRS Message Received Behavior is
                               undefined if this field is set to 10b and the
                               FRS Supported bit in the Device Capabilities 2
                               Register is Clear. Behavior is undefined if this
                               field is set to 11b. Downstream Ports with the
                               DRS Supported bit Clear in the Link Capabilities
                               2 register must hardwire this field to 00b. This
                               field is Reserved for Upstream Ports. Default
                               value of this field is 00b.
                            */

  } Bits;
  UINT16 Data;

} LINKCTL_IIO_CXL_STRUCT;

/* LINKSTS_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000052)                                                      */
/*      SPRB0 (0x10000052)                                                      */
/*      SPRHBM (0x10000052)                                                     */
/*      SPRC0 (0x10000052)                                                      */
/*      SPRMCC (0x10000052)                                                     */
/*      SPRUCC (0x10000052)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Status
*/


#define LINKSTS_IIO_CXL_REG 0x23010052

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cls : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field indicates the negotiated link speed
                               of the given PCI Express link. The encoded value
                               specifies a bit location in the Supported Link
                               Speeds Vector (in the Link Capabilities 2
                               register) that corresponds to the current Link
                               speed. Defined encodings are: 0001b Supported
                               Link Speeds Vector field bit 0 0010b Supported
                               Link Speeds Vector field bit 1 0011b Supported
                               Link Speeds Vector field bit 2 0100b Supported
                               Link Speeds Vector field bit 3 0101b Supported
                               Link Speeds Vector field bit 4 0110b Supported
                               Link Speeds Vector field bit 5 0111b Supported
                               Link Speeds Vector field bit 6 All other
                               encodings are Reserved The value in this field
                               is undefined when the link is not up.
                            */
    UINT16 nlw : 6;

                            /* Bits[9:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates the negotiated width of the
                               PCI Express link. 00 0001b: x1 00 0010b: X2 00
                               0100b: x4 00 1000b: X8 00 1100b: X12not
                               supported 01 0000b: X16 10 0000b: X32not
                               supported All other values are reserved. The
                               value in this field is undefined when the link
                               is not up.
                            */
    UINT16 undefined : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not applicable */
    UINT16 lt : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /*
                               For PCIe device, this bit indicates that the
                               Physical Layer LTSSM is in the Configuration or
                               Recovery state, or a 1b was written to the
                               Retrain Link bit but the Link training has not
                               yet begun. Hardware clears this bit when the
                               LTSSM exits the Configuration/Recovery state.
                            */
    UINT16 scc : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000001*/

                            /*
                               When to 1b, this bit indicates that the
                               component uses the same physical reference clock
                               that he platform provides on the connector. If
                               the device uses an independent clock
                               irrespective of the presence of a reference on
                               the connector, this bit must be clear. 1:
                               Indicates same reference clock. 0: Indicates
                               independent reference clock The value of this
                               field will be reflected by CAPSR.LINKSTS_SCC.
                            */
    UINT16 dllla : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the status of the Data Link
                               Control and Management Status Machine. It
                               returns a 1b to indicate the DL_Active state, 0b
                               otherwise.
                            */
    UINT16 lbms : 1;

                            /* Bits[14:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by hardware to indicate that
                               either of the following has occurred without the
                               port transitioning through DL_Down status: A
                               link retraining has completed following a write
                               of 1b to the Retrain link bit. Hardware has
                               changed link speed of width to attempt to
                               correct unreliable link operation, either
                               through an LTSSM timeout or a higher level
                               process. This bit must be set if the Physical
                               Layer reports a non-autonomous speed or width
                               change initiated by the Upstream Port.
                            */
    UINT16 labs : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set by hardware to indicate that the
                               PCIe cluster has autonomously changed link or
                               width, without the port transitioning through
                               DL_Down status, for reason other than to attempt
                               to correct unreliable link operation. This bit
                               must be set if the Physical Layer reports an
                               autonomous speed or width change initiated by
                               the Upstream Port.
                            */

  } Bits;
  UINT16 Data;

} LINKSTS_IIO_CXL_STRUCT;

/* SLOTCAP_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000054)                                                      */
/*      SPRB0 (0x20000054)                                                      */
/*      SPRHBM (0x20000054)                                                     */
/*      SPRC0 (0x20000054)                                                      */
/*      SPRMCC (0x20000054)                                                     */
/*      SPRUCC (0x20000054)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Lock Key bit is located in the Personality Lock Key Control Register ('PLKCTL').
*/


#define SLOTCAP_IIO_CXL_REG 0x23020054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 abp : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an Attention Button is
                               implemented on the chassis for this slot. 0:
                               indicates that an Attention Button is not
                               present 1: indicates that an Attention Button is
                               present
                            */
    UINT32 pcp : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that a Power Controller is
                               implemented on the chassis for this slot. 0:
                               indicates that a Power Controller is not present
                               1: indicates that a Power Controller is present
                            */
    UINT32 mrlsp : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an MRL Sensor is
                               implemented on the chassis for this slot. 0:
                               indicates that an MRL Sensor is not present 1:
                               indicates that an MRL Sensor is present
                            */
    UINT32 aip : 1;

                            /* Bits[3:3], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that an Attention Indicator
                               is implemented on the chassis for this slot. 0:
                               indicates that an Attention Indicator is not
                               present 1: indicates that an Attention Indicator
                               is present
                            */
    UINT32 pip : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               This bit indicates that a Power Indicator is
                               implemented on the chassis for this slot. 0:
                               indicates that Power Indicator is not present 1:
                               indicates that Power Indicator is present
                            */
    UINT32 hps : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This field indicates that a device in this slot
                               may be removed from the system without prior
                               notification. 0: indicates that hot-plug
                               surprise is not supported 1: indicates that hot-
                               plug surprise is supported
                            */
    UINT32 hpc : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               This field defines hot-plug support capabilities
                               for the PCI-Express port. 0: indicates that this
                               slot is not capable of supporting Hot-plug
                               operations. 1: indicates that this slot is
                               capable of supporting Hot-plug operations
                            */
    UINT32 splv : 8;

                            /* Bits[14:7], Access Type=RW/L, default=None*/

                            /*
                               This field specifies the upper limit on power
                               supplied by slot in conjunction with the Slot
                               Power Limit Scale value defined previously Power
                               limit (in Watts). i.e Power limit = SPLS x SPLV.
                               This register must be implemented if the Slot
                               Implemented bit is set in EXPCAP. Writes to this
                               register (SLOTCAP) when the Data Link Layer
                               reports DL_Up status, or the link transitions
                               from a non-DL_Up to a DL_Up would cause the Port
                               to send the Set_Slot_Power_Limit Message.
                            */
    UINT32 spls : 2;

                            /* Bits[16:15], Access Type=RW/L, default=None*/

                            /*
                               This field specifies the scale used for the Slot
                               Power Limit Value. Range of Values: 00: 1.0x 01:
                               0.1x 10: 0.01x 11: 0.001x This register must be
                               implemented if the Slot Implemented bit is set
                               in EXPCAP. Writes to this register (SLOTCAP)
                               when the Data Link Layer reports DL_Up status,
                               or the link transitions from a non-DL_Up to a
                               DL_Up would cause the Port to send the
                               Set_Slot_Power_Limit Message.
                            */
    UINT32 emip : 1;

                            /* Bits[17:17], Access Type=RW/L, default=None*/

                            /*
                               This bit when set indicates that an
                               Electromechanical Interlock is implemented on
                               the chassis for this slot and that lock is
                               controlled by bit 11 in Slot Control Register.
                            */
    UINT32 nccs : 1;

                            /* Bits[18:18], Access Type=RW/L, default=None*/

                            /*
                               When Set, this bit indicates that this slot does
                               not generate software notification when an
                               issued command is completed by the Hot-Plug
                               Controller. This bit is only permitted to be Set
                               if the hot-plug capable Port is able to accept
                               writes to all fields of the Slot Control
                               register without delay between successive
                               writes. The EIP PCIe port is capable of
                               interrupt notification when completing the
                               hotplug command The field name is made
                               consistent with PCIe 2.0a spec
                            */
    UINT32 psn : 13;

                            /* Bits[31:19], Access Type=RW/L, default=None*/

                            /*
                               This field indicates the physical slot number
                               connected to the PCI-Express port. It should be
                               initialized to 0 for ports connected to devices
                               that are either integrated on the system board
                               or integrated within the same silicon such as
                               the switch device or the Root port.
                            */

  } Bits;
  UINT32 Data;

} SLOTCAP_IIO_CXL_STRUCT;

/* SLOTCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000058)                                                      */
/*      SPRB0 (0x10000058)                                                      */
/*      SPRHBM (0x10000058)                                                     */
/*      SPRC0 (0x10000058)                                                      */
/*      SPRMCC (0x10000058)                                                     */
/*      SPRUCC (0x10000058)                                                     */
/* Register default value on SPRA0: 0x000003C0                                  */
/* Register default value on SPRB0: 0x000003C0                                  */
/* Register default value on SPRHBM: 0x000003C0                                 */
/* Register default value on SPRC0: 0x000003C0                                  */
/* Register default value on SPRMCC: 0x000003C0                                 */
/* Register default value on SPRUCC: 0x000003C0                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Slot Control
*/


#define SLOTCTL_IIO_CXL_REG 0x23010058

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 abpe : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via an attention
                               button pressed event. 0: Disables generation of
                               hot-plug interrupts or wake messages when the
                               attention button is pressed. 1: Enables
                               generation of hot-plug interrupts or wake
                               messages when the attention button is pressed
                            */
    UINT16 pfdie : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a power fault
                               event. 0: Disables generation of hot-plug
                               interrupts or wake messages when a power fault
                               event happens. 1: Enables generation of hot-plug
                               interrupts or wake messages when a power fault
                               event happens.
                            */
    UINT16 mscie : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a MRL Sensor
                               changed event. 0: Disables generation of hot-
                               plug interrupts or wake messages when an MRL
                               Sensor changed event happens. 1: Enables
                               generation of hot-plug interrupts or wake
                               messages when an MRL Sensor changed event
                               happens.
                            */
    UINT16 pdcie : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit enables the generation of hot-plug
                               interrupts or wake messages via a presence
                               detect changed event. 0: Disables generation of
                               hot-plug interrupts or wake messages when a
                               presence detect changed event happens. 1-
                               Enables generation of hot-plug interrupts or
                               wake messages when a presence detect changed
                               event happens.
                            */
    UINT16 ccie : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables the generation of Hot-plug
                               interrupts when a command is completed by the
                               Hot-plug controller connected to the PCI-Express
                               port. 0: Disables hot-plug interrupts on a
                               command completion by a hot-plug Controller 1:
                               Enables hot-plug interrupts on a command
                               completion by a hot-plug Controller
                            */
    UINT16 hpie : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables the generation of Hot-plug
                               interrupts and events in the PCIExpress port. 0:
                               Disables Hot-plug events and interrupts 1:
                               Enables Hot-plug events and interrupts
                            */
    UINT16 aic : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000003*/

                            /*
                               If an Attention Indicator is implemented, writes
                               to this register sets the Attention Indicator to
                               the written state. Reads of this field reflect
                               the value from the latest write, even if the
                               corresponding hot-plug command is not executed
                               yet at the VPP, unless software issues a write
                               without waiting for the previous command to
                               complete in which case the read value is
                               undefined. 00: Reserved. 01: On 10: Blink (The
                               switch drives 1.5 Hz square wave) 11: Off When
                               this register is written, the event is signaled
                               via the virtual pins of the switch over a
                               dedicated SMBus port.
                            */
    UINT16 pic : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000003*/

                            /*
                               If a Power Indicator is implemented, writes to
                               this register set the Power Indicator to the
                               written state. Reads of this field must reflect
                               the value from the latest write, even if the
                               corresponding hot-plug command is not executed
                               yet at the VPP, unless software issues a write
                               without waiting for the previous command to
                               complete in which case the read value is
                               undefined. 00: Reserved. 01: On 10: Blink (The
                               PCIe cluster drives 1.5 Hz square wave for
                               Chassis mounted LEDs in the case of legacy card
                               form factor for PCI-Express devices) 11: Off
                               When this register is written, the event is
                               signaled via the virtual pins of the switch over
                               a dedicated SMBus port. The switch does not
                               generated the Power_Indicator_On/Off/Blink
                               messages on PCI Express when this field is
                               written to by software.
                            */
    UINT16 pcc : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               This bit indicates the current state of the
                               Power applied to the slot of the PCIExpress
                               port. Reads of this field must reflect the value
                               from the latest write, even if the corresponding
                               hot-plug command is not executed yet at the VPP,
                               unless software issues a write without waiting
                               for the previous command to complete in which
                               case the read value is undefined. 0: Power On 1:
                               Power Off
                            */
    UINT16 eic : 1;

                            /* Bits[11:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               When software writes either a 1 to this bit, The
                               PCIe port pulses the EMIL pin per PCIExpress
                               Server/Workstation Module Electromechanical Spec
                               Rev 1.0. Write of 0 has no effect. This bit
                               always returns a 0 when read. If
                               electromechanical lock is not implemented, then
                               either a write of 1 or 0 to this register has no
                               effect.
                            */
    UINT16 dllsce : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, this field enables software
                               notification when Data Link Layer Link Active
                               reporting field is changed.
                            */
    UINT16 aspld : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this disables the automatic sending of
                               a Set_Slot_Power_Limit Message when a Link
                               transitions from a non-DL_Up status to a DL_Up
                               status.
                            */
    UINT16 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} SLOTCTL_IIO_CXL_STRUCT;

/* SLOTSTS_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x1000005a)                                                      */
/*      SPRB0 (0x1000005a)                                                      */
/*      SPRHBM (0x1000005a)                                                     */
/*      SPRC0 (0x1000005a)                                                      */
/*      SPRMCC (0x1000005a)                                                     */
/*      SPRUCC (0x1000005a)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Slot Status
*/


#define SLOTSTS_IIO_CXL_REG 0x2301005A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 abp : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the attention button is
                               pressed. It is subsequently cleared by software
                               after the field has been read and processed. On-
                               board logic per slot must set the VPP signal
                               corresponding to this bit inactive if the
                               FF/system does not support out-of-band presence
                               detect. Design should implement this as an edge
                               detection logic in the chipset/platform to
                               recognize a 0 -> 1 transition as a ABP event.
                               Due to the long time frames for human
                               interaction, software could potentially have
                               serviced and cleared this event while the
                               operator is pressing the attention button. For
                               instance, if the user presses the Attention
                               button that lasts for 2ms and the VPP sampling
                               rate is, say 100us and if the Interrupt Service
                               routine (ISR) processes and clears the ABP in
                               100us, there could be up to 10 (i.e
                               2000/(100+100)) different interrupts for the
                               same event.Hardware must only generate 1
                               interrupt for every ABP event by treating it as
                               edge based rather than level based event.
                            */
    UINT16 pfd : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when a power fault event is
                               detected by the power controller. It is
                               subsequently cleared by software after the field
                               has been read and processed. On-board logic per
                               slot must set the VPP signal corresponding to
                               this bit inactive if the FF/system does not
                               support out-of-band presence detect.
                            */
    UINT16 mrlsc : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when an MRL Sensor Changed event
                               is detected. It is subsequently cleared by
                               software after the field has been read and
                               processed. On-board logic per slot must set the
                               VPP signal corresponding to this bit inactive if
                               the FF/system does not support out-of-band
                               presence detect.
                            */
    UINT16 pdcs : 1;

                            /* Bits[3:3], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the value reported in the
                               Presence Detect State bit is changed. It is
                               subsequently cleared by software after the field
                               has been read and processed. On-board logic per
                               slot must set the VPP signal corresponding to
                               this bit inactive if the system does not support
                               out-of-band presence detect. RPs may hold the
                               re-training to occur until the SLOTSTS.PDCS bit
                               has been cleared by software for the removal
                               event.
                            */
    UINT16 ccs : 1;

                            /* Bits[4:4], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set when the hot-plug controller
                               completes an issued command and is ready to
                               accept a new command. It is subsequently cleared
                               by software after the field has been read and
                               processed. If Command Completed notification is
                               supported, then the No Command Completed Support
                               bit in the Slot Capabilities register should be
                               0.
                            */
    UINT16 mrlss : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit reports the status of an MRL sensor if
                               it is implemented. 0: MRL Closed 1: MRL Open If
                               Hotplug is implemented through VPP, the correct
                               polarity of the external MRL sensor in the
                               motherboard should be translated to map to the
                               encodings as defined in this register field.
                               (Tylersburg issue)
                            */
    UINT16 pds : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field conveys the Presence Detect status of
                               an adapter in the slot. It reflects the Logical
                               'OR' of the Physical Layer in-band presence
                               detect mechanism and any out-of-band presence
                               detect mechanism defined for the slot's
                               corresponding form factor. 0: Card/Module/Cable
                               slot empty or Cable Slot occupied but not
                               powered 1: Card/module Present in slot (powered
                               or unpowered) or cable present and powered on
                               the other end. This field is set to 1 by the
                               switch following reset for all the ports since
                               it is related to the complement of the EXPCAP.SI
                               bit whose default is 0 implying that the card is
                               connected to the switch on the motherboard.
                               Software should ensure that for those standard
                               PCI-Express ports which are hot-plug capable, it
                               sets the EXPCAP.SI field to '1' such that PDS
                               becomes 0. Then any subsequent hotplug action
                               will ensure that this field is set. Refer to the
                               algorithm given below: if (EXPCAP.SI == FALSE)
                               // always set to 1b and ignore the input from
                               inband/OOB presence detect SLOTSTS.PDS = 1b else
                               // if (EXPCAP.SI == TRUE) // Slot Empty = 0,
                               Card Present = 1 SLOTSTS.PDS reflects slot
                               status of side-band SMBUS Presence Detect signal
                               OR Inband Presence Detect Mechanism.
                            */
    UINT16 els : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /*
                               A read to this register returns the current
                               state of the Electromechanical Interlock (the
                               EMILS pin) which has the defined encodings as:
                               0: Electromechanical Interlock Disengaged 1:
                               Electromechanical Interlock Engaged
                            */
    UINT16 dllscs : 1;

                            /* Bits[8:8], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit is set (if it is not already set) when
                               the state of the Data Link Layer Link Active bit
                               in the Link Status register has changed.
                               Software must read Data Link Layer Active field
                               to determine the link state before initiating
                               configuration cycles to the hot plugged device.
                            */
    UINT16 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} SLOTSTS_IIO_CXL_STRUCT;

/* ROOTCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x1000005c)                                                      */
/*      SPRB0 (0x1000005c)                                                      */
/*      SPRHBM (0x1000005c)                                                     */
/*      SPRC0 (0x1000005c)                                                      */
/*      SPRMCC (0x1000005c)                                                     */
/*      SPRUCC (0x1000005c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Control
*/


#define ROOTCTL_IIO_CXL_REG 0x2301005C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 secee : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for
                               correctable errors. 1: indicates that a System
                               Error should be generated if a correctable error
                               (ERR_COR) is reported by any of the devices in
                               the hierarchy associated with and including this
                               PCI-Express port 0: No System Error should be
                               generated on a correctable error (ERR_COR)
                               reported by any of the devices in the hierarchy
                               associated with and including this PCI-Express
                               port.
                            */
    UINT16 senfee : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for non-fatal
                               errors. 1: indicates that a System Error should
                               be generated if a non-fatal error (ERR_NONFATAL)
                               is reported by any of the devices in the
                               hierarchy associated with and including this
                               PCI-Express port. 0: No System Error should be
                               generated on a non-fatal error (ERR_NONFATAL)
                               reported by any of the devices in the hierarchy.
                            */
    UINT16 sefee : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls generation of system errors
                               in the PCI-Express port hierarchy for fatal
                               errors. 1: indicates that a System Error should
                               be generated if a fatal error (ERR_FATAL) is
                               reported by any of the devices in the hierarchy
                               associated with and including this PCI-Express
                               port. 0: No System Error should be generated on
                               a fatal error (ERR_FATAL) reported by any of the
                               devices in the hierarchy.
                            */
    UINT16 pmeie : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field controls the generation of interrupts
                               for PME messages. 1: Enables interrupt
                               generation upon receipt of a PME message as
                               reflected in the PME Status bit defined in the
                               ROOTSTS register. A PME interrupt is generated
                               if the PMESTATUS register bit defined in Section
                               1.5.2.15, 'Root Status Register (ROOTSTS)' on
                               page 270, is set when this bit is set from a
                               cleared state. 0: Disables interrupt generation
                               for PME messages.
                            */
    UINT16 crssve : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the Root Port to
                               return Configuration Request Retry Status (CRS)
                               Completion Status to software (see PCIe Spec.
                               Section 2.3.1). Root Ports that do not implement
                               this capability must hardwire this bit to 0b.
                               Default value of this bit is 0b.
                            */
    UINT16 rsvd : 11;

                            /* Bits[15:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ROOTCTL_IIO_CXL_STRUCT;

/* ROOTCAP_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x1000005e)                                                      */
/*      SPRB0 (0x1000005e)                                                      */
/*      SPRHBM (0x1000005e)                                                     */
/*      SPRC0 (0x1000005e)                                                      */
/*      SPRMCC (0x1000005e)                                                     */
/*      SPRUCC (0x1000005e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Root Capabilities
*/


#define ROOTCAP_IIO_CXL_REG 0x2301005E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 crssv : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit, when set, indicates that the Root Port
                               is capable of returning Configuration Retry
                               Status (CRS) on completions to software. Based
                               on Design input, the CRS notification will be
                               implemented in the EIP PCIe macro and hence the
                               default is set to 1. The field attribute is made
                               as RW-O for any specific changes to be installed
                               by BIOS
                            */
    UINT16 rsvd : 15;

                            /* Bits[15:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ROOTCAP_IIO_CXL_STRUCT;

/* ROOTSTS_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000060)                                                      */
/*      SPRB0 (0x20000060)                                                      */
/*      SPRHBM (0x20000060)                                                     */
/*      SPRC0 (0x20000060)                                                      */
/*      SPRMCC (0x20000060)                                                     */
/*      SPRUCC (0x20000060)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Status
*/


#define ROOTSTS_IIO_CXL_REG 0x23020060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmerid : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates the PCI requester ID of the
                               last PME requestor.
                            */
    UINT32 pmests : 1;

                            /* Bits[16:16], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This field indicates status of a PME that is
                               underway in the PCI-Express port. 1: PME was
                               asserted by a requester as indicated by the
                               PMEREQID field This bit is cleared by software
                               by writing a '1'. Subsequent PMEs are kept
                               pending until the PME Status is cleared.
                            */
    UINT32 pmepend : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates that another PME is pending
                               when the PME Status bit is set. When the PME
                               Status bit is cleared by software, the pending
                               PME is delivered by hardware by setting the PME
                               Status bit again and updating the Requestor ID
                               appropriately. The PME pending bit is cleared by
                               hardware if no more PMEs are pending. NOTE: The
                               root port can handle two outstanding PM_PME
                               messages in its internal queues of the Power
                               Management controller per port. If the
                               downstream device issues more than 2 PM_PME
                               messages successively, it will be dropped.
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ROOTSTS_IIO_CXL_STRUCT;

/* DEVCAP2_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000064)                                                      */
/*      SPRB0 (0x20000064)                                                      */
/*      SPRHBM (0x20000064)                                                     */
/*      SPRC0 (0x20000064)                                                      */
/*      SPRMCC (0x20000064)                                                     */
/*      SPRUCC (0x20000064)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Device Capabilities 2
*/


#define DEVCAP2_IIO_CXL_REG 0x23020064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ctrs : 4;

                            /* Bits[3:0], Access Type=RW/L, default=None*/

                            /*
                               This field indicates device support for the
                               optional Completion Timeout programmability
                               mechanism. This mechanism allows system software
                               to modify the Completion Timeout value. This
                               field is applicable only to Root Ports,
                               Endpoints that issue requests on their own
                               behalf, and PCI Express to PCI/PCI-X Bridges
                               that take ownership of request issues on PCI
                               Express. Four time values ranges are defined:
                               Range A: 50us to 10ms Range B: 10ms to 250ms
                               Range C: 250ms to 4s Range D: 4s to 64s Bits
                               ares set according to table below to show
                               timeout value ranges supported. 0000b:
                               Completions Timeout programming not supported --
                               values is fixed by implementation in the range
                               50us to 50ms. 0001b: Range A 0010b: Range B
                               0011b: Range A and B 0110b: Range B and C 0111b:
                               Range A, B, and C 1110b: Range B, C, and D
                               1111b: Range A, B, C, and D All other values are
                               reserved. For all other devices this field is
                               reserved and maybe be hardwired to 0000b. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ctds : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               A value of 1b indicates support for the
                               completion Timeout Disable Mechanism. Support of
                               completion timeout disable is optional for Root
                               Ports. The PCIe port supports completions
                               timeout disable. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 ari : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               This bit is set to 1b indicating that the
                               downstream port supports this capability.
                               Applicable only to Switch Downstream Ports and
                               Root Ports, must be 0b for other Function types.
                               This bit must be set to 1b if a Switch
                               Downstream Port or Root Port supports this
                               optional capability. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 ars : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the port supports
                               this optional capability. Applicable only to
                               switch upstream ports, Switch downstream ports,
                               and root ports,. Must be 00b for other function
                               types. Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 ad32acs : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               Applicable to Functions with Memory Space BARs
                               as well as all Root Ports, must be 0b otherwise.
                               Includes FetchAdd, Swap, and CAS AtomicOps. This
                               bit must be set to 1b if the Function supports
                               this optional capability. This is set to 1 for
                               Rootport implementations in the PCIe EIP. Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 ad64acs : 1;

                            /* Bits[8:8], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the function
                               supports this optional capability. Applicable to
                               Functions with Memory Space BARs as well as all
                               Root Ports, must be 0b otherwise. Includes
                               FetchAdd, Swap, and CAS AtomicOps. Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 ad128acs : 1;

                            /* Bits[9:9], Access Type=RW/L, default=None*/

                            /*
                               This bit must be set to 1b if the function
                               supports this optional capability. Applicable to
                               functions with memory space BARs as well as Root
                               Ports. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 nroeprpass : 1;

                            /* Bits[10:10], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the routing element never
                               carries out the passing permitted by Table 2-39
                               entry A2b that is associated with the Relaxed
                               Ordering Attribute field being Set. This bit
                               applies only for Switches and RCs that support
                               peer-topeer traffic between Root Ports. This bit
                               applies only to Posted Requests being forwarded
                               through the Switch or RC and does not apply to
                               traffic originating or terminating within the
                               Switch or RC itself. All Ports on a Switch or RC
                               must report the same value for this bit. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ltrms : 1;

                            /* Bits[11:11], Access Type=RW/V/L, default=None*/

                            /*
                               This bit when set indicates support for the
                               Latency Tolerance Reporting (LTR) mechanism.
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register . H/W will change this
                               field to 'RO' of zero when DISALBE_LTR fuse is
                               set to 1 if supported.
                            */
    UINT32 tphcs : 2;

                            /* Bits[13:12], Access Type=RW/L, default=None*/

                            /*
                               Value indicates Completer support for TPH or
                               Extended TPH. 00b:TPH and Extended TPH Completer
                               not supported 01b: TPH Completer supported,
                               Extended TPH completer not supported 10b:
                               Reserved 11b: Both TPH and Extended TPH
                               Completer supported Applicable only to Root
                               Ports and Endpoints. Must be 00b for other
                               function types. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tenbtcs : 1;

                            /* Bits[16:16], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the Function supports 10-Bit
                               Tag Completer capability, otherwise, the
                               Function does not. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 tenbtrs : 1;

                            /* Bits[17:17], Access Type=RW/L, default=None*/

                            /*
                               If this bit is Set, the Function supports 10-Bit
                               Tag Requester capability, otherwise, the
                               Function does not. This bit must not be Set if
                               the 10-Bit Tag Completer Supported bit is Clear.
                               Note that 10-Bit Tag field generation must be
                               enabled by the 10- Bit Tag Requester Enable bit
                               in the Device Control 2 register of the
                               Requester Function before 10-Bit Tags can be
                               generated by the Requester. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 obffs : 2;

                            /* Bits[19:18], Access Type=RW/L, default=None*/

                            /*
                               00b: OBFF Not Supported 01b: OBFF supported
                               using Message signaling only 10b: OBFF supported
                               using WAKE# signaling only 11b: OBFF supported
                               using WAKE# and Message signaling Applicable
                               only to Root Ports, Switch Ports, and Endpoints
                               that support this capability. Must be 00b for
                               other function types. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 exfmtfs : 1;

                            /* Bits[20:20], Access Type=RW/L, default=None*/

                            /*
                               0: The Function supports a 2-bit definition of
                               the Fmt field (default) 1: The Function supports
                               the 3-bit definition of the Fmt field. Must be
                               Set for Functions that support End-End TLP
                               Prefixes. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 e2etlps : 1;

                            /* Bits[21:21], Access Type=RW/L, default=None*/

                            /*
                               Indicates whether End-End TLP Prefix support is
                               offered by a Function. 0: No Support 1: Support
                               is provided to receive TLPs containing End-End
                               TLP Prefixes. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 maxe2etlp : 2;

                            /* Bits[23:22], Access Type=RW/V/L, default=None*/

                            /*
                               Indicates the maximum number of End-End TLP
                               Prefixes supported by this Function. TLPs
                               received by this Function that contain more End-
                               End TLP Prefixes than are supported must be
                               handled as Malformed TLPs. 01: 1 End-End TLP
                               Prefix 10: 2 End-End TLP Prefixes 11: 3 End-End
                               TLP Prefixes 00: 4 End-End TLP Prefixes If End-
                               End TLP Prefix Supported is Clear, this field is
                               Reserved. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 rsvd_24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frs : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               When Set, indicates support for the optional
                               Function Readiness Status (FRS) capability. Must
                               be Set for all Functions that support generation
                               or receipt capabilities of FRS Messages. Must
                               not be Set by Switch Functions that do not
                               generate FRS Messages on their own behalf. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} DEVCAP2_IIO_CXL_STRUCT;

/* DEVCTL2_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000068)                                                      */
/*      SPRB0 (0x10000068)                                                      */
/*      SPRHBM (0x10000068)                                                     */
/*      SPRC0 (0x10000068)                                                      */
/*      SPRMCC (0x10000068)                                                     */
/*      SPRUCC (0x10000068)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Device Control 2
*/


#define DEVCTL2_IIO_CXL_REG 0x23010068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ctv : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               In devices that support completion timeout
                               programmability, this field allows system
                               software to modify the completion timeout range.
                               The following encodings and corresponding
                               timeout ranges are defined based on
                               implementation choice. This field provides finer
                               control based over the ranges chosen by
                               DEVAP2.CTRS. The implementation specific range
                               is shown in brackets 0000b: 50us to 50ms (16.8ms
                               - 25.2ms based on core clk period) 0001b: 50us
                               to 100us (65.5us - 99.3us based on core clk
                               period) 0010b: 1ms to 10ms (4.2ms - 6.3ms based
                               on core clk period) 0101b: 16ms to 55ms (33.6ms
                               - 50.3ms based on core clk period) 0110b: 65ms
                               to 210ms (134.2ms - 201.3ms based on core clk
                               period) 1001b: 260ms to 900ms (536.9ms - 805.3ms
                               based on core clk period) 1010b: 1s to 3.5s
                               (2.1s - 3.2s based on core clk period) 1101b: 4s
                               to 13s (8.6s - 12.9s based on core clk period)
                               1110b: 17s to 64s (34.4s - 51.5s based on core
                               clk period) All others are reserved. It is
                               highly recommended that the completion timeout
                               value not be less then 10ms. A small completion
                               timeout value may result in premature completion
                               timeout for slower responding devices.
                            */
    UINT16 ctd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               1: Disable the completions timeout mechanism for
                               all NP transactions. 0: Completion timeout is
                               enabled for all NP transactions.
                            */
    UINT16 arie : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1b, ARI is enabled for the
                               downstream port or root ports. The Downstream
                               Port disables its traditional Device Number
                               field being 0 enforcement when turning a Type 1
                               Configuration Request into a Type 0
                               Configuration Request, permitting access to
                               Extended Functions in an ARI Device immediately
                               below the Port. Default value of this bit is 0b.
                            */
    UINT16 are : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Applicable only to Endpoints and Root Ports,
                               must be hardwired to 0b for other Function
                               types. The Function is allowed to initiate
                               AtomicOp Requests only if this bit and the Bus
                               Master Enable bit in the Command register are
                               both Set.
                            */
    UINT16 aeb : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, AtomicOp requests that
                               target this out going Egress port must be
                               blocked. Applicable and mandatory for switch
                               Upstream Ports, Switch Downstream Ports, and
                               Root Ports that implement AtomicOp routing
                               capability. Otherwise, must be hardwired to 0b.
                            */
    UINT16 idore : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               This bit when set to 1b allows the function to
                               set the ID-Based Ordering (IDO) bit on requests
                               it initiates. Applicable only to Endpoints
                               including RC integrated Endpoints and Root
                               Ports.
                            */
    UINT16 idoce : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /*
                               This bit when set to 1b allows the function to
                               set the ID-Based Ordering (IDO) bit of
                               completions it returns. Applicable only to
                               Endpoints including RC integrated Endpoints and
                               Root Ports.
                            */
    UINT16 ltrme : 1;

                            /* Bits[10:10], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set to 1b, this bit enables Upstream Ports
                               to send LTR messages and Downstream Ports to
                               process LTR Messages. Applicable to Root Ports,
                               Switches, and Endpoints that implement the LTR
                               capability must implement this bit. For
                               Downstream Ports, this bit must be reset to the
                               default value if the Port goes to DL_Down
                               status. H/W will change this field to 'RO' of
                               zero when DISALBE_LTR fuse is set to 1 if
                               supported.
                            */
    UINT16 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 tenbtre : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, in combination with the Extended Tag
                               Field Enable bit in the Device Control register,
                               determines how many Tag field bits a Requester
                               is permitted to use. When the 10-Bit Tag
                               Requester Enable bit is Set, the Requester is
                               permitted to use 10-Bit Tags. See PCIe Spec.
                               Section 2.2.6.2 for complete details. Software
                               should not change the value of this bit while
                               the Function has outstanding Non-Posted
                               Requests, otherwise, the result is undefined.
                               Functions that do not implement 10-Bit Tag
                               Requester capability are permitted to hardwire
                               this bit to 0b. Default value of this bit is 0b
                            */
    UINT16 obffe : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               00b: OBFF Disabled 01b: OBFF Enabled using
                               Message signaling [Variation A] 10b: OBFF
                               Enabled using Message signaling [Variation B]
                               11b: OBFF Enabled using WAKE# signaling This
                               field is required for all Ports that support the
                               OBFF Capability. For a Multi-Function Device
                               associated with an Upstream Port of a Device
                               that implements OBFF, the field in Function 0 is
                               of type RW, and only Function 0 controls the
                               Component's behavior. In all other Functions of
                               that Device, this field is of type RsvdP.
                            */
    UINT16 e2etlpblk : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Controls whether the routing function is
                               permitted to forward TLPs containing an End-End
                               TLP Prefix. 0: Forwarding Enabled - Function is
                               permitted to send TLPs with End-End TLP
                               Prefixes. 1: Forwarding Blocked - Function is
                               not permitted to send TLPs with End-End TLP
                               Prefixes. This bit is applicable to Root Ports
                               and Switch Ports where the End-End TLP Prefix
                               Supported bit is Set. This bit is not applicable
                               and is RsvdP in all other cases
                            */

  } Bits;
  UINT16 Data;

} DEVCTL2_IIO_CXL_STRUCT;

/* LINKCAP2_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x2000006c)                                                      */
/*      SPRB0 (0x2000006c)                                                      */
/*      SPRHBM (0x2000006c)                                                     */
/*      SPRC0 (0x2000006c)                                                      */
/*      SPRMCC (0x2000006c)                                                     */
/*      SPRUCC (0x2000006c)                                                     */
/* Register default value on SPRA0: 0x0000003E                                  */
/* Register default value on SPRB0: 0x0000003E                                  */
/* Register default value on SPRHBM: 0x0000003E                                 */
/* Register default value on SPRC0: 0x0000003E                                  */
/* Register default value on SPRMCC: 0x0000003E                                 */
/* Register default value on SPRUCC: 0x0000003E                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Link Capabilities 2
*/


#define LINKCAP2_IIO_CXL_REG 0x2302006C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 slnkspv : 7;

                            /* Bits[7:1], Access Type=RO/V, default=0x0000001F*/

                            /*
                               This field indicates the supported Link speed(s)
                               of the associated Port. For each bit, a value of
                               1b indicates that the corresponding Link speed
                               is supported, otherwise, the Link speed is not
                               supported. Bit definitions within this field
                               are: bit 0 2.5 GT/s bit 1 5.0 GT/s bit 2 8.0
                               GT/s bit 3 16.0 GT/s bit 4 32.0 GT/s bit 6:5
                               Reserved Multi-Function devices associated with
                               an Upstream Port must report the same value in
                               this field for all Functions.
                            */
    UINT32 cls : 1;

                            /* Bits[8:8], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports crosslinks When set to
                               0b on a Port that supports Link speeds of 8.0
                               GT/s or higher, this bit indicates that the
                               associated Port does not support crosslinks.
                               When set to 0b on a Port that only supports Link
                               speeds of 2.5 GT/s or 5.0 GT/s, this bit
                               provides no information regarding the Port's
                               level of crosslink support. It is recommended
                               that this bit be Set in any Port that supports
                               crosslinks even though doing so is only required
                               for Ports that also support operating at 8.0
                               GT/s or higher Link speeds. Note: Software
                               should use this bit when referencing fields
                               whose definition depends on whether or not the
                               Port supports crosslinks. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 lskposgssv : 7;

                            /* Bits[15:9], Access Type=RW/L, default=None*/

                            /*
                               If this field is non-zero, it indicates that the
                               Port, when operating at the indicated speed(s)
                               supports SRIS and also supports software control
                               of the SKP Ordered Set transmission scheduling
                               rate. Bit definitions within this field are: Bit
                               0 2.5 GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3
                               16.0 GT/s Bits 6:4 RsvdP Multi-Function devices
                               associated with an Upstream Port must report the
                               same value in this field for all Functions.
                               Behavior is undefined if a bit is Set in this
                               field and the corresponding bit is not Set in
                               the Supported Link Speeds Vector. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 lskposrssv : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               If this field is non-zero, it indicates that the
                               Port, when operating at the indicated speed(s)
                               supports SRIS and also supports receiving SKP OS
                               at the rate defined for SRNS while running in
                               SRIS. Bit definitions within this field are: Bit
                               0 2.5 GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3
                               16.0 GT/s Bits 6:4 RsvdP Multi-Function devices
                               associated with an Upstream Port must report the
                               same value in this field for all Functions.
                               Behavior is undefined if a bit is Set in this
                               field and the corresponding bit is not Set in
                               the Supported Link Speeds Vector. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register . Currently, design does not
                               support reception of low frequency SOS in L0.
                            */
    UINT32 rpds : 1;

                            /* Bits[23:23], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports detection and reporting
                               of Retimer presence. This bit must be set to 1b
                               in a Port when the Supported Link Speeds Vector
                               of the Link Capabilities 2 register indicates
                               support for a Link speed of 16.0 GT/s or higher.
                               It is permitted to be set to 1b regardless of
                               the supported Link speeds. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rpds2 : 1;

                            /* Bits[24:24], Access Type=RW/L, default=None*/

                            /*
                               When set to 1b, this bit indicates that the
                               associated Port supports detection and reporting
                               of two Retimers presence. This bit must be set
                               to 1b in a Port when the Supported Link Speeds
                               Vector of the Link Capabilities 2 register
                               indicates support for a Link speed of 16.0 GT/s
                               or higher. It is permitted to be set to 1b
                               regardless of the supported Link speeds if the
                               Retimer Presence Detect Supported bit is also
                               set to 1b. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 rsvd_25 : 6;

                            /* Bits[30:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 drss : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               When Set, indicates support for the optional
                               Device Readiness Status (DRS) capability. Must
                               be Set in Downstream Ports that support DRS.
                               Must be Set in Downstream Ports that support
                               FRS. For Upstream Ports that support DRS, it is
                               strongly recommended that this bit be Set in
                               Function 0. For all other Functions associated
                               with an Upstream Port, this bit must be Clear.
                               Must be Clear in Functions that are not
                               associated with a Port. RsvdP in all other
                               Functions. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} LINKCAP2_IIO_CXL_STRUCT;

/* LINKSTS2_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x10000072)                                                      */
/*      SPRB0 (0x10000072)                                                      */
/*      SPRHBM (0x10000072)                                                     */
/*      SPRC0 (0x10000072)                                                      */
/*      SPRMCC (0x10000072)                                                     */
/*      SPRUCC (0x10000072)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Status 2
*/


#define LINKSTS2_IIO_CXL_REG 0x23010072

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cdl : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               When the link is operating at 5 Gb/s speed, this
                               bit reflects the level of de-emphasis. 1b: -3.5
                               dB 0b: -6dB The value in this bit is undefined
                               when the Link is not operating at 5.0 GT/s
                               speed. Components that support only the 2.5 GT/s
                               speed are permitted to hardwire this bit to 0b.
                            */
    UINT16 eqcmplt : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that the
                               Transmitter Equalization procedure at the 8.0
                               GT/s data rate has completed. Details of the
                               Transmitter Equalization process and when this
                               bit needs to be set to 1b is provided in PCIe
                               Spec. Section 4.2.6.4.2. The default value of
                               this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph1succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph2succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 eqph3succ : 1;

                            /* Bits[4:4], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 8.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCie Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 lnkeqreq : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 8.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions. Components that
                               only support speeds below 8.0 GT/s are permitted
                               to hardwire this bit to 0b. With the M-PCIe PHY,
                               this feature is unused and this bit is hardwired
                               to 0b.
                            */
    UINT16 rpd : 1;

                            /* Bits[6:6], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that a
                               Retimer was present during the most recent Link
                               negotiation. The default value of this bit is
                               0b. This bit is required for Ports that have the
                               Retimer Presence Detect Supported bit of the
                               Link Capabilities 2 register set to 1b. Ports
                               that have the Retimer Presence Detect Supported
                               bit set to 0b are permitted to hardwire this bit
                               to 0b.
                            */
    UINT16 rpd2 : 1;

                            /* Bits[7:7], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that two
                               Retimers were present during the most recent
                               Link negotiation. The default value of this bit
                               is 0b. This bit is required for Ports that have
                               the Two Retimers Presence Detect Supported bit
                               of the Link Capabilities 2 register set to 1b.
                               Ports that have the Two Retimers Presence Detect
                               Supported bit set to 0b are permitted to
                               hardwire this bit to 0b.
                            */
    UINT16 clres : 2;

                            /* Bits[9:8], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the state of the Crosslink
                               negotiation. It must be implemented if Crosslink
                               Supported is Set and the Port supports 16.0 GT/s
                               or higher data rate. It is permitted to be
                               implemented in all other Ports. If Crosslink
                               Supported is Clear, this field may be hardwired
                               to 01b or 10b. Encoding is: 00b Crosslink
                               Resolution is not supported. No information is
                               provided regarding the status of the Crosslink
                               negotiation. 01b Crosslink negotiation resolved
                               as an Upstream Port. 10b Crosslink negotiation
                               resolved as a Downstream Port. 11b Crosslink
                               negotiation is not completed. Once a value of
                               01b or 10b is returned in this field, that value
                               must continue to be returned while the Link is
                               Up.
                            */
    UINT16 rsvd : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 dcp : 3;

                            /* Bits[14:12], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field indicates the presence and DRS status
                               for the Downstream Component, if any, connected
                               to the Link, defined values are: 000b Link Down
                               - Presence Not Determined 001b Link Down -
                               Component Not Present indicates the Downstream
                               Port (DP) has determined that a Downstream
                               Component is not present 010b Link Down -
                               Component Present indicates the DP has
                               determined that a Downstream Component is
                               present, but the Data Link Layer is not active
                               011b Reserved 100b Link Up - Component Present
                               indicates the DP has determined that a
                               Downstream Component is present, but no DRS
                               Message has been received since the Data Link
                               Layer became active 101b Link Up - Component
                               Present and DRS Received indicates the DP has
                               received a DRS Message since the Data Link Layer
                               became active 110b Reserved 111b Reserved
                               Component Presence state must be determined by
                               the logical 'OR' of the Physical Layer in-band
                               presence detect mechanism and, if present, any
                               out-of-band presence detect mechanism
                               implemented for the Link. If no out-of-band
                               presence detect mechanism is implemented, then
                               Component Presence state must be determined
                               solely by the Physical Layer in-band presence
                               detect mechanism. This field must be implemented
                               in any Downstream Port where the DRS Supported
                               bit is Set in the Link Capabilities 2 register.
                               This field is RsvdZ for all other Functions.
                               Default value of this field is 000b
                            */
    UINT16 drsmr : 1;

                            /* Bits[15:15], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit must be Set whenever the Port receives
                               a DRS Message. This bit must be Cleared in
                               DL_Down. This bit must be implemented in any
                               Downstream Port where the DRS Supported bit is
                               Set in the Link Capabilities 2 register. This
                               bit is RsvdZ for all other Functions. Default
                               value of this bit is 0b.
                            */

  } Bits;
  UINT16 Data;

} LINKSTS2_IIO_CXL_STRUCT;

/* MSICAPLST_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x10000080)                                                      */
/*      SPRB0 (0x10000080)                                                      */
/*      SPRHBM (0x10000080)                                                     */
/*      SPRC0 (0x10000080)                                                      */
/*      SPRMCC (0x10000080)                                                     */
/*      SPRUCC (0x10000080)                                                     */
/* Register default value on SPRA0: 0x00000005                                  */
/* Register default value on SPRB0: 0x00000005                                  */
/* Register default value on SPRHBM: 0x00000005                                 */
/* Register default value on SPRC0: 0x00000005                                  */
/* Register default value on SPRMCC: 0x00000005                                 */
/* Register default value on SPRUCC: 0x00000005                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* MSI Capability List
*/


#define MSICAPLST_IIO_CXL_REG 0x23010080

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000005*/

                            /* Identifies the function as MSI capable. */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list (MSIXCAPLST). A null value is
                               used to indicate that this is the last
                               capability. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . The Next
                               Pointer is terminated for DP, vRP/vSP, RP and
                               DMI EP in RC.
                            */

  } Bits;
  UINT16 Data;

} MSICAPLST_IIO_CXL_STRUCT;

/* MSICTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000082)                                                      */
/*      SPRB0 (0x10000082)                                                      */
/*      SPRHBM (0x10000082)                                                     */
/*      SPRC0 (0x10000082)                                                      */
/*      SPRMCC (0x10000082)                                                     */
/*      SPRUCC (0x10000082)                                                     */
/* Register default value on SPRA0: 0x00000100                                  */
/* Register default value on SPRB0: 0x00000100                                  */
/* Register default value on SPRHBM: 0x00000100                                 */
/* Register default value on SPRC0: 0x00000100                                  */
/* Register default value on SPRMCC: 0x00000100                                 */
/* Register default value on SPRUCC: 0x00000100                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Control
*/


#define MSICTL_IIO_CXL_REG 0x23010082

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 msie : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set, MSI is enabled and traditional
                               interrupt pins are not used to generate
                               interrupts.
                            */
    UINT16 mmc : 3;

                            /* Bits[3:1], Access Type=RO, default=0x00000000*/

                            /* Only one message is supported. */
    UINT16 mmen : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               Only one message is supported. These bits are
                               R/W for software compatibility.
                            */
    UINT16 ad64c : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit indicates that the function
                               is capable of generating a 64-bit message
                               address.
                            */
    UINT16 pvm : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000001*/

                            /*
                               This bit indicates that PCI Express ports
                               support MSI per-vector masking. The value of
                               this field will be reflected by
                               CAPSR.MSICTL_PVM.
                            */
    UINT16 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} MSICTL_IIO_CXL_STRUCT;

/* MSIADDR_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000084)                                                      */
/*      SPRB0 (0x20000084)                                                      */
/*      SPRHBM (0x20000084)                                                     */
/*      SPRC0 (0x20000084)                                                      */
/*      SPRMCC (0x20000084)                                                     */
/*      SPRUCC (0x20000084)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Address
*/


#define MSIADDR_IIO_CXL_REG 0x23020084

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address : 30;

                            /* Bits[31:2], Access Type=RW, default=0x00000000*/

                            /*
                               Message address specified by the system, always
                               DWORD aligned
                            */

  } Bits;
  UINT32 Data;

} MSIADDR_IIO_CXL_STRUCT;

/* MSIDATA_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000088)                                                      */
/*      SPRB0 (0x20000088)                                                      */
/*      SPRHBM (0x20000088)                                                     */
/*      SPRC0 (0x20000088)                                                      */
/*      SPRMCC (0x20000088)                                                     */
/*      SPRUCC (0x20000088)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* MSI Message Data
*/


#define MSIDATA_IIO_CXL_REG 0x23020088

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 iv : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               The interrupt vector will be modified by the EIP
                               PCIe Gen3 to provide context sensitive interrupt
                               information for different events that require
                               attention from the processor. e.g Hot plug,
                               Power Management and RAS error events. Since
                               only one MSI message is supported, there is no
                               modification as shown in Table 1-26 on page 322.
                               However if more than one message is supported in
                               the future, the IV can be modified on the LSB.
                            */
    UINT32 dm : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               0000: Fixed: Trigger Mode can be edge or level.
                               0001: Lowest Priority: Trigger Mode can be edge
                               or level. 0010: SMI/PMI/MCA - Not supported via
                               MSI of root port 0011: Reserved - Not supported
                               via MSI of root port 0100: NMI - Not supported
                               via MSI of root port 0101: INIT - Not supported
                               via MSI of root port 0110: Reserved 0111: ExtINT
                               - Not supported via MSI of primary port 1000
                               -1111 - Reserved
                            */
    UINT32 future : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /*
                               These bits are don't care for an IOxAPIC
                               interrupt message data field specification.
                            */
    UINT32 lvl : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               if TM is 0h, then this field is a don't care.
                               Edge triggered messages are always treated as
                               assert messages. For level triggered interrupts,
                               this bit reflects the state of the interrupt
                               input if TM is 1h, then 0: Deassert Messages 1:
                               Assert Messages
                            */
    UINT32 tm : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* 0: Edge Triggered 1: Level Triggered */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIDATA_IIO_CXL_STRUCT;

/* MSIMSK_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x2000008c)                                                      */
/*      SPRB0 (0x2000008c)                                                      */
/*      SPRHBM (0x2000008c)                                                     */
/*      SPRC0 (0x2000008c)                                                      */
/*      SPRMCC (0x2000008c)                                                     */
/*      SPRUCC (0x2000008c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The MSI Mask Bit register enables software to disable message sending on a per-vector basis.
*/


#define MSIMSK_IIO_CXL_REG 0x2302008C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mskb : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               For each Mask bit that is set, the PCI Express
                               port is prohibited from sending the associated
                               message. Corresponding bits are masked if set to
                               '1'
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIMSK_IIO_CXL_STRUCT;

/* MSIPENDING_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000090)                                                      */
/*      SPRB0 (0x20000090)                                                      */
/*      SPRHBM (0x20000090)                                                     */
/*      SPRC0 (0x20000090)                                                      */
/*      SPRMCC (0x20000090)                                                     */
/*      SPRUCC (0x20000090)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Mask Pending register enables software to defer message sending on a per-vector basis.
*/


#define MSIPENDING_IIO_CXL_REG 0x23020090

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pb : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For each Pending bit that is set, the PCI
                               Express port has a pending associated message.
                               Corresponding bits are pending if set to '1'
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MSIPENDING_IIO_CXL_STRUCT;

/* SSCAPLST_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x10000094)                                                      */
/*      SPRB0 (0x10000094)                                                      */
/*      SPRHBM (0x10000094)                                                     */
/*      SPRC0 (0x10000094)                                                      */
/*      SPRMCC (0x10000094)                                                     */
/*      SPRUCC (0x10000094)                                                     */
/* Register default value on SPRA0: 0x0000800D                                  */
/* Register default value on SPRB0: 0x0000800D                                  */
/* Register default value on SPRHBM: 0x0000800D                                 */
/* Register default value on SPRC0: 0x0000800D                                  */
/* Register default value on SPRMCC: 0x0000800D                                 */
/* Register default value on SPRUCC: 0x0000800D                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Subsystem Capability List
*/


#define SSCAPLST_IIO_CXL_REG 0x23010094

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x0000000D*/

                            /*
                               Identifies the function as Subsystem
                               Identification capable.
                            */
    UINT16 np : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000080*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list. (MSICAPLST)
                            */

  } Bits;
  UINT16 Data;

} SSCAPLST_IIO_CXL_STRUCT;

/* SSVID_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x10000098)                                                      */
/*      SPRB0 (0x10000098)                                                      */
/*      SPRHBM (0x10000098)                                                     */
/*      SPRC0 (0x10000098)                                                      */
/*      SPRMCC (0x10000098)                                                     */
/*      SPRUCC (0x10000098)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Subsystem Vendor ID
*/


#define SSVID_IIO_CXL_REG 0x23010098

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ssvid : 16;

                            /* Bits[15:0], Access Type=RW/L, default=None*/

                            /*
                               Assigned by PCI-SIG for vendor ID. Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */

  } Bits;
  UINT16 Data;

} SSVID_IIO_CXL_STRUCT;

/* SSID_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x1000009a)                                                      */
/*      SPRB0 (0x1000009a)                                                      */
/*      SPRHBM (0x1000009a)                                                     */
/*      SPRC0 (0x1000009a)                                                      */
/*      SPRMCC (0x1000009a)                                                     */
/*      SPRUCC (0x1000009a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Subsystem ID
*/


#define SSID_IIO_CXL_REG 0x2301009A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ssid : 16;

                            /* Bits[15:0], Access Type=RW/L, default=None*/

                            /*
                               Assigned to uniquely identify the subsystem
                               vendor. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */

  } Bits;
  UINT16 Data;

} SSID_IIO_CXL_STRUCT;

/* PMCAPLST_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x100000a0)                                                      */
/*      SPRB0 (0x100000a0)                                                      */
/*      SPRHBM (0x100000a0)                                                     */
/*      SPRC0 (0x100000a0)                                                      */
/*      SPRMCC (0x100000a0)                                                     */
/*      SPRUCC (0x100000a0)                                                     */
/* Register default value on SPRA0: 0x00009401                                  */
/* Register default value on SPRB0: 0x00009401                                  */
/* Register default value on SPRHBM: 0x00009401                                 */
/* Register default value on SPRC0: 0x00009401                                  */
/* Register default value on SPRMCC: 0x00009401                                 */
/* Register default value on SPRUCC: 0x00009401                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Power Management Capability List
*/


#define PMCAPLST_IIO_CXL_REG 0x230100A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 capabilityid : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000001*/

                            /*
                               Identifies the function as PCI Power Management
                               capable.
                            */
    UINT16 nextpointer : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000094*/

                            /*
                               Contains the offset of the next item in the
                               capabilities list.
                            */

  } Bits;
  UINT16 Data;

} PMCAPLST_IIO_CXL_STRUCT;

/* PMCAP_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x100000a2)                                                      */
/*      SPRB0 (0x100000a2)                                                      */
/*      SPRHBM (0x100000a2)                                                     */
/*      SPRC0 (0x100000a2)                                                      */
/*      SPRMCC (0x100000a2)                                                     */
/*      SPRUCC (0x100000a2)                                                     */
/* Register default value on SPRA0: 0x0000C803                                  */
/* Register default value on SPRB0: 0x0000C803                                  */
/* Register default value on SPRHBM: 0x0000C803                                 */
/* Register default value on SPRC0: 0x0000C803                                  */
/* Register default value on SPRMCC: 0x0000C803                                 */
/* Register default value on SPRUCC: 0x0000C803                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Power Management Capabilities
*/


#define PMCAP_IIO_CXL_REG 0x230100A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ver : 3;

                            /* Bits[2:0], Access Type=RO, default=0x00000003*/

                            /*
                               The PM implementation in the PCIe cluster is
                               compliant with PCI Bus Power Management
                               Interface Specification, Revision 1.2.
                            */
    UINT16 pmeclk : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /* Does not apply to PCI Express. Hard-wired to 0. */
    UINT16 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 dsi : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Device-specific initialization is not required
                               when transitioning to D0 from D3hot state. This
                               bit is zero.
                            */
    UINT16 ac : 3;

                            /* Bits[8:6], Access Type=RO, default=0x00000000*/

                            /* Auxiliary power is not supported. */
    UINT16 d1s : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 d2s : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 pmes : 5;

                            /* Bits[15:11], Access Type=RO, default=0x00000019*/

                            /*
                               PME assertion is supported when in D3hot/D3cold.
                               Identifies power states in which the PCIe can
                               send an 'Assert_PMEGPE/ Deassert PMEGPE'
                               message. Bits 15, 14 and 11 must be set to '1'
                               for PCIPCI bridge structures representing ports
                               on root complexes. The definition of these bits
                               is taken from the PCI Bus Power Management
                               Interface Specification Revision 1.1. XXXX1b -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D0 XXX1Xb - Assert_PMEGPE/Deassert PMEGPE can be
                               sent from D1 (Not supported by PCI-E) XX1XXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D2 (Not supported by PCI-E) X1XXXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D3 hot (Supported by PCI-E) 1XXXXb -
                               Assert_PMEGPE/Deassert PMEGPE can be sent from
                               D3 cold (Supported by PCI-E) In the EIP PCIe
                               implementation, there is no PME support for D3
                               cold as the part does not have the capability.
                               For PCIe compliance purposes, bit 15 is set to
                               1.
                            */

  } Bits;
  UINT16 Data;

} PMCAP_IIO_CXL_STRUCT;

/* PMCSR_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x100000a4)                                                      */
/*      SPRB0 (0x100000a4)                                                      */
/*      SPRHBM (0x100000a4)                                                     */
/*      SPRC0 (0x100000a4)                                                      */
/*      SPRMCC (0x100000a4)                                                     */
/*      SPRUCC (0x100000a4)                                                     */
/* Register default value on SPRA0: 0x00000008                                  */
/* Register default value on SPRB0: 0x00000008                                  */
/* Register default value on SPRHBM: 0x00000008                                 */
/* Register default value on SPRC0: 0x00000008                                  */
/* Register default value on SPRMCC: 0x00000008                                 */
/* Register default value on SPRUCC: 0x00000008                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Power Management Control Status
*/


#define PMCSR_IIO_CXL_REG 0x230100A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ps : 2;

                            /* Bits[1:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used both to determine the current
                               power state of a function and to set the
                               function into a new power state. The definition
                               of the supported values is given below: 0h - D0
                               3h - D3hot If software attempts to write an
                               unsupported, optional state to this field, the
                               write operation must complete normally, however,
                               the data is discarded and no state change
                               occurs.
                            */
    UINT16 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 nsr : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000001*/

                            /*
                               This bit indicates the state of the Function
                               afer writing the PowerState field to transition
                               the Function from D3Hot to D0. When Set, this
                               transition preserves internal Function state.
                               The Function is in D0Active and no additional
                               sofware intervention is required. When Clear,
                               this transition results in undefined internal
                               Function state. Regardless of this bit,
                               Functions that transition from D3Hot to D0 by
                               Fundamental Reset will return to D0uninitialized
                               with only PME context preserved if PME is
                               supported and enabled. The value of this field
                               will be reflected by CAPSR.PMCSR_NSR.
                            */
    UINT16 rsvd_4 : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 pmeen : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, the Function is permitted to generate
                               a PME. When Clear, the Function is not permitted
                               to generate a PME.
                            */
    UINT16 ds : 4;

                            /* Bits[12:9], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 dc : 2;

                            /* Bits[14:13], Access Type=RO, default=0x00000000*/

                            /* Not supported */
    UINT16 pmests : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set when the Function would normally
                               generate a PME signal. The value of this bit is
                               not affected by the value of the PME_En bit.
                            */

  } Bits;
  UINT16 Data;

} PMCSR_IIO_CXL_STRUCT;

/* PMBSE_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0xa6)                                                            */
/*      SPRB0 (0xa6)                                                            */
/*      SPRHBM (0xa6)                                                           */
/*      SPRC0 (0xa6)                                                            */
/*      SPRMCC (0xa6)                                                           */
/*      SPRUCC (0xa6)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Power Management Bridge Support Extensions
*/


#define PMBSE_IIO_CXL_REG 0x230000A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 rsvd : 6;

                            /* Bits[5:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 b23en : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Not supported. This bit has no meaning since the
                               BPCC_En bit is hard-wired to 0.
                            */
    UINT8 bpcc_en : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Neither bus or clock control of PCI is supported
                               when in D3hot state. This bit is hard-wired to
                               0.
                            */

  } Bits;
  UINT8 Data;

} PMBSE_IIO_CXL_STRUCT;

/* AERPR_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x200000ac)                                                      */
/*      SPRB0 (0x200000ac)                                                      */
/*      SPRHBM (0x200000ac)                                                     */
/*      SPRC0 (0x200000ac)                                                      */
/*      SPRMCC (0x200000ac)                                                     */
/*      SPRUCC (0x200000ac)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* AER Policy
*/


#define AERPR_IIO_CXL_REG 0x230200AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 iptlpanfe : 1;

                            /* Bits[0:0], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               This bit controls the error severity and must
                               NOT control the EP bit. The IP shall forward the
                               EP bit unmodified. 'ERRUNCSEV.PTLPES ' |
                               'AERPR.IPTLPANFE' | 'AER Error Type' 0 | 0 |
                               Non-fatal 0 | 1 | Advisory non-fatal 1 | X |
                               Fatal Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . This
                               field is only applicable to (v)RPs and should be
                               treated as reserved for other devices.
                            */
    UINT32 ptlpib : 1;

                            /* Bits[1:1], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               When 'Poison TLP Ingress Blocking' bit is set,
                               the IP must drop/abort received Poisoned TLP's
                               after AER logging and the TLP must not be
                               forwarded on to IOSF. This would be done in the
                               IOSF Master block. Non-Posted requests would use
                               the UR path to the IOSF Target block. AER must
                               continue to log the Inbound Poison TLP Error in
                               Uncorrectable Error Status. This bit is
                               orthogonal to 'Inbound Poison TLP Advisory Non-
                               Fatal Enable' bits. The table below covers only
                               the cases where PTLP is the only error in the
                               Ingress TLP. 'AERPR.PTLPIB ' | 'ERRUNCSEV.PTLPES
                               ' | 'AERPR.IPTLPANFE' | 'AER Error Type' | '
                               Forward on to IOSF' 0 | 0 | 0 | Non-fatal | yes
                               0 | 0 | 1 | Advisory non-fatal | yes 0 | 1 | X |
                               Fatal | yes 1 | 0 | 0 | Non-fatal | no 1 | 0 | 1
                               | Advisory non-fatal | no 1 | 1 | X | Fatal | no
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register .
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} AERPR_IIO_CXL_STRUCT;


/* CRSRT_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x100000be)                                                      */
/*      SPRB0 (0x100000be)                                                      */
/*      SPRHBM (0x100000be)                                                     */
/*      SPRC0 (0x100000be)                                                      */
/*      SPRMCC (0x100000be)                                                     */
/*      SPRUCC (0x100000be)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* CRS Retry Timeout
*/


#define CRSRT_IIO_CXL_REG 0x230100BE

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 crsrtv : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000010*/

                            /*
                               When handling a Completion with Configuration
                               Retry Status, the rules as specified in Section
                               2.3.2 of the PCIe Spec apply for both the case
                               when CRS Software Visibility is enabled and when
                               it is not enabled. The IP should re-issue the
                               request till a programmable H/W timer expires
                               and then complete the request as UR without any
                               error logging. The programmable H/W timer will
                               be timeout after the requested values - 'Timeout
                               after' with min/max. as specified. The
                               implementation specific range is shown in
                               brackets 00h: disabled 01h: 64ms (67.1ms -
                               100.7ms based on core clk period) 02h: 256ms
                               (268.4ms - 402.7ms based on core clk period)
                               08h: 512ms (536.9ms - 805.3ms based on core clk
                               period) 10h: 1s (1.1s - 1.6s based on core clk
                               period) 20h: 2s (2.1s - 3.2s based on core clk
                               period) 40h: 4s (4.3s - 6.4s based on core clk
                               period) 80h: 8s (8.6s - 12.9s based on core clk
                               period) All others are reserved.
                            */
    UINT16 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} CRSRT_IIO_CXL_STRUCT;






/* PPD0_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x200000d4)                                                      */
/*      SPRB0 (0x200000d4)                                                      */
/*      SPRHBM (0x200000d4)                                                     */
/*      SPRC0 (0x200000d4)                                                      */
/*      SPRMCC (0x200000d4)                                                     */
/*      SPRUCC (0x200000d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PCIe Port Definition Control Register 0
*/


#define PPD0_IIO_CXL_REG 0x230200D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 clrtrnenonlnkdn : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               when set to 1, a link down event will cause the
                               link train enable field (ILINKTRN0) of this
                               register to be cleared and block subsequent
                               training until that train enable is set again.
                               If 0, a link down will not clear the train
                               enable unless a link down causes a reset.
                            */
    UINT32 rsvd : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ilinktrn0 : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit controls PCI Express port link training
                               for the associated port. A value of '1'
                               initiates link training on the corresponding
                               port. After writing this bit to a '1', software
                               can poll the Data Link Layer link active bit in
                               the LINKSTS register to determine if a port is
                               up and running. This bit clears on warm reset,
                               i.e. the associated port will not automatically
                               initiate link training after warm reset.
                               Hardware-aware of software should set
                               PPD0.ClrTrnEnOnLnkDn to '1' on DL_Down events if
                               desirable, such as in NTB mode. 0: The
                               associated PCI Express port has not initiated
                               link training. 1: The associated PCI Express
                               port is initiating link training or has trained.
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PPD0_IIO_CXL_STRUCT;


/* LTRCSR_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x200000ec)                                                      */
/*      SPRB0 (0x200000ec)                                                      */
/*      SPRHBM (0x200000ec)                                                     */
/*      SPRC0 (0x200000ec)                                                      */
/*      SPRMCC (0x200000ec)                                                     */
/*      SPRUCC (0x200000ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Latency Tolerance Reporting Control Status
*/


#define LTRCSR_IIO_CXL_REG 0x230200EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ltrsovren : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, the latency tolerance
                               values for this port will be overridden to the
                               values programmed in the LTRSLOVRV, LTRSLSOVRV
                               and LTRSROVR fields. The latency values from the
                               LTR messages received from the devices will be
                               ignored. Hardware should treat this bit as
                               dynamic and the transition of this bit from '0'
                               to '1' will cause a new IOSF sideband LTR
                               message to be sent to update PMC if the new
                               aggregated latency values change as a result of
                               this.
                            */
    UINT32 ltrnsovren : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, the latency tolerance
                               values for this port will be overridden to the
                               values programmed in the LTRNSLOVRV, LTRNSLSOVRV
                               and LTRNSROVR fields. The latency values from
                               the LTR messages received from the devices will
                               be ignored. Hardware should treat this bit as
                               dynamic and the transition of this bit from '0'
                               to '1' will cause a new IOSF sideband LTR
                               message to be sent to update PMC if the new
                               aggregated latency values change as a result of
                               this.
                            */
    UINT32 ltrovrplcy : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This register bit defines the LTR override
                               behavior when the respective LTR Override Enable
                               bits are set. 0: The LTR Override values will be
                               in effect when the link is up and in D0, until a
                               valid new LTR message is received from the
                               device. 1: The LTR Override values will be in
                               effect when the link is up and in D0. LTR values
                               from the valid new LTR message received from
                               device will be ignored. Note: This register
                               should be programmed prior to enabling LTR
                               override and should not be modified after LTR
                               override has been enabled.
                            */
    UINT32 ltramd : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Default is 0 to enable LTR aggregation mode. Set
                               1 to disable LTR Aggregation Mode.
                            */
    UINT32 rsvd : 12;

                            /* Bits[15:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ltrr : 1;

                            /* Bits[16:16], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to '1' by hardware when an LTR message is
                               received and both the LTR Mechanism Supported
                               bit and LTR Mechanism Enable bit are set. It can
                               be set/cleared by hardware internally, or
                               software by writing 1 to clear it.
                            */
    UINT32 ivlsvr : 1;

                            /* Bits[17:17], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to '1' by hardware when an LTR message is
                               received with Not Permitted Latency Scale Value
                               and both the LTR Mechanism Supported bit and the
                               LTR Mechanism Enable bit are set. Cleared to '0'
                               by software writing 1 to this register.
                            */
    UINT32 rsvd_18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LTRCSR_IIO_CXL_STRUCT;

/* LTRL_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x200000f0)                                                      */
/*      SPRB0 (0x200000f0)                                                      */
/*      SPRHBM (0x200000f0)                                                     */
/*      SPRC0 (0x200000f0)                                                      */
/*      SPRMCC (0x200000f0)                                                     */
/*      SPRUCC (0x200000f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Latency Tolerance Reporting Latency
*/


#define LTRL_IIO_CXL_REG 0x230200F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ltrslf : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field contains the Snoop Latency field of
                               the latest received LTR Message. When an LTR
                               message is received and both the LTR Mechanism
                               Supported bit and LTR Mechanism Enable field are
                               set, bytes 14:15 of the PCIe header are stored
                               in this register. This includes the case where
                               the Latency Scale Value contains 'Not Permitted'
                               encoding.
                            */
    UINT32 ltrnslf : 16;

                            /* Bits[31:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field contains the No-Snoop Latency field
                               of the latest received LTR Message. When an LTR
                               message is received and both the LTR Mechanism
                               Supported bit and LTR Mechanism Enable field are
                               set, bytes 12:13 of the PCIe header are stored
                               in this register. This includes the case where
                               the Latency Scale Value contains 'Not Permitted'
                               encoding.
                            */

  } Bits;
  UINT32 Data;

} LTRL_IIO_CXL_STRUCT;

/* LTROVR_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x200000f4)                                                      */
/*      SPRB0 (0x200000f4)                                                      */
/*      SPRHBM (0x200000f4)                                                     */
/*      SPRC0 (0x200000f4)                                                      */
/*      SPRMCC (0x200000f4)                                                     */
/*      SPRUCC (0x200000f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Latency Tolerance Reporting Latency Override
*/


#define LTROVR_IIO_CXL_REG 0x230200F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ltrslovrv : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the Snoop latency override
                               value for this particular PCIe root port.
                            */
    UINT32 ltrslsovrv : 3;

                            /* Bits[12:10], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the Snoop latency scale
                               override value for this particular PCIe root
                               port. 000: LTRSLOVRV times 1 ns 001: LTRSLOVRV
                               times 32 ns 010: LTRSLOVRV times 1,024 ns 011:
                               LTRSLOVRV times 32,768 ns 100: LTRSLOVRV times
                               1,048,576 ns 101: LTRSLOVRV times 33,554,432 ns
                               Others: Not Permitted.
                            */
    UINT32 rsvd : 2;

                            /* Bits[14:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ltrsrovr : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the Snoop Requirement bit
                               override value for this particular PCIe root
                               port.
                            */
    UINT32 ltrnslovrv : 10;

                            /* Bits[25:16], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the No-Snoop latency
                               override value for this particular PCIe root
                               port.
                            */
    UINT32 ltrnslsovrv : 3;

                            /* Bits[28:26], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the No-Snoop latency scale
                               override value for this particular PCIe root
                               port. 000: LTRNSLOVRV times 1 ns 001: LTRNSLOVRV
                               times 32 ns 010: LTRNSLOVRV times 1,024 ns 011:
                               LTRNSLOVRV times 32,768 ns 100: LTRNSLOVRV times
                               1,048,576 ns 101: LTRNSLOVRV times 33,554,432 ns
                               Others: Not Permitted.
                            */
    UINT32 rsvd_29 : 2;

                            /* Bits[30:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ltrnsrovr : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field contains the No-Snoop Requirement bit
                               override value for this particular PCIe root
                               port.
                            */

  } Bits;
  UINT32 Data;

} LTROVR_IIO_CXL_STRUCT;

/* INTXSWZCTL_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0xf8)                                                            */
/*      SPRB0 (0xf8)                                                            */
/*      SPRHBM (0xf8)                                                           */
/*      SPRC0 (0xf8)                                                            */
/*      SPRMCC (0xf8)                                                           */
/*      SPRUCC (0xf8)                                                           */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register provides software the ability to swizzle the legacy interrupts (INTx) from each port and remap them to a different interrupt type for purposes of interrupt rebalancing. This swizzling only applies to inbound INTx messages that arrive on the secondary side of the switch or root port. This register does not affect PCI-Express defined INTx re-map based on device # that is required by the PCI-Express base specification. 
This register should be treated as reserved if not applicable to device/project specific.
*/


#define INTXSWZCTL_IIO_CXL_REG 0x230000F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 intxswz : 3;

                            /* Bits[2:0], Access Type=RW/L, default=None*/

                            /*
                               The encoding below defines the target INTx type
                               to which the incoming INTx message is mapped to
                               for that port. 000b:INTA becomes INTA, INTB
                               becomes INTB, INTC becomes INTC, INTD becomes
                               INTD, 001b:INTA becomes INTB, INTB becomes INTC,
                               INTC becomes INTD, INTD becomes INTA, 010b:INTA
                               becomes INTC, INTB becomes INTD, INTC becomes
                               INTA, INTD becomes INTB, 011b:INTA becomes INTD,
                               INTB becomes INTA, INTC becomes INTB, INTD
                               becomes INTC, 100b:INTA becomes INTA, INTB
                               becomes INTA, INTC becomes INTA, INTD becomes
                               INTA,
                            */
    UINT8 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} INTXSWZCTL_IIO_CXL_STRUCT;


/* AERCAPHDR_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000100)                                                      */
/*      SPRB0 (0x20000100)                                                      */
/*      SPRHBM (0x20000100)                                                     */
/*      SPRC0 (0x20000100)                                                      */
/*      SPRMCC (0x20000100)                                                     */
/*      SPRUCC (0x20000100)                                                     */
/* Register default value on SPRA0: 0x00010001                                  */
/* Register default value on SPRB0: 0x00010001                                  */
/* Register default value on SPRHBM: 0x00010001                                 */
/* Register default value on SPRC0: 0x00010001                                  */
/* Register default value on SPRMCC: 0x00010001                                 */
/* Register default value on SPRUCC: 0x00010001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Advanced Error Reporting Extended Capability Header
*/


#define AERCAPHDR_IIO_CXL_REG 0x23020100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 excapid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000001*/

                            /*
                               Identifies the function as Advanced Error
                               Reporting capable.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. This field must be 2h if the
                               End-End TLP Prefix Supported bit of Device
                               Capabilities 2 Register is Set and must be 1h or
                               2h otherwise.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities list. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} AERCAPHDR_IIO_CXL_STRUCT;

/* ERRUNCSTS_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000104)                                                      */
/*      SPRB0 (0x20000104)                                                      */
/*      SPRHBM (0x20000104)                                                     */
/*      SPRC0 (0x20000104)                                                      */
/*      SPRMCC (0x20000104)                                                     */
/*      SPRUCC (0x20000104)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register reports the error status of individual uncorrectable error sources. An individual error status bit that is set to 1 indicates that a particular error occurred. Software can clear an error status by writing a 1 to the respective bit.
*/


#define ERRUNCSTS_IIO_CXL_REG 0x23020104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpe : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a data link protocol error
                               is detected.
                            */
    UINT32 slde : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a surprise down error is
                               detected. This bit does not apply to the
                               upstream port.
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpe : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set and the bridge logs the header
                               when a poisoned TLP is received from PCI
                               Express.
                            */
    UINT32 fce : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when a flow control protocol
                               error is detected.
                            */
    UINT32 cte : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               For Switch Ports, this bit is set if the Switch
                               Port issues Non-Posted Requests on its own
                               behalf (vs. only forwarding such as Requests
                               generated by other devices).
                            */
    UINT32 cae : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The bridge sets this bit and logs the header
                               associated with the request when the
                               configuration unit signals a completer abort.
                            */
    UINT32 uce : 1;

                            /* Bits[16:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever a completion is
                               received with a requestor ID that does not match
                               side A or side B, or when a completion is
                               received with a matching requestor ID but an
                               unexpected tag field. Header logging is
                               performed.
                            */
    UINT32 roe : 1;

                            /* Bits[17:17], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when the PCI Express interface
                               unit receive buffers overflow.
                            */
    UINT32 mtlpe : 1;

                            /* Bits[18:18], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set when it receives a malformed
                               TLP. Header logging is performed.
                            */
    UINT32 ecrce : 1;

                            /* Bits[19:19], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* ECRC checking is optional for project specific. */
    UINT32 ure : 1;

                            /* Bits[20:20], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an unsupported request
                               is detected on PCI Express port
                            */
    UINT32 acse : 1;

                            /* Bits[21:21], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an ACS violation is
                               detected by the PCI Express port.
                            */
    UINT32 uie : 1;

                            /* Bits[22:22], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an uncorrectable
                               internal error is detected.
                            */
    UINT32 mce : 1;

                            /* Bits[23:23], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever a Multicast TLP is
                               blocked.
                            */
    UINT32 aebe : 1;

                            /* Bits[24:24], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set whenever an Atomic OP TLP is
                               blocked on any egress port
                            */
    UINT32 tpbe : 1;

                            /* Bits[25:25], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* TLP Prefix Blocked Error Status */
    UINT32 ptlpeb : 1;

                            /* Bits[26:26], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Poisoned TLP Egress Blocked Status */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCSTS_IIO_CXL_STRUCT;

/* ERRUNCMSK_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000108)                                                      */
/*      SPRB0 (0x20000108)                                                      */
/*      SPRHBM (0x20000108)                                                     */
/*      SPRC0 (0x20000108)                                                      */
/*      SPRMCC (0x20000108)                                                     */
/*      SPRUCC (0x20000108)                                                     */
/* Register default value on SPRA0: 0x04400000                                  */
/* Register default value on SPRB0: 0x04400000                                  */
/* Register default value on SPRHBM: 0x04400000                                 */
/* Register default value on SPRC0: 0x04400000                                  */
/* Register default value on SPRMCC: 0x04400000                                 */
/* Register default value on SPRUCC: 0x04400000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the reporting of individual uncorrectable errors by device to the host bridge via a PCI Express error message. This register also controls the logging of the header. Refer to the PCI Express specifications for details of how the mask bits function. A masked error (respective bit set in the mask register) is not reported to the host bridge by the switch, nor is the header logged (status bits unaffected by the mask bit). There is a mask bit per bit of the Uncorrectable Error Status Register.
The attr. of AER Error Mask bits in VRSP will be changed to be compliant with PCIe Spec.
*/


#define ERRUNCMSK_IIO_CXL_REG 0x23020108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpem : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /* Data Link Protocol Error Mask */
    UINT32 sldem : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               This bit does not apply to the upstream port or
                               End point
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Received Mask */
    UINT32 fcem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Flow Control Protocol Error Mask */
    UINT32 ctem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /* Completion Timeout Mask */
    UINT32 caem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Completer Abort Mask */
    UINT32 ucem : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Unexpected Completion Mask */
    UINT32 roem : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Receiver Overflow Mask */
    UINT32 mtlpem : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Malformed TLP Mask */
    UINT32 ecrcem : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* ECRC Error Mask */
    UINT32 urem : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /* Unsupported Request Error Mask */
    UINT32 acsem : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* ACS Violation Mask */
    UINT32 uiem : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000001*/

                            /* Uncorrectable Internal Error Mask */
    UINT32 mcem : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /* MC Blocked TLP Mask */
    UINT32 aebem : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* AtomicOp Egress Blocked Mask */
    UINT32 tpbem : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /* TLP Prefix Blocked Error Mask */
    UINT32 ptlpebm : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000001*/

                            /* Poisoned TLP Egress Blocked Mask */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCMSK_IIO_CXL_STRUCT;

/* ERRUNCSEV_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x2000010c)                                                      */
/*      SPRB0 (0x2000010c)                                                      */
/*      SPRHBM (0x2000010c)                                                     */
/*      SPRC0 (0x2000010c)                                                      */
/*      SPRMCC (0x2000010c)                                                     */
/*      SPRUCC (0x2000010c)                                                     */
/* Register default value on SPRA0: 0x00462030                                  */
/* Register default value on SPRB0: 0x00462030                                  */
/* Register default value on SPRHBM: 0x00462030                                 */
/* Register default value on SPRC0: 0x00462030                                  */
/* Register default value on SPRMCC: 0x00462030                                 */
/* Register default value on SPRUCC: 0x00462030                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls whether an individual uncorrectable error is reported as a fatal error. An uncorrectable error is reported as fatal when the corresponding error bit in this register is set. When the bit is cleared, the corresponding error is considered non-fatal. 
The attr. of AER Error Severity bits in VRSP will be changed to be compliant with PCIe Spec.
*/


#define ERRUNCSEV_IIO_CXL_REG 0x2302010C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlpes : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000001*/

                            /* Data Link Protocol Error Severity */
    UINT32 sldes : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000001*/

                            /*
                               This bit does not apply to the upstream port or
                               end point
                            */
    UINT32 rsvd_6 : 6;

                            /* Bits[11:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptlpes : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Received Severity */
    UINT32 fces : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Flow Control Protocol Error Severity */
    UINT32 ctes : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /* Completion Timeout Error Severity */
    UINT32 caes : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Completer Abort Error Severity */
    UINT32 uces : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Unexpected Completion Error Severity */
    UINT32 roes : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000001*/

                            /* Receiver Overflow Error Severity */
    UINT32 mtlpes : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /* Malformed TLP Severity */
    UINT32 ecrces : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* ECRC Error Severity */
    UINT32 ures : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /* Unsupported Request Error Severity */
    UINT32 acses : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* ACS Violation Severity */
    UINT32 uies : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000001*/

                            /* Uncorrectable Internal Error Severity */
    UINT32 mces : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /* MC Blocked TLP Severity */
    UINT32 aebes : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* AtomicOp Egress Blocked Severity */
    UINT32 tpbes : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /* TLP Prefix Blocked Error Severity */
    UINT32 ptlpebs : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000000*/

                            /* Poisoned TLP Egress Blocked Severity */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRUNCSEV_IIO_CXL_STRUCT;

/* ERRCORSTS_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000110)                                                      */
/*      SPRB0 (0x20000110)                                                      */
/*      SPRHBM (0x20000110)                                                     */
/*      SPRC0 (0x20000110)                                                      */
/*      SPRMCC (0x20000110)                                                     */
/*      SPRUCC (0x20000110)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register reports the error status of individual correctable error sources on a PCI Express device. An individual error status bit set to 1 indicates that a particular error has occurred. Software can clear the error status by writing a 1 to the respective bit.
*/


#define ERRCORSTS_IIO_CXL_REG 0x23020110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 re : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when the physical layer
                               detects a receiver error.
                            */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpe : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* The switch sets this bit on CRC errors on TLP. */
    UINT32 bdllpe : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* The switch sets this bit on CRC errors on DLLP. */
    UINT32 rnre : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when the replay number
                               rolls over from 11 to 00.
                            */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rtte : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The PCIe sets this bit when replay timer time-
                               out occurs.
                            */
    UINT32 anfe : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Advisory Non-Fatal Error */
    UINT32 cie : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Correctable Internal Error */
    UINT32 hloe : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Header Log Overflow Error */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRCORSTS_IIO_CXL_STRUCT;

/* ERRCORMSK_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000114)                                                      */
/*      SPRB0 (0x20000114)                                                      */
/*      SPRHBM (0x20000114)                                                     */
/*      SPRC0 (0x20000114)                                                      */
/*      SPRMCC (0x20000114)                                                     */
/*      SPRUCC (0x20000114)                                                     */
/* Register default value on SPRA0: 0x0000E000                                  */
/* Register default value on SPRB0: 0x0000E000                                  */
/* Register default value on SPRHBM: 0x0000E000                                 */
/* Register default value on SPRC0: 0x0000E000                                  */
/* Register default value on SPRMCC: 0x0000E000                                 */
/* Register default value on SPRUCC: 0x0000E000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register controls the reporting of individual correctable errors via ERR_COR message. A masked error (respective bit set in mask register) is not reported to the host bridge by the switch. There is a mask bit corresponding to every bit in the Correctable Error Status Register.
*/


#define ERRCORMSK_IIO_CXL_REG 0x23020114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rem : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Receiver Error Mask */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpem : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /* Bad TLP Error Mask */
    UINT32 bdllpem : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Bad DLLP Error Mask */
    UINT32 rnrem : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* Replay Number Rollover Error Mask */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rttem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /* Replay Timer Timeout Error Mask */
    UINT32 anfem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Advisory Non-Fatal Error Mask */
    UINT32 ciem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /* Correctable Internal Error Mask */
    UINT32 hloem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Header Log Overflow Error Mask */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ERRCORMSK_IIO_CXL_STRUCT;

/* AERCAPCTL_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000118)                                                      */
/*      SPRB0 (0x20000118)                                                      */
/*      SPRHBM (0x20000118)                                                     */
/*      SPRC0 (0x20000118)                                                      */
/*      SPRMCC (0x20000118)                                                     */
/*      SPRUCC (0x20000118)                                                     */
/* Register default value on SPRA0: 0x00001000                                  */
/* Register default value on SPRB0: 0x00001000                                  */
/* Register default value on SPRHBM: 0x00001000                                 */
/* Register default value on SPRC0: 0x00001000                                  */
/* Register default value on SPRMCC: 0x00001000                                 */
/* Register default value on SPRUCC: 0x00001000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register gives the status and control for ECRC checks and also the pointer to the first uncorrectable error that happened.
*/


#define AERCAPCTL_IIO_CXL_REG 0x23020118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fep : 5;

                            /* Bits[4:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field identifies the bit position of the
                               first error reported in the Uncorrectable Error
                               Status Register (xref). This register re-arms
                               itself (which does not change its current value)
                               as soon as the error status bit indicated by the
                               pointer is cleared by the software by writing a
                               1 to that status bit.
                            */
    UINT32 egc : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, this bit indicates that the Function is
                               capable of generating ECRC. The value of this
                               field will be reflected by CAPSR.AERCAPCTL_EGC.
                            */
    UINT32 ege : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, ECRC generation is enabled. Functions
                               that do not implement the associated mechanism
                               are permitted to hardwire this bit to 0b.
                               Default value of this bit is 0b.
                            */
    UINT32 ecc : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, this bit indicates that the Function is
                               capable of checking ECRC. The value of this
                               field will be reflected by CAPSR.AERCAPCTL_ECC.
                            */
    UINT32 ece : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               When Set, ECRC checking is enabled. Functions
                               that do not implement the associated mechanism
                               are permitted to hardwire this bit to 0b.
                            */
    UINT32 mhrc : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /* Supports more than one error header. */
    UINT32 mhre : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit enables the function to
                               record more than one error header.
                            */
    UINT32 tlpplp : 1;

                            /* Bits[11:11], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               If Set and the First Error Pointer is valid,
                               indicates that the TLP Prefix Log register
                               contains valid information. If Clear or if First
                               Error Pointer is invalid, the TLP Prefix Log
                               register is undefined.
                            */
    UINT32 ctphlc : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000001*/

                            /*
                               If Set, this bit indicates that the Function
                               records the prefix/header of Request TLPs that
                               experience a Completion Timeout error. The value
                               of this field will be reflected by
                               CAPSR.AERCAPCTL_CTPHLC
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} AERCAPCTL_IIO_CXL_STRUCT;

/* AERHDRLOG1_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x2000011c)                                                      */
/*      SPRB0 (0x2000011c)                                                      */
/*      SPRHBM (0x2000011c)                                                     */
/*      SPRC0 (0x2000011c)                                                      */
/*      SPRMCC (0x2000011c)                                                     */
/*      SPRUCC (0x2000011c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG1_IIO_CXL_REG 0x2302011C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG1_IIO_CXL_STRUCT;

/* AERHDRLOG2_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000120)                                                      */
/*      SPRB0 (0x20000120)                                                      */
/*      SPRHBM (0x20000120)                                                     */
/*      SPRC0 (0x20000120)                                                      */
/*      SPRMCC (0x20000120)                                                     */
/*      SPRUCC (0x20000120)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG2_IIO_CXL_REG 0x23020120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG2_IIO_CXL_STRUCT;

/* AERHDRLOG3_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000124)                                                      */
/*      SPRB0 (0x20000124)                                                      */
/*      SPRHBM (0x20000124)                                                     */
/*      SPRC0 (0x20000124)                                                      */
/*      SPRMCC (0x20000124)                                                     */
/*      SPRUCC (0x20000124)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG3_IIO_CXL_REG 0x23020124

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG3_IIO_CXL_STRUCT;

/* AERHDRLOG4_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000128)                                                      */
/*      SPRB0 (0x20000128)                                                      */
/*      SPRHBM (0x20000128)                                                     */
/*      SPRC0 (0x20000128)                                                      */
/*      SPRMCC (0x20000128)                                                     */
/*      SPRUCC (0x20000128)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* This register logs the 4 Dwords of the transaction header for PCI Express errors.
*/


#define AERHDRLOG4_IIO_CXL_REG 0x23020128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlphdrlog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               As soon as an error is logged in this register,
                               it remains locked for further error-logging
                               until the software clears the status bit that
                               caused the header log (in other words, until the
                               error pointer is re-armed for logging again).
                            */

  } Bits;
  UINT32 Data;

} AERHDRLOG4_IIO_CXL_STRUCT;

/* ROOTERRCMD_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x2000012c)                                                      */
/*      SPRB0 (0x2000012c)                                                      */
/*      SPRHBM (0x2000012c)                                                     */
/*      SPRC0 (0x2000012c)                                                      */
/*      SPRMCC (0x2000012c)                                                     */
/*      SPRUCC (0x2000012c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Error Command
*/


#define ROOTERRCMD_IIO_CXL_REG 0x2302012C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cere : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Correctable error is reported
                               by any of the functions in the hierarchy
                               associated with this Root Port.
                            */
    UINT32 nfere : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Non-Fatal error is reported by
                               any of the functions in the hierarchy associated
                               with this Root Port.
                            */
    UINT32 fere : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables the generation of an
                               interrupt when a Fatal error is reported by any
                               of the functions in the hierarchy associated
                               with this Root Port.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ROOTERRCMD_IIO_CXL_STRUCT;

/* ROOTERRSTS_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000130)                                                      */
/*      SPRB0 (0x20000130)                                                      */
/*      SPRHBM (0x20000130)                                                     */
/*      SPRC0 (0x20000130)                                                      */
/*      SPRMCC (0x20000130)                                                     */
/*      SPRUCC (0x20000130)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Root Error Status
*/


#define ROOTERRSTS_IIO_CXL_REG 0x23020130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cer : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Correctable Error Received */
    UINT32 mcer : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Multiple Error Correctable Error Received */
    UINT32 efr : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Error Fatal/Non-Fatal Received */
    UINT32 mefr : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Multiple Error Fatal/Non-Fatal Received */
    UINT32 fuf : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* First Uncorrectable Fatal */
    UINT32 nfemr : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Non-Fatal Error message Received */
    UINT32 femr : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Fatal Error Message Received */
    UINT32 rsvd : 20;

                            /* Bits[26:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 aemn : 5;

                            /* Bits[31:27], Access Type=RO/V, default=0x00000000*/

                            /*
                               This register indicates which MSI/MSI-X vector
                               is used for the interrupt message generated in
                               association with any of the status bits of this
                               Capability. For MSI, the value in this register
                               indicates the offset between the base Message
                               Data and the interrupt message that is
                               generated. Hardware is required to update this
                               field so that it is correct if the number of MSI
                               Messages assigned to the Function changes when
                               software writes to the Multiple Message Enable
                               field in the MSI Message Control register. For
                               MSI-X, the value in this register indicates
                               which MSI-X Table entry is used to generate the
                               interrupt message. The entry must be one of the
                               first 32 entries even if the Function implements
                               more than 32 entries. For a given MSI-X
                               implementation, the entry must remain constant.
                               For remaining fields info, please refer to PCIe
                               Spec. for more details.
                            */

  } Bits;
  UINT32 Data;

} ROOTERRSTS_IIO_CXL_STRUCT;

/* ERRSRCID_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000134)                                                      */
/*      SPRB0 (0x20000134)                                                      */
/*      SPRHBM (0x20000134)                                                     */
/*      SPRC0 (0x20000134)                                                      */
/*      SPRMCC (0x20000134)                                                     */
/*      SPRUCC (0x20000134)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Error Source Identification
*/


#define ERRSRCID_IIO_CXL_REG 0x23020134

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecsid : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Loaded with the Requester ID indicated in the
                               received ERR_COR Message when the ERR_COR
                               Received bit is not already set.
                            */
    UINT32 efsid : 16;

                            /* Bits[31:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Loaded with the Requester ID indicated in the
                               received ERR_FATAL or ERR_NONFATAL Message when
                               the ERR_FATAL/NONFATAL Received bit is not
                               already set.
                            */

  } Bits;
  UINT32 Data;

} ERRSRCID_IIO_CXL_STRUCT;

/* TLPPLOG1_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000138)                                                      */
/*      SPRB0 (0x20000138)                                                      */
/*      SPRHBM (0x20000138)                                                     */
/*      SPRC0 (0x20000138)                                                      */
/*      SPRMCC (0x20000138)                                                     */
/*      SPRUCC (0x20000138)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG1_IIO_CXL_REG 0x23020138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG1_IIO_CXL_STRUCT;

/* TLPPLOG2_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x2000013c)                                                      */
/*      SPRB0 (0x2000013c)                                                      */
/*      SPRHBM (0x2000013c)                                                     */
/*      SPRC0 (0x2000013c)                                                      */
/*      SPRMCC (0x2000013c)                                                     */
/*      SPRUCC (0x2000013c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG2_IIO_CXL_REG 0x2302013C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG2_IIO_CXL_STRUCT;

/* TLPPLOG3_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000140)                                                      */
/*      SPRB0 (0x20000140)                                                      */
/*      SPRHBM (0x20000140)                                                     */
/*      SPRC0 (0x20000140)                                                      */
/*      SPRMCC (0x20000140)                                                     */
/*      SPRUCC (0x20000140)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG3_IIO_CXL_REG 0x23020140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG3_IIO_CXL_STRUCT;

/* TLPPLOG4_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000144)                                                      */
/*      SPRB0 (0x20000144)                                                      */
/*      SPRHBM (0x20000144)                                                     */
/*      SPRC0 (0x20000144)                                                      */
/*      SPRMCC (0x20000144)                                                     */
/*      SPRUCC (0x20000144)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* TLP Prefix Log
*/


#define TLPPLOG4_IIO_CXL_REG 0x23020144

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tlpplog : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The TLP Prefix Log register captures the End-End
                               TLP Prefix(s) for the TLP corresponding to the
                               detected error, refer to PCIe Spec. for further
                               details. The TLP Prefix Log register is only
                               meaningful when the TLP Prefix Log Present bit
                               is Set.
                            */

  } Bits;
  UINT32 Data;

} TLPPLOG4_IIO_CXL_STRUCT;

/* PTMECH_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000150)                                                      */
/*      SPRB0 (0x20000150)                                                      */
/*      SPRHBM (0x20000150)                                                     */
/*      SPRC0 (0x20000150)                                                      */
/*      SPRMCC (0x20000150)                                                     */
/*      SPRUCC (0x20000150)                                                     */
/* Register default value on SPRA0: 0x0000001F                                  */
/* Register default value on SPRB0: 0x0000001F                                  */
/* Register default value on SPRHBM: 0x0000001F                                 */
/* Register default value on SPRC0: 0x0000001F                                  */
/* Register default value on SPRMCC: 0x0000001F                                 */
/* Register default value on SPRUCC: 0x0000001F                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PTM Extended Capability Header
*/


#define PTMECH_IIO_CXL_REG 0x23020150

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000001F*/

                            /* Identifies the function as PTM capable. */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the version of the Capability
                               structure present. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/V/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . H/W may skip over the linked
                               capabilities list when DISALBE_PTM fuse is set
                               to 1 if supported, or hardware-aware S/W will
                               need to program this field appropriately for
                               linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} PTMECH_IIO_CXL_STRUCT;

/* PTMCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000154)                                                      */
/*      SPRB0 (0x20000154)                                                      */
/*      SPRHBM (0x20000154)                                                     */
/*      SPRC0 (0x20000154)                                                      */
/*      SPRMCC (0x20000154)                                                     */
/*      SPRUCC (0x20000154)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PTM Capability
*/


#define PTMCAP_IIO_CXL_REG 0x23020154

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ptmreqc : 1;

                            /* Bits[0:0], Access Type=RW/V/L, default=None*/

                            /*
                               Endpoints and Root Complex Integrated Endpoints
                               are permitted to, and Switches supporting PTM
                               must, set this bit to 1b to indicate they
                               implement the PTM Requester role. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 ptmrspc : 1;

                            /* Bits[1:1], Access Type=RW/V/L, default=None*/

                            /*
                               Root Ports and RCRB's are permitted to, and
                               Switches supporting PTM must, set this bit to 1b
                               to indicate they implement the PTM Responder
                               role. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 ptmrtc : 1;

                            /* Bits[2:2], Access Type=RW/V/L, default=None*/

                            /*
                               Root Ports, RCRB's and Switches are permitted to
                               set this bit to 1b, if they implement a PTM Time
                               Source Role and are capable of serving as the
                               PTM Root. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 eptmc : 1;

                            /* Bits[3:3], Access Type=RW/V/L, default=None*/

                            /*
                               If Set, indicates that this device supports
                               Enhanced Precision Time Management (ePTM). It is
                               strongly recommended that this bit be Set in all
                               PTM Devices. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lcg : 8;

                            /* Bits[15:8], Access Type=RW/L, default=None*/

                            /*
                               0000 0000b - Time Source does not implement a
                               local clock. It simply propagates timing
                               information obtained from further Upstream in
                               the PTM Hierarchy when responding to PTM Request
                               messages. 0000 0001b - 1111 1110b: Indicates the
                               period of this Time Source's local clock in ns.
                               1111 1111b: Indicates the period of this Time
                               Source's local clock is greater than 254 ns. If
                               the PTM Root Select bit is Set, this local clock
                               is used to provide PTM Master Time. Otherwise,
                               the Time Source uses this local clock to locally
                               track PTM Master Time received from further
                               Upstream within a PTM Hierarchy. This field is
                               reserved for Functions that do not implement the
                               PTM Time Source role. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTMCAP_IIO_CXL_STRUCT;

/* PTMCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000158)                                                      */
/*      SPRB0 (0x20000158)                                                      */
/*      SPRHBM (0x20000158)                                                     */
/*      SPRC0 (0x20000158)                                                      */
/*      SPRMCC (0x20000158)                                                     */
/*      SPRUCC (0x20000158)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* PTM Control
*/


#define PTMCTL_IIO_CXL_REG 0x23020158

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ptme : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this Function is permitted to
                               participate in the PTM mechanism according to
                               its selected role(s)
                            */
    UINT32 rts : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, if the PTM Enable bit is also Set,
                               this Time Source is the PTM Root. Within each
                               PTM Hierarchy, it is recommended that system
                               software select only the furthest Upstream Time
                               Source to be the PTM Root. Default value is 0b.
                               If the value of the PTM Root Capable bit is 0b,
                               this bit is permitted to be hardwired to 0b.
                            */
    UINT32 rsvd : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 eg : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               For Functions implementing the PTM Requester
                               Role, this field provides information relating
                               to the expected accuracy of the PTM clock, but
                               does not otherwise affect the PTM mechanism. For
                               Endpoints, system software must program this
                               field to the value representing the maximum
                               Local Clock Granularity reported by the PTM Root
                               and all intervening PTM Time Sources. For Root
                               Complex Integrated Endpoints, system software
                               must set this field to the value reported in the
                               Local Clock Granularity field by the associated
                               PTM Time Source. Permitted values: 0000 0000b:
                               Unknown PTM granularity - one or more Switches
                               between this Function and the PTM Root reported
                               a Local Clock Granularity value of 0000 0000b.
                               0000 0001b - 1111 1110b: Indicates the effective
                               PTM granularity in ns. 1111 1111b: Indicates the
                               effective PTM granularity is greater than 254
                               ns. If PTM Requester Capable is Clear, this
                               field is permitted to be hardwired to 0000
                               0000b.
                            */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTMCTL_IIO_CXL_STRUCT;

/* EINJCAPHDR_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000190)                                                      */
/*      SPRB0 (0x20000190)                                                      */
/*      SPRHBM (0x20000190)                                                     */
/*      SPRC0 (0x20000190)                                                      */
/*      SPRMCC (0x20000190)                                                     */
/*      SPRUCC (0x20000190)                                                     */
/* Register default value on SPRA0: 0x0001000B                                  */
/* Register default value on SPRB0: 0x0001000B                                  */
/* Register default value on SPRHBM: 0x0001000B                                 */
/* Register default value on SPRC0: 0x0001000B                                  */
/* Register default value on SPRMCC: 0x0001000B                                 */
/* Register default value on SPRUCC: 0x0001000B                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* EINJ Extended Capability Header
*/


#define EINJCAPHDR_IIO_CXL_REG 0x23020190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000000B*/

                            /* Vendor Defined Capability */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/V/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . H/W may skip over the linked
                               capabilities list when DISALBE_DPC fuse is set
                               to 1 if supported, or hardware-aware S/W will
                               need to program this field appropriately for
                               linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} EINJCAPHDR_IIO_CXL_STRUCT;

/* EINJHDR_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000194)                                                      */
/*      SPRB0 (0x20000194)                                                      */
/*      SPRHBM (0x20000194)                                                     */
/*      SPRC0 (0x20000194)                                                      */
/*      SPRMCC (0x20000194)                                                     */
/*      SPRUCC (0x20000194)                                                     */
/* Register default value on SPRA0: 0x00A00003                                  */
/* Register default value on SPRB0: 0x00A00003                                  */
/* Register default value on SPRHBM: 0x00A00003                                 */
/* Register default value on SPRC0: 0x00A00003                                  */
/* Register default value on SPRMCC: 0x00A00003                                 */
/* Register default value on SPRUCC: 0x00A00003                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* EINJ Header
*/


#define EINJHDR_IIO_CXL_REG 0x23020194

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vsecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000003*/

                            /*
                               This field is a vendor-defined ID number that
                               indicates the nature and format of the VSEC
                               structure. Software must qualify the Vendor ID
                               before interpreting this field. 3h is assigned
                               to WHEA Error Injection.
                            */
    UINT32 vsecrev : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               This field is a vendor-defined version number
                               that indicates the version of the VSEC
                               structure. Software must qualify the Vendor ID
                               and VSEC ID before interpreting this field.
                            */
    UINT32 vseclen : 12;

                            /* Bits[31:20], Access Type=RO, default=0x0000000A*/

                            /*
                               This field indicates the number of bytes in the
                               entire VSEC structure, including the PCI Express
                               Extended Capability header, the Vendor-Specific
                               header, and the Vendor-Specific registers.
                            */

  } Bits;
  UINT32 Data;

} EINJHDR_IIO_CXL_STRUCT;

/* EINJCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x10000198)                                                      */
/*      SPRB0 (0x10000198)                                                      */
/*      SPRHBM (0x10000198)                                                     */
/*      SPRC0 (0x10000198)                                                      */
/*      SPRMCC (0x10000198)                                                     */
/*      SPRUCC (0x10000198)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* EINJ Control
*/


#define EINJCTL_IIO_CXL_REG 0x23010198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 einjdis : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               This bit disables the usage of the PCIe Error
                               Injection bits for EINJCTL.INJRCVERR, INJCTOERR
                               Note: Lock Key bit is located in the EINJCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 injrcverr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is written from 0 to 1, one and
                               only one error assertion pulse is produced on
                               the error source signal for the given port. This
                               error will appear equivalent to an actual error
                               assertion because this event is OR'd into the
                               existing error reporting structure. To log
                               another error, this bit must be cleared first,
                               before setting again. Leaving this bit in a 1
                               state does not produce a persistent error
                               condition.
                            */
    UINT16 injctoerr : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is written from 0 to 1, one and
                               only one error assertion pulse is produced on
                               the error source signal for the given port. This
                               error will appear equivalent to an actual error
                               assertion because this event is OR'd into the
                               existing error reporting structure. To log
                               another error, this bit must be cleared first,
                               before setting again. Leaving this bit in a 1
                               state does not produce a persistent error
                               condition.
                            */
    UINT16 rsvd : 13;

                            /* Bits[15:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} EINJCTL_IIO_CXL_STRUCT;

/* EDPCPR_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x2000019c)                                                      */
/*      SPRB0 (0x2000019c)                                                      */
/*      SPRHBM (0x2000019c)                                                     */
/*      SPRC0 (0x2000019c)                                                      */
/*      SPRMCC (0x2000019c)                                                     */
/*      SPRUCC (0x2000019c)                                                     */
/* Register default value on SPRA0: 0x00000E00                                  */
/* Register default value on SPRB0: 0x00000E00                                  */
/* Register default value on SPRHBM: 0x00000E00                                 */
/* Register default value on SPRC0: 0x00000E00                                  */
/* Register default value on SPRMCC: 0x00000E00                                 */
/* Register default value on SPRUCC: 0x00000E00                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* eDPC Policy
*/


#define EDPCPR_IIO_CXL_REG 0x2302019C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 serr_cor : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with correctable severity.
                            */
    UINT32 serr_fnat : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with non-fatal severity.
                            */
    UINT32 serr_fat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit indicates that a RP PIO error triggered
                               a system error with fatal severity.
                            */
    UINT32 rsvd : 6;

                            /* Bits[8:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cplsts : 3;

                            /* Bits[11:9], Access Type=RW/P/L, default=0x00000007*/

                            /*
                               This is the completion status field used to
                               signal a synchronous processor exception. If
                               this field is non-zero, this field is used
                               instead of the UR/CA determined by the logic. If
                               this field is zero, the completion status is
                               based on the DPCCTL.DPCCC field. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register . This field is only applicable
                               to RPs and should be treated as reserved for
                               other devices.
                            */
    UINT32 txure : 1;

                            /* Bits[12:12], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit enables RP PIO error handling for all
                               cases where downstream non-posted requests are
                               completed by the root port with a UR/CA
                               completion. This includes non-posted requests
                               outstanding when the link goes down, non-posted
                               requests targeting a link that is down, non-
                               posted requests received from the device core
                               after DPC has been triggered, and AER cases such
                               as AEB, PTLPEB, etc. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} EDPCPR_IIO_CXL_STRUCT;

/* DPCECH_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x200001a0)                                                      */
/*      SPRB0 (0x200001a0)                                                      */
/*      SPRHBM (0x200001a0)                                                     */
/*      SPRC0 (0x200001a0)                                                      */
/*      SPRMCC (0x200001a0)                                                     */
/*      SPRUCC (0x200001a0)                                                     */
/* Register default value on SPRA0: 0x0001001D                                  */
/* Register default value on SPRB0: 0x0001001D                                  */
/* Register default value on SPRHBM: 0x0001001D                                 */
/* Register default value on SPRC0: 0x0001001D                                  */
/* Register default value on SPRMCC: 0x0001001D                                 */
/* Register default value on SPRUCC: 0x0001001D                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* DPC Extended Capability Header
*/


#define DPCECH_IIO_CXL_REG 0x230201A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000001D*/

                            /* Identifies the function as DPC capable. */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/V/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . H/W may skip over the linked
                               capabilities list when DISALBE_DPC fuse is set
                               to 1 if supported, or hardware-aware S/W will
                               need to program this field appropriately for
                               linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} DPCECH_IIO_CXL_STRUCT;

/* DPCCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x100001a4)                                                      */
/*      SPRB0 (0x100001a4)                                                      */
/*      SPRHBM (0x100001a4)                                                     */
/*      SPRC0 (0x100001a4)                                                      */
/*      SPRMCC (0x100001a4)                                                     */
/*      SPRUCC (0x100001a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* DPC Capability
*/


#define DPCCAP_IIO_CXL_REG 0x230101A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcimn : 5;

                            /* Bits[4:0], Access Type=RW/L, default=None*/

                            /*
                               This field indicates which MSI/MSI-X vector is
                               used for the interrupt message generated in
                               association with the DPC Capability structure.
                               For MSI, the value in this field indicates the
                               offset between the base Message Data and the
                               interrupt message that is generated. Hardware is
                               required to update this field so that it is
                               correct if the number of MSI Messages assigned
                               to the Function changes when software writes to
                               the Multiple Message Enable field in the MSI
                               Message Control register. For MSI-X, the value
                               in this field indicates which MSI-X Table entry
                               is used to generate the interrupt message. The
                               entry must be one of the first 32 entries even
                               if the Function implements more than 32 entries.
                               For a given MSI-X implementation, the entry must
                               remain constant. If both MSI and MSI-X are
                               implemented, they are permitted to use different
                               vectors, though software is permitted to enable
                               only one mechanism at a time. If MSI-X is
                               enabled, the value in this field must indicate
                               the vector for MSI-X. If MSI is enabled or
                               neither is enabled, the value in this field must
                               indicate the vector for MSI. If software enables
                               both MSI and MSI-X at the same time, the value
                               in this field is undefined.
                            */
    UINT16 rpedpc : 1;

                            /* Bits[5:5], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that a Root Port
                               supports a defined set of DPC Extensions that
                               are specific to Root Ports. Switch Downstream
                               Ports must not Set this bit.
                            */
    UINT16 ptlpebs : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that the Root Port or
                               Switch Downstream Port supports the ability to
                               block the transmission of a poisoned TLP from
                               its Egress Port. Root Ports that support RP
                               Extensions for DPC must Set this bit
                            */
    UINT16 dpcsts : 1;

                            /* Bits[7:7], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that a Root Port or
                               Switch Downstream Port supports the ability for
                               software to trigger DPC. Root Ports that support
                               RP Extensions for DPC must Set this bit.
                            */
    UINT16 rppiols : 4;

                            /* Bits[11:8], Access Type=RW/L, default=None*/

                            /*
                               This field indicates how many DWORDs are
                               allocated for the RP PIO log registers,
                               comprised by the RP PIO Header Log, the RP PIO
                               ImpSpec Log, and RP PIO TLP Prefix Log. If the
                               Root Port supports RP Extensions for DPC, the
                               value of this field must be 4 or greater,
                               otherwise, the value of this field must be 0.
                            */
    UINT16 dlaecss : 1;

                            /* Bits[12:12], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that the Root Port or
                               Switch Downstream Port supports the ability to
                               signal with ERR_COR when the Link transitions to
                               the DL_Active state. Root Ports that support RP
                               Extensions for DPC must Set this bit.
                            */
    UINT16 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCCAP_IIO_CXL_STRUCT;

/* DPCCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x100001a6)                                                      */
/*      SPRB0 (0x100001a6)                                                      */
/*      SPRHBM (0x100001a6)                                                     */
/*      SPRC0 (0x100001a6)                                                      */
/*      SPRMCC (0x100001a6)                                                     */
/*      SPRUCC (0x100001a6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DPC Control
*/


#define DPCCTL_IIO_CXL_REG 0x230101A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcte : 2;

                            /* Bits[1:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field enables DPC and controls the
                               conditions that cause DPC to be triggered.
                               Defined encodings are: 00b DPC is disabled 01b
                               DPC is enabled and is triggered when the
                               Downstream Port detects an unmasked
                               uncorrectable error or when the Downstream Port
                               receives an ERR_FATAL Message. 10b DPC is
                               enabled and is triggered when the Downstream
                               Port detects an unmasked uncorrectable error or
                               when the Downstream Port receives an
                               ERR_NONFATAL or ERR_FATAL Message. 11b Reserved
                               H/W will change this field to 'RO' of zero when
                               DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dpccc : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit controls the Completion Status for
                               Completions formed during DPC. 0b Completer
                               Abort (CA) Completion Status 1b Unsupported
                               Request (UR) Completion Status H/W will change
                               this field to 'RO' of zero when DISALBE_DPC fuse
                               is set to 1 if supported.
                            */
    UINT16 dpcie : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of an
                               interrupt to indicate that DPC has been
                               triggered H/W will change this field to 'RO' of
                               zero when DISALBE_DPC fuse is set to 1 if
                               supported.
                            */
    UINT16 dpcece : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit enables the sending of an
                               ERR_COR Message to indicate that DPC has been
                               triggered. H/W will change this field to 'RO' of
                               zero when DISALBE_DPC fuse is set to 1 if
                               supported.
                            */
    UINT16 ptlpebe : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the Poisoned TLP Egress
                               Blocking Supported bit is Set, otherwise, it is
                               permitted to be hardwired to 0b. Software must
                               not Set this bit unless the Poisoned TLP Egress
                               Blocking Supported bit is Set. When Set, this
                               bit enables the associated Egress Port to block
                               the transmission of poisoned TLPs. H/W will
                               change this field to 'RO' of zero when
                               DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dpcst : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the DPC Software
                               Triggering Supported bit is Set, otherwise, it
                               is permitted to be hardwired to 0b. If DPC is
                               enabled and the DPC Trigger Status bit is Clear,
                               when software writes 1b to this bit, DPC is
                               triggered. Otherwise, software writing a 1b to
                               this bit has no effect. It is permitted to write
                               1b to this bit while simultaneously writing
                               updated values to other fields in this register,
                               notably the DPC Trigger Enable field. For this
                               case, the DPC Software Trigger semantics are
                               based on the updated value of the DPC Trigger
                               Enable field. This bit always returns 0b when
                               read. H/W will change this field to 'RO' of zero
                               when DISALBE_DPC fuse is set to 1 if supported.
                            */
    UINT16 dlaece : 1;

                            /* Bits[7:7], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit must be RW if the DL_Active ERR_COR
                               Signaling Supported bit is Set, otherwise, it is
                               permitted to be hardwired to 0b. Software must
                               not Set this bit unless the DL_Active ERR_COR
                               Signaling Supported bit is Set. When Set, this
                               bit enables the associated Downstream Port to
                               signal with ERR_COR when the Link transitions to
                               the DL_Active state. H/W will change this field
                               to 'RO' of zero when DISALBE_DPC fuse is set to
                               1 if supported.
                            */
    UINT16 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCCTL_IIO_CXL_STRUCT;

/* DPCSTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x100001a8)                                                      */
/*      SPRB0 (0x100001a8)                                                      */
/*      SPRHBM (0x100001a8)                                                     */
/*      SPRC0 (0x100001a8)                                                      */
/*      SPRMCC (0x100001a8)                                                     */
/*      SPRUCC (0x100001a8)                                                     */
/* Register default value on SPRA0: 0x00001F00                                  */
/* Register default value on SPRB0: 0x00001F00                                  */
/* Register default value on SPRHBM: 0x00001F00                                 */
/* Register default value on SPRC0: 0x00001F00                                  */
/* Register default value on SPRMCC: 0x00001F00                                 */
/* Register default value on SPRUCC: 0x00001F00                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DPC Status
*/


#define DPCSTS_IIO_CXL_REG 0x230101A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcts : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that DPC has been
                               triggered. DPC is event triggered. While this
                               bit is Set, hardware must direct the LTSSM to
                               the Disabled State. This bit must be cleared
                               before the LTSSM can be released from the
                               Disabled State. See Section 6.2.10 of eDPC ECN
                               for requirements on how long software must leave
                               the Downstream Port in DPC. Once these
                               requirements are met, software is permitted to
                               clear this bit regardless of the state of other
                               status bits associated with the triggering
                               event. After clearing this bit, software must
                               honor timing requirements defined in Section
                               6.6.1 of eDPC ECN with respect to the first
                               Configuration Read following a Conventional
                               Reset.
                            */
    UINT16 dpctr : 2;

                            /* Bits[2:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field indicates why DPC has been triggered.
                               Defined encodings are: 00b DPC was triggered due
                               to an unmasked uncorrectable error. 01b DPC was
                               triggered due to receiving an ERR_NONFATAL. 10b
                               DPC was triggered due to receiving an ERR_FATAL.
                               11b Reserved DPC was triggered due to a reason
                               that is indicated by the DPC Trigger Reason
                               Extension field. This field is valid only when
                               the DPC Trigger Status bit is Set, otherwise the
                               value of this field is undefined
                            */
    UINT16 dpcis : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set if DPC is triggered while the
                               DPC Interrupt Enable bit is Set. This may cause
                               the generation of an interrupt.
                            */
    UINT16 dpcrpb : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               When the DPC Trigger Status bit is Set and this
                               bit is Set, the Root Port is busy with internal
                               activity that must complete before software is
                               permitted to Clear the DPC Trigger Status bit.
                               If software Clears the DPC Trigger Status bit
                               while this bit is Set, the behavior is
                               undefined. This field is valid only when the DPC
                               Trigger Status bit is Set, otherwise the value
                               of this field is undefined. This bit is
                               applicable only for Root Ports that support RP
                               Extensions for DPC, and is Reserved for Switch
                               Downstream Ports. Default value of this bit is
                               undefined.
                            */
    UINT16 dpctre : 2;

                            /* Bits[6:5], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This field serves as an extension to the DPC
                               Trigger Reason field. When that field is valid
                               and has a value of 11b, this field indicates why
                               DPC has been triggered. Defined encodings are:
                               00b DPC was triggered due to an RP PIO error.
                               01b DPC was triggered due to the DPC Software
                               Trigger bit. 10b Reserved 11b Reserved This
                               field is valid only when the DPC Trigger Status
                               bit is Set and the value of the DPC Trigger
                               Reason field is 11b, otherwise the value of this
                               field is undefined.
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 rppiofep : 5;

                            /* Bits[12:8], Access Type=RO/V/P, default=0x0000001F*/

                            /*
                               The value of this field identifies a bit
                               position in the RP PIO Status register, and this
                               field is considered valid when that bit is Set.
                               When this field is valid, and software writes a
                               1b to the indicated RP PIO Status bit (thus
                               clearing it), this field must revert to its
                               default value. This field is applicable only for
                               Root Ports that support RP Extensions for DPC,
                               and otherwise is Reserved. If this field is not
                               Reserved, its default value is 11111b,
                               indicating a permanently Reserved RP PIO Status
                               bit, thus guaranteeing that this field is not
                               considered valid.
                            */
    UINT16 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} DPCSTS_IIO_CXL_STRUCT;

/* DPCESID_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x100001aa)                                                      */
/*      SPRB0 (0x100001aa)                                                      */
/*      SPRHBM (0x100001aa)                                                     */
/*      SPRC0 (0x100001aa)                                                      */
/*      SPRMCC (0x100001aa)                                                     */
/*      SPRUCC (0x100001aa)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* DPC Error Source ID
*/


#define DPCESID_IIO_CXL_REG 0x230101AA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 dpcesid : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When the DPC Trigger Reason field indicates that
                               DPC was triggered due to the reception of an
                               ERR_NONFATAL or ERR_FATAL, this register
                               contains the Requester ID of the received
                               Message. Otherwise, the value of this register
                               is undefined.
                            */

  } Bits;
  UINT16 Data;

} DPCESID_IIO_CXL_STRUCT;

/* RPPIOSTS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200001ac)                                                      */
/*      SPRB0 (0x200001ac)                                                      */
/*      SPRHBM (0x200001ac)                                                     */
/*      SPRC0 (0x200001ac)                                                      */
/*      SPRMCC (0x200001ac)                                                     */
/*      SPRUCC (0x200001ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Status
*/


#define RPPIOSTS_IIO_CXL_REG 0x230201AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSTS_IIO_CXL_STRUCT;

/* RPPIOMSK_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200001b0)                                                      */
/*      SPRB0 (0x200001b0)                                                      */
/*      SPRHBM (0x200001b0)                                                     */
/*      SPRC0 (0x200001b0)                                                      */
/*      SPRMCC (0x200001b0)                                                     */
/*      SPRUCC (0x200001b0)                                                     */
/* Register default value on SPRA0: 0x00070707                                  */
/* Register default value on SPRB0: 0x00070707                                  */
/* Register default value on SPRHBM: 0x00070707                                 */
/* Register default value on SPRC0: 0x00070707                                  */
/* Register default value on SPRMCC: 0x00070707                                 */
/* Register default value on SPRUCC: 0x00070707                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Mask
*/


#define RPPIOMSK_IIO_CXL_REG 0x230201B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Configuration Request received UR Completion
                               Mask
                            */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000001*/

                            /*
                               Configuration Request received CA Completion
                               Mask
                            */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000001*/

                            /* Configuration Request Completion Timeout Mask */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request received UR Completion Mask */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request received CA Completion Mask */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000001*/

                            /* I/O Request Completion Timeout Mask */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request received UR Completion Mask */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request received CA Completion Mask */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /* Memory Request Completion Timeout Mask */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOMSK_IIO_CXL_STRUCT;

/* RPPIOSEV_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200001b4)                                                      */
/*      SPRB0 (0x200001b4)                                                      */
/*      SPRHBM (0x200001b4)                                                     */
/*      SPRC0 (0x200001b4)                                                      */
/*      SPRMCC (0x200001b4)                                                     */
/*      SPRUCC (0x200001b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Severity
*/


#define RPPIOSEV_IIO_CXL_REG 0x230201B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request received UR Completion
                               Severity
                            */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request received CA Completion
                               Severity
                            */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Configuration Request Completion Timeout
                               Severity
                            */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion Severity */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion Severity */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout Severity */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion Severity */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion Severity */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout Severity */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSEV_IIO_CXL_STRUCT;

/* RPPIOSE_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x200001b8)                                                      */
/*      SPRB0 (0x200001b8)                                                      */
/*      SPRHBM (0x200001b8)                                                     */
/*      SPRC0 (0x200001b8)                                                      */
/*      SPRMCC (0x200001b8)                                                     */
/*      SPRUCC (0x200001b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO SysError
*/


#define RPPIOSE_IIO_CXL_REG 0x230201B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOSE_IIO_CXL_STRUCT;

/* RPPIOEXC_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200001bc)                                                      */
/*      SPRB0 (0x200001bc)                                                      */
/*      SPRHBM (0x200001bc)                                                     */
/*      SPRC0 (0x200001bc)                                                      */
/*      SPRMCC (0x200001bc)                                                     */
/*      SPRUCC (0x200001bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* RP PIO Exception
*/


#define RPPIOEXC_IIO_CXL_REG 0x230201BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cfgurc : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received UR Completion */
    UINT32 cfgcac : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request received CA Completion */
    UINT32 cfgcto : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Configuration Request Completion Timeout */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 iourc : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received UR Completion */
    UINT32 iocac : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request received CA Completion */
    UINT32 iocto : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* I/O Request Completion Timeout */
    UINT32 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 memurc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received UR Completion */
    UINT32 memcac : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request received CA Completion */
    UINT32 memcto : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Memory Request Completion Timeout */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPPIOEXC_IIO_CXL_STRUCT;

/* RPPIOHDRLOG1_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x200001c0)                                                      */
/*      SPRB0 (0x200001c0)                                                      */
/*      SPRHBM (0x200001c0)                                                     */
/*      SPRC0 (0x200001c0)                                                      */
/*      SPRMCC (0x200001c0)                                                     */
/*      SPRUCC (0x200001c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG1_IIO_CXL_REG 0x230201C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG1_IIO_CXL_STRUCT;

/* RPPIOHDRLOG2_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x200001c4)                                                      */
/*      SPRB0 (0x200001c4)                                                      */
/*      SPRHBM (0x200001c4)                                                     */
/*      SPRC0 (0x200001c4)                                                      */
/*      SPRMCC (0x200001c4)                                                     */
/*      SPRUCC (0x200001c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG2_IIO_CXL_REG 0x230201C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG2_IIO_CXL_STRUCT;

/* RPPIOHDRLOG3_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x200001c8)                                                      */
/*      SPRB0 (0x200001c8)                                                      */
/*      SPRHBM (0x200001c8)                                                     */
/*      SPRC0 (0x200001c8)                                                      */
/*      SPRMCC (0x200001c8)                                                     */
/*      SPRUCC (0x200001c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG3_IIO_CXL_REG 0x230201C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG3_IIO_CXL_STRUCT;

/* RPPIOHDRLOG4_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x200001cc)                                                      */
/*      SPRB0 (0x200001cc)                                                      */
/*      SPRHBM (0x200001cc)                                                     */
/*      SPRC0 (0x200001cc)                                                      */
/*      SPRMCC (0x200001cc)                                                     */
/*      SPRUCC (0x200001cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* RP PIO Header Log
*/


#define RPPIOHDRLOG4_IIO_CXL_REG 0x230201CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hb : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Header of TLP associated with error. The format
                               should be the same as Header Log Register in
                               AER.
                            */

  } Bits;
  UINT32 Data;

} RPPIOHDRLOG4_IIO_CXL_STRUCT;

/* ACSCAPHDR_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000220)                                                      */
/*      SPRB0 (0x20000220)                                                      */
/*      SPRHBM (0x20000220)                                                     */
/*      SPRC0 (0x20000220)                                                      */
/*      SPRMCC (0x20000220)                                                     */
/*      SPRUCC (0x20000220)                                                     */
/* Register default value on SPRA0: 0x0001000D                                  */
/* Register default value on SPRB0: 0x0001000D                                  */
/* Register default value on SPRHBM: 0x0001000D                                 */
/* Register default value on SPRC0: 0x0001000D                                  */
/* Register default value on SPRMCC: 0x0001000D                                 */
/* Register default value on SPRUCC: 0x0001000D                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Access Control Services Extended Capability Header
*/


#define ACSCAPHDR_IIO_CXL_REG 0x23020220

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000000D*/

                            /*
                               Identifies the function as Access Control
                               Services capable.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} ACSCAPHDR_IIO_CXL_STRUCT;

/* ACSCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000224)                                                      */
/*      SPRB0 (0x10000224)                                                      */
/*      SPRHBM (0x10000224)                                                     */
/*      SPRC0 (0x10000224)                                                      */
/*      SPRMCC (0x10000224)                                                     */
/*      SPRUCC (0x10000224)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* This register identifies the Access Control Services (ACS) capabilities.
*/


#define ACSCAP_IIO_CXL_REG 0x23010224

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vacssv : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Source Validation. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT16 bacstb : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Translation Blocking. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 racsp2prr : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS P2P
                               Request Redirect. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT16 cacsp2prr : 1;

                            /* Bits[3:3], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS P2P
                               Completion Redirect. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This includes Read Completions,
                               AtomicOp Completions, and other Completions,
                               either with or without data.
                            */
    UINT16 uacsuf : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component implements ACS
                               Upstream Forwarding. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT16 eacsp2pec : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Hardwired to 0. Indicates that the component
                               does not implement ACS P2P Egress Control.
                            */
    UINT16 tacsdtp2p : 1;

                            /* Bits[6:6], Access Type=RW/L, default=None*/

                            /*
                               Indicates that the component does implement ACS
                               Direct Translated P2P. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Required for Root Ports that support
                               Address Translation Services (ATS) and also
                               support peer-to-peer traffic with other Root
                               Ports, required for Switch Downstream Ports,
                            */
    UINT16 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 ecvs : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the number of bits in the Egress
                               Control Vector. This is set to 00h as ACS P2P
                               Egress Control (ACSP2PEC) bit 5 in this register
                               is 0b.
                            */

  } Bits;
  UINT16 Data;

} ACSCAP_IIO_CXL_STRUCT;

/* ACSCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000226)                                                      */
/*      SPRB0 (0x10000226)                                                      */
/*      SPRHBM (0x10000226)                                                     */
/*      SPRC0 (0x10000226)                                                      */
/*      SPRMCC (0x10000226)                                                     */
/*      SPRUCC (0x10000226)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register identifies the Access Control Services (ACS) control bits.
*/


#define ACSCTL_IIO_CXL_REG 0x23010226

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vacssve : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component validates the Bus Number
                               from the Requester ID of upstream Requests
                               against the secondary / subordinate Bus Numbers.
                            */
    UINT16 bacstbe : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component blocks all upstream
                               Memory Requests whose Address Translation (AT)
                               field is not set to the default value.
                            */
    UINT16 racsp2prre : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit determines when the component redirects
                               peer-to-peer Requests upstream.
                            */
    UINT16 cacsp2pcre : 1;

                            /* Bits[3:3], Access Type=RW/V, default=0x00000000*/

                            /*
                               Determines when the component redirects peer-to-
                               peer Completions upstream, applicable only to
                               Read Completions whose Relaxed Ordering
                               Attribute is clear.
                            */
    UINT16 uacsufe : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               When set, the component forwards upstream any
                               Request or Completion TLPs it receives that were
                               redirected upstream by a component lower in the
                               hierarchy. Note that the U bit only applies to
                               upstream TLPs arriving at a Downstream Port, and
                               whose normal routing targets the same Downstream
                               Port.
                            */
    UINT16 eacsp2pece : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               This is hardwired to 0b as the component does
                               not implement ACS P2P Egress Control.
                            */
    UINT16 tacsp2pece : 1;

                            /* Bits[6:6], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, overrides the ACS P2P Request Redirect
                               and ACS P2P Egress Control mechanisms with peer-
                               to-peer Memory Requests whose Address
                               Translation (AT) field indicates a Translated
                               address This bit is ignored if ACS Translation
                               Blocking (B) is enabled.
                            */
    UINT16 rsvd : 9;

                            /* Bits[15:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} ACSCTL_IIO_CXL_STRUCT;

/* VCECH_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000280)                                                      */
/*      SPRB0 (0x20000280)                                                      */
/*      SPRHBM (0x20000280)                                                     */
/*      SPRC0 (0x20000280)                                                      */
/*      SPRMCC (0x20000280)                                                     */
/*      SPRUCC (0x20000280)                                                     */
/* Register default value on SPRA0: 0x00010002                                  */
/* Register default value on SPRB0: 0x00010002                                  */
/* Register default value on SPRHBM: 0x00010002                                 */
/* Register default value on SPRC0: 0x00010002                                  */
/* Register default value on SPRMCC: 0x00010002                                 */
/* Register default value on SPRUCC: 0x00010002                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Virtual Channel Extended Capability Header
*/


#define VCECH_IIO_CXL_REG 0x23020280

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000002*/

                            /*
                               Extended Capability ID for the Virtual Channel
                               Capability is either 0002h or 0009h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               Indicates the version of the Capability
                               structure present.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} VCECH_IIO_CXL_STRUCT;

/* PVCCR1_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000284)                                                      */
/*      SPRB0 (0x20000284)                                                      */
/*      SPRHBM (0x20000284)                                                     */
/*      SPRC0 (0x20000284)                                                      */
/*      SPRMCC (0x20000284)                                                     */
/*      SPRUCC (0x20000284)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Port VC Capability Register 1
*/


#define PVCCR1_IIO_CXL_REG 0x23020284

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 evcc : 3;

                            /* Bits[2:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates the number of (extended) Virtual
                               Channels in addition to the default VC supported
                               by the device. This field is valid for all
                               Functions. The minimum value of this field is
                               000b (for devices that only support the default
                               VC). The maximum value is 7. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PVCCR1_IIO_CXL_STRUCT;

/* PVCCR2_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000288)                                                      */
/*      SPRB0 (0x20000288)                                                      */
/*      SPRHBM (0x20000288)                                                     */
/*      SPRC0 (0x20000288)                                                      */
/*      SPRMCC (0x20000288)                                                     */
/*      SPRUCC (0x20000288)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Port VC Capability Register 2
*/


#define PVCCR2_IIO_CXL_REG 0x23020288

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vcac : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the types of VC Arbitration supported
                               by the Function for the LPVC group. This field
                               is valid for all Functions that report a Low
                               Priority Extended VC Count field greater than 0.
                               For all other Functions, this field must be
                               hardwired to 00h. Each bit location within this
                               field corresponds to a VC Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the Port can be
                               configured to provide different VC arbitration
                               services. Defined bit positions are: Bit 0
                               Hardware fixed arbitration scheme, e.g., Round
                               Robin Bit 1 Weighted Round Robin (WRR)
                               arbitration with 32 phases Bit 2 WRR arbitration
                               with 64 phases Bit 3 WRR arbitration with 128
                               phases Bits 4-7 Reserved
                            */
    UINT32 rsvd : 16;

                            /* Bits[23:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcato : 8;

                            /* Bits[31:24], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates the location of the VC Arbitration
                               Table. This field is valid for all Functions.
                               This field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 0 indicates that the table
                               is not present.
                            */

  } Bits;
  UINT32 Data;

} PVCCR2_IIO_CXL_STRUCT;

/* PVCCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1000028c)                                                      */
/*      SPRB0 (0x1000028c)                                                      */
/*      SPRHBM (0x1000028c)                                                     */
/*      SPRC0 (0x1000028c)                                                      */
/*      SPRMCC (0x1000028c)                                                     */
/*      SPRUCC (0x1000028c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Port VC Control
*/


#define PVCCTL_IIO_CXL_REG 0x2301028C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 lvcat : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Used by software to update the VC Arbitration
                               Table. This bit is valid for all Functions when
                               the selected VC Arbitration uses the VC
                               Arbitration Table. Software sets this bit to
                               request hardware to apply new values programmed
                               into VC Arbitration Table, clearing this bit has
                               no effect. Software checks the VC Arbitration
                               Table Status bit to confirm that new values
                               stored in the VC Arbitration Table are latched
                               by the VC arbitration logic. This bit always
                               returns 0b when read.
                            */
    UINT16 vcas : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /*
                               Used by software to configure the VC arbitration
                               by selecting one of the supported VC Arbitration
                               schemes indicated by the VC Arbitration
                               Capability field in the Port VC Capability
                               register 2. This field is valid for all
                               Functions. The permissible values of this field
                               are numbers corresponding to one of the asserted
                               bits in the VC Arbitration Capability field.
                               This field cannot be modified when more than one
                               VC in the LPVC group is enabled.
                            */
    UINT16 rsvd : 12;

                            /* Bits[15:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PVCCTL_IIO_CXL_STRUCT;

/* PVCSTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x1000028e)                                                      */
/*      SPRB0 (0x1000028e)                                                      */
/*      SPRHBM (0x1000028e)                                                     */
/*      SPRC0 (0x1000028e)                                                      */
/*      SPRMCC (0x1000028e)                                                     */
/*      SPRUCC (0x1000028e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Port VC Status
*/


#define PVCSTS_IIO_CXL_REG 0x2301028E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 vcats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indicates the coherency status of the VC
                               Arbitration Table. This bit is valid for all
                               Functions when the selected VC uses the VC
                               Arbitration Table. This bit is Set by hardware
                               when any entry of the VC Arbitration Table is
                               written by software. This bit is Cleared by
                               hardware when hardware finishes loading values
                               stored in the VC Arbitration Table after
                               software sets the Load VC Arbitration Table bit
                               in the Port VC Control register. Default value
                               of this bit is 0b.
                            */
    UINT16 rsvd : 15;

                            /* Bits[15:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PVCSTS_IIO_CXL_STRUCT;

/* VC0RC_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000290)                                                      */
/*      SPRB0 (0x20000290)                                                      */
/*      SPRHBM (0x20000290)                                                     */
/*      SPRC0 (0x20000290)                                                      */
/*      SPRMCC (0x20000290)                                                     */
/*      SPRUCC (0x20000290)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* VC0 Resource Capability
*/


#define VC0RC_IIO_CXL_REG 0x23020290

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pac : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates types of Port Arbitration supported by
                               the VC resource. This field is valid for all
                               Switch Ports, Root Ports that support peer-to-
                               peer traffic, and RCRBs, but not for Endpoints
                               or Root Ports that do not support peer-to-peer
                               traffic. Each bit location within this field
                               corresponds to a Port Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the VC resource
                               can be configured to provide different
                               arbitration services. Software selects among
                               these capabilities by writing to the Port
                               Arbitration Select field (see Section 7.11.7).
                               Defined bit positions are: Bit 0 Non-
                               configurable hardware-fixed arbitration scheme,
                               e.g., Round Robin (RR) Bit 1 Weighted Round
                               Robin (WRR) arbitration with 32 phases Bit 2 WRR
                               arbitration with 64 phases Bit 3 WRR arbitration
                               with 128 phases Bit 4 Time-based WRR with 128
                               phases Bit 5 WRR arbitration with 256 phases
                               Bits 6-7 Reserved Note: Lock Key bit is located
                               in the Personality Lock Key Control Register
                            */
    UINT32 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rst : 1;

                            /* Bits[15:15], Access Type=RW/L, default=None*/

                            /*
                               When Clear, transactions with or without the No
                               Snoop bit Set within the TLP header are allowed
                               on this VC. When Set, any transaction for which
                               the No Snoop attribute is applicable but is not
                               Set within the TLP header is permitted to be
                               rejected as an Unsupported Request. This bit is
                               valid for Root Ports and RCRB, it is not valid
                               for Endpoints or Switch Ports. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 mts : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the maximum number of time slots
                               (minus one) that the VC resource is capable of
                               supporting when it is configured for time-based
                               WRR Port Arbitration. For example, a value 000
                               0000b in this field indicates the supported
                               maximum number of time slots is 1 and a value of
                               111 1111b indicates the supported maximum number
                               of time slots is 128. This field is valid for
                               all Switch Ports, Root Ports that support peer-
                               to-peer traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this field is
                               valid only when the Port Arbitration Capability
                               field indicates that the VC resource supports
                               time-based WRR Port Arbitration. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pato : 8;

                            /* Bits[31:24], Access Type=RW/L, default=None*/

                            /*
                               Indicates the location of the Port Arbitration
                               Table associated with the VC resource. This
                               field is valid for all Switch Ports, Root Ports
                               that support peer-to-peer traffic, and RCRBs,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. This
                               field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 00h indicates that the
                               table is not present. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} VC0RC_IIO_CXL_STRUCT;

/* VC0RCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000294)                                                      */
/*      SPRB0 (0x20000294)                                                      */
/*      SPRHBM (0x20000294)                                                     */
/*      SPRC0 (0x20000294)                                                      */
/*      SPRMCC (0x20000294)                                                     */
/*      SPRUCC (0x20000294)                                                     */
/* Register default value on SPRA0: 0x800000FF                                  */
/* Register default value on SPRB0: 0x800000FF                                  */
/* Register default value on SPRHBM: 0x800000FF                                 */
/* Register default value on SPRC0: 0x800000FF                                  */
/* Register default value on SPRMCC: 0x800000FF                                 */
/* Register default value on SPRUCC: 0x800000FF                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC0 Resource Control
*/


#define VC0RCTL_IIO_CXL_REG 0x23020294

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tc0vcm : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000001*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. Bit 0 of this field is
                               read-only. It must be Set for the default VC0
                               and Clear for all other enabled VCs.
                            */
    UINT32 tcvcm : 7;

                            /* Bits[7:1], Access Type=RW, default=0x0000007F*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. For example, when bit 7
                               is Set in this field, TC7 is mapped to this VC
                               resource. When more than 1 bit in this field is
                               Set, it indicates that multiple TCs are mapped
                               to the VC resource. In order to remove one or
                               more TCs from the TC/VC Map of an enabled VC,
                               software must ensure that no new or outstanding
                               transactions with the TC labels are targeted at
                               the given Link. Default value of this field is
                               3Fh for the first VC resource with MVC and is
                               00h for other VC resources.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lpat : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit updates the Port Arbitration
                               logic from the Port Arbitration Table for the VC
                               resource. This bit is valid for all Switch
                               Ports, Root Ports that support peer-to-peer
                               traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this bit is
                               only valid when the Port Arbitration Table is
                               used by the selected Port Arbitration scheme
                               (that is indicated by a Set bit in the Port
                               Arbitration Capability field selected by Port
                               Arbitration Select). Software sets this bit to
                               signal hardware to update Port Arbitration logic
                               with new values stored in Port Arbitration
                               Table, clearing this bit has no effect. Software
                               uses the Port Arbitration Table Status bit to
                               confirm whether the new values of Port
                               Arbitration Table are completely latched by the
                               arbitration logic. This bit always returns 0b
                               when read.
                            */
    UINT32 lpas : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000000*/

                            /*
                               This field configures the VC resource to provide
                               a particular Port Arbitration service. This
                               field is valid for RCRBs, Root Ports that
                               support peer-to-peer traffic, and Switch Ports,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. The
                               permissible value of this field is a number
                               corresponding to one of the asserted bits in the
                               Port Arbitration Capability field of the VC
                               resource.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcid : 3;

                            /* Bits[26:24], Access Type=RO, default=0x00000000*/

                            /*
                               This field assigns a VC ID to the VC resource
                               (see note for exceptions). This field is valid
                               for all Functions. This field cannot be modified
                               when the VC is already enabled. Note: For the
                               first VC resource (default VC), this field is
                               read-only and must be hardwired to 000b.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcen : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000001*/

                            /*
                               This bit, when Set, enables a Virtual Channel
                               (see note 1 for exceptions). The Virtual Channel
                               is disabled when this bit is cleared. This bit
                               is valid for all Functions. Software must use
                               the VC Negotiation Pending bit to check whether
                               the VC negotiation is complete. Default value of
                               this bit is 1b for the first VC resource and is
                               0b for other VC resource(s). Notes: 1. This bit
                               is hardwired to 1b for the default VC (VC0),
                               i.e., writing to this bit has no effect for VC0.
                               2. To enable a Virtual Channel, the VC Enable
                               bits for that Virtual Channel must be Set in
                               both components on a Link. 3. To disable a
                               Virtual Channel, the VC Enable bits for that
                               Virtual Channel must be cleared in both
                               components on a Link. 4. Software must ensure
                               that no traffic is using a Virtual Channel at
                               the time it is disabled. 5. Software must fully
                               disable a Virtual Channel in both components on
                               a Link before re-enabling the Virtual Channel.
                            */

  } Bits;
  UINT32 Data;

} VC0RCTL_IIO_CXL_STRUCT;

/* VC0RSTS_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x1000029a)                                                      */
/*      SPRB0 (0x1000029a)                                                      */
/*      SPRHBM (0x1000029a)                                                     */
/*      SPRC0 (0x1000029a)                                                      */
/*      SPRMCC (0x1000029a)                                                     */
/*      SPRUCC (0x1000029a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC0 Resource Status
*/


#define VC0RSTS_IIO_CXL_REG 0x2301029A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the coherency status of the
                               Port Arbitration Table associated with the VC
                               resource. This bit is valid for RCRBs, Root
                               Ports that support peer-to-peer traffic, and
                               Switch Ports, but is not valid for Endpoints or
                               Root Ports that do not support peer-to-peer
                               traffic. In addition, this bit is valid only
                               when the Port Arbitration Table is used by the
                               selected Port Arbitration for the VC resource.
                               This bit is Set by hardware when any entry of
                               the Port Arbitration Table is written to by
                               software. This bit is Cleared by hardware when
                               hardware finishes loading values stored in the
                               Port Arbitration Table after software sets the
                               Load Port Arbitration Table bit.
                            */
    UINT16 vcnp : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates whether the Virtual Channel
                               negotiation (initialization or disabling) is in
                               pending state. This bit is valid for all
                               Functions. The value of this bit is defined only
                               when the Link is in the DL_Active state and the
                               Virtual Channel is enabled (its VC Enable bit is
                               Set). When this bit is Set by hardware, it
                               indicates that the VC resource has not completed
                               the process of negotiation. This bit is Cleared
                               by hardware after the VC negotiation is complete
                               (on exit from the FC_INIT2 state). For VC0, this
                               bit is permitted to be hardwired to 0b. Before
                               using a Virtual Channel, software must check
                               whether the VC Negotiation Pending bits for that
                               Virtual Channel are Clear in both components on
                               the Link.
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} VC0RSTS_IIO_CXL_STRUCT;

/* VC1RC_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x2000029c)                                                      */
/*      SPRB0 (0x2000029c)                                                      */
/*      SPRHBM (0x2000029c)                                                     */
/*      SPRC0 (0x2000029c)                                                      */
/*      SPRMCC (0x2000029c)                                                     */
/*      SPRUCC (0x2000029c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* VC1 Resource Capability
*/


#define VC1RC_IIO_CXL_REG 0x2302029C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pac : 8;

                            /* Bits[7:0], Access Type=RW/L, default=None*/

                            /*
                               Indicates types of Port Arbitration supported by
                               the VC resource. This field is valid for all
                               Switch Ports, Root Ports that support peer-to-
                               peer traffic, and RCRBs, but not for Endpoints
                               or Root Ports that do not support peer-to-peer
                               traffic. Each bit location within this field
                               corresponds to a Port Arbitration Capability
                               defined below. When more than 1 bit in this
                               field is Set, it indicates that the VC resource
                               can be configured to provide different
                               arbitration services. Software selects among
                               these capabilities by writing to the Port
                               Arbitration Select field (see Section 7.11.7).
                               Defined bit positions are: Bit 0 Non-
                               configurable hardware-fixed arbitration scheme,
                               e.g., Round Robin (RR) Bit 1 Weighted Round
                               Robin (WRR) arbitration with 32 phases Bit 2 WRR
                               arbitration with 64 phases Bit 3 WRR arbitration
                               with 128 phases Bit 4 Time-based WRR with 128
                               phases Bit 5 WRR arbitration with 256 phases
                               Bits 6-7 Reserved Note: Lock Key bit is located
                               in the Personality Lock Key Control Register
                            */
    UINT32 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rst : 1;

                            /* Bits[15:15], Access Type=RW/L, default=None*/

                            /*
                               When Clear, transactions with or without the No
                               Snoop bit Set within the TLP header are allowed
                               on this VC. When Set, any transaction for which
                               the No Snoop attribute is applicable but is not
                               Set within the TLP header is permitted to be
                               rejected as an Unsupported Request. This bit is
                               valid for Root Ports and RCRB, it is not valid
                               for Endpoints or Switch Ports. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 mts : 7;

                            /* Bits[22:16], Access Type=RW/L, default=None*/

                            /*
                               Indicates the maximum number of time slots
                               (minus one) that the VC resource is capable of
                               supporting when it is configured for time-based
                               WRR Port Arbitration. For example, a value 000
                               0000b in this field indicates the supported
                               maximum number of time slots is 1 and a value of
                               111 1111b indicates the supported maximum number
                               of time slots is 128. This field is valid for
                               all Switch Ports, Root Ports that support peer-
                               to-peer traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this field is
                               valid only when the Port Arbitration Capability
                               field indicates that the VC resource supports
                               time-based WRR Port Arbitration. Note: Lock Key
                               bit is located in the Personality Lock Key
                               Control Register .
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pato : 8;

                            /* Bits[31:24], Access Type=RW/L, default=None*/

                            /*
                               Indicates the location of the Port Arbitration
                               Table associated with the VC resource. This
                               field is valid for all Switch Ports, Root Ports
                               that support peer-to-peer traffic, and RCRBs,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. This
                               field contains the zero-based offset of the
                               table in DQWORDS (16 bytes) from the base
                               address of the Virtual Channel Capability
                               structure. A value of 00h indicates that the
                               table is not present. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */

  } Bits;
  UINT32 Data;

} VC1RC_IIO_CXL_STRUCT;

/* VC1RCTL_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x200002a0)                                                      */
/*      SPRB0 (0x200002a0)                                                      */
/*      SPRHBM (0x200002a0)                                                     */
/*      SPRC0 (0x200002a0)                                                      */
/*      SPRMCC (0x200002a0)                                                     */
/*      SPRUCC (0x200002a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC1 Resource Control
*/


#define VC1RCTL_IIO_CXL_REG 0x230202A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tc0vcm : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. Bit 0 of this field is
                               read-only. It must be Set for the default VC0
                               and Clear for all other enabled VCs.
                            */
    UINT32 tcvcm : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /*
                               This field indicates the TCs that are mapped to
                               the VC resource. This field is valid for all
                               Functions. Bit locations within this field
                               correspond to TC values. For example, when bit 7
                               is Set in this field, TC7 is mapped to this VC
                               resource. When more than 1 bit in this field is
                               Set, it indicates that multiple TCs are mapped
                               to the VC resource. In order to remove one or
                               more TCs from the TC/VC Map of an enabled VC,
                               software must ensure that no new or outstanding
                               transactions with the TC labels are targeted at
                               the given Link. Traffic Class 7 is always routed
                               to VCm so it will be 0 in other VCs.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lpat : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, this bit updates the Port Arbitration
                               logic from the Port Arbitration Table for the VC
                               resource. This bit is valid for all Switch
                               Ports, Root Ports that support peer-to-peer
                               traffic, and RCRBs, but is not valid for
                               Endpoints or Root Ports that do not support
                               peer-to-peer traffic. In addition, this bit is
                               only valid when the Port Arbitration Table is
                               used by the selected Port Arbitration scheme
                               (that is indicated by a Set bit in the Port
                               Arbitration Capability field selected by Port
                               Arbitration Select). Software sets this bit to
                               signal hardware to update Port Arbitration logic
                               with new values stored in Port Arbitration
                               Table, clearing this bit has no effect. Software
                               uses the Port Arbitration Table Status bit to
                               confirm whether the new values of Port
                               Arbitration Table are completely latched by the
                               arbitration logic. This bit always returns 0b
                               when read.
                            */
    UINT32 lpas : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000000*/

                            /*
                               This field configures the VC resource to provide
                               a particular Port Arbitration service. This
                               field is valid for RCRBs, Root Ports that
                               support peer-to-peer traffic, and Switch Ports,
                               but is not valid for Endpoints or Root Ports
                               that do not support peer-to-peer traffic. The
                               permissible value of this field is a number
                               corresponding to one of the asserted bits in the
                               Port Arbitration Capability field of the VC
                               resource.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcid : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               This field assigns a VC ID to the VC resource
                               (see note for exceptions). This field is valid
                               for all Functions. This field cannot be modified
                               when the VC is already enabled. Note: For the
                               first VC resource (default VC), this field is
                               read-only and must be hardwired to 000b.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vcen : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This bit, when Set, enables a Virtual Channel
                               (see note 1 for exceptions). The Virtual Channel
                               is disabled when this bit is cleared. This bit
                               is valid for all Functions. Software must use
                               the VC Negotiation Pending bit to check whether
                               the VC negotiation is complete. Default value of
                               this bit is 1b for the first VC resource and is
                               0b for other VC resource(s). Notes: 1. This bit
                               is hardwired to 1b for the default VC (VC0),
                               i.e., writing to this bit has no effect for VC0.
                               2. To enable a Virtual Channel, the VC Enable
                               bits for that Virtual Channel must be Set in
                               both components on a Link. 3. To disable a
                               Virtual Channel, the VC Enable bits for that
                               Virtual Channel must be cleared in both
                               components on a Link. 4. Software must ensure
                               that no traffic is using a Virtual Channel at
                               the time it is disabled. 5. Software must fully
                               disable a Virtual Channel in both components on
                               a Link before re-enabling the Virtual Channel.
                            */

  } Bits;
  UINT32 Data;

} VC1RCTL_IIO_CXL_STRUCT;

/* VC1RSTS_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x100002a6)                                                      */
/*      SPRB0 (0x100002a6)                                                      */
/*      SPRHBM (0x100002a6)                                                     */
/*      SPRC0 (0x100002a6)                                                      */
/*      SPRMCC (0x100002a6)                                                     */
/*      SPRUCC (0x100002a6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VC1 Resource Status
*/


#define VC1RSTS_IIO_CXL_REG 0x230102A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 pats : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates the coherency status of the
                               Port Arbitration Table associated with the VC
                               resource. This bit is valid for RCRBs, Root
                               Ports that support peer-to-peer traffic, and
                               Switch Ports, but is not valid for Endpoints or
                               Root Ports that do not support peer-to-peer
                               traffic. In addition, this bit is valid only
                               when the Port Arbitration Table is used by the
                               selected Port Arbitration for the VC resource.
                               This bit is Set by hardware when any entry of
                               the Port Arbitration Table is written to by
                               software. This bit is Cleared by hardware when
                               hardware finishes loading values stored in the
                               Port Arbitration Table after software sets the
                               Load Port Arbitration Table bit.
                            */
    UINT16 vcnp : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates whether the Virtual Channel
                               negotiation (initialization or disabling) is in
                               pending state. This bit is valid for all
                               Functions. The value of this bit is defined only
                               when the Link is in the DL_Active state and the
                               Virtual Channel is enabled (its VC Enable bit is
                               Set). When this bit is Set by hardware, it
                               indicates that the VC resource has not completed
                               the process of negotiation. This bit is Cleared
                               by hardware after the VC negotiation is complete
                               (on exit from the FC_INIT2 state). For VC0, this
                               bit is permitted to be hardwired to 0b. Before
                               using a Virtual Channel, software must check
                               whether the VC Negotiation Pending bits for that
                               Virtual Channel are Clear in both components on
                               the Link.
                            */
    UINT16 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} VC1RSTS_IIO_CXL_STRUCT;




/* IOSFDEVCLKGCTL_IIO_CXL_REG supported on:                                     */
/*      SPRA0 (0x100002e4)                                                      */
/*      SPRB0 (0x100002e4)                                                      */
/*      SPRHBM (0x100002e4)                                                     */
/*      SPRC0 (0x100002e4)                                                      */
/*      SPRMCC (0x100002e4)                                                     */
/*      SPRUCC (0x100002e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* It is included for DMI in RC as an extension of Rootport definition.
*/


#define IOSFDEVCLKGCTL_IIO_CXL_REG 0x230102E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block controls the delay before going
                               into IDLE. 16 (default value) is the minimum
                               number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /* This bit when set enables clock gating to occur. */

  } Bits;
  UINT16 Data;

} IOSFDEVCLKGCTL_IIO_CXL_STRUCT;

/* SBDEVCLKGCTL_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x100002e6)                                                      */
/*      SPRB0 (0x100002e6)                                                      */
/*      SPRHBM (0x100002e6)                                                     */
/*      SPRC0 (0x100002e6)                                                      */
/*      SPRMCC (0x100002e6)                                                     */
/*      SPRUCC (0x100002e6)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Sideband Device Clock Gate Control
*/


#define SBDEVCLKGCTL_IIO_CXL_REG 0x230102E6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer. On SPR, this also enables the
                               controller to request gating of the ART clock
                               used for PTM master time.
                            */

  } Bits;
  UINT16 Data;

} SBDEVCLKGCTL_IIO_CXL_STRUCT;




/* PPD1_IIO_CXL_REG supported on:                                               */
/*      SPRA0 (0x200004c0)                                                      */
/*      SPRB0 (0x200004c0)                                                      */
/*      SPRHBM (0x200004c0)                                                     */
/*      SPRC0 (0x200004c0)                                                      */
/*      SPRMCC (0x200004c0)                                                     */
/*      SPRUCC (0x200004c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* PCIe Port Definition Control Register 1
*/


#define PPD1_IIO_CXL_REG 0x230204C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 npd : 3;

                            /* Bits[10:8], Access Type=RW/V/L, default=None*/

                            /*
                               000b - Reserved 001b - Operate as RP 010b -
                               Operate as NTB-NTB (NT Port) if supported 011b -
                               Operate as NTB-> DSP (NTB EP) if supported 100b
                               - Operate as DMI if supported The remaining
                               encoding are reserved. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . The default value is determined by
                               soft straps/fuse proxy. (DSP and NTB only)
                            */
    UINT32 rsvd_11 : 3;

                            /* Bits[13:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pcfgsts : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit is written by hardware and shows the
                               result of the Port Configuration strap combined
                               with the Port Configuration override settings,
                               or an indication of IAL.io mode. 0 - Port is
                               configured as USD/DSP for NTB or proprietary RP,
                               else in non-IAL.io 1 - Port is configured as
                               DSD/USP for NTB or proprietary RP, else in
                               IAL.io. This field will be reserved in all other
                               devices.
                            */
    UINT32 cre : 1;

                            /* Bits[15:15], Access Type=RW/V/L, default=None*/

                            /*
                               This bit controls the ability of the external
                               side of the NTB to respond to transactions
                               (normal, UR, CRS). The PCIe link is expected to
                               be active after training in about 10-100ms from
                               platform reset deassertion. However, the
                               internal controller may take longer to boot, and
                               to initialize its registers. To allow longer
                               boot time, the CRE bit is used to ensure that
                               the Internal side and related functionality is
                               up and operational before allowing transactions
                               from the external side to be processed even
                               though link training could have been completed
                               prior. 0: External Link handles PCIe
                               transactions (configuration, memory, messages)
                               in the normal fashion during linkup state. 1:
                               External Link presents Configuration Retry
                               Status (CRS) to the incoming configuration cycle
                               on the external cycle in the linkup state. All
                               other requests will be URed. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . The NTB will respond with
                               Configuration Retry Status (CRS) on the PCIe
                               link for configuration cycles until such time
                               when the internal firmware completes
                               initialization of all internal resources. If the
                               external side sends any other request (memory,
                               messages) before this initialization is done, it
                               will be master aborted (UR) on the external
                               side. It is the responsibility of software to
                               adhere to this flow. This bit is reserved in
                               Downstream Port .
                            */
    UINT32 safemode_en : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               The default value of 1 is for non-RC ports (0
                               for RC ports)
                            */
    UINT32 safemode_exit : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               def 0 (write to unblock clearing of safemode),
                               self clears once safemode_en state has been
                               updated to 0 internally
                            */
    UINT32 safemode_mlw : 6;

                            /* Bits[23:18], Access Type=RO, default=0x00000000*/

                            /*
                               max link width to support in safe mode, 0 is
                               reserved. refer to MLW definition.
                            */
    UINT32 rsvd_24 : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cl : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RW-L bits of PPD1 register
                               only. 1b: Lock 0b: Unlocked Note: Lock Key bit
                               is located in the PPD1 Register . This bit is
                               self-locking. Once this bit is set to a 1b, this
                               key bit can not be unlocked. Writing a 0b has no
                               effect on this bit.
                            */

  } Bits;
  UINT32 Data;

} PPD1_IIO_CXL_STRUCT;

/* PLKCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000558)                                                      */
/*      SPRB0 (0x10000558)                                                      */
/*      SPRHBM (0x10000558)                                                     */
/*      SPRC0 (0x10000558)                                                      */
/*      SPRMCC (0x10000558)                                                     */
/*      SPRUCC (0x10000558)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX2                                             */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* Personality Lock Key Control
*/


#define PLKCTL_IIO_CXL_REG 0x23010558

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cl : 1;

                            /* Bits[0:0], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits (capabilities,
                               next capability pointer, SSID/SVID, slot
                               register, etc) bits for the function. 1b: Lock
                               0b: Unlocked Note: Lock Key bit is located in
                               the PLKCTL Register . This bit is self-locking.
                               Once this bit is set to a 1b, this key bit can
                               not be unlocked. Writing a 0b has no effect on
                               this bit.
                            */
    UINT16 tlcl : 1;

                            /* Bits[1:1], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in
                               XPEINJ[1:0], XPCDTHROTTLEP,N,C, XPTDEF*,
                               MBAR01CTL EXPPTMBARCTL, XPERRINJCTL,
                               SWERRINJCTL, IDFERRINJCTL. 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 llcl : 1;

                            /* Bits[2:2], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in the
                               following CSRs. XPLDEF XPLDEF2 LLRBERRINJCTL
                               RXPERRINJCTL CRCERRINJCTL CRCERRINJMSK RTRYCTL
                               PACKTHRESH ECRCERRINJCTL 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit.
                            */
    UINT16 dpcl : 1;

                            /* Bits[3:3], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in the
                               following CSRs. XPDDEF 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit. Only applicable to R-Link with Delta Phy
                               Layer, and should be treated as reserved if not
                               applicable.
                            */
    UINT16 plcl : 1;

                            /* Bits[4:4], Access Type=RW/L, default=None*/

                            /*
                               Lock key bit for all RWS-L bits located in the
                               following CSRs. OBEINJCTL 1b: Lock 0b: Unlocked
                               Note: Lock Key bit is located in the PLKCTL
                               Register . This bit is self-locking. Once this
                               bit is set to a 1b, this key bit can not be
                               unlocked. Writing a 0b has no effect on this
                               bit. Only applicable to PCIe Phy Layer, and
                               should be treated as reserved if not applicable.
                            */
    UINT16 rsvd : 11;

                            /* Bits[15:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PLKCTL_IIO_CXL_STRUCT;

/* XPPMDL0_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000580)                                                      */
/*      SPRB0 (0x20000580)                                                      */
/*      SPRHBM (0x20000580)                                                     */
/*      SPRC0 (0x20000580)                                                      */
/*      SPRMCC (0x20000580)                                                     */
/*      SPRUCC (0x20000580)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data Low Bits
*/


#define XPPMDL0_IIO_CXL_REG 0x23020580

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* Low order bits [31:0] for PM data counter[1:0]. */

  } Bits;
  UINT32 Data;

} XPPMDL0_IIO_CXL_STRUCT;

/* XPPMDL1_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000584)                                                      */
/*      SPRB0 (0x20000584)                                                      */
/*      SPRHBM (0x20000584)                                                     */
/*      SPRC0 (0x20000584)                                                      */
/*      SPRMCC (0x20000584)                                                     */
/*      SPRUCC (0x20000584)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data Low Bits
*/


#define XPPMDL1_IIO_CXL_REG 0x23020584

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* Low order bits [31:0] for PM data counter[1:0]. */

  } Bits;
  UINT32 Data;

} XPPMDL1_IIO_CXL_STRUCT;

/* XPPMCL0_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000588)                                                      */
/*      SPRB0 (0x20000588)                                                      */
/*      SPRHBM (0x20000588)                                                     */
/*      SPRC0 (0x20000588)                                                      */
/*      SPRMCC (0x20000588)                                                     */
/*      SPRUCC (0x20000588)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare Low Bits
*/


#define XPPMCL0_IIO_CXL_REG 0x23020588

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0xFFFFFFFF*/

                            /*
                               Low order bits [31:0] for PM compare
                               register[1:0].
                            */

  } Bits;
  UINT32 Data;

} XPPMCL0_IIO_CXL_STRUCT;

/* XPPMCL1_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x2000058c)                                                      */
/*      SPRB0 (0x2000058c)                                                      */
/*      SPRHBM (0x2000058c)                                                     */
/*      SPRC0 (0x2000058c)                                                      */
/*      SPRMCC (0x2000058c)                                                     */
/*      SPRUCC (0x2000058c)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare Low Bits
*/


#define XPPMCL1_IIO_CXL_REG 0x2302058C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpl : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0xFFFFFFFF*/

                            /*
                               Low order bits [31:0] for PM compare
                               register[1:0].
                            */

  } Bits;
  UINT32 Data;

} XPPMCL1_IIO_CXL_STRUCT;

/* XPPMDH_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000590)                                                      */
/*      SPRB0 (0x10000590)                                                      */
/*      SPRHBM (0x10000590)                                                     */
/*      SPRC0 (0x10000590)                                                      */
/*      SPRMCC (0x10000590)                                                     */
/*      SPRUCC (0x10000590)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Data High Bits
*/


#define XPPMDH_IIO_CXL_REG 0x23010590

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cnth0 : 4;

                            /* Bits[3:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               High order bits [35:32] of the 36-bit PM Data0
                               register.
                            */
    UINT16 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 cnth1 : 4;

                            /* Bits[11:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               High order bits [35:32] of the 36-bit PM Data1
                               register.
                            */
    UINT16 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} XPPMDH_IIO_CXL_STRUCT;

/* XPPMCH_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x10000592)                                                      */
/*      SPRB0 (0x10000592)                                                      */
/*      SPRHBM (0x10000592)                                                     */
/*      SPRC0 (0x10000592)                                                      */
/*      SPRMCC (0x10000592)                                                     */
/*      SPRUCC (0x10000592)                                                     */
/* Register default value on SPRA0: 0x00000F0F                                  */
/* Register default value on SPRB0: 0x00000F0F                                  */
/* Register default value on SPRHBM: 0x00000F0F                                 */
/* Register default value on SPRC0: 0x00000F0F                                  */
/* Register default value on SPRMCC: 0x00000F0F                                 */
/* Register default value on SPRUCC: 0x00000F0F                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Compare High Bits
*/


#define XPPMCH_IIO_CXL_REG 0x23010592

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 cmph0 : 4;

                            /* Bits[3:0], Access Type=RW/V, default=0x0000000F*/

                            /*
                               High order bits [35:32] of the 36-bit PM
                               Compare0 register.
                            */
    UINT16 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 cmph1 : 4;

                            /* Bits[11:8], Access Type=RW/V, default=0x0000000F*/

                            /*
                               High order bits [35:32] of the 36-bit PM
                               Compare1 register.
                            */
    UINT16 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} XPPMCH_IIO_CXL_STRUCT;

/* XPPMR0_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000594)                                                      */
/*      SPRB0 (0x20000594)                                                      */
/*      SPRHBM (0x20000594)                                                     */
/*      SPRC0 (0x20000594)                                                      */
/*      SPRMCC (0x20000594)                                                     */
/*      SPRUCC (0x20000594)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Response Control
*/


#define XPPMR0_IIO_CXL_REG 0x23020594

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntrst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit resets the following bit
                               fields. This only applies to the set of
                               registers for this PM block. Setting this bit
                               resets the PMD counter, the associated adder
                               storage register and the count mode state latch
                               (see bits CNTMD) to the default state. It does
                               not change the state of this PMR register, the
                               event selections, or the value in the compare
                               register. Note: This bit must be cleared by
                               software, otherwise the counters remain in
                               reset. There is also a reset bit in the
                               XPPERFCON register which clears all PM registers
                               including the PMR.
                            */
    UINT32 ovs : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures the overflow event from
                               the PMD counter. This bit remains set once an
                               event is reported even though the original
                               condition is no longer valid. Writing a logic
                               '1' clears the bit.
                            */
    UINT32 cmpstat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures a count compare event.
                               0: no event 1: count compare - PMD counter
                               greater than PMC register when in compare mode.
                               This bit remains set once an event is reported
                               even though the original condition is no longer
                               valid. Writing a logic '1' clears the bit.
                            */
    UINT32 pto : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects what the signal is
                               communicated to the chip's event logic
                               structure. 00: No cluster trigger output from
                               PerfMons or header match. 01: PM Status. 10: PM
                               Event Detection. 11: Address Header Match
                            */
    UINT32 pmssig : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0: Level output from status/overflow signals. 1:
                               Pulsed output from status/overflow signals.
                            */
    UINT32 cmpmd : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               This field defines how the PMC (compare)
                               register is to be used. 00: compare mode
                               disabled (PMC register not used) sig p = sig s
                               01: max compare only: The PMC register value is
                               compared with the counter value. If the counter
                               value is greater then the Compare Status
                               (CMPSTAT) will be set. sig p = sig n 10: max
                               compare with update of PMC at end of sample: The
                               PMC register value is compared with the counter
                               value, and if the counter value is greater, the
                               PMC register is updated with the counter value.
                               Note, the Compare Status field is not affected
                               in this mode. sig p = sig n 11: Reserved
                            */
    UINT32 rstevsel : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field will reset the PMD counter. For
                               details regarding usage and pair mode operation
                               see Chapter 21. 000: No reset condition 001:
                               Partner's event status: When the partner counter
                               causes an event status condition to be
                               activated, either by a counter overflow or max
                               comparison, then this counter will reset and
                               continue counting. 010: Partners PME register
                               event: When the partner counter detects a match
                               condition which meets its selected PME register
                               qualifications, then this counter will reset and
                               continue counting. 011: This PM counter's status
                               output. 100: GE[0], from the Global Debug Event
                               Block. 101: GE[1], from the Global Debug Event
                               Block. 110: GE[2], from the Global Debug Event
                               Block. 111: GE[3], from the Global Debug Event
                               Block. Note: The GEs used are dependent on bit
                               31 (LOCGLOBEVSEL). If bit 31 is used, local
                               events will be used instead of global events.
                            */
    UINT32 cens : 3;

                            /* Bits[13:11], Access Type=RW, default=0x00000000*/

                            /*
                               These bits identify which input enables the
                               counter. Default value disables counting. 000:
                               Disabled 001: Local Count Enabled (LCEN). This
                               bit is always a logic 1. 010: Partner counter's
                               event status (max compare or overflow) 011:
                               Header MatchOut signal 100: GE[0], from the
                               Global Debug Event Block 101: GE[1], from the
                               Global Debug Event Block 110: GE[2], from the
                               Global Debug Event Block 111: GE[3], from the
                               Global Debug Event Block Note: Address/Header
                               MatchOut signal must align with PMEVL,H events
                               for this to be effective. Note: The GEs used are
                               dependent on bit 31 (LOCGLOBEVSEL). If bit 31 is
                               used, local events will be used instead of
                               global events.
                            */
    UINT32 cntmd : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets how the events will be counted.
                               00: Count clocks for the duration of event
                               signal is active. 01: Count rising edge events
                               (for active low signals EVPOLINV must be set for
                               correct measurements). 10: Count clocks
                               continuously after the event was asserted. The
                               latched state of this condition is cleared by
                               PerfMon reset block, PMR.CNTRST bit, or
                               XPPERFCON.GRST. 11: Enable queue threshold
                               measuring. This mode will reassign the event
                               selection registers from both PerfMons, selects
                               a modified count enable, and enables add/sub
                               operation. Selecting this mode will not allow
                               normal PerfMon operations to occur. To simplify
                               the logic a strict assignment of functions is
                               applied. PM0's event selection registers are
                               assigned to the add (increment) function and
                               PM1's event selection registers are assigned to
                               the subtract (decrement) function. When both PM0
                               and PM1 events are asserted or when both are not
                               asserted do not add or subtract values from the
                               queue. PM0Ev.........PM1Ev............PM
                               condition
                               ....0...................0...................Do
                               not add/sub ....1...................0...........
                               ..........Add queue value ....0.................
                               ..1.....................Sub queue value
                               ....1...................1...................Do
                               not add/sub Setting this mode enables the PM
                               event registers as described but it also enables
                               the selection of a Qempty signal to be used a
                               count enable signal. The count enable is latched
                               high continuously and only cleared with PM
                               global reset or local counter reset. The
                               THRQMSRSTR bit field selects which bit[3] of
                               each nibble in each byte lane that acts as a
                               count enable. Once this event occurs it is
                               latched and queue counting begins. Because this
                               signal is latched a counter reset or PERCON
                               global reset is required to start another
                               measurement. This latched condition is cleared
                               by the PMR.CNTRST bit, or XPPERFCON.GRST.
                            */
    UINT32 evpolinv : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               This bit inverts the polarity of the conditioned
                               event signal. 0: No inversion 1: Invert the
                               polarity of the conditioned event signal
                            */
    UINT32 cntevsel : 2;

                            /* Bits[18:17], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the condition for incrementing the
                               performance monitor counter. 00: Event source
                               selected by PMEVL,H 01: Partner event status
                               (max compare or overflow) 10: All clocks when
                               enabled 11: Reserved
                            */
    UINT32 egs : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which event register to use for
                               performance monitoring. 00: Bus events
                               (XPPMEVL,H register) 01: Resource utilizations
                               (in the XPPMER register) 10: Queue measurement
                               (in the XPPMER register) 11: FIFO queue
                               measurements (selects 1h on the queue
                               measurement bus).
                            */
    UINT32 ldes : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This selection enables the local debug bus to be
                               selected for event counting. Enabling this
                               selection changes the PMEVL,H register into
                               24bits of DFx masking and matching. 0: Disable
                               DFx event monitoring 1: Enable DFx event
                               monitoring.
                            */
    UINT32 dfxlnsel : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field is only active when LDES is
                               asserted. These bits select which set of 3 byte
                               lanes from the 72 bit (9 byte lane) local debug
                               bus is active for DFx event counting with the
                               PerfMons. 00: Local Debug Byte Lanes 0-2 01:
                               Local Debug Byte Lanes 3-5 10: Local Debug Byte
                               Lanes 6-8 11: Reserved
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rstpulsen : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will select a pulsed version of
                               the reset signal source in the reset block. 0:
                               Normal reset signaling 1: Select a pulsed reset
                               from the reset signal sources.
                            */
    UINT32 latcntensel : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               0: Normal PM operation. Use CENS as count
                               enable. 1: Use Latched count enable from queue
                               empty events
                            */
    UINT32 frcpmdaddz : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               This feature is used with the queue measurement
                               bus. When this bit is set the value on the queue
                               measurement bus is added to zero so the result
                               in PMD will always reflect the value from the
                               queue measurement bus. 0: Do not add zero.
                               Normal PerfMon operation. 1: Add zero with input
                               queue bus.
                            */
    UINT32 notgrtcmp : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               0: PMC will compare a greater than function.
                               When clear the perfmon status will assert when
                               the PMD is greater than the PMC. 1: PMC will
                               compare with NOT(greater than) function. When
                               set the perfmon status will assert when the PMD
                               is less than or equal to the PMC. CSPEC NOTE:
                               This bit was not in Seaburg.
                            */
    UINT32 locglobevsel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This register bit allows for standalone cluster
                               simulation. Normally the global events are used
                               as control signals for the performance monitors.
                               When this bit is set to1, the internal
                               IPTRIG[0-3] signals are selected respectively in
                               place of the external GE[0-3] signals. Note: It
                               is possible to have one PERFMON use the internal
                               events, while the other PERFMON uses the
                               external events. 0:Global events are selected
                               1:Local events are selected
                            */

  } Bits;
  UINT32 Data;

} XPPMR0_IIO_CXL_STRUCT;

/* XPPMR1_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000598)                                                      */
/*      SPRB0 (0x20000598)                                                      */
/*      SPRHBM (0x20000598)                                                     */
/*      SPRC0 (0x20000598)                                                      */
/*      SPRMCC (0x20000598)                                                     */
/*      SPRUCC (0x20000598)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* XP PM Response Control
*/


#define XPPMR1_IIO_CXL_REG 0x23020598

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cntrst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit resets the following bit
                               fields. This only applies to the set of
                               registers for this PM block. Setting this bit
                               resets the PMD counter, the associated adder
                               storage register and the count mode state latch
                               (see bits CNTMD) to the default state. It does
                               not change the state of this PMR register, the
                               event selections, or the value in the compare
                               register. Note: This bit must be cleared by
                               software, otherwise the counters remain in
                               reset. There is also a reset bit in the
                               XPPERFCON register which clears all PM registers
                               including the PMR.
                            */
    UINT32 ovs : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures the overflow event from
                               the PMD counter. This bit remains set once an
                               event is reported even though the original
                               condition is no longer valid. Writing a logic
                               '1' clears the bit.
                            */
    UINT32 cmpstat : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This status bit captures a count compare event.
                               0: no event 1: count compare - PMD counter
                               greater than PMC register when in compare mode.
                               This bit remains set once an event is reported
                               even though the original condition is no longer
                               valid. Writing a logic '1' clears the bit.
                            */
    UINT32 pto : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects what the signal is
                               communicated to the chip's event logic
                               structure. 00: No cluster trigger output from
                               PerfMons or header match. 01: PM Status. 10: PM
                               Event Detection. 11: Address Header Match
                            */
    UINT32 pmssig : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0: Level output from status/overflow signals. 1:
                               Pulsed output from status/overflow signals.
                            */
    UINT32 cmpmd : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               This field defines how the PMC (compare)
                               register is to be used. 00: compare mode
                               disabled (PMC register not used) sig p = sig s
                               01: max compare only: The PMC register value is
                               compared with the counter value. If the counter
                               value is greater then the Compare Status
                               (CMPSTAT) will be set. sig p = sig n 10: max
                               compare with update of PMC at end of sample: The
                               PMC register value is compared with the counter
                               value, and if the counter value is greater, the
                               PMC register is updated with the counter value.
                               Note, the Compare Status field is not affected
                               in this mode. sig p = sig n 11: Reserved
                            */
    UINT32 rstevsel : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field will reset the PMD counter. For
                               details regarding usage and pair mode operation
                               see Chapter 21. 000: No reset condition 001:
                               Partner's event status: When the partner counter
                               causes an event status condition to be
                               activated, either by a counter overflow or max
                               comparison, then this counter will reset and
                               continue counting. 010: Partners PME register
                               event: When the partner counter detects a match
                               condition which meets its selected PME register
                               qualifications, then this counter will reset and
                               continue counting. 011: This PM counter's status
                               output. 100: GE[0], from the Global Debug Event
                               Block. 101: GE[1], from the Global Debug Event
                               Block. 110: GE[2], from the Global Debug Event
                               Block. 111: GE[3], from the Global Debug Event
                               Block. Note: The GEs used are dependent on bit
                               31 (LOCGLOBEVSEL). If bit 31 is used, local
                               events will be used instead of global events.
                            */
    UINT32 cens : 3;

                            /* Bits[13:11], Access Type=RW, default=0x00000000*/

                            /*
                               These bits identify which input enables the
                               counter. Default value disables counting. 000:
                               Disabled 001: Local Count Enabled (LCEN). This
                               bit is always a logic 1. 010: Partner counter's
                               event status (max compare or overflow) 011:
                               Header MatchOut signal 100: GE[0], from the
                               Global Debug Event Block 101: GE[1], from the
                               Global Debug Event Block 110: GE[2], from the
                               Global Debug Event Block 111: GE[3], from the
                               Global Debug Event Block Note: Address/Header
                               MatchOut signal must align with PMEVL,H events
                               for this to be effective. Note: The GEs used are
                               dependent on bit 31 (LOCGLOBEVSEL). If bit 31 is
                               used, local events will be used instead of
                               global events.
                            */
    UINT32 cntmd : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               This field sets how the events will be counted.
                               00: Count clocks for the duration of event
                               signal is active. 01: Count rising edge events
                               (for active low signals EVPOLINV must be set for
                               correct measurements). 10: Count clocks
                               continuously after the event was asserted. The
                               latched state of this condition is cleared by
                               PerfMon reset block, PMR.CNTRST bit, or
                               XPPERFCON.GRST. 11: Enable queue threshold
                               measuring. This mode will reassign the event
                               selection registers from both PerfMons, selects
                               a modified count enable, and enables add/sub
                               operation. Selecting this mode will not allow
                               normal PerfMon operations to occur. To simplify
                               the logic a strict assignment of functions is
                               applied. PM0's event selection registers are
                               assigned to the add (increment) function and
                               PM1's event selection registers are assigned to
                               the subtract (decrement) function. When both PM0
                               and PM1 events are asserted or when both are not
                               asserted do not add or subtract values from the
                               queue. PM0Ev.........PM1Ev............PM
                               condition
                               ....0...................0...................Do
                               not add/sub ....1...................0...........
                               ..........Add queue value ....0.................
                               ..1.....................Sub queue value
                               ....1...................1...................Do
                               not add/sub Setting this mode enables the PM
                               event registers as described but it also enables
                               the selection of a Qempty signal to be used a
                               count enable signal. The count enable is latched
                               high continuously and only cleared with PM
                               global reset or local counter reset. The
                               THRQMSRSTR bit field selects which bit[3] of
                               each nibble in each byte lane that acts as a
                               count enable. Once this event occurs it is
                               latched and queue counting begins. Because this
                               signal is latched a counter reset or PERCON
                               global reset is required to start another
                               measurement. This latched condition is cleared
                               by the PMR.CNTRST bit, or XPPERFCON.GRST.
                            */
    UINT32 evpolinv : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               This bit inverts the polarity of the conditioned
                               event signal. 0: No inversion 1: Invert the
                               polarity of the conditioned event signal
                            */
    UINT32 cntevsel : 2;

                            /* Bits[18:17], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the condition for incrementing the
                               performance monitor counter. 00: Event source
                               selected by PMEVL,H 01: Partner event status
                               (max compare or overflow) 10: All clocks when
                               enabled 11: Reserved
                            */
    UINT32 egs : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which event register to use for
                               performance monitoring. 00: Bus events
                               (XPPMEVL,H register) 01: Resource utilizations
                               (in the XPPMER register) 10: Queue measurement
                               (in the XPPMER register) 11: FIFO queue
                               measurements (selects 1h on the queue
                               measurement bus).
                            */
    UINT32 ldes : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               This selection enables the local debug bus to be
                               selected for event counting. Enabling this
                               selection changes the PMEVL,H register into
                               24bits of DFx masking and matching. 0: Disable
                               DFx event monitoring 1: Enable DFx event
                               monitoring.
                            */
    UINT32 dfxlnsel : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               This bit field is only active when LDES is
                               asserted. These bits select which set of 3 byte
                               lanes from the 72 bit (9 byte lane) local debug
                               bus is active for DFx event counting with the
                               PerfMons. 00: Local Debug Byte Lanes 0-2 01:
                               Local Debug Byte Lanes 3-5 10: Local Debug Byte
                               Lanes 6-8 11: Reserved
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rstpulsen : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will select a pulsed version of
                               the reset signal source in the reset block. 0:
                               Normal reset signaling 1: Select a pulsed reset
                               from the reset signal sources.
                            */
    UINT32 latcntensel : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               0: Normal PM operation. Use CENS as count
                               enable. 1: Use Latched count enable from queue
                               empty events
                            */
    UINT32 frcpmdaddz : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               This feature is used with the queue measurement
                               bus. When this bit is set the value on the queue
                               measurement bus is added to zero so the result
                               in PMD will always reflect the value from the
                               queue measurement bus. 0: Do not add zero.
                               Normal PerfMon operation. 1: Add zero with input
                               queue bus.
                            */
    UINT32 notgrtcmp : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               0: PMC will compare a greater than function.
                               When clear the perfmon status will assert when
                               the PMD is greater than the PMC. 1: PMC will
                               compare with NOT(greater than) function. When
                               set the perfmon status will assert when the PMD
                               is less than or equal to the PMC. CSPEC NOTE:
                               This bit was not in Seaburg.
                            */
    UINT32 locglobevsel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This register bit allows for standalone cluster
                               simulation. Normally the global events are used
                               as control signals for the performance monitors.
                               When this bit is set to1, the internal
                               IPTRIG[0-3] signals are selected respectively in
                               place of the external GE[0-3] signals. Note: It
                               is possible to have one PERFMON use the internal
                               events, while the other PERFMON uses the
                               external events. 0:Global events are selected
                               1:Local events are selected
                            */

  } Bits;
  UINT32 Data;

} XPPMR1_IIO_CXL_STRUCT;

/* XPPMEVL0_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x2000059c)                                                      */
/*      SPRB0 (0x2000059c)                                                      */
/*      SPRHBM (0x2000059c)                                                     */
/*      SPRC0 (0x2000059c)                                                      */
/*      SPRMCC (0x2000059c)                                                     */
/*      SPRUCC (0x2000059c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVH except where noted.
The qualifications for fields in this register are as follows:
PMEV Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) and INOUTBND) + GESEL
 IO_Cfg_Write_event = (REQCMP[0] and CMPR[1] and RDWR[1] and DATALEN and (TTYP[2] + (TTYP[1] and CFGTYP)))
 IO_Cfg_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and (TTYP[2] + (FMTTYP[1] and CFGTYP)))
 Mem_Write_event = (REQCMP[0] and CMPR[0] and RDWR[1] and DATALEN and TTYP[3] and LOCK and EXTADDR and SNATTR)
 Note: An outbound memory write does not have a snoop attribute as an inbound memory write has. So the user should set SNATTR='11' for outbound memory write transaction event counting.
 Mem_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and ((TTYP[3] and LOCK and EXTADDR and SNATTR) + TTYP[2] + (TTYP[1] and CFGTYP)))
 Note: For outbound memory reads there is no concept of issuing a snoop cycle. The user should select SNATTR='11' for either snoop attribute.
 Msg_event = (TTYP[0] and DND)
 (INOUTBND[0] and (MatchEq) + (IOBND[1] and (MatchEq)
Note: Setting both bits in INOUTBND is acceptable however the performance data gathered will not be accurate since once one header can be counted at a time.
*/


#define XPPMEVL0_IIO_CXL_REG 0x2302059C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpstat : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               (for Completion Packet) or message encoding (for
                               Request Packet). 1xxx: Completer abort x1xx:
                               Configuration request retry status (only used
                               for receive completions) xx1x: Unsupported
                               request xxx1: Successful completion 1111: Any
                               status
                            */
    UINT32 datlen : 7;

                            /* Bits[10:4], Access Type=RW, default=0x00000000*/

                            /*
                               1xxxxxx: (129 to 256 bytes) x1xxxxx: (65 to 128
                               bytes) xx1xxxx: (33 to 64 bytes) xxx1xxx: (17 to
                               32 bytes) xxxx1xx: (9 to 16 bytes) xxxxx1x: (0
                               to 8 bytes) xxxxxx1: 0 bytes, used for a special
                               zero length encoded packets 111111: Any Data
                               length
                            */
    UINT32 ttyp : 5;

                            /* Bits[15:11], Access Type=RW, default=0x00000000*/

                            /*
                               (ORed group) 1xxxx: Trusted x1xxx: Memory xx1xx:
                               IO xxx1x: Configuration xxxx1: Messages 11111:
                               Any transaction type
                            */
    UINT32 cfgtyp : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               (If Config cycle Space selected) x1: Type 0 1x:
                               Type 1 11: Either
                            */
    UINT32 extaddr : 2;

                            /* Bits[19:18], Access Type=RW, default=0x00000000*/

                            /* x1: 32b addressing 1x: 64b addressing 11: Either */
    UINT32 lock : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* x1: No lock 1x: Lock 11: Either */
    UINT32 cmpr : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               (Request packet only) x1: No completion required
                               1x: Completion required 11: Either
                            */
    UINT32 rdwr : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /* x1: Read 1x: Write 11: Either */
    UINT32 reqcmp : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request packet 1x: Completion packet 11:
                               Either
                            */
    UINT32 snattr : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Snoop required 1x: No snoop required 11:
                               Either
                            */
    UINT32 dnd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request/completion/message packet with data
                               1x: Request/completion/message packet without
                               data
                            */

  } Bits;
  UINT32 Data;

} XPPMEVL0_IIO_CXL_STRUCT;

/* XPPMEVL1_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200005a0)                                                      */
/*      SPRB0 (0x200005a0)                                                      */
/*      SPRHBM (0x200005a0)                                                     */
/*      SPRC0 (0x200005a0)                                                      */
/*      SPRMCC (0x200005a0)                                                     */
/*      SPRUCC (0x200005a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVH except where noted.
The qualifications for fields in this register are as follows:
PMEV Match = ((IO_Cfg_Write_event + IO_Cfg_Read_event _+ Mem_Write_event + Mem_Read_event + Trusted_write_event + Trusted_read_event + General_event) and INOUTBND) + GESEL
 IO_Cfg_Write_event = (REQCMP[0] and CMPR[1] and RDWR[1] and DATALEN and (TTYP[2] + (TTYP[1] and CFGTYP)))
 IO_Cfg_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and (TTYP[2] + (FMTTYP[1] and CFGTYP)))
 Mem_Write_event = (REQCMP[0] and CMPR[0] and RDWR[1] and DATALEN and TTYP[3] and LOCK and EXTADDR and SNATTR)
 Note: An outbound memory write does not have a snoop attribute as an inbound memory write has. So the user should set SNATTR='11' for outbound memory write transaction event counting.
 Mem_Read_event = (REQCMP[0] and CMPR[1] and RDWR[0] and DATALEN and ((TTYP[3] and LOCK and EXTADDR and SNATTR) + TTYP[2] + (TTYP[1] and CFGTYP)))
 Note: For outbound memory reads there is no concept of issuing a snoop cycle. The user should select SNATTR='11' for either snoop attribute.
 Msg_event = (TTYP[0] and DND)
 (INOUTBND[0] and (MatchEq) + (IOBND[1] and (MatchEq)
Note: Setting both bits in INOUTBND is acceptable however the performance data gathered will not be accurate since once one header can be counted at a time.
*/


#define XPPMEVL1_IIO_CXL_REG 0x230205A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmpstat : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               (for Completion Packet) or message encoding (for
                               Request Packet). 1xxx: Completer abort x1xx:
                               Configuration request retry status (only used
                               for receive completions) xx1x: Unsupported
                               request xxx1: Successful completion 1111: Any
                               status
                            */
    UINT32 datlen : 7;

                            /* Bits[10:4], Access Type=RW, default=0x00000000*/

                            /*
                               1xxxxxx: (129 to 256 bytes) x1xxxxx: (65 to 128
                               bytes) xx1xxxx: (33 to 64 bytes) xxx1xxx: (17 to
                               32 bytes) xxxx1xx: (9 to 16 bytes) xxxxx1x: (0
                               to 8 bytes) xxxxxx1: 0 bytes, used for a special
                               zero length encoded packets 111111: Any Data
                               length
                            */
    UINT32 ttyp : 5;

                            /* Bits[15:11], Access Type=RW, default=0x00000000*/

                            /*
                               (ORed group) 1xxxx: Trusted x1xxx: Memory xx1xx:
                               IO xxx1x: Configuration xxxx1: Messages 11111:
                               Any transaction type
                            */
    UINT32 cfgtyp : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               (If Config cycle Space selected) x1: Type 0 1x:
                               Type 1 11: Either
                            */
    UINT32 extaddr : 2;

                            /* Bits[19:18], Access Type=RW, default=0x00000000*/

                            /* x1: 32b addressing 1x: 64b addressing 11: Either */
    UINT32 lock : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* x1: No lock 1x: Lock 11: Either */
    UINT32 cmpr : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               (Request packet only) x1: No completion required
                               1x: Completion required 11: Either
                            */
    UINT32 rdwr : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /* x1: Read 1x: Write 11: Either */
    UINT32 reqcmp : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request packet 1x: Completion packet 11:
                               Either
                            */
    UINT32 snattr : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Snoop required 1x: No snoop required 11:
                               Either
                            */
    UINT32 dnd : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               x1: Request/completion/message packet with data
                               1x: Request/completion/message packet without
                               data
                            */

  } Bits;
  UINT32 Data;

} XPPMEVL1_IIO_CXL_STRUCT;

/* XPPMEVH0_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200005a4)                                                      */
/*      SPRB0 (0x200005a4)                                                      */
/*      SPRHBM (0x200005a4)                                                     */
/*      SPRC0 (0x200005a4)                                                      */
/*      SPRMCC (0x200005a4)                                                     */
/*      SPRUCC (0x200005a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVL except for the Global Event signals. These signals are OR'ed with any event in the XPPMEVL and enables for debug operations requiring the accumulation of specific debug signals.
*/


#define XPPMEVH0_IIO_CXL_REG 0x230205A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxtxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which path to count transactions. 1x:
                               Transmit x1: Receive (from PCI bus) 11: Either
                            */
    UINT32 gesel : 4;

                            /* Bits[5:2], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which GE[3:0] is used for event
                               counting. This field is OR'd with other fields
                               in this register. The GEs cannot be qualified
                               with other PerfMon signals. If more than 1 GE is
                               selected then the resultant event is the OR
                               between each GE. However, properly counting
                               Global Event based on design, XP PM Response
                               Control Register bit [13:11] CENS must be set to
                               choose GE[3:0] and also bit[18:17] CNTEVSEL must
                               be set to 2'b10. 1xxx: GE[3] x1xx: GE[2] xx1x:
                               GE[1] xxx1: GE[0]
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMEVH0_IIO_CXL_STRUCT;

/* XPPMEVH1_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x200005a8)                                                      */
/*      SPRB0 (0x200005a8)                                                      */
/*      SPRHBM (0x200005a8)                                                     */
/*      SPRC0 (0x200005a8)                                                      */
/*      SPRMCC (0x200005a8)                                                     */
/*      SPRUCC (0x200005a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Selections in this register correspond to fields within the PEX packet header. Each field selection is ANDed with all other fields in this register including the XPPMEVL except for the Global Event signals. These signals are OR'ed with any event in the XPPMEVL and enables for debug operations requiring the accumulation of specific debug signals.
*/


#define XPPMEVH1_IIO_CXL_REG 0x230205A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxtxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which path to count transactions. 1x:
                               Transmit x1: Receive (from PCI bus) 11: Either
                            */
    UINT32 gesel : 4;

                            /* Bits[5:2], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which GE[3:0] is used for event
                               counting. This field is OR'd with other fields
                               in this register. The GEs cannot be qualified
                               with other PerfMon signals. If more than 1 GE is
                               selected then the resultant event is the OR
                               between each GE. However, properly counting
                               Global Event based on design, XP PM Response
                               Control Register bit [13:11] CENS must be set to
                               choose GE[3:0] and also bit[18:17] CNTEVSEL must
                               be set to 2'b10. 1xxx: GE[3] x1xx: GE[2] xx1x:
                               GE[1] xxx1: GE[0]
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMEVH1_IIO_CXL_STRUCT;

/* XPPMER0_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x200005ac)                                                      */
/*      SPRB0 (0x200005ac)                                                      */
/*      SPRHBM (0x200005ac)                                                     */
/*      SPRC0 (0x200005ac)                                                      */
/*      SPRMCC (0x200005ac)                                                     */
/*      SPRUCC (0x200005ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is used to select queuing structures for measurement. Use of this event register is mutually exclusive with the XPPMEVL,H registers. The Event Register Select field in the PMR register must select this register for to enable monitoring operations of the queues.
*/


#define XPPMER0_IIO_CXL_REG 0x230205AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects a Tx/Rx queue to monitor.
                               Either receiver or transmit direction for
                               measurement. 1x: Transmit x1: Receive (from PCIe
                               bus) 11: Either Transmit or Receive direction
                            */
    UINT32 fccsel : 3;

                            /* Bits[4:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which flow class for resource
                               event xx1: Posted x1x: Non-Posted 1xx:
                               Completion
                            */
    UINT32 vcsel : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which VC to count. Only one
                               VC can be counted at a time.
                            */
    UINT32 avcsel : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               0: Not all VC selected 1: All VC selected This
                               bit will override VCSEL if selected
                            */
    UINT32 hdsel : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* 0: Data Queue selected 1: Header Queue selected */
    UINT32 qmsel : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               00: Transaction Bandwidth Measurement. Counts
                               data payload in dwords going in the direction
                               programmed (RxTx, FC, VC, Port) 01: FIFO Queue
                               Histogram Measurement. Uses the queue depth.
                               (RxTx, FC, VC, Port, Hdr/Data) 10: Credit
                               Consumed Histogram Measurement. Uses the credit
                               consumed count. (RxTx, FC, VC, Port, Hdr/Data)
                               11: Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lnkutil : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Link Utilization field counts clocks that a port
                               is receiving data and checking for receiver
                               errors. It is used to calculate link
                               reliability. If one counter counts receiver
                               errors and another counter counts the cycles the
                               port was checking for receiver error, a bit
                               error rate can be calculated. 0000: No event
                               selected 1000: Port 3 of 4, where applicable
                               (DSPs only) 0100: Port 2 of 4, where applicable
                               (DSPs only) 0010: Port 1 of 4, where applicable
                               (DSPs only) 0001: Port 0 of 4 (USP, DSPs,
                               vSP/vRP) If multiple bits are set, each port
                               with a set bit will be counted (ie. you can
                               count the total traffic on all ports) For
                               configs with less then 4 ports, the upper bits
                               corresponding to non-existent ports have no
                               effect.
                            */
    UINT32 xprsca : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000000*/

                            /*
                               This selects which PCI-Express links are being
                               monitored and against with XPPMEVL and XPPMEFH
                               match registers and the queue measure select
                               modes. A logic 1 selects that PCIe link for
                               monitoring. 1000: Select port 3 for monitoring.
                               0100: Select port 2 for monitoring. 0010: Select
                               port 1 for monitoring. 0001: Select port 0 for
                               monitoring. For header match, error counting,
                               queue measure, and bandwidth measure, the
                               perfmon will measure the sum of the events
                               across the ports. However, for the
                               TxL0s/RxL0s/L1 state selection, the select feeds
                               into the single bit PMER match wire of the
                               perfmon, and is affectively a 'wire-OR' of the
                               selected ports, and thus edges, cycles counted
                               by perfmon are on the wire-OR signal and not the
                               sum of the events per port.
                            */
    UINT32 rxl0su : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               0: No rx_l0s utilization selected 1: Enable
                               rx_l0s utilization counting
                            */
    UINT32 txl0su : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               0: No tx_l0s utilization selected 1: Enable
                               tx_l0s utilization counting
                            */
    UINT32 cntcerr : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               correctable errors by the perfmon counter. Only
                               correctable errors that are not masked by the
                               ERRCORDETMSK register are counted. Errors are
                               counted on the ports enabled by the XPRSCA field
                               in this register.
                            */
    UINT32 cntucerr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               uncorrectable errors by the perfmon counter.
                               Only uncorrectable errors that are not masked by
                               the ERRUNCDETMSK register are counted. Errors
                               are counted on the ports enabled by the XPRSCA
                               field in this register.
                            */
    UINT32 l1sue : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               0: No L1 state utilization selected 1: Enable L1
                               state utilization counting XPPMR.CNTMD could be
                               utilized to count the rising edge for acquiring
                               number of times L1 is entered if desirable.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMER0_IIO_CXL_STRUCT;

/* XPPMER1_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x200005b0)                                                      */
/*      SPRB0 (0x200005b0)                                                      */
/*      SPRHBM (0x200005b0)                                                     */
/*      SPRC0 (0x200005b0)                                                      */
/*      SPRMCC (0x200005b0)                                                     */
/*      SPRUCC (0x200005b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is used to select queuing structures for measurement. Use of this event register is mutually exclusive with the XPPMEVL,H registers. The Event Register Select field in the PMR register must select this register for to enable monitoring operations of the queues.
*/


#define XPPMER1_IIO_CXL_REG 0x230205B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrxsel : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects a Tx/Rx queue to monitor.
                               Either receiver or transmit direction for
                               measurement. 1x: Transmit x1: Receive (from PCIe
                               bus) 11: Either Transmit or Receive direction
                            */
    UINT32 fccsel : 3;

                            /* Bits[4:2], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which flow class for resource
                               event xx1: Posted x1x: Non-Posted 1xx:
                               Completion
                            */
    UINT32 vcsel : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects which VC to count. Only one
                               VC can be counted at a time.
                            */
    UINT32 avcsel : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               0: Not all VC selected 1: All VC selected This
                               bit will override VCSEL if selected
                            */
    UINT32 hdsel : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* 0: Data Queue selected 1: Header Queue selected */
    UINT32 qmsel : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               00: Transaction Bandwidth Measurement. Counts
                               data payload in dwords going in the direction
                               programmed (RxTx, FC, VC, Port) 01: FIFO Queue
                               Histogram Measurement. Uses the queue depth.
                               (RxTx, FC, VC, Port, Hdr/Data) 10: Credit
                               Consumed Histogram Measurement. Uses the credit
                               consumed count. (RxTx, FC, VC, Port, Hdr/Data)
                               11: Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 lnkutil : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Link Utilization field counts clocks that a port
                               is receiving data and checking for receiver
                               errors. It is used to calculate link
                               reliability. If one counter counts receiver
                               errors and another counter counts the cycles the
                               port was checking for receiver error, a bit
                               error rate can be calculated. 0000: No event
                               selected 1000: Port 3 of 4, where applicable
                               (DSPs only) 0100: Port 2 of 4, where applicable
                               (DSPs only) 0010: Port 1 of 4, where applicable
                               (DSPs only) 0001: Port 0 of 4 (USP, DSPs,
                               vSP/vRP) If multiple bits are set, each port
                               with a set bit will be counted (ie. you can
                               count the total traffic on all ports) For
                               configs with less then 4 ports, the upper bits
                               corresponding to non-existent ports have no
                               effect.
                            */
    UINT32 xprsca : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000000*/

                            /*
                               This selects which PCI-Express links are being
                               monitored and against with XPPMEVL and XPPMEFH
                               match registers and the queue measure select
                               modes. A logic 1 selects that PCIe link for
                               monitoring. 1000: Select port 3 for monitoring.
                               0100: Select port 2 for monitoring. 0010: Select
                               port 1 for monitoring. 0001: Select port 0 for
                               monitoring. For header match, error counting,
                               queue measure, and bandwidth measure, the
                               perfmon will measure the sum of the events
                               across the ports. However, for the
                               TxL0s/RxL0s/L1 state selection, the select feeds
                               into the single bit PMER match wire of the
                               perfmon, and is affectively a 'wire-OR' of the
                               selected ports, and thus edges, cycles counted
                               by perfmon are on the wire-OR signal and not the
                               sum of the events per port.
                            */
    UINT32 rxl0su : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               0: No rx_l0s utilization selected 1: Enable
                               rx_l0s utilization counting
                            */
    UINT32 txl0su : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               0: No tx_l0s utilization selected 1: Enable
                               tx_l0s utilization counting
                            */
    UINT32 cntcerr : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               correctable errors by the perfmon counter. Only
                               correctable errors that are not masked by the
                               ERRCORDETMSK register are counted. Errors are
                               counted on the ports enabled by the XPRSCA field
                               in this register.
                            */
    UINT32 cntucerr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit enables the counting of
                               uncorrectable errors by the perfmon counter.
                               Only uncorrectable errors that are not masked by
                               the ERRUNCDETMSK register are counted. Errors
                               are counted on the ports enabled by the XPRSCA
                               field in this register.
                            */
    UINT32 l1sue : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               0: No L1 state utilization selected 1: Enable L1
                               state utilization counting XPPMR.CNTMD could be
                               utilized to count the rising edge for acquiring
                               number of times L1 is entered if desirable.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPMER1_IIO_CXL_STRUCT;





/* XPPERFCON_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x200005c4)                                                      */
/*      SPRB0 (0x200005c4)                                                      */
/*      SPRHBM (0x200005c4)                                                     */
/*      SPRC0 (0x200005c4)                                                      */
/*      SPRMCC (0x200005c4)                                                     */
/*      SPRUCC (0x200005c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The XPPERFCON register is a local performance monitor control register used to clear all of the counters or to assign which XP (PCIe) device participates in the performance monitoring event. All perfmon blocks will needs this register.
We will perform ORing this register and global PERFCON from full chip for backup usage and self contained purpose.
*/


#define XPPERFCON_IIO_CXL_REG 0x230205C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 grst : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit to a logic 1 will reset the
                               following bit fields in all PerfMon blocks
                               throughout the component. xxxPMDx.CNT,
                               xxxPMR.OVS, xxxPMR.CMPSTAT, xxxPMCx.PMCx
                               registers, and count mode state latch selected
                               by xxxPMR.CNTMD = '01'. Where xxx is the cluster
                               prefix name. Note: Software must clear this bit
                               after setting it, otherwise the PerfMons remain
                               in a reset state.
                            */
    UINT32 gce : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is AND'ed with the PMR.CENS mux enable
                               selection. 0: Disable all counters. 1: Enable
                               local selection of CENS.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} XPPERFCON_IIO_CXL_STRUCT;

/* XPPERFSTAT_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x5c8)                                                           */
/*      SPRB0 (0x5c8)                                                           */
/*      SPRHBM (0x5c8)                                                          */
/*      SPRC0 (0x5c8)                                                           */
/*      SPRMCC (0x5c8)                                                          */
/*      SPRUCC (0x5c8)                                                          */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Performance Monitor Local Status
*/


#define XPPERFSTAT_IIO_CXL_REG 0x230005C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 xppm0stat : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates the status of PM0 from either
                               the compare or overflow status. This is bit is
                               cleared by writing a '1'.
                            */
    UINT8 xppm1stat : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This bit indicates the status of PM0 from either
                               the compare or overflow status. This is bit is
                               cleared by writing a '1'.
                            */
    UINT8 rsvd : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} XPPERFSTAT_IIO_CXL_STRUCT;





/* XPHMSK0_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000710)                                                      */
/*      SPRB0 (0x20000710)                                                      */
/*      SPRHBM (0x20000710)                                                     */
/*      SPRC0 (0x20000710)                                                      */
/*      SPRMCC (0x20000710)                                                     */
/*      SPRUCC (0x20000710)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Each XP cluster will support one Header Match DFx feature. One match and mask register contains bit that are equivalent to the PCIe header for a 64bit addressing mode. When the interface is operating in 32-bit addressing mode then the user must program the registers appropriately. In other words the mapping between the header and the bits in the register is a physical mapping rather than a logic mapping.
The header bits to be used in matching are selected by the mask bits in this register. A zero in a mask bit position causes the corresponding bit in the header to be ignored. A one in a mask bit position indicates that the corresponding bit in the header must match the value of the same bit in the Match register for that bit to be considered to have matched. Pattern match out is asserted only if all enabled bit match (AND matching). If all mask bits are 0, MatchOut is 0. Table below shows how the Match and Mask operators generate a MatchOut assertion on a bit-by-bit basis.
Mask and Match Operational Table
*/


#define XPHMSK0_IIO_CXL_REG 0x23020710

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt0 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte0 */
    UINT32 hmskbyt1 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte1 */
    UINT32 hmskbyt2 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte2 */
    UINT32 hmskbyt3 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte3 */

  } Bits;
  UINT32 Data;

} XPHMSK0_IIO_CXL_STRUCT;

/* XPHMSK1_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000714)                                                      */
/*      SPRB0 (0x20000714)                                                      */
/*      SPRHBM (0x20000714)                                                     */
/*      SPRC0 (0x20000714)                                                      */
/*      SPRMCC (0x20000714)                                                     */
/*      SPRUCC (0x20000714)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK1_IIO_CXL_REG 0x23020714

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt4 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte4 */
    UINT32 hmskbyt5 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte5 */
    UINT32 hmskbyt6 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte6 */
    UINT32 hmskbyt7 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte7 */

  } Bits;
  UINT32 Data;

} XPHMSK1_IIO_CXL_STRUCT;

/* XPHMSK2_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000718)                                                      */
/*      SPRB0 (0x20000718)                                                      */
/*      SPRHBM (0x20000718)                                                     */
/*      SPRC0 (0x20000718)                                                      */
/*      SPRMCC (0x20000718)                                                     */
/*      SPRUCC (0x20000718)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK2_IIO_CXL_REG 0x23020718

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt8 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte8 */
    UINT32 hmskbyt9 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte9 */
    UINT32 hmskbyt10 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte10 */
    UINT32 hmskbyt11 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte11 */

  } Bits;
  UINT32 Data;

} XPHMSK2_IIO_CXL_STRUCT;

/* XPHMSK3_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x2000071c)                                                      */
/*      SPRB0 (0x2000071c)                                                      */
/*      SPRHBM (0x2000071c)                                                     */
/*      SPRC0 (0x2000071c)                                                      */
/*      SPRMCC (0x2000071c)                                                     */
/*      SPRUCC (0x2000071c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the mask bits to determine which fields of bits the match register is effective.
*/


#define XPHMSK3_IIO_CXL_REG 0x2302071C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmskbyt12 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte12 */
    UINT32 hmskbyt13 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte13 */
    UINT32 hmskbyt14 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte14 */
    UINT32 hmskbyt15 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header mask byte15 */

  } Bits;
  UINT32 Data;

} XPHMSK3_IIO_CXL_STRUCT;

/* XPHMAT0_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000720)                                                      */
/*      SPRB0 (0x20000720)                                                      */
/*      SPRHBM (0x20000720)                                                     */
/*      SPRC0 (0x20000720)                                                      */
/*      SPRMCC (0x20000720)                                                     */
/*      SPRUCC (0x20000720)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Least Significant Dword (LSDW) of a 128-bit match register that is used to compare inbound transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions. The output of the match logic is connected to XP[7,3,0]CTO0.
*/


#define XPHMAT0_IIO_CXL_REG 0x23020720

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt0 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte0 */
    UINT32 hmatbyt1 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte1 */
    UINT32 hmatbyt2 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte2 */
    UINT32 hmatbyt3 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte3 */

  } Bits;
  UINT32 Data;

} XPHMAT0_IIO_CXL_STRUCT;

/* XPHMAT1_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000724)                                                      */
/*      SPRB0 (0x20000724)                                                      */
/*      SPRHBM (0x20000724)                                                     */
/*      SPRC0 (0x20000724)                                                      */
/*      SPRMCC (0x20000724)                                                     */
/*      SPRUCC (0x20000724)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Least Significant +1 Dword (LSDW+1) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT1_IIO_CXL_REG 0x23020724

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt4 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte4 */
    UINT32 hmatbyt5 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte5 */
    UINT32 hmatbyt6 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte6 */
    UINT32 hmatbyt7 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte7 */

  } Bits;
  UINT32 Data;

} XPHMAT1_IIO_CXL_STRUCT;

/* XPHMAT2_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000728)                                                      */
/*      SPRB0 (0x20000728)                                                      */
/*      SPRHBM (0x20000728)                                                     */
/*      SPRC0 (0x20000728)                                                      */
/*      SPRMCC (0x20000728)                                                     */
/*      SPRUCC (0x20000728)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Most Significant -1 Dword (MSDW-1) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT2_IIO_CXL_REG 0x23020728

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt8 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte8 */
    UINT32 hmatbyt9 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte9 */
    UINT32 hmatbyt10 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte10 */
    UINT32 hmatbyt11 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte11 */

  } Bits;
  UINT32 Data;

} XPHMAT2_IIO_CXL_STRUCT;

/* XPHMAT3_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x2000072c)                                                      */
/*      SPRB0 (0x2000072c)                                                      */
/*      SPRHBM (0x2000072c)                                                     */
/*      SPRC0 (0x2000072c)                                                      */
/*      SPRMCC (0x2000072c)                                                     */
/*      SPRUCC (0x2000072c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register contains the Most Significant Dword (MSDW) of a 128-bit match register that is used to compare transactions finding a unique match. This register is used with the mask register to produced ranges of searches for particular types of transactions.
*/


#define XPHMAT3_IIO_CXL_REG 0x2302072C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hmatbyt12 : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte12 */
    UINT32 hmatbyt13 : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte13 */
    UINT32 hmatbyt14 : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte14 */
    UINT32 hmatbyt15 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000000*/

                            /* Header match byte15 */

  } Bits;
  UINT32 Data;

} XPHMAT3_IIO_CXL_STRUCT;

/* XPTRIGSEL_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x10000730)                                                      */
/*      SPRB0 (0x10000730)                                                      */
/*      SPRHBM (0x10000730)                                                     */
/*      SPRC0 (0x10000730)                                                      */
/*      SPRMCC (0x10000730)                                                     */
/*      SPRUCC (0x10000730)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The name 'IP' in this reference refers to the PCIe Ports as a whole, meaning transaction, link, and physical layers. There is one register defined for the upstream PCIe port, one for each downstream PCIe x16 port, and one for the virtual switch/root port.
*/


#define XPTRIGSEL_IIO_CXL_REG 0x23010730

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ipt0sel : 4;

                            /* Bits[3:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt1sel : 4;

                            /* Bits[7:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt2sel : 4;

                            /* Bits[11:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */
    UINT16 ipt3sel : 4;

                            /* Bits[15:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Selects the trigger source within the cluster.
                               0000: Mask and Match 64 0001: Header Match Rx
                               0010: PerfMon 0 0011: PerfMon 1 0100: LTSSM0
                               TrackerSel 0101: LTSSM1 TrackerSel 0110: LTSSM2
                               TrackerSel 0111: LTSSM3 TrackerSel 1000: Header
                               Match Tx 1001: Header Match Tx or Rx 1010-1111:
                               Reserved
                            */

  } Bits;
  UINT16 Data;

} XPTRIGSEL_IIO_CXL_STRUCT;









/* CAPSR_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000748)                                                      */
/*      SPRB0 (0x20000748)                                                      */
/*      SPRHBM (0x20000748)                                                     */
/*      SPRC0 (0x20000748)                                                      */
/*      SPRMCC (0x20000748)                                                     */
/*      SPRUCC (0x20000748)                                                     */
/* Register default value on SPRA0: 0x00054041                                  */
/* Register default value on SPRB0: 0x00054041                                  */
/* Register default value on SPRHBM: 0x00054041                                 */
/* Register default value on SPRC0: 0x00054041                                  */
/* Register default value on SPRMCC: 0x00054041                                 */
/* Register default value on SPRUCC: 0x00054041                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Capability Shadowed
*/


#define CAPSR_IIO_CXL_REG 0x23020748

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pmcsr_nsr : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding PMCSR.NSR once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 msixctl_ts : 11;

                            /* Bits[11:1], Access Type=RW/P, default=0x00000020*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding MSIXCTL.TS once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_egc : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.EGC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_ecc : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.ECC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 aercapctl_ctphlc : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding AERCAPCTL.CPTHLC
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linkctl_ecpm : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKCTL.ECPM once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linksts_scc : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKSTS.SCC once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 linkctl2_sd : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding LINKCTL2.SD once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 msictl_pvm : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding MSICTL.PVM once
                               this field was written. This field should be
                               treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 g5sts_txprecreq : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is utilized for Platform aware
                               Software to program the value based on
                               platform/device specific. Hardware will reflect
                               the value to the corresponding G5STS.TXPREREQ
                               once this field was written. This field should
                               be treated as reserved if not supported by
                               project/device specific.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CAPSR_IIO_CXL_STRUCT;



/* CORERRCNTMSK_IIO_CXL_REG supported on:                                       */
/*      SPRA0 (0x20000760)                                                      */
/*      SPRB0 (0x20000760)                                                      */
/*      SPRHBM (0x20000760)                                                     */
/*      SPRC0 (0x20000760)                                                      */
/*      SPRMCC (0x20000760)                                                     */
/*      SPRUCC (0x20000760)                                                     */
/* Register default value on SPRA0: 0x0000F1C1                                  */
/* Register default value on SPRB0: 0x0000F1C1                                  */
/* Register default value on SPRHBM: 0x0000F1C1                                 */
/* Register default value on SPRC0: 0x0000F1C1                                  */
/* Register default value on SPRMCC: 0x0000F1C1                                 */
/* Register default value on SPRUCC: 0x0000F1C1                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Counter Mask
*/


#define CORERRCNTMSK_IIO_CXL_REG 0x23020760

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rem : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /* Link receiver error counter mask. */
    UINT32 rsvd : 5;

                            /* Bits[5:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 btlpem : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000001*/

                            /* Link bad TLP error counter mask. */
    UINT32 bdllpem : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000001*/

                            /* Link bad DLLP error counter mask. */
    UINT32 rnrem : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /* Link replay number rollover error counter mask */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rttem : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000001*/

                            /* Link replay timer timeout error counter mask. */
    UINT32 anfem : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /* Link advisory non-fatal error counter mask. */
    UINT32 ciem : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /* Correctable internal error counter mask. */
    UINT32 hloem : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Header log overflow error counter mask. */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORERRCNTMSK_IIO_CXL_STRUCT;

/* CORERRCNT_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000764)                                                      */
/*      SPRB0 (0x20000764)                                                      */
/*      SPRHBM (0x20000764)                                                     */
/*      SPRC0 (0x20000764)                                                      */
/*      SPRMCC (0x20000764)                                                     */
/*      SPRUCC (0x20000764)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Counter
*/


#define CORERRCNT_IIO_CXL_REG 0x23020764

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errcnt : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Link correctable error counter. 1. A Correctable
                               Error Counter Mask register controls which
                               errors contribute to the counter. a. Masked
                               errors (mask=1) do not contribute to the counter
                               2. Logic is in parallel to AER Correctable mask
                               and reporting. a. Correctable Errors masked by
                               AER Correctable Error Mask can contribute to the
                               counter if unmasked in Correctable Error Counter
                               Mask b. This provides the ability to have
                               certain errors be counted and certain errors
                               generate messages always.
                            */

  } Bits;
  UINT32 Data;

} CORERRCNT_IIO_CXL_STRUCT;

/* CORERRTH_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000768)                                                      */
/*      SPRB0 (0x20000768)                                                      */
/*      SPRHBM (0x20000768)                                                     */
/*      SPRC0 (0x20000768)                                                      */
/*      SPRMCC (0x20000768)                                                     */
/*      SPRUCC (0x20000768)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Correctable Error Threshold
*/


#define CORERRTH_IIO_CXL_REG 0x23020768

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errth : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Link correctable error threshold. Non zero
                               threshold value enables the correctable error
                               counter. When the Correctable Error Counter is
                               enabled, an internal ERR_COR message is
                               generated when the counter becomes equal to
                               threshold. If threshold is 15 and count is 14,
                               the next correctable error generates 1
                               Correctable error message. Same holds true for
                               count and threshold of 0xFFFFFFFF.
                               CORERRCNT.ERRCNT would be saturated, i.e. stops
                               counting at 0xFFFFFFFF accordingly.
                            */

  } Bits;
  UINT32 Data;

} CORERRTH_IIO_CXL_STRUCT;











/* PTMGTECSR_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000794)                                                      */
/*      SPRB0 (0x20000794)                                                      */
/*      SPRHBM (0x20000794)                                                     */
/*      SPRC0 (0x20000794)                                                      */
/*      SPRMCC (0x20000794)                                                     */
/*      SPRUCC (0x20000794)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* PTM Global Time Extended Control Status
*/


#define PTMGTECSR_IIO_CXL_REG 0x23020794

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 iosfmadp : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               This register determine the MAD field of the
                               SyncStartCmd IOSF Sideband message when the Root
                               Port is requesting for the Global Time. Bits
                               Status 0000 Bound Range Low 0001 Bound Range 2
                               0010 Bound Range Max others reserved.
                            */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tgtscf : 1;

                            /* Bits[8:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               When this bit is set, the Controller will re-
                               fetch the Global Time from the Always Running
                               Unit (ARU) if no fetch is currently already in
                               progress. Once the fetch is completed, the
                               Controller will update the Local TSC with the
                               newly fetch Global Time. The local time is
                               invalidated while the re-fetch is in progress,
                               and any PTMs will receive a response without
                               data until the new time fetch is complete.
                               Hardware would clear this bit upon completed
                               fetching the Global Time. Software can only set
                               this register if PGTSCFE is not set.
                            */
    UINT32 pgtscfe : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit set, the Controller will re-fetch
                               the Global Time from the Always Running Unit
                               (ARU) depending on the frequency determined by
                               the PGTSCFF. Once Fetch is completed, the
                               Controller would update all the Local TSC with
                               the newly fetch Global Time. This register would
                               only take effect after the PTME register is set.
                               Software can only set this register if TGTSCF is
                               not set.
                            */
    UINT32 pgtscff : 3;

                            /* Bits[12:10], Access Type=RW, default=0x00000000*/

                            /*
                               This field determine the frequency that the Root
                               Port would autonomously update the Local TSC by
                               re-fetch the Global Time Stamp Counter. This
                               register determine the bit rollover on the Local
                               TSC in Crystal Oscillator counters. Bits MSB
                               Selection 000 Bit[10] of the Crystal Oscillator
                               Local TSC 001 Bit[12] of the Crystal Oscillator
                               Local TSC 010 Bit[14] of the Crystal Oscillator
                               Local TSC 011 Bit[16] of the Crystal Oscillator
                               Local TSC 100 Bit[18] of the Crystal Oscillator
                               Local TSC 101 Bit[20] of the Crystal Oscillator
                               Local TSC 110 Bit[22] of the Crystal Oscillator
                               Local TSC 111 Bit[24] of the Crystal Oscillator
                               Local TSC This setting would cause a Local TSC
                               refresh on every: Bits MSB Selection 000 1 us
                               (Not Applicable) 001 4 us 010 16 us 011 64 us
                               100 256 us 101 1 ms 110 4 ms 111 16 ms Software
                               is expected to program this field first before
                               programming the PGTSCFE register.
                            */
    UINT32 gtfspc : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /*
                               This register is set to 1 by the Root Port when
                               it is in progress of fetching the Global Time
                               from ARU.
                            */
    UINT32 gtffc : 2;

                            /* Bits[15:14], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This register is incremented when the Root Port
                               detected a fail on each Global Time Fetch on
                               IOSF Sideband. The Root Port would increment the
                               value of this register whenever ARU sends a
                               SyncComp with the Fail status. If more than 3
                               failures are detected in the Global Time Fetch,
                               Root Port would keep the value of this register
                               to '11' (max) value. Software is expected to
                               write '11' to this register to clear the entire
                               field to 0.
                            */
    UINT32 mtsv : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               When this valid bit is set, the real-time master
                               time stamp values (PTMLLRMT, PTMULRMT) contain
                               good data. When the valid bit is cleared, the
                               contents of the real-time master time stamp
                               fields are undefined. Hardware clears the valid
                               bit when the trigger bit is set.
                            */
    UINT32 rsvd_17 : 7;

                            /* Bits[23:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 gtffe : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               GTFFE=0 Normal operation. When set to 1 to
                               enable Global Time Fetch Freeze and can be
                               utilized in conjunction with PTMLLMT, PTMULMT,
                               and PTMPD status registers for PTM debug.
                            */
    UINT32 gtffp : 2;

                            /* Bits[26:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               GTFFE=1, GTFFP=00 Disable capturing Master Time
                               and Propagation Delay information from PTM
                               dialogs GTFFE=1, GTFFP=01 Capture Master Time
                               from the next PTM_REQUEST, then disable
                               capturing Master Time and Propagation Delay
                               information from subsequent PTM dialogs GTFFE=1,
                               GTFFP=1x Capture Master Time and Propagation
                               Delay from the next PTM_REQUEST, then disable
                               capturing Master Time and Propagation Delay
                               information from subsequent PTM dialogs
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTMGTECSR_IIO_CXL_STRUCT;












/* IALPMMCTL_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x200007d0)                                                      */
/*      SPRB0 (0x200007d0)                                                      */
/*      SPRHBM (0x200007d0)                                                     */
/*      SPRC0 (0x200007d0)                                                      */
/*      SPRMCC (0x200007d0)                                                     */
/*      SPRUCC (0x200007d0)                                                     */
/* Register default value on SPRA0: 0x48008086                                  */
/* Register default value on SPRB0: 0x48008086                                  */
/* Register default value on SPRHBM: 0x48008086                                 */
/* Register default value on SPRC0: 0x48008086                                  */
/* Register default value on SPRMCC: 0x48008086                                 */
/* Register default value on SPRUCC: 0x48008086                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* IAL PM Message Control
*/


#define IALPMMCTL_IIO_CXL_REG 0x230207D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vid : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x00008086*/

                            /* Vendor ID for IAL PM Message. */
    UINT32 st : 8;

                            /* Bits[23:16], Access Type=RW/P, default=0x00000000*/

                            /* Subtype for IAL PM Message. */
    UINT32 vmeb15 : 8;

                            /* Bits[31:24], Access Type=RW/P, default=0x00000048*/

                            /*
                               Byte 15, vendor message encoding, must be
                               programmable and default to a value of
                               0100_1000b
                            */

  } Bits;
  UINT32 Data;

} IALPMMCTL_IIO_CXL_STRUCT;



/* FCCRDSSCTL_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000880)                                                      */
/*      SPRB0 (0x20000880)                                                      */
/*      SPRHBM (0x20000880)                                                     */
/*      SPRC0 (0x20000880)                                                      */
/*      SPRMCC (0x20000880)                                                     */
/*      SPRUCC (0x20000880)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Snapshot Control
*/


#define FCCRDSSCTL_IIO_CXL_REG 0x23020880

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 flow_class : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /* 00 = Posted 01 = Non-Posted 10 = Completion */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 virtual_channel : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               The virtual channel to select (VC0-VC7). In
                               addition, this field could be optional expanded
                               and associated with Credit Throttling registers
                               per VC, however it's implementation specific
                            */
    UINT32 freeze_cnt : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, it freezes the counts in the credit
                               observability registers. If the bit is clear,
                               the counts continuously update.
                            */
    UINT32 rsvd_8 : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDSSCTL_IIO_CXL_STRUCT;

/* FCCRDLSS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000884)                                                      */
/*      SPRB0 (0x20000884)                                                      */
/*      SPRHBM (0x20000884)                                                     */
/*      SPRC0 (0x20000884)                                                      */
/*      SPRMCC (0x20000884)                                                     */
/*      SPRUCC (0x20000884)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Limit Snapshot
*/


#define FCCRDLSS_IIO_CXL_REG 0x23020884

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 12;

                            /* Bits[11:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfd : 1;

                            /* Bits[12:12], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Data of flow class specified in FCCRDSSCTL.
                               May not be valid until FCCRDSSCTL.FREEZE_CNT is
                               written.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hss : 8;

                            /* Bits[23:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfh : 1;

                            /* Bits[24:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Header of flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hs : 2;

                            /* Bits[26:25], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Gen4 FC Header Credit Scale for flow class
                               specified in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 ds : 2;

                            /* Bits[28:27], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Gen4 FC Data Credit Scale for flow class
                               specified in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDLSS_IIO_CXL_STRUCT;

/* FCCRDASS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000888)                                                      */
/*      SPRB0 (0x20000888)                                                      */
/*      SPRHBM (0x20000888)                                                     */
/*      SPRC0 (0x20000888)                                                      */
/*      SPRMCC (0x20000888)                                                     */
/*      SPRUCC (0x20000888)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Allocated Snapshot
*/


#define FCCRDASS_IIO_CXL_REG 0x23020888

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 icfd : 1;

                            /* Bits[16:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Data of flow class specified in FCCRDSSCTL.
                               May not be valid until FCCRDSSCTL.FREEZE_CNT is
                               written.
                            */
    UINT32 hss : 12;

                            /* Bits[28:17], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 icfh : 1;

                            /* Bits[29:29], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set, it advertises infinite credits flag
                               for Header of flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDASS_IIO_CXL_STRUCT;

/* FCCRDCSS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x2000088c)                                                      */
/*      SPRB0 (0x2000088c)                                                      */
/*      SPRHBM (0x2000088c)                                                     */
/*      SPRC0 (0x2000088c)                                                      */
/*      SPRMCC (0x2000088c)                                                     */
/*      SPRUCC (0x2000088c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Consumed Snapshot
*/


#define FCCRDCSS_IIO_CXL_REG 0x2302088C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hss : 12;

                            /* Bits[27:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDCSS_IIO_CXL_STRUCT;

/* FCCRDRSS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000890)                                                      */
/*      SPRB0 (0x20000890)                                                      */
/*      SPRHBM (0x20000890)                                                     */
/*      SPRC0 (0x20000890)                                                      */
/*      SPRMCC (0x20000890)                                                     */
/*      SPRUCC (0x20000890)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Note: The credit_allocated and credit_received counters in the RTL are only big enough to cover the size of the max credits advertised. The values displayed in those credit registers will not have the full 8 bit header, 12 bit data counts. Some of the upper bits will be zeroed out.
*/


#define FCCRDRSS_IIO_CXL_REG 0x23020890

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dss : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Data Credit Limit for flow class specified in
                               FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 hss : 12;

                            /* Bits[27:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               FC Header Credit Limit for flow class specified
                               in FCCRDSSCTL. May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCCRDRSS_IIO_CXL_STRUCT;

/* FCCRDDSS_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000894)                                                      */
/*      SPRB0 (0x20000894)                                                      */
/*      SPRHBM (0x20000894)                                                     */
/*      SPRC0 (0x20000894)                                                      */
/*      SPRMCC (0x20000894)                                                     */
/*      SPRUCC (0x20000894)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* FC Credit Difference Snapshot
*/


#define FCCRDDSS_IIO_CXL_REG 0x23020894

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdd : 8;

                            /* Bits[7:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Rx data credit
                               allocated (FCCRDASS) and data credit received
                               counts (FCCRDRSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 rhd : 8;

                            /* Bits[15:8], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Rx header credit
                               allocated (FCCRDASS) and header credit received
                               counts (FCCRDRSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written. The hdr
                               credits captured are the txn layer counts. These
                               may be different (scaling - 1) from the link due
                               to credit scaling is activated. For instance,
                               the txn layer allocated 223 credits, however,
                               the link layer could only advertise 220 because
                               it could only use the scale factor of 4.
                            */
    UINT32 tdd : 8;

                            /* Bits[23:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Tx data credit
                               limit (FCCRDLSS) and data credit consumed counts
                               (FCCRDCSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */
    UINT32 thd : 8;

                            /* Bits[31:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               This is the difference in the Tx header credit
                               limit (FCCRDLSS) and header credit consumed
                               counts (FCCRDCSS). May not be valid until
                               FCCRDSSCTL.FREEZE_CNT is written.
                            */

  } Bits;
  UINT32 Data;

} FCCRDDSS_IIO_CXL_STRUCT;





/* XPTDEF5_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x100008d2)                                                      */
/*      SPRB0 (0x100008d2)                                                      */
/*      SPRHBM (0x100008d2)                                                     */
/*      SPRC0 (0x100008d2)                                                      */
/*      SPRMCC (0x100008d2)                                                     */
/*      SPRUCC (0x100008d2)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PCI-Express Transaction Layer Defeature Register 5
*/


#define XPTDEF5_IIO_CXL_REG 0x230108D2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 sairstpd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               This bit disables local TLP Prefix for SAI/RS
                               generation onto the attached link. Clearing this
                               bit enables sending the local SAI/RS TLP Prefix
                               onto the attached link. Setting this bit will
                               block sending the local SAI/RS TLP Prefix on the
                               link. This bit does not affect how the local
                               SAI/RS TLP Prefix is handled on the receive
                               side. This is only supported in DMI and IAL.io
                               DP. It should be treated as reserved if not
                               applicable. TLP Prefix generation is disabled in
                               IAL.io DP, and enabled in IAL.io UP and DMI as
                               default.
                            */
    UINT16 reco : 15;

                            /* Bits[15:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is reserved for ECO or scratch
                               purpose.
                            */

  } Bits;
  UINT16 Data;

} XPTDEF5_IIO_CXL_STRUCT;

/* XPTDEF6_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x100008d4)                                                      */
/*      SPRB0 (0x100008d4)                                                      */
/*      SPRHBM (0x100008d4)                                                     */
/*      SPRC0 (0x100008d4)                                                      */
/*      SPRMCC (0x100008d4)                                                     */
/*      SPRUCC (0x100008d4)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PCI-Express Transaction Layer Defeature Register 6
*/


#define XPTDEF6_IIO_CXL_REG 0x230108D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 enqd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               When this bit is cleared, ENQ is sent downstream
                               instead of generating a UR. Setting this bit
                               disables forwarding ENQ downstream. This is only
                               supported in PCIe Gen5 RPs and IAL.io DP. ENQ is
                               disabled by default and should be treated as
                               reserved if not applicable.
                            */
    UINT16 reco : 15;

                            /* Bits[15:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is reserved for ECO or scratch
                               purpose.
                            */

  } Bits;
  UINT16 Data;

} XPTDEF6_IIO_CXL_STRUCT;


/* PT0TXNCLKGCTL_IIO_CXL_REG supported on:                                      */
/*      SPRA0 (0x100008e4)                                                      */
/*      SPRB0 (0x100008e4)                                                      */
/*      SPRHBM (0x100008e4)                                                     */
/*      SPRC0 (0x100008e4)                                                      */
/*      SPRMCC (0x100008e4)                                                     */
/*      SPRUCC (0x100008e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 Transaction Clock Gate Control
*/


#define PT0TXNCLKGCTL_IIO_CXL_REG 0x230108E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0TXNCLKGCTL_IIO_CXL_STRUCT;


/* TXCRSTOCTL_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x200008f0)                                                      */
/*      SPRB0 (0x200008f0)                                                      */
/*      SPRHBM (0x200008f0)                                                     */
/*      SPRC0 (0x200008f0)                                                      */
/*      SPRMCC (0x200008f0)                                                     */
/*      SPRUCC (0x200008f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* Transmit Timeout and Configuration Retry Timeout
*/


#define TXCRSTOCTL_IIO_CXL_REG 0x230208F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txtofcen : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               When a TLP reaches the top of the transmit queue
                               and met all ordering requirements, different
                               resources may block the TLP from being
                               sent/processed. This field enables a transmit
                               timeout timer per class to allow status and
                               further action should a TLP be blocked from
                               sending for a long time. Bit 0 enables the timer
                               for the posted flow class. Bit 1 enables the
                               timer for the non-posted flow class. Bit 2
                               enables the timer for the completion flow class.
                            */
    UINT32 txnpctodis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               When completion timeout is enabled, if a non-
                               posted request cannot be sent due to credits and
                               there are no outstanding non-posted requests, a
                               timer will start and time out the request if it
                               is not sent before the programmed completion
                               timer value is reached. Setting this bit
                               disables the timer and blocks the timeout. The
                               transmit timeout functionality in this register
                               runs in parallel and may timeout the non-posted
                               request using the transmit timeout value, even
                               if this bit disables the request timeout due to
                               the completion timeout expiration.
                            */
    UINT32 txtov : 4;

                            /* Bits[7:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is the encoded range for the transmit
                               timeout counter. The timer is used for each flow
                               class. 0 65us to 98us 1 131us to 196us 2 262us
                               to 393us 3 524us to 786us 4 1ms to 1.6ms 5 2ms
                               to 3ms 6 4ms to 6ms 7 8ms to 12ms 8 16ms to 25ms
                               9 33ms to 50ms 10 67ms to 100ms 11 134ms to
                               201ms 12 268ms to 402ms 13 536ms to 805ms 14 1s
                               to 1.6s 15 2s to 3s
                            */
    UINT32 txtouren : 3;

                            /* Bits[10:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               These bits enable the transmitter to treat a TLP
                               that has timed out by the transmit timeout
                               mechanism as an unsupported request. For posted
                               and completions, the TLP is silently dropped.
                               For non-posted, a completion with UR status is
                               synthesized and returned.
                            */
    UINT32 txtolden : 3;

                            /* Bits[13:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               These bits enable a transmit timeout to trigger
                               a link down. When the link goes down, any
                               requests blocked by external credits will be
                               completed following the normal link down
                               handling. Once the packet that caused the
                               timeout is processed, the link will be allowed
                               to retrain.
                            */
    UINT32 txtostr : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Once a transaction times out, it is expected
                               that the following transactions will also time
                               out. Therefore, the default handling is to use
                               the transmit timeout status bits to UR requests
                               or keep the link down until the status bits are
                               cleared. Setting this bit changes that behavior
                               so the timed out transaction will UR or bring
                               the link down, but following transaction will
                               need to timeout before being handled by the
                               timeout logic. Note that link down will drop
                               and/or UR packets until the link retrains.
                            */
    UINT32 crs_to_dis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               If a configuration request is retried for more
                               than the timeout specified by CRSRT.CRSRTV, the
                               targeted device is determined to be broken, and
                               a completion with unsupported request is
                               returned. Setting this bit disables the retry
                               timeout, allowing the retries to occur forever.
                            */
    UINT32 txtosts : 3;

                            /* Bits[18:16], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This field indicates a request or completion
                               could not be sent or processed before the
                               transmit timeout timer has expired. Bit 0 is for
                               the posted flow class. Bit 1 is for the non-
                               posted flow class. Bit 2 is for the completion
                               flow class.
                            */
    UINT32 txnpctosts : 1;

                            /* Bits[19:19], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set if a non-posted request cannot
                               be sent and the completion timeout mechanism
                               triggered a UR completion.
                            */
    UINT32 crs_to_sts : 1;

                            /* Bits[20:20], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is set if a configuration request is
                               retried for more than the timeout specified by
                               CRSRT.CRSRTV, dependently of the configuration
                               retry timeout disable.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TXCRSTOCTL_IIO_CXL_STRUCT;


/* XPTDEF2_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x200008f8)                                                      */
/*      SPRB0 (0x200008f8)                                                      */
/*      SPRHBM (0x200008f8)                                                     */
/*      SPRC0 (0x200008f8)                                                      */
/*      SPRMCC (0x200008f8)                                                     */
/*      SPRUCC (0x200008f8)                                                     */
/* Register default value on SPRA0: 0x000C1D00                                  */
/* Register default value on SPRB0: 0x000C1D00                                  */
/* Register default value on SPRHBM: 0x000C1D00                                 */
/* Register default value on SPRC0: 0x000C1D00                                  */
/* Register default value on SPRMCC: 0x000C1D00                                 */
/* Register default value on SPRUCC: 0x000C1D00                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Lock Key bit is located in the Personality Lock Key Control Register (PLKCTL.TLCL).
*/


#define XPTDEF2_IIO_CXL_REG 0x230208F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 gblstopd : 1;

                            /* Bits[0:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               When the design detects an uncorrectable
                               internal error, a stop signal in the design
                               asserts, blocking the processing of transactions
                               in both directions in the transaction layer.
                               Setting this bit, disables the stop mechanism,
                               allowing the transactions to proceed as if no
                               error occurred. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 msixsmsgv : 1;

                            /* Bits[1:1], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit when set, causes only a single MSI-X
                               vector to be generated if MSI-X is enabled. This
                               bit affects the default value of the MSI-X Table
                               Size field Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 mctpdbc : 1;

                            /* Bits[2:2], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit will disable the Bus 0 check
                               for all MCTP VDM Type1 messages. MCTP will be
                               dropped in case of Bus Check failure. The check
                               is enabled by default as following: Upstream -
                               ReqBus =/= 0 Downstream RID - TgtBus =/= 0
                               Downstream BRC - ReqBus == 0 (RP only) Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 ucchkd : 1;

                            /* Bits[3:3], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit disables some optional
                               unexpected checks on completions. Specifically,
                               it disables the checking on the byte count and
                               lower address fields. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 crd : 1;

                            /* Bits[4:4], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Setting this bit disables the re-issuing of a
                               configuration request if the request is
                               completed with a configuration retry status
                               (CRS). The completion with CRS will be returned
                               to the requestor. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 cplcombine_d : 1;

                            /* Bits[5:5], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               When a larger read request is split into smaller
                               read requests, the completions for the small
                               requests may be opportunistically combined into
                               larger completions to enable higher bandwidth
                               and link utilization, as long as packet
                               formation rules are not violated. This bit
                               disables the port from combining completions.
                               Note: Lock Key bit is located in the Personality
                               Lock Key Control Register . This is only valid
                               for project specific .
                            */
    UINT32 msigenov : 1;

                            /* Bits[6:6], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               1: Enables Root Port MSI generation override
                               even if PCICMD.BME = 0 for the root port device
                               as required by PCI Express specification. 0:
                               Normal operation for Root Port behavior. If
                               PCICMD.BME = 0, the root port will not generate
                               a MSI. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . This is
                               only valid for project specific .
                            */
    UINT32 erco : 1;

                            /* Bits[7:7], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               The default ordering is to allow received
                               completions to pass received posted requests to
                               avoid receiver overflow conditions if posted
                               requests cannot be processed. Setting this bit
                               will enable PCI Express ordering for
                               completions, preventing completions from passing
                               posted requests. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                               This is only valid for project specific
                            */
    UINT32 evpid : 1;

                            /* Bits[8:8], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               1: Enables SB Virtual Port ID mode with
                               allocated VPIDs which is associated with ports
                               for all the egress INTx messages based on
                               project specific. We will assign <N-1> virtual
                               sideband PortID's to associate with the physical
                               PortID which is port 0. The physical one is the
                               same one as being assigned by the router as we
                               have now, and would be used for all non-INTx
                               messages and INTx messages from port 0. However,
                               the VPIDs would be used for INTx messages
                               routing from port<N-1:1>, respectively. This
                               allows all INTx from N ports to be forwarded to
                               the ILB accordingly, so ILB can differentiate
                               the source of the INTx message. 0: Normal
                               operation with single SB Port ID per cluster for
                               INTx delivery. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register . This
                               is only valid for project specific with multi
                               root ports.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mmbnce : 1;

                            /* Bits[10:10], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set, if the Requester ID bus number of an
                               MCTP message request received on the PCIe link
                               does not fall within the range between SCBN and
                               SBBN, the MCTP message will be silently
                               discarded. This is applicable to (v)RP for
                               security measure. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                            */
    UINT32 tcpar_chk_dis : 1;

                            /* Bits[11:11], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set this bit disables the command parity
                               check for incoming commands into the IOSF Target
                               block. The logic will ignore the command parity
                               bit and will operate as though the parity bit
                               did not exist. No errors will be logged and good
                               DW based parity will be written into the header
                               queue. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 tdpar_chk_dis : 1;

                            /* Bits[12:12], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               When set this bit disables the data parity check
                               for incoming data into the IOSF Target block.
                               The logic will ignore the data parity bit and
                               will operate as though the parity bit did not
                               exist. No errors will be logged and good DW
                               based parity will be written into the data
                               queue. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 uprodis : 1;

                            /* Bits[13:13], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disables the ability of upstream relaxed ordered
                               completions from passing posted requests in the
                               same direction. Note: Lock Key bit is located in
                               the Personality Lock Key Control Register .
                            */
    UINT32 dnrodis : 1;

                            /* Bits[14:14], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disables the ability of downstream relaxed
                               ordered completions from passing posted requests
                               in the same direction. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register .
                            */
    UINT32 forcerodn : 1;

                            /* Bits[15:15], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Forces all downstream completions to follow
                               relaxed ordering rules. This allows downstream
                               completions to pass downstream posted requests.
                               Note that setting this bit breaks the producer
                               consumer model when the data is in the address
                               space below the port and the flag is in the
                               address space outside the port, because the read
                               of the flag will not push the data writes down
                               the port. The belief is that usage model is not
                               used. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register .
                            */
    UINT32 msiavcd : 1;

                            /* Bits[16:16], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Disable MSI address violation check that does
                               not target 0xFEEx_xxxx. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This is only valid for RPs usage.
                            */
    UINT32 ecrcmfepd : 1;

                            /* Bits[17:17], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit changes the error precedence if a TLP
                               has both a ECRC error and is malform. When this
                               bit is set to 1, the packet will be logged as an
                               ECRC error. When set to 0, the packet will be
                               logged as a malform TLP, which is compliant to
                               the PCIe spec errata. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . Only the type of error logged is
                               affected. If the TLP is malform, it will be
                               dropped with no credit return. If there is only
                               an ECRC error detected on a packet, it will be
                               dropped and credits will be returned per PCI-SIG
                               Errata.
                            */
    UINT32 hrsrd : 1;

                            /* Bits[18:18], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               For Surprise Removal, EIP RPs will not allow
                               retrain to occur until the SLOTSTS.PDCS bit has
                               been cleared by software for the removal event.
                               This bit is to disable the above behavior and
                               allow the retrain to occur. Note: Lock Key bit
                               is located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 hrdllscsd : 1;

                            /* Bits[19:19], Access Type=RW/P/L, default=0x00000001*/

                            /*
                               EIP RPs will not allow retrain to occur until
                               the SLOTSTS.DLLSCS bit has been cleared by
                               software for the DL_Active event changed. This
                               bit is to disable the above behavior and allow
                               the retrain to occur. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This field is only applicable to RPs
                               and should be treated as reserved for other
                               devices.
                            */
    UINT32 hrhpid : 1;

                            /* Bits[20:20], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               EIP RPs will not allow retrain if hot plug
                               interrupts are enabled until SLOTSTS.PDCS or
                               SLOTSTS.DLLSCS bit has been cleared by software
                               for removal or DL_Active event changed. This bit
                               is to disable the above behavior and allow the
                               retrain to occur. Note: Lock Key bit is located
                               in the Personality Lock Key Control Register .
                               This field is only applicable to RPs and should
                               be treated as reserved for other devices.
                            */
    UINT32 recop : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               This field is reserved for ECO or scratch
                               purpose.
                            */
    UINT32 rsp : 1;

                            /* Bits[22:22], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               0 - When an inbound read is processed the read
                               splitting logic will only split the TLP up if it
                               is greater than the programmed MPS value in the
                               DEVCTL.MPS register field. When a transaction is
                               larger than the DEVCTL.MPS programming the split
                               will occur on DEVCTL.MPS address aligned values.
                               1 - When an inbound read is processed the read
                               splitting logic will split the TLP on address
                               boundaries determined by the programming of
                               DEVCTL.MPS. This will potentially lead to
                               transactions getting split that are smaller than
                               what is programmed in the DEVCTL.MPS. If the
                               request is not aligned to the programmed value
                               then the read splitting logic will split it up
                               so that it is aligned. Note: Lock Key bit is
                               located in the Personality Lock Key Control
                               Register . This is only valid for RPs usage.
                            */
    UINT32 reco : 8;

                            /* Bits[30:23], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This field is reserved for ECO purpose. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register . RECO[0] is assigned to
                               disable Flow Control Protocol Error checks.
                            */
    UINT32 msiavs : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               MSI address violation check status that does not
                               target 0xFEEx_xxxx while MSIAVCD is not being
                               set. This is only valid for RPs usage.
                            */

  } Bits;
  UINT32 Data;

} XPTDEF2_IIO_CXL_STRUCT;


/* FCUCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000900)                                                      */
/*      SPRB0 (0x20000900)                                                      */
/*      SPRHBM (0x20000900)                                                     */
/*      SPRC0 (0x20000900)                                                      */
/*      SPRMCC (0x20000900)                                                     */
/*      SPRUCC (0x20000900)                                                     */
/* Register default value on SPRA0: 0x0018619E                                  */
/* Register default value on SPRB0: 0x0018619E                                  */
/* Register default value on SPRHBM: 0x0018619E                                 */
/* Register default value on SPRC0: 0x0018619E                                  */
/* Register default value on SPRMCC: 0x0018619E                                 */
/* Register default value on SPRUCC: 0x0018619E                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update Control
*/


#define FCUCTL_IIO_CXL_REG 0x23020900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_fc_period : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x0000001E*/

                            /*
                               This field dictates the period at which flow
                               control updates are sent when there are no
                               additional credits to return for a particular
                               flow class/VC. The timer is set to
                               'idle_fc_period' * 1.024us -1.024us/+0us. A
                               value of 0 is illegal
                            */
    UINT32 fc_c_period : 6;

                            /* Bits[11:6], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fc_n_period : 6;

                            /* Bits[17:12], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fc_p_period : 6;

                            /* Bits[23:18], Access Type=RW/P, default=0x00000006*/

                            /*
                               In SG Mode, This specifies the latency after
                               which the flow control packet will be scheduled.
                               The latency starts from the time at which the
                               credit release is received by the link layer.
                               For X16, the number of cycles is csr_period * 4
                               * (gen1 ? 4 : gen 2 ? 2 : 1). For X8 or X4, the
                               number is scaled by 2, for X2, the number is
                               scaled by 4, and for x1, the number is scaled by
                               8 from the X16 number. The timer has an accuracy
                               for +- 4 cycles. Note: A value of 0 is illegal
                               in this mode. The value of the timer is shifted
                               left by the value of DEVCTL.MPS. For example,
                               for MPS=256, the latency is scaled by a factor
                               of two (shift of 1 bit left).
                            */
    UINT32 fcu_mode : 2;

                            /* Bits[25:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 = Spec Defined (Default) 01 = SG-Like 10 =
                               'Just-In-Time'
                            */
    UINT32 rsvd : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUCTL_IIO_CXL_STRUCT;

/* FCUJITPCTL0_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x20000904)                                                      */
/*      SPRB0 (0x20000904)                                                      */
/*      SPRHBM (0x20000904)                                                     */
/*      SPRC0 (0x20000904)                                                      */
/*      SPRMCC (0x20000904)                                                     */
/*      SPRUCC (0x20000904)                                                     */
/* Register default value on SPRA0: 0x00004009                                  */
/* Register default value on SPRB0: 0x00004009                                  */
/* Register default value on SPRHBM: 0x00004009                                 */
/* Register default value on SPRC0: 0x00004009                                  */
/* Register default value on SPRMCC: 0x00004009                                 */
/* Register default value on SPRUCC: 0x00004009                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT P Control
*/


#define FCUJITPCTL0_IIO_CXL_REG 0x23020904

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000009*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Data Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000004*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Header Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the data threshold is reached
                               or crossed. This field does not impact the
                               updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITPCTL0_IIO_CXL_STRUCT;

/* FCUJITPCTL1_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x20000908)                                                      */
/*      SPRB0 (0x20000908)                                                      */
/*      SPRHBM (0x20000908)                                                     */
/*      SPRC0 (0x20000908)                                                      */
/*      SPRMCC (0x20000908)                                                     */
/*      SPRUCC (0x20000908)                                                     */
/* Register default value on SPRA0: 0x00004009                                  */
/* Register default value on SPRB0: 0x00004009                                  */
/* Register default value on SPRHBM: 0x00004009                                 */
/* Register default value on SPRC0: 0x00004009                                  */
/* Register default value on SPRMCC: 0x00004009                                 */
/* Register default value on SPRUCC: 0x00004009                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT P Control
*/


#define FCUJITPCTL1_IIO_CXL_REG 0x23020908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000009*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Data Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000004*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Posted Header Queue before a FC-P Update is
                               scheduled. An update is scheduled either when
                               this threshold or the data threshold is reached
                               or crossed. This field does not impact the
                               updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITPCTL1_IIO_CXL_STRUCT;

/* FCUJITNCTL0_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x20000910)                                                      */
/*      SPRB0 (0x20000910)                                                      */
/*      SPRHBM (0x20000910)                                                     */
/*      SPRC0 (0x20000910)                                                      */
/*      SPRMCC (0x20000910)                                                     */
/*      SPRUCC (0x20000910)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT NP Control
*/


#define FCUJITNCTL0_IIO_CXL_REG 0x23020910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Data Queue before a FC-NP Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Header Queue before a FC-NP
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITNCTL0_IIO_CXL_STRUCT;

/* FCUJITNCTL1_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x20000914)                                                      */
/*      SPRB0 (0x20000914)                                                      */
/*      SPRHBM (0x20000914)                                                     */
/*      SPRC0 (0x20000914)                                                      */
/*      SPRMCC (0x20000914)                                                     */
/*      SPRUCC (0x20000914)                                                     */
/* Register default value on SPRA0: 0x00001001                                  */
/* Register default value on SPRB0: 0x00001001                                  */
/* Register default value on SPRHBM: 0x00001001                                 */
/* Register default value on SPRC0: 0x00001001                                  */
/* Register default value on SPRMCC: 0x00001001                                 */
/* Register default value on SPRUCC: 0x00001001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT NP Control
*/


#define FCUJITNCTL1_IIO_CXL_REG 0x23020914

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Data Queue before a FC-NP Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000001*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Non-Posted Header Queue before a FC-NP
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITNCTL1_IIO_CXL_STRUCT;

/* FCUJITCCTL0_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x2000091c)                                                      */
/*      SPRB0 (0x2000091c)                                                      */
/*      SPRHBM (0x2000091c)                                                     */
/*      SPRC0 (0x2000091c)                                                      */
/*      SPRMCC (0x2000091c)                                                     */
/*      SPRUCC (0x2000091c)                                                     */
/* Register default value on SPRA0: 0x00002016                                  */
/* Register default value on SPRB0: 0x00002016                                  */
/* Register default value on SPRHBM: 0x00002016                                 */
/* Register default value on SPRC0: 0x00002016                                  */
/* Register default value on SPRMCC: 0x00002016                                 */
/* Register default value on SPRUCC: 0x00002016                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT CPL Control
*/


#define FCUJITCCTL0_IIO_CXL_REG 0x2302091C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Data Queue before a FC-CPL Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. Threshold values
                               should be programmed to at least match the
                               credit scaling factor if credit scaling occurs.
                               If the threshold is programmed lower, duplicate
                               FCUs can result which may impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000002*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Header Queue before a FC-CPL
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITCCTL0_IIO_CXL_STRUCT;

/* FCUJITCCTL1_IIO_CXL_REG supported on:                                        */
/*      SPRA0 (0x20000920)                                                      */
/*      SPRB0 (0x20000920)                                                      */
/*      SPRHBM (0x20000920)                                                     */
/*      SPRC0 (0x20000920)                                                      */
/*      SPRMCC (0x20000920)                                                     */
/*      SPRUCC (0x20000920)                                                     */
/* Register default value on SPRA0: 0x00002016                                  */
/* Register default value on SPRB0: 0x00002016                                  */
/* Register default value on SPRHBM: 0x00002016                                 */
/* Register default value on SPRC0: 0x00002016                                  */
/* Register default value on SPRMCC: 0x00002016                                 */
/* Register default value on SPRUCC: 0x00002016                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* FC Update JIT CPL Control
*/


#define FCUJITCCTL1_IIO_CXL_REG 0x23020920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fc_dat_thresh : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Data Queue before a FC-CPL Update
                               is scheduled. An update is scheduled either when
                               this threshold or the header threshold is
                               reached or crossed. This field does not impact
                               the updates scheduled due to the mandatory 30us
                               update timer. This field is only utilized when
                               FCUCTL[25:24] = 10 'JIT Mode'. The FCUJIT*CTL
                               Registers should exist on a per-VC basis. e.g.
                               FCUJIT*CTL0 is for VC0, FCUJIT*CTL1 is for VC1,
                               and FCUJIT*CTL2 is for VCm if MVC is supported.
                               Threshold values should be programmed to at
                               least match the credit scaling factor if credit
                               scaling occurs. If the threshold is programmed
                               lower, duplicate FCUs can result which may
                               impact performance.
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fc_hdr_thresh : 7;

                            /* Bits[18:12], Access Type=RW/P, default=0x00000002*/

                            /*
                               Number of PCIe credits that must be freed from
                               the Completion Header Queue before a FC-CPL
                               Update is scheduled. An update is scheduled
                               either when this threshold or the data threshold
                               is reached or crossed. This field does not
                               impact the updates scheduled due to the
                               mandatory 30us update timer. This field is only
                               utilized when FCUCTL[25:24] = 10 'JIT Mode'. The
                               FCUJIT*CTL Registers should exist on a per-VC
                               basis. e.g. FCUJIT*CTL0 is for VC0, FCUJIT*CTL1
                               is for VC1, and FCUJIT*CTL2 is for VCm if MVC is
                               supported. Threshold values should be programmed
                               to at least match the credit scaling factor if
                               credit scaling occurs. If the threshold is
                               programmed lower, duplicate FCUs can result
                               which may impact performance.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FCUJITCCTL1_IIO_CXL_STRUCT;


/* VCXINITDLY_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000934)                                                      */
/*      SPRB0 (0x20000934)                                                      */
/*      SPRHBM (0x20000934)                                                     */
/*      SPRC0 (0x20000934)                                                      */
/*      SPRMCC (0x20000934)                                                     */
/*      SPRUCC (0x20000934)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* VCx Init Delay
*/


#define VCXINITDLY_IIO_CXL_REG 0x23020934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 delay : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Delay in [us] between FC Inits for VCx. A value
                               of 0 is not recommended as it may starve other
                               VC's traffic.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} VCXINITDLY_IIO_CXL_STRUCT;


/* ACKCTL_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000940)                                                      */
/*      SPRB0 (0x20000940)                                                      */
/*      SPRHBM (0x20000940)                                                     */
/*      SPRC0 (0x20000940)                                                      */
/*      SPRMCC (0x20000940)                                                     */
/*      SPRUCC (0x20000940)                                                     */
/* Register default value on SPRA0: 0x00000016                                  */
/* Register default value on SPRB0: 0x00000016                                  */
/* Register default value on SPRHBM: 0x00000016                                 */
/* Register default value on SPRC0: 0x00000016                                  */
/* Register default value on SPRMCC: 0x00000016                                 */
/* Register default value on SPRUCC: 0x00000016                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BTSMM_W                                          */
/* SPRB0 Security PolicyGroup: BTSMM_W                                          */
/* SPRHBM Security PolicyGroup: BTSMM_W                                         */
/* SPRC0 Security PolicyGroup: BTSMM_W                                          */
/* SPRMCC Security PolicyGroup: BTSMM_W                                         */
/* SPRUCC Security PolicyGroup: BTSMM_W                                         */
/* ACK Control
*/


#define ACKCTL_IIO_CXL_REG 0x23020940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ack_threshold : 11;

                            /* Bits[10:0], Access Type=RW/P, default=0x00000016*/

                            /*
                               In JIT Mode, specified the number of 16B
                               quantities (header and.or data) that is received
                               before scheduling an ACK.
                            */
    UINT32 ack_period : 5;

                            /* Bits[15:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               In 'SG Mode' this specifies the latency after
                               which a packet will be acked. The timer starts
                               running once it is internally received. For X16,
                               the number of cycles is csr_period * 4 * (gen1 ?
                               4 : gen2 ? 2 : 1). For X8 or X4, the number is
                               scaled by 2, for X2, the number is scaled by 4,
                               and for x1, the number is scaled by 8 from the
                               X16 number. Finally, the value of the timer is
                               shifted left by the value in devctrl.mps to
                               obtain the final ack timer. The timer has an
                               accuracy for +- 4 cycles. Note: A value of 0 is
                               illegal.
                            */
    UINT32 ack_mode : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* 0 = Spec Defined (Default) 1 = SG-Like */
    UINT32 jit_mode : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               0 = Spec Defined or SG-Like depending on
                               ACK_MODE (Default) 1 = 'Just-In-Time' Mode In
                               this mode, it is suggested to also enable SG
                               Mode in bit 16 and set the ACK_PERIOD as large
                               as possible w/o causing a REPLAY_TIMEOUT. This
                               allows the JIT logic to control the majority of
                               the ACKing. In the case where the traffic volume
                               is low and does not trigger the JIT Threshold,
                               the ACK_PERIOD timer will eventually TO and
                               cause an ACK to be scheduled. When set to 0,
                               ACKing is purely based on the ACK_PERIOD (in SG
                               Mode) or the spec-defined timeout (in Spec
                               Mode).
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ACKCTL_IIO_CXL_STRUCT;






/* PT0LDPHYCLKGCTL_IIO_CXL_REG supported on:                                    */
/*      SPRA0 (0x10000968)                                                      */
/*      SPRB0 (0x10000968)                                                      */
/*      SPRHBM (0x10000968)                                                     */
/*      SPRC0 (0x10000968)                                                      */
/*      SPRMCC (0x10000968)                                                     */
/*      SPRUCC (0x10000968)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 LCLK Delta PHY Clock Gating
*/


#define PT0LDPHYCLKGCTL_IIO_CXL_REG 0x23010968

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0LDPHYCLKGCTL_IIO_CXL_STRUCT;

/* PT1LDPHYCLKGCTL_IIO_CXL_REG supported on:                                    */
/*      SPRA0 (0x1000096a)                                                      */
/*      SPRB0 (0x1000096a)                                                      */
/*      SPRHBM (0x1000096a)                                                     */
/*      SPRC0 (0x1000096a)                                                      */
/*      SPRMCC (0x1000096a)                                                     */
/*      SPRUCC (0x1000096a)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 1 LCLK Delta PHY Clock Gating
*/


#define PT1LDPHYCLKGCTL_IIO_CXL_REG 0x2301096A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT1LDPHYCLKGCTL_IIO_CXL_STRUCT;

/* PT2LDPHYCLKGCTL_IIO_CXL_REG supported on:                                    */
/*      SPRA0 (0x1000096c)                                                      */
/*      SPRB0 (0x1000096c)                                                      */
/*      SPRHBM (0x1000096c)                                                     */
/*      SPRC0 (0x1000096c)                                                      */
/*      SPRMCC (0x1000096c)                                                     */
/*      SPRUCC (0x1000096c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 2 LCLK Delta PHY Clock Gating
*/


#define PT2LDPHYCLKGCTL_IIO_CXL_REG 0x2301096C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT2LDPHYCLKGCTL_IIO_CXL_STRUCT;

/* PT3LDPHYCLKGCTL_IIO_CXL_REG supported on:                                    */
/*      SPRA0 (0x1000096e)                                                      */
/*      SPRB0 (0x1000096e)                                                      */
/*      SPRHBM (0x1000096e)                                                     */
/*      SPRC0 (0x1000096e)                                                      */
/*      SPRMCC (0x1000096e)                                                     */
/*      SPRUCC (0x1000096e)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 3 LCLK Delta PHY Clock Gating
*/


#define PT3LDPHYCLKGCTL_IIO_CXL_REG 0x2301096E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT3LDPHYCLKGCTL_IIO_CXL_STRUCT;















#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJCTL_IIO_CXL_REG supported on:                                       */
/*      SPRB0 (0x200009d0)                                                      */
/*      SPRHBM (0x200009d0)                                                     */
/*      SPRC0 (0x200009d0)                                                      */
/*      SPRMCC (0x200009d0)                                                     */
/*      SPRUCC (0x200009d0)                                                     */
/* Register default value on SPRB0: 0x00FFF000                                  */
/* Register default value on SPRHBM: 0x00FFF000                                 */
/* Register default value on SPRC0: 0x00FFF000                                  */
/* Register default value on SPRMCC: 0x00FFF000                                 */
/* Register default value on SPRUCC: 0x00FFF000                                 */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Control
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJMSK_IIO_CXL_REG supported on:                                       */
/*      SPRB0 (0x200009d4)                                                      */
/*      SPRHBM (0x200009d4)                                                     */
/*      SPRC0 (0x200009d4)                                                      */
/*      SPRMCC (0x200009d4)                                                     */
/*      SPRUCC (0x200009d4)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Mask
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* LUTERRINJMSKWID_IIO_CXL_REG supported on:                                    */
/*      SPRB0 (0x200009d8)                                                      */
/*      SPRHBM (0x200009d8)                                                     */
/*      SPRC0 (0x200009d8)                                                      */
/*      SPRMCC (0x200009d8)                                                     */
/*      SPRUCC (0x200009d8)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: DFX2                                             */
/* SPRHBM Security PolicyGroup: DFX2                                            */
/* SPRC0 Security PolicyGroup: DFX2                                             */
/* SPRMCC Security PolicyGroup: DFX2                                            */
/* SPRUCC Security PolicyGroup: DFX2                                            */
/* LUT Error Injection Mask Width ID
*/

#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* PT0LNKCLKGCTL_IIO_CXL_REG supported on:                                      */
/*      SPRA0 (0x100009e4)                                                      */
/*      SPRB0 (0x100009e4)                                                      */
/*      SPRHBM (0x100009e4)                                                     */
/*      SPRC0 (0x100009e4)                                                      */
/*      SPRMCC (0x100009e4)                                                     */
/*      SPRUCC (0x100009e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Port 0 Link Clock Gate Control
*/


#define PT0LNKCLKGCTL_IIO_CXL_REG 0x230109E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} PT0LNKCLKGCTL_IIO_CXL_STRUCT;

/* CFGPCIECLKGCTL_IIO_CXL_REG supported on:                                     */
/*      SPRA0 (0x100009ec)                                                      */
/*      SPRB0 (0x100009ec)                                                      */
/*      SPRHBM (0x100009ec)                                                     */
/*      SPRC0 (0x100009ec)                                                      */
/*      SPRMCC (0x100009ec)                                                     */
/*      SPRUCC (0x100009ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX1                                             */
/* SPRB0 Security PolicyGroup: DFX1                                             */
/* SPRHBM Security PolicyGroup: DFX1                                            */
/* SPRC0 Security PolicyGroup: DFX1                                             */
/* SPRMCC Security PolicyGroup: DFX1                                            */
/* SPRUCC Security PolicyGroup: DFX1                                            */
/* Configuration PCIe Clock Gate Control
*/


#define CFGPCIECLKGCTL_IIO_CXL_REG 0x230109EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 ict : 8;

                            /* Bits[7:0], Access Type=RW, default=None*/

                            /*
                               This field indicates the number of clocks that
                               the IP block must be idle before the clock
                               disable process begins. 16 (default value) is
                               the minimum number of clocks recommended.
                            */
    UINT16 rsvd : 7;

                            /* Bits[14:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 icge : 1;

                            /* Bits[15:15], Access Type=RW, default=None*/

                            /*
                               This bit when set enables clock gating to occur
                               when the IP block is idle longer then the Idle
                               Clock Timer.
                            */

  } Bits;
  UINT16 Data;

} CFGPCIECLKGCTL_IIO_CXL_STRUCT;

/* SECEXPCAP_IIO_CXL_REG supported on:                                          */
/*      SPRA0 (0x20000a30)                                                      */
/*      SPRB0 (0x20000a30)                                                      */
/*      SPRHBM (0x20000a30)                                                     */
/*      SPRC0 (0x20000a30)                                                      */
/*      SPRMCC (0x20000a30)                                                     */
/*      SPRUCC (0x20000a30)                                                     */
/* Register default value on SPRA0: 0x00010019                                  */
/* Register default value on SPRB0: 0x00010019                                  */
/* Register default value on SPRHBM: 0x00010019                                 */
/* Register default value on SPRC0: 0x00010019                                  */
/* Register default value on SPRMCC: 0x00010019                                 */
/* Register default value on SPRUCC: 0x00010019                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Secondary PCI Express Extended Capability Header
*/


#define SECEXPCAP_IIO_CXL_REG 0x23020A30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000019*/

                            /*
                               PCI Express Extended Capability ID for the
                               Secondary PCI Express Extended Capability is
                               0019h
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Extended Capability structure or 000h if
                               no other items exist in the linked list of
                               Capabilities. Software will need to program this
                               field appropriately for linked list of
                               capabilities if default is not supported. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */

  } Bits;
  UINT32 Data;

} SECEXPCAP_IIO_CXL_STRUCT;

/* LINKCTL3_IIO_CXL_REG supported on:                                           */
/*      SPRA0 (0x20000a34)                                                      */
/*      SPRB0 (0x20000a34)                                                      */
/*      SPRHBM (0x20000a34)                                                     */
/*      SPRC0 (0x20000a34)                                                      */
/*      SPRMCC (0x20000a34)                                                     */
/*      SPRUCC (0x20000a34)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Link Control 3
*/


#define LINKCTL3_IIO_CXL_REG 0x23020A34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pe : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               When this register is 1b and a 1b is written to
                               the 'Link Retrain' register with 'Target Link
                               Speed' set to 8 GT/s or higher, the Downstream
                               Port must perform Transmitter Equalization.
                               Software must guarantee that no transactions are
                               pending in the link while the link is in
                               Recovery when this bit is set to 1b. This bit is
                               not applicable and is reserved for Endpoints,
                               PCI Express to PCI/PCIX bridges, and Upstream
                               Ports of Switches.
                            */
    UINT32 lnkeqreqinten : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, this bit enables the generation of
                               interrupt to indicate that the Link Equalization
                               Request bit or the Link Equalization Request
                               16.0 GT/s bit has been set. This bit is not
                               applicable and is reserved for Endpoints, PCI
                               Express to PCI/PCIX bridges, and Upstream Ports
                               of Switches.
                            */
    UINT32 rsvd : 7;

                            /* Bits[8:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 elskposgv : 5;

                            /* Bits[13:9], Access Type=RW, default=0x00000000*/

                            /*
                               When the Link is in L0 and the bit in this field
                               corresponding to the current Link speed is Set,
                               SKP Ordered Sets are scheduled at the rate
                               defined for SRNS, overriding the rate required
                               based on the clock tolerance architecture. See
                               section 4.2.7 for additional requirements. Bit
                               definitions within this field are: Bit 0 2.5
                               GT/s Bit 1 5.0 GT/s Bit 2 8.0 GT/s Bit 3 16.0
                               GT/s Bit 4 32.0 GT/s Bits 6:5 RsvdP Each
                               unreserved bit in this field must be RW if the
                               corresponding bit in the Lower SKP OS Generation
                               Supported Speeds Vector is Set, otherwise the
                               bit must to be RW or hardwired to 0. Behavior is
                               undefined if a bit is Set in this field and the
                               corresponding bit in the Lower SKP OS Generation
                               Supported Speeds Vector is not Set. The default
                               value of this field is 000 0000b
                            */
    UINT32 rsvd_14 : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINKCTL3_IIO_CXL_STRUCT;

/* LANEERRSTS_IIO_CXL_REG supported on:                                         */
/*      SPRA0 (0x20000a38)                                                      */
/*      SPRB0 (0x20000a38)                                                      */
/*      SPRHBM (0x20000a38)                                                     */
/*      SPRC0 (0x20000a38)                                                      */
/*      SPRMCC (0x20000a38)                                                     */
/*      SPRUCC (0x20000a38)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* The Equalization Control Register consist of control fields required for per lane equalization and the number of entries in this register are sized by Max Link Width
*/


#define LANEERRSTS_IIO_CXL_REG 0x23020A38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l0err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l1err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l2err : 1;

                            /* Bits[2:2], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l3err : 1;

                            /* Bits[3:3], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l4err : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l5err : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l6err : 1;

                            /* Bits[6:6], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l7err : 1;

                            /* Bits[7:7], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l8err : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l9err : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l10err : 1;

                            /* Bits[10:10], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l11err : 1;

                            /* Bits[11:11], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l12err : 1;

                            /* Bits[12:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l13err : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l14err : 1;

                            /* Bits[14:14], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 l15err : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A value of 1b indicates that a lane based error
                               was detected on the corresponding PCI Express
                               Lane Number.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LANEERRSTS_IIO_CXL_STRUCT;

/* DLFECH_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000a90)                                                      */
/*      SPRB0 (0x20000a90)                                                      */
/*      SPRHBM (0x20000a90)                                                     */
/*      SPRC0 (0x20000a90)                                                      */
/*      SPRMCC (0x20000a90)                                                     */
/*      SPRUCC (0x20000a90)                                                     */
/* Register default value on SPRA0: 0x00010025                                  */
/* Register default value on SPRB0: 0x00010025                                  */
/* Register default value on SPRHBM: 0x00010025                                 */
/* Register default value on SPRC0: 0x00010025                                  */
/* Register default value on SPRMCC: 0x00010025                                 */
/* Register default value on SPRUCC: 0x00010025                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Data Link Feature Extended Capability Header
*/


#define DLFECH_IIO_CXL_REG 0x23020A90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000025*/

                            /*
                               This field is a PCISIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. Extended Capability ID for Data Link
                               Feature is 0025h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               Contains the offset of the next structure in the
                               Extended Capabilities list. (G4ECH). Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register . Software will need to program
                               this field appropriately for linked capabilities
                               list if default is not supported.
                            */

  } Bits;
  UINT32 Data;

} DLFECH_IIO_CXL_STRUCT;

/* DLFCAP_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000a94)                                                      */
/*      SPRB0 (0x20000a94)                                                      */
/*      SPRHBM (0x20000a94)                                                     */
/*      SPRC0 (0x20000a94)                                                      */
/*      SPRMCC (0x20000a94)                                                     */
/*      SPRUCC (0x20000a94)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Data Link Feature Capabilities
*/


#define DLFCAP_IIO_CXL_REG 0x23020A94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ldlfs : 23;

                            /* Bits[22:0], Access Type=RW/L, default=None*/

                            /*
                               This field contains the Feature Supported value
                               used when this Port sends a Data Link Feature
                               DLLP (see PCIe Spec. Figure 3-12). Defined
                               features are: Bit 0 - Local Scaled Flow Control
                               Supported This bit indicates that this Port
                               supports the Scaled Flow Control Feature (see
                               PCIe Spec. Section 3.4.2). Bits 22:1 RsvdP Bits
                               associated with features that this Port is
                               capable of supporting are HwInit, defaulting to
                               1b. Other bits in this field are RsvdP. Note:
                               Lock Key bit is located in the Personality Lock
                               Key Control Register .
                            */
    UINT32 rsvd : 8;

                            /* Bits[30:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dlfee : 1;

                            /* Bits[31:31], Access Type=RW/L, default=None*/

                            /*
                               If Set, this bit indicates that this Port will
                               enter the DL_Feature negotiation state (see PCIe
                               Spec. Section 3.2.1). Default is 1b. Note: Lock
                               Key bit is located in the Personality Lock Key
                               Control Register .
                            */

  } Bits;
  UINT32 Data;

} DLFCAP_IIO_CXL_STRUCT;

/* DLFSTS_IIO_CXL_REG supported on:                                             */
/*      SPRA0 (0x20000a98)                                                      */
/*      SPRB0 (0x20000a98)                                                      */
/*      SPRHBM (0x20000a98)                                                     */
/*      SPRC0 (0x20000a98)                                                      */
/*      SPRMCC (0x20000a98)                                                     */
/*      SPRUCC (0x20000a98)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Data Link Feature Status
*/


#define DLFSTS_IIO_CXL_REG 0x23020A98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdlfs : 23;

                            /* Bits[22:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               These bits indicate that the Remote Port
                               supports the corresponding Data Link Feature.
                               These bits capture all information from the
                               Feature Supported field of the Data Link Feature
                               DLLP even when this Port does not support the
                               corresponding feature. This field is Cleared on
                               entry to state DL_Inactive (see PCIe Spec.
                               Section 3.2.1). Features currently defined are:
                               Bit 0 - Remote Scaled Flow Control Supported
                               This bit indicates that the Remote Port supports
                               the Scaled Flow Control Feature (see PCIe Spec.
                               Section 3.4.2). Bits 22:1 - Undefined
                            */
    UINT32 rsvd : 8;

                            /* Bits[30:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rdlfsv : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit indicates that the Port has received a
                               Data Link Feature DLLP in state DL_Feature (see
                               PCIe Spec. Section 3.2.1) and that the Remote
                               Data Link Feature Supported field is meaningful.
                               This bit is Cleared on entry to state
                               DL_Inactive (see PCIe Spec. Section 3.2.1).
                               Default is 0b.
                            */

  } Bits;
  UINT32 Data;

} DLFSTS_IIO_CXL_STRUCT;

/* G4ECH_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000a9c)                                                      */
/*      SPRB0 (0x20000a9c)                                                      */
/*      SPRHBM (0x20000a9c)                                                     */
/*      SPRC0 (0x20000a9c)                                                      */
/*      SPRMCC (0x20000a9c)                                                     */
/*      SPRUCC (0x20000a9c)                                                     */
/* Register default value on SPRA0: 0x00010026                                  */
/* Register default value on SPRB0: 0x00010026                                  */
/* Register default value on SPRHBM: 0x00010026                                 */
/* Register default value on SPRC0: 0x00010026                                  */
/* Register default value on SPRMCC: 0x00010026                                 */
/* Register default value on SPRUCC: 0x00010026                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Physical Layer 16.0 GT/s Extended Capability Header
*/


#define G4ECH_IIO_CXL_REG 0x23020A9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000026*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Physical Layer 16.0 GT/s Capability is 0026h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} G4ECH_IIO_CXL_STRUCT;

/* G4STS_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000aa8)                                                      */
/*      SPRB0 (0x20000aa8)                                                      */
/*      SPRHBM (0x20000aa8)                                                     */
/*      SPRC0 (0x20000aa8)                                                      */
/*      SPRMCC (0x20000aa8)                                                     */
/*      SPRUCC (0x20000aa8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 16.0 GT/s Status
*/


#define G4STS_IIO_CXL_REG 0x23020AA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eq16cmplt : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that the 16.0 GT/s
                               Transmitter Equalization procedure has
                               completed. Details of the Transmitter
                               Equalization process and when this bit needs to
                               be set to 1b is provided in PCIe Spec. Section
                               4.2.6.4.2. The default value of this bit is 0b.
                               For a Multi-Function Upstream Port, this bit
                               must be implemented in Function 0 and RsvdZ in
                               other Functions.
                            */
    UINT32 eq16ph1succ : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq16ph2succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq16ph3succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 16.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 linkeqreq16 : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 16.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G4STS_IIO_CXL_STRUCT;

/* G5ECH_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000ae0)                                                      */
/*      SPRB0 (0x20000ae0)                                                      */
/*      SPRHBM (0x20000ae0)                                                     */
/*      SPRC0 (0x20000ae0)                                                      */
/*      SPRMCC (0x20000ae0)                                                     */
/*      SPRUCC (0x20000ae0)                                                     */
/* Register default value on SPRA0: 0x0001002A                                  */
/* Register default value on SPRB0: 0x0001002A                                  */
/* Register default value on SPRHBM: 0x0001002A                                 */
/* Register default value on SPRC0: 0x0001002A                                  */
/* Register default value on SPRMCC: 0x0001002A                                 */
/* Register default value on SPRUCC: 0x0001002A                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Physical Layer 32.0 GT/s Extended Capability Header
*/


#define G5ECH_IIO_CXL_REG 0x23020AE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000002A*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Physical Layer 32.0 GT/s Capability is 002Ah.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} G5ECH_IIO_CXL_STRUCT;

/* G5STS_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000aec)                                                      */
/*      SPRB0 (0x20000aec)                                                      */
/*      SPRHBM (0x20000aec)                                                     */
/*      SPRC0 (0x20000aec)                                                      */
/*      SPRMCC (0x20000aec)                                                     */
/*      SPRUCC (0x20000aec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* 32.0 GT/s Status
*/


#define G5STS_IIO_CXL_REG 0x23020AEC

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eq32cmplt : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that the 32.0 GT/s
                               Transmitter Equalization procedure has
                               completed. Details of the Transmitter
                               Equalization process and when this bit needs to
                               be set to 1b is provided in PCIe Spec. Section
                               4.2.6.4.2. The default value of this bit is 0b.
                               For a Multi-Function Upstream Port, this bit
                               must be implemented in Function 0 and RsvdZ in
                               other Functions.
                            */
    UINT32 eq32ph1succ : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph2succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph3succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 linkeqreq32 : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 32.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 modtsrcvd : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, Received Modified TS Data 1 Register and
                               Received Modified TS Data 2 Register contain
                               meaningful data. This bit is Cleared when the
                               Link is Down. This bit is Set when the Modified
                               TS1/TS2 Ordered Set is received Default is 0b.
                            */
    UINT32 rcvdelbctl : 2;

                            /* Bits[7:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field contains the Enhanced Link Behavior
                               Control bits from the most recent TS1 or TS2
                               received in the Polling or Configuration states.
                               This field is Cleared on DL_Down. Default is
                               00b.
                            */
    UINT32 txprecon : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates whether the Receiver ask
                               this transmitter to enable Precoding. This bit
                               is cleared on DL_Down. Default is 0b.
                            */
    UINT32 txprecreq : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /*
                               When Set, this Port will request the transmitter
                               to use Precoding by setting the Precoding
                               Request bit in the TS1s/TS2s it transmits prior
                               to entry to Recovery.Speed. Default is
                               Implementation Specific The value of this field
                               will be reflected by CAPSR.G5STS_TXPRECREQ.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G5STS_IIO_CXL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eq32cmplt : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that the 32.0 GT/s
                               Transmitter Equalization procedure has
                               completed. Details of the Transmitter
                               Equalization process and when this bit needs to
                               be set to 1b is provided in PCIe Spec. Section
                               4.2.6.4.2. The default value of this bit is 0b.
                               For a Multi-Function Upstream Port, this bit
                               must be implemented in Function 0 and RsvdZ in
                               other Functions.
                            */
    UINT32 eq32ph1succ : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph2succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph3succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 linkeqreq32 : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 32.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 modtsrcvd : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, Received Modified TS Data 1 Register and
                               Received Modified TS Data 2 Register contain
                               meaningful data. This bit is Cleared when the
                               Link is Down. This bit is Set when the Modified
                               TS1/TS2 Ordered Set is received Default is 0b.
                            */
    UINT32 rcvdelbctl : 2;

                            /* Bits[7:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field contains the Enhanced Link Behavior
                               Control bits from the most recent TS1 or TS2
                               received in the Polling or Configuration states.
                               This field is Cleared on DL_Down. Default is
                               00b.
                            */
    UINT32 txprecon : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates whether the Receiver ask
                               this transmitter to enable Precoding. This bit
                               is cleared on DL_Down. Default is 0b.
                            */
    UINT32 txprecreq : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /*
                               When Set, this Port will request the transmitter
                               to use Precoding by setting the Transmitter
                               Precode Request bit in the TS1s/TS2s it
                               transmits prior to entry to Recovery.Speed.
                               Default is Implementation Specific The value of
                               this field will be reflected by
                               CAPSR.G5STS_TXPRECREQ.
                            */
    UINT32 neqnr : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /*
                               When Set, this Port either received a Modified
                               TS1/TS2 with the No Equalization Needed bit Set
                               or received a non-modified TS1/TS2 was received
                               with the No Equalization Needed encoding (also
                               reported in the Received Enhanced Link Behavior
                               Control field). Default is 0b.
                            */
    UINT32 rsvd : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G5STS_IIO_CXL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eq32cmplt : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When Set, this bit indicates that the 32.0 GT/s
                               Transmitter Equalization procedure has
                               completed. Details of the Transmitter
                               Equalization process and when this bit needs to
                               be set to 1b is provided in PCIe Spec. Section
                               4.2.6.4.2. The default value of this bit is 0b.
                               For a Multi-Function Upstream Port, this bit
                               must be implemented in Function 0 and RsvdZ in
                               other Functions.
                            */
    UINT32 eq32ph1succ : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 1
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph2succ : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 2
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 eq32ph3succ : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               When set to 1b, this bit indicates that Phase 3
                               of the 32.0 GT/s Transmitter Equalization
                               procedure has successfully completed. Details of
                               the Transmitter Equalization process and when
                               this bit needs to be set to 1b is provided in
                               PCIe Spec. Section 4.2.6.4.2. The default value
                               of this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 linkeqreq32 : 1;

                            /* Bits[4:4], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit is Set by hardware to request the 32.0
                               GT/s Link equalization process to be performed
                               on the Link. Refer to PCIe Spec. Sections 4.2.3
                               and 4.2.6.4.2 for details. The default value of
                               this bit is 0b. For a Multi-Function Upstream
                               Port, this bit must be implemented in Function 0
                               and RsvdZ in other Functions.
                            */
    UINT32 modtsrcvd : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               If Set, Received Modified TS Data 1 Register and
                               Received Modified TS Data 2 Register contain
                               meaningful data. This bit is Cleared when the
                               Link is Down. This bit is Set when the Modified
                               TS1/TS2 Ordered Set is received Default is 0b.
                            */
    UINT32 rcvdelbctl : 2;

                            /* Bits[7:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field contains the Enhanced Link Behavior
                               Control bits from the most recent TS1 or TS2
                               received in the Polling or Configuration states.
                               This field is Cleared on DL_Down. Default is
                               00b.
                            */
    UINT32 txprecon : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This field indicates whether the Receiver ask
                               this transmitter to enable Precoding. This bit
                               is cleared on DL_Down. Default is 0b.
                            */
    UINT32 txprecreq : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /*
                               When Set, this Port will request the transmitter
                               to use Precoding by setting the Precoding
                               Request bit in the TS1s/TS2s it transmits prior
                               to entry to Recovery.Speed. Default is
                               Implementation Specific The value of this field
                               will be reflected by CAPSR.G5STS_TXPRECREQ.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} G5STS_IIO_CXL_STRUCT;

/* APECH_IIO_CXL_REG supported on:                                              */
/*      SPRA0 (0x20000b20)                                                      */
/*      SPRB0 (0x20000b20)                                                      */
/*      SPRHBM (0x20000b20)                                                     */
/*      SPRC0 (0x20000b20)                                                      */
/*      SPRMCC (0x20000b20)                                                     */
/*      SPRUCC (0x20000b20)                                                     */
/* Register default value on SPRA0: 0x0001002B                                  */
/* Register default value on SPRB0: 0x0001002B                                  */
/* Register default value on SPRHBM: 0x0001002B                                 */
/* Register default value on SPRC0: 0x0001002B                                  */
/* Register default value on SPRMCC: 0x0001002B                                 */
/* Register default value on SPRUCC: 0x0001002B                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Alternate Protocol Extended Capability Header
*/


#define APECH_IIO_CXL_REG 0x23020B20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x0000002B*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Alternate Protocol Capability is 002Bh.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} APECH_IIO_CXL_STRUCT;


/* FLXBUSPTEXCAP_IIO_CXL_REG supported on:                                      */
/*      SPRA0 (0x20000ea4)                                                      */
/*      SPRB0 (0x20000ea4)                                                      */
/*      SPRHBM (0x20000ea4)                                                     */
/*      SPRC0 (0x20000ea4)                                                      */
/*      SPRMCC (0x20000ea4)                                                     */
/*      SPRUCC (0x20000ea4)                                                     */
/* Register default value on SPRA0: 0x00010023                                  */
/* Register default value on SPRB0: 0x00010023                                  */
/* Register default value on SPRHBM: 0x00010023                                 */
/* Register default value on SPRC0: 0x00010023                                  */
/* Register default value on SPRMCC: 0x00010023                                 */
/* Register default value on SPRUCC: 0x00010023                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* PCIe DVSEC for Intel Flex Bus Port Expended Capability Header
*/


#define FLXBUSPTEXCAP_IIO_CXL_REG 0x23020EA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000023*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Physical Layer 32.0 GT/s Capability is 002Ah.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} FLXBUSPTEXCAP_IIO_CXL_STRUCT;

/* MARGECH_IIO_CXL_REG supported on:                                            */
/*      SPRA0 (0x20000edc)                                                      */
/*      SPRB0 (0x20000edc)                                                      */
/*      SPRHBM (0x20000edc)                                                     */
/*      SPRC0 (0x20000edc)                                                      */
/*      SPRMCC (0x20000edc)                                                     */
/*      SPRUCC (0x20000edc)                                                     */
/* Register default value on SPRA0: 0x00010027                                  */
/* Register default value on SPRB0: 0x00010027                                  */
/* Register default value on SPRHBM: 0x00010027                                 */
/* Register default value on SPRC0: 0x00010027                                  */
/* Register default value on SPRMCC: 0x00010027                                 */
/* Register default value on SPRUCC: 0x00010027                                 */
/* SPRA0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRB0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRHBM Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRC0 Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst     */
/* SPRMCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* SPRUCC Register File:    sprsp_top/pcierli_sprrli4x16[0]/rp0/rcrbbar_inst    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BOOT_W                                           */
/* SPRB0 Security PolicyGroup: BOOT_W                                           */
/* SPRHBM Security PolicyGroup: BOOT_W                                          */
/* SPRC0 Security PolicyGroup: BOOT_W                                           */
/* SPRMCC Security PolicyGroup: BOOT_W                                          */
/* SPRUCC Security PolicyGroup: BOOT_W                                          */
/* Margining Extended Capability Header
*/


#define MARGECH_IIO_CXL_REG 0x23020EDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecid : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000027*/

                            /*
                               This field is a PCI-SIG defined ID number that
                               indicates the nature and format of the Extended
                               Capability. The Extended Capability ID for the
                               Margining Capability is 0027h.
                            */
    UINT32 cv : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               This field is a PCI-SIG defined version number
                               that indicates the version of the Capability
                               structure present. Must be 1h for this version
                               of the specification.
                            */
    UINT32 nco : 12;

                            /* Bits[31:20], Access Type=RW/L, default=None*/

                            /*
                               This field contains the offset to the next PCI
                               Express Capability structure or 000h if no other
                               items exist in the linked list of Capabilities.
                               For Extended Capabilities implemented in
                               Configuration Space, this offset is relative to
                               the beginning of PCI-compatible Configuration
                               Space and thus must always be either 000h (for
                               terminating list of Capabilities) or greater
                               than 0FFh. Note: Lock Key bit is located in the
                               Personality Lock Key Control Register . Software
                               will need to program this field appropriately
                               for linked capabilities list if default is not
                               supported.
                            */

  } Bits;
  UINT32 Data;

} MARGECH_IIO_CXL_STRUCT;
#endif /* _IIO_CXL_h */
