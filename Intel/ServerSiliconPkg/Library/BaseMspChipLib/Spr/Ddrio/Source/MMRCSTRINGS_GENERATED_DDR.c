/** @file
  File name:    MMRCSTRINGS_GENERATED_DDR.c
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCSTRINGS_GENERATED_DDR.c, which is used for non-tool-generated
  data
  Includes various strings specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#include "Spr/Ddrio/Include/MMRCPROJECT_DEFINITIONS_GENERATED_DDR.h"
#include "MspData.h"

#if CAPSULESTRINGS_DDR
CHAR8 *OutputStrings_DDR[] = {
  NULL, 
};
#endif //CAPSULESTRINGS_DDR

#if DUMP_REGISTER_NAMES_DDR
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields0_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo0_DDR[] = {{"ddrcc_ctl0_bit_0_", "", 0x0001A800, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields1_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo1_DDR[] = {{"ddrcc_ctl0_bit_1_", "", 0x0001A804, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields2_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo2_DDR[] = {{"ddrcc_ctl0_bit_2_", "", 0x0001A808, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields3_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo3_DDR[] = {{"ddrcc_ctl0_bit_3_", "", 0x0001A80C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields4_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo4_DDR[] = {{"ddrcc_ctl0_bit_4_", "", 0x0001A810, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields5_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo5_DDR[] = {{"ddrcc_ctl0_bit_5_", "", 0x0001A814, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields6_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo6_DDR[] = {{"ddrcc_ctl0_bit_6_", "", 0x0001A818, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields7_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo7_DDR[] = {{"ddrcc_ctl0_bit_7_", "", 0x0001A81C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields8_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo8_DDR[] = {{"ddrcc_ctl0_bit_8_", "", 0x0001A820, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields9_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo9_DDR[] = {{"ddrcc_ctl0_bit_9_", "", 0x0001A824, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields10_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo10_DDR[] = {{"ddrcc_ctl0_bit_10_", "", 0x0001A828, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields11_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo11_DDR[] = {{"ddrcc_ctl0_bit_11_", "", 0x0001A82C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields12_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo12_DDR[] = {{"ddrcc_ctl0_bit_12_", "", 0x0001A830, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields13_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo13_DDR[] = {{"ddrcc_ctl0_bit_13_", "", 0x0001A834, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields14_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo14_DDR[] = {{"ddrcc_ctl0_bit_14_", "", 0x0001A838, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields15_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo15_DDR[] = {{"ddrcc_ctl0_bit_15_", "", 0x0001A83C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields16_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo16_DDR[] = {{"ddrcc_ctl0_bit_16_", "", 0x0001A840, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields17_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo17_DDR[] = {{"ddrcc_ctl0_bit_17_", "", 0x0001A844, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields18_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo18_DDR[] = {{"ddrcc_ctl0_bit_18_", "", 0x0001A848, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields19_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo19_DDR[] = {{"ddrcc_ctl0_bit_19_", "", 0x0001A84C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields20_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo20_DDR[] = {{"ddrcc_ctl0_bit_20_", "", 0x0001A850, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields21_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo21_DDR[] = {{"ddrcc_ctl0_bit_21_", "", 0x0001A854, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields22_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{30, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", "RX Vref control 1 with step size is vccddr_hv/256. Default is 75% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 12 to 21[br]\r\n"
"                    Note: This vref is intended to use for REQ/ERR/RSP_A/RSP_B"},
#else
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", "RX Vref control 0 with step size is vccddr_hv/256. Default is 62.5% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 0 to 11[br]\r\n"
"                    Note: This vref is intended to use for alert_n"},
#else
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo22_DDR[] = {{"ddrcc_rxvref_ctl", "", 0x0001A858, 3, 0x00000000FFFFFFFF, 0x000000000000BFA0}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields23_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "CMD Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "CMD Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo23_DDR[] = {{"ddrcc_comp_la0", "", 0x0001A85C, 2, 0x0000000000000FFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields24_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "CMD Slew Rate Comp Value. It is trained by BIOS. [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate. [br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "CMD TCO Comp Value. It is program by BIOS but it is not trained.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo24_DDR[] = {{"ddrcc_comp_la1", "", 0x0001A860, 2, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields25_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo25_DDR[] = {{"ddrcc_comp_offset", "", 0x0001A864, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields26_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", "Double the timer for VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo26_DDR[] = {{"ddrcc_vsshi_ctl", "", 0x0001A868, 6, 0x00000000FFFFFFFF, 0x0000000000000118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields27_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo27_DDR[] = {{"ddrcc_dll_pi_test_adc_0_", "", 0x0001A86C, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields28_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo28_DDR[] = {{"ddrcc_dll_pi_test_adc_1_", "", 0x0001A870, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields29_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo29_DDR[] = {{"ddrcc_dll_csr_0_", "", 0x0001A874, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields30_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo30_DDR[] = {{"ddrcc_dll_csr_1_", "", 0x0001A878, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields31_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "cmd_dly_adj", "CMD delay adjust value. It is added to all per bit command delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the command fubs."},
#else
{0, 7, 0x00000000, "RW", "cmd_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo31_DDR[] = {{"ddrcc_train_offset0", "", 0x0001A87C, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields32_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo32_DDR[] = {{"ddrcc_piref_offset0_0_", "", 0x0001A880, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields33_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo33_DDR[] = {{"ddrcc_piref_offset0_1_", "", 0x0001A884, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields34_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo34_DDR[] = {{"ddrcc_piref_offset0_2_", "", 0x0001A888, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields35_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo35_DDR[] = {{"ddrcc_piref_offset0_3_", "", 0x0001A88C, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields36_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "rx_path_ungate", "SW set this bit to 1 to ungate the DDRIO to MC RX data path."},
#else
{10, 10, 0x00000000, "RW", "rx_path_ungate", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", "Force the Rx amplifier combiner to a lower static power state during Alert and DDR-T modes,[br]\r\n"
"                    which reduces FiSH temperatures and helps RV."},
#else
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for cmd buf."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo36_DDR[] = {{"ddrcc_rx_ctl0", "", 0x0001A890, 7, 0x0000000007FFFFFF, 0x0000000007C0900B}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields37_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable offset control in cmd buf and RX BIAS"},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo37_DDR[] = {{"ddrcc_rx_ctl1", "", 0x0001A894, 2, 0x00000000FFFFFFFF, 0x0000000000000040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields38_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 : CMD BUF bypass SCOMP and TCO delay in the transmitter."},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", "CA Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", "CS Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", "CA 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", "CS 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", "CA 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", "CS 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ca_imode_en", "CA Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{11, 11, 0x00000000, "RW", "ca_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "cs_imode_en", "CS Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{10, 10, 0x00000000, "RW", "cs_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of drive segment enable for CMD buf. Also, it is used by COMP to TXEQ logic to generate the EQCODE."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of CmdCtl driver (Ron) static legs. [br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Hardware default of 0x1F has 15 static legs enabled. [br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo38_DDR[] = {{"ddrcc_tx_ctl0", "", 0x0001A89C, 12, 0x00000000FFFFFFFF, 0x00000000800000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields39_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", "CA TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", "CS TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", "CA TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63"},
#else
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", "CS TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "io_dir_valid", "Set by BIOS to indicate the io_dir control field is valid.[br]\r\n"
"                    - if this bit is not set, force the receive data to 0[br]\r\n"
"                    - it is used by the command buf CBB to latch the io_pwrdn_pull_low siganl when set to 1 by BIOS. That sequential is power by always on power (s3localvcc), so when analog power is down, the buf use it to determine to either pull low or tri-state the IO."},
#else
{0, 0, 0x00000000, "RW", "io_dir_valid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo39_DDR[] = {{"ddrcc_tx_ctl1", "", 0x0001A8A0, 5, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields40_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "Per bit VOC RX pass gate enable for VOC training and NTL testing."},
#else
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All CMDCTL Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - CMDCTL Vref generators are switched off while in CKE power down regardless the setting of rx_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. The cmd Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - The cmd Vref generators are switched off while in Self Refresh regardless the setting of rx_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo40_DDR[] = {{"ddrcc_dfx_ctl0", "", 0x0001A8A8, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields41_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW/V", "hw_cal_en", "HW calibation enable control per FSM (cmd has 4). Set to 1 to enable the HW calibration. [br]\r\n"
"                    They are 4 HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW cal FSM will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br]\r\n"
"                    For ACIO testing, all 4 stages can be enabled by SW."},
#else
{28, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 17, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digital simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for first iteration,  24 Dclk for subsequent [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Txpiclk :  24 Dclk [br]\r\n"
"                    Loop Delay:  8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all bits."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo41_DDR[] = {{"ddrcc_hw_train_ctl0", "", 0x0001A8AC, 10, 0x00000000FFFFFFFF, 0x0000000000002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields42_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo42_DDR[] = {{"ddrcc_hwcal_sts0_0_", "", 0x0001A8B0, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields43_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo43_DDR[] = {{"ddrcc_hwcal_sts0_1_", "", 0x0001A8B4, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields44_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo44_DDR[] = {{"ddrcc_hwcal_sts0_2_", "", 0x0001A8B8, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields45_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo45_DDR[] = {{"ddrcc_hwcal_sts0_3_", "", 0x0001A8BC, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields46_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo46_DDR[] = {{"ddrcc_hwcal_sts1_0_", "", 0x0001A8C0, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields47_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo47_DDR[] = {{"ddrcc_hwcal_sts1_1_", "", 0x0001A8C4, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields48_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo48_DDR[] = {{"ddrcc_hwcal_sts1_2_", "", 0x0001A8C8, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields49_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo49_DDR[] = {{"ddrcc_hwcal_sts1_3_", "", 0x0001A8CC, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields50_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rx_vref_en", "Per Vref control to enable RX Vref.[br]\r\n"
"                    Bit 0: signal index 0-11 [br]\r\n"
"                    Bit 1: signal index 12-21"},
#else
{30, 31, 0x00000000, "RW", "rx_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx Bias and Rx Bias Vref On"},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force all the CMD IO weak ODT on. The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "force_txon", "Forces all the CMD transmitter driver on."},
#else
{26, 26, 0x00000000, "RW", "force_txon", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "force_strong_odt_on", "Force all the CMD IO strong ODT on. When set, it always enable one segment for ODT regardless of the state of drive enable. [br]\r\n"
"                    The intend use case is for ACIO with burnin"},
#else
{25, 25, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", "Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. \r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rx_path_fb_en", "Set to 1 to enable sample path and unsample path feedback results. [br]\r\n"
"                    Note: It is used for SW SA training and SW ACIO txpiclk training."},
#else
{4, 4, 0x00000000, "RW", "rx_path_fb_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", "Set to 1 to enable DDR-T2 Request training"},
#else
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo50_DDR[] = {{"ddrcc_train_ctl1", "", 0x0001A8D4, 21, 0x00000000FFFFFFFF, 0x0000000018000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields51_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Bottom piref calibration. Legal value is 0 to 17."},
#else
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Top piref calibration. Legal value is 0 to 11."},
#else
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Bottom piref calibration. Legal value is 0 to 17."},
#else
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Top piref calibration. Legal value is 0 to 17."},
#else
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{11, 11, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "csa_trigger_en", "When set to 1, the counting window does not start until the first CS assertion (any CS assertion). This trigger only applies for the counters associated with the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{10, 10, 0x00000000, "RW", "csa_trigger_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 1.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 0.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo51_DDR[] = {{"ddrcc_train_ctl2", "", 0x0001A8D8, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields52_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "value that sets the number of DCLK cycles that the selected CMDCTL input samples will be counted. Linear setting. This is broadcast to all the CMDCTL fub. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared."},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo52_DDR[] = {{"ddrcc_train_cnt_window0", "", 0x0001A8DC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields53_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo53_DDR[] = {{"ddrcc_train_cnt_result_0_", "", 0x0001A8E0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields54_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo54_DDR[] = {{"ddrcc_train_cnt_result_1_", "", 0x0001A8E4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields55_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 25, 0x00000000, "RO/V", "sa_train_result", "Per bit senseamp train result[br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{4, 25, 0x00000000, "RO/V", "sa_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result[br]\r\n"
"                    Bit 3 : DLL 1 - piref for IO[lb]21:16[rb][br]\r\n"
"                    Bit 2 : DLL 1 - piref for IO[lb]15:12[rb][br]\r\n"
"                    Bit 1 : DLL 0 - piref for IO[lb]11:6[rb][br]\r\n"
"                    Bit 0 : DLL 0 - piref for IO[lb]5:0[rb]"},
#else
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo55_DDR[] = {{"ddrcc_train_result0", "", 0x0001A8E8, 2, 0x0000000003FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields56_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", "RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training. [br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo56_DDR[] = {{"ddrcc_train_result1", "", 0x0001A8EC, 1, 0x00000000003FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields57_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo57_DDR[] = {{"ddrcc_ctl0_bit_0_", "", 0x00012A00, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields58_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo58_DDR[] = {{"ddrcc_ctl0_bit_1_", "", 0x00012A04, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields59_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo59_DDR[] = {{"ddrcc_ctl0_bit_2_", "", 0x00012A08, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields60_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo60_DDR[] = {{"ddrcc_ctl0_bit_3_", "", 0x00012A0C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields61_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo61_DDR[] = {{"ddrcc_ctl0_bit_4_", "", 0x00012A10, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields62_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo62_DDR[] = {{"ddrcc_ctl0_bit_5_", "", 0x00012A14, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields63_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo63_DDR[] = {{"ddrcc_ctl0_bit_6_", "", 0x00012A18, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields64_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo64_DDR[] = {{"ddrcc_ctl0_bit_7_", "", 0x00012A1C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields65_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo65_DDR[] = {{"ddrcc_ctl0_bit_8_", "", 0x00012A20, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields66_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo66_DDR[] = {{"ddrcc_ctl0_bit_9_", "", 0x00012A24, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields67_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo67_DDR[] = {{"ddrcc_ctl0_bit_10_", "", 0x00012A28, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields68_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo68_DDR[] = {{"ddrcc_ctl0_bit_11_", "", 0x00012A2C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields69_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo69_DDR[] = {{"ddrcc_ctl0_bit_12_", "", 0x00012A30, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields70_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo70_DDR[] = {{"ddrcc_ctl0_bit_13_", "", 0x00012A34, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields71_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo71_DDR[] = {{"ddrcc_ctl0_bit_14_", "", 0x00012A38, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields72_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo72_DDR[] = {{"ddrcc_ctl0_bit_15_", "", 0x00012A3C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields73_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo73_DDR[] = {{"ddrcc_ctl0_bit_16_", "", 0x00012A40, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields74_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo74_DDR[] = {{"ddrcc_ctl0_bit_17_", "", 0x00012A44, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields75_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo75_DDR[] = {{"ddrcc_ctl0_bit_18_", "", 0x00012A48, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields76_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo76_DDR[] = {{"ddrcc_ctl0_bit_19_", "", 0x00012A4C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields77_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo77_DDR[] = {{"ddrcc_ctl0_bit_20_", "", 0x00012A50, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields78_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo78_DDR[] = {{"ddrcc_ctl0_bit_21_", "", 0x00012A54, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields79_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{30, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", "RX Vref control 1 with step size is vccddr_hv/256. Default is 75% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 12 to 21[br]\r\n"
"                    Note: This vref is intended to use for REQ/ERR/RSP_A/RSP_B"},
#else
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", "RX Vref control 0 with step size is vccddr_hv/256. Default is 62.5% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 0 to 11[br]\r\n"
"                    Note: This vref is intended to use for alert_n"},
#else
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo79_DDR[] = {{"ddrcc_rxvref_ctl", "", 0x00012A58, 3, 0x00000000FFFFFFFF, 0x000000000000BFA0}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields80_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "CMD Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "CMD Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo80_DDR[] = {{"ddrcc_comp_la0", "", 0x00012A5C, 2, 0x0000000000000FFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields81_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "CMD Slew Rate Comp Value. It is trained by BIOS. [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate. [br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "CMD TCO Comp Value. It is program by BIOS but it is not trained.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo81_DDR[] = {{"ddrcc_comp_la1", "", 0x00012A60, 2, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields82_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo82_DDR[] = {{"ddrcc_comp_offset", "", 0x00012A64, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields83_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", "Double the timer for VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo83_DDR[] = {{"ddrcc_vsshi_ctl", "", 0x00012A68, 6, 0x00000000FFFFFFFF, 0x0000000000000118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields84_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo84_DDR[] = {{"ddrcc_dll_pi_test_adc_0_", "", 0x00012A6C, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields85_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo85_DDR[] = {{"ddrcc_dll_pi_test_adc_1_", "", 0x00012A70, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields86_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo86_DDR[] = {{"ddrcc_dll_csr_0_", "", 0x00012A74, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields87_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo87_DDR[] = {{"ddrcc_dll_csr_1_", "", 0x00012A78, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields88_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "cmd_dly_adj", "CMD delay adjust value. It is added to all per bit command delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the command fubs."},
#else
{0, 7, 0x00000000, "RW", "cmd_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo88_DDR[] = {{"ddrcc_train_offset0", "", 0x00012A7C, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields89_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo89_DDR[] = {{"ddrcc_piref_offset0_0_", "", 0x00012A80, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields90_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo90_DDR[] = {{"ddrcc_piref_offset0_1_", "", 0x00012A84, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields91_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo91_DDR[] = {{"ddrcc_piref_offset0_2_", "", 0x00012A88, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields92_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo92_DDR[] = {{"ddrcc_piref_offset0_3_", "", 0x00012A8C, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields93_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "rx_path_ungate", "SW set this bit to 1 to ungate the DDRIO to MC RX data path."},
#else
{10, 10, 0x00000000, "RW", "rx_path_ungate", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", "Force the Rx amplifier combiner to a lower static power state during Alert and DDR-T modes,[br]\r\n"
"                    which reduces FiSH temperatures and helps RV."},
#else
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for cmd buf."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo93_DDR[] = {{"ddrcc_rx_ctl0", "", 0x00012A90, 7, 0x0000000007FFFFFF, 0x0000000007C0900B}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields94_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable offset control in cmd buf and RX BIAS"},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo94_DDR[] = {{"ddrcc_rx_ctl1", "", 0x00012A94, 2, 0x00000000FFFFFFFF, 0x0000000000000040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields95_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 : CMD BUF bypass SCOMP and TCO delay in the transmitter."},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", "CA Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", "CS Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", "CA 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", "CS 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", "CA 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", "CS 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ca_imode_en", "CA Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{11, 11, 0x00000000, "RW", "ca_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "cs_imode_en", "CS Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{10, 10, 0x00000000, "RW", "cs_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of drive segment enable for CMD buf. Also, it is used by COMP to TXEQ logic to generate the EQCODE."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of CmdCtl driver (Ron) static legs. [br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Hardware default of 0x1F has 15 static legs enabled. [br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo95_DDR[] = {{"ddrcc_tx_ctl0", "", 0x00012A9C, 12, 0x00000000FFFFFFFF, 0x00000000800000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields96_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", "CA TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", "CS TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", "CA TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63"},
#else
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", "CS TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "io_dir_valid", "Set by BIOS to indicate the io_dir control field is valid.[br]\r\n"
"                    - if this bit is not set, force the receive data to 0[br]\r\n"
"                    - it is used by the command buf CBB to latch the io_pwrdn_pull_low siganl when set to 1 by BIOS. That sequential is power by always on power (s3localvcc), so when analog power is down, the buf use it to determine to either pull low or tri-state the IO."},
#else
{0, 0, 0x00000000, "RW", "io_dir_valid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo96_DDR[] = {{"ddrcc_tx_ctl1", "", 0x00012AA0, 5, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields97_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "Per bit VOC RX pass gate enable for VOC training and NTL testing."},
#else
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All CMDCTL Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - CMDCTL Vref generators are switched off while in CKE power down regardless the setting of rx_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. The cmd Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - The cmd Vref generators are switched off while in Self Refresh regardless the setting of rx_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo97_DDR[] = {{"ddrcc_dfx_ctl0", "", 0x00012AA8, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields98_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW/V", "hw_cal_en", "HW calibation enable control per FSM (cmd has 4). Set to 1 to enable the HW calibration. [br]\r\n"
"                    They are 4 HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW cal FSM will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br]\r\n"
"                    For ACIO testing, all 4 stages can be enabled by SW."},
#else
{28, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 17, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digital simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for first iteration,  24 Dclk for subsequent [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Txpiclk :  24 Dclk [br]\r\n"
"                    Loop Delay:  8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all bits."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo98_DDR[] = {{"ddrcc_hw_train_ctl0", "", 0x00012AAC, 10, 0x00000000FFFFFFFF, 0x0000000000002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields99_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo99_DDR[] = {{"ddrcc_hwcal_sts0_0_", "", 0x00012AB0, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields100_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo100_DDR[] = {{"ddrcc_hwcal_sts0_1_", "", 0x00012AB4, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields101_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo101_DDR[] = {{"ddrcc_hwcal_sts0_2_", "", 0x00012AB8, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields102_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo102_DDR[] = {{"ddrcc_hwcal_sts0_3_", "", 0x00012ABC, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields103_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo103_DDR[] = {{"ddrcc_hwcal_sts1_0_", "", 0x00012AC0, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields104_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo104_DDR[] = {{"ddrcc_hwcal_sts1_1_", "", 0x00012AC4, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields105_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo105_DDR[] = {{"ddrcc_hwcal_sts1_2_", "", 0x00012AC8, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields106_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo106_DDR[] = {{"ddrcc_hwcal_sts1_3_", "", 0x00012ACC, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields107_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rx_vref_en", "Per Vref control to enable RX Vref.[br]\r\n"
"                    Bit 0: signal index 0-11 [br]\r\n"
"                    Bit 1: signal index 12-21"},
#else
{30, 31, 0x00000000, "RW", "rx_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx Bias and Rx Bias Vref On"},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force all the CMD IO weak ODT on. The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "force_txon", "Forces all the CMD transmitter driver on."},
#else
{26, 26, 0x00000000, "RW", "force_txon", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "force_strong_odt_on", "Force all the CMD IO strong ODT on. When set, it always enable one segment for ODT regardless of the state of drive enable. [br]\r\n"
"                    The intend use case is for ACIO with burnin"},
#else
{25, 25, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", "Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. \r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rx_path_fb_en", "Set to 1 to enable sample path and unsample path feedback results. [br]\r\n"
"                    Note: It is used for SW SA training and SW ACIO txpiclk training."},
#else
{4, 4, 0x00000000, "RW", "rx_path_fb_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", "Set to 1 to enable DDR-T2 Request training"},
#else
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo107_DDR[] = {{"ddrcc_train_ctl1", "", 0x00012AD4, 21, 0x00000000FFFFFFFF, 0x0000000018000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields108_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Bottom piref calibration. Legal value is 0 to 17."},
#else
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Top piref calibration. Legal value is 0 to 11."},
#else
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Bottom piref calibration. Legal value is 0 to 17."},
#else
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Top piref calibration. Legal value is 0 to 17."},
#else
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{11, 11, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "csa_trigger_en", "When set to 1, the counting window does not start until the first CS assertion (any CS assertion). This trigger only applies for the counters associated with the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{10, 10, 0x00000000, "RW", "csa_trigger_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 1.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 0.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo108_DDR[] = {{"ddrcc_train_ctl2", "", 0x00012AD8, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields109_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "value that sets the number of DCLK cycles that the selected CMDCTL input samples will be counted. Linear setting. This is broadcast to all the CMDCTL fub. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared."},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo109_DDR[] = {{"ddrcc_train_cnt_window0", "", 0x00012ADC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields110_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo110_DDR[] = {{"ddrcc_train_cnt_result_0_", "", 0x00012AE0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields111_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo111_DDR[] = {{"ddrcc_train_cnt_result_1_", "", 0x00012AE4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields112_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 25, 0x00000000, "RO/V", "sa_train_result", "Per bit senseamp train result[br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{4, 25, 0x00000000, "RO/V", "sa_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result[br]\r\n"
"                    Bit 3 : DLL 1 - piref for IO[lb]21:16[rb][br]\r\n"
"                    Bit 2 : DLL 1 - piref for IO[lb]15:12[rb][br]\r\n"
"                    Bit 1 : DLL 0 - piref for IO[lb]11:6[rb][br]\r\n"
"                    Bit 0 : DLL 0 - piref for IO[lb]5:0[rb]"},
#else
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo112_DDR[] = {{"ddrcc_train_result0", "", 0x00012AE8, 2, 0x0000000003FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields113_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", "RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training. [br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo113_DDR[] = {{"ddrcc_train_result1", "", 0x00012AEC, 1, 0x00000000003FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields114_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo114_DDR[] = {{"ddrcc_ctl0_bit_0_", "", 0x0001AC00, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields115_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo115_DDR[] = {{"ddrcc_ctl0_bit_1_", "", 0x0001AC04, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields116_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo116_DDR[] = {{"ddrcc_ctl0_bit_2_", "", 0x0001AC08, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields117_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo117_DDR[] = {{"ddrcc_ctl0_bit_3_", "", 0x0001AC0C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields118_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo118_DDR[] = {{"ddrcc_ctl0_bit_4_", "", 0x0001AC10, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields119_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo119_DDR[] = {{"ddrcc_ctl0_bit_5_", "", 0x0001AC14, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields120_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo120_DDR[] = {{"ddrcc_ctl0_bit_6_", "", 0x0001AC18, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields121_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo121_DDR[] = {{"ddrcc_ctl0_bit_7_", "", 0x0001AC1C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields122_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo122_DDR[] = {{"ddrcc_ctl0_bit_8_", "", 0x0001AC20, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields123_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo123_DDR[] = {{"ddrcc_ctl0_bit_9_", "", 0x0001AC24, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields124_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo124_DDR[] = {{"ddrcc_ctl0_bit_10_", "", 0x0001AC28, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields125_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo125_DDR[] = {{"ddrcc_ctl0_bit_11_", "", 0x0001AC2C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields126_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo126_DDR[] = {{"ddrcc_ctl0_bit_12_", "", 0x0001AC30, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields127_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo127_DDR[] = {{"ddrcc_ctl0_bit_13_", "", 0x0001AC34, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields128_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo128_DDR[] = {{"ddrcc_ctl0_bit_14_", "", 0x0001AC38, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields129_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo129_DDR[] = {{"ddrcc_ctl0_bit_15_", "", 0x0001AC3C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields130_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo130_DDR[] = {{"ddrcc_ctl0_bit_16_", "", 0x0001AC40, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields131_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo131_DDR[] = {{"ddrcc_ctl0_bit_17_", "", 0x0001AC44, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields132_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo132_DDR[] = {{"ddrcc_ctl0_bit_18_", "", 0x0001AC48, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields133_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo133_DDR[] = {{"ddrcc_ctl0_bit_19_", "", 0x0001AC4C, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields134_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo134_DDR[] = {{"ddrcc_ctl0_bit_20_", "", 0x0001AC50, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields135_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "tx_ui", "Transmit Unit Interval. [br]\r\n"
"                    Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]\r\n"
"                    Bit 0: Set to 1 if TX UI is 2 DCLK. [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]\r\n"
"                    - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]\r\n"
"                    - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)"},
#else
{29, 30, 0x00000000, "RW", "tx_ui", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sa_en", "Sense Amplifier enable to Command buf."},
#else
{27, 27, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", "RX FIFO pointer separation control"},
#else
{24, 26, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "cs_para_sel", "0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap and ca_txeq_2nd_tap.[br]\r\n"
"                    1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code, cs_txeq_1st_tap and cs_txeq_2nd_tap"},
#else
{23, 23, 0x00000000, "RW", "cs_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", "0: sampled path - ERID (DDRT), REQ (DDRT2)[br]\r\n"
"                    1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B (DDR5)"},
#else
{22, 22, 0x00000001, "RW", "rx_unsample_path_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable to Command buf."},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_dis", "BIOS can disable this IO if this CMD IO pin is not used.[br]\r\n"
"                    Currently use case is for DDR5 RDIMM. We only pin out 7 of the IOs. The other 7 IOs are not pinout. "},
#else
{20, 20, 0x00000000, "RW", "io_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "pi_n_clk_en", "PI N clock enable control. For IO that doesn't require to have the PI N clock on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ, alert input don't require PI N clock to receive the data. They are recive on the DCLK."},
#else
{19, 19, 0x00000001, "RW", "pi_n_clk_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state[br]\r\n"
"                    1: pull low (cke for DDR4 or CS for DDR5)"},
#else
{18, 18, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and received data (RX).[br]\r\n"
"                    0: CMD IO is used for RX [br]\r\n"
"                    1: CMD IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control. "},
#else
{17, 17, 0x00000000, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 16, 0x00000040, "RW", "cmd_pie_offset", "This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code) to DLL. Default value is 64."},
#else
{10, 16, 0x00000040, "RW", "cmd_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 8, 0x00000000, "RW/V", "cmd_dly", "CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]\r\n"
"                    This field is added with cmd_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). [br]\r\n"
"                    The final delay - [br]\r\n"
"                    8:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the cmd pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB)  is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: we have 2 DLL in CMD fub, which generate 4 piref clocks. Please refer to ddrcc_piref_offset0 register definition for piref assignment for each bit[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 8, 0x00000000, "RW/V", "cmd_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo135_DDR[] = {{"ddrcc_ctl0_bit_21_", "", 0x0001AC54, 13, 0x00000000FFFFFFFF, 0x0000000000490000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields136_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{30, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", "RX Vref control 1 with step size is vccddr_hv/256. Default is 75% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 12 to 21[br]\r\n"
"                    Note: This vref is intended to use for REQ/ERR/RSP_A/RSP_B"},
#else
{8, 15, 0x000000BF, "RW", "rx_vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", "RX Vref control 0 with step size is vccddr_hv/256. Default is 62.5% vccddr_hv.[br]\r\n"
"                    These control is applied for cc bit 0 to 11[br]\r\n"
"                    Note: This vref is intended to use for alert_n"},
#else
{0, 7, 0x000000A0, "RW", "rx_vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo136_DDR[] = {{"ddrcc_rxvref_ctl", "", 0x0001AC58, 3, 0x00000000FFFFFFFF, 0x000000000000BFA0}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields137_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "CMD Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "CMD Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the cmdbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo137_DDR[] = {{"ddrcc_comp_la0", "", 0x0001AC5C, 2, 0x0000000000000FFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields138_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "CMD Slew Rate Comp Value. It is trained by BIOS. [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate. [br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "CMD TCO Comp Value. It is program by BIOS but it is not trained.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo138_DDR[] = {{"ddrcc_comp_la1", "", 0x0001AC60, 2, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields139_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo139_DDR[] = {{"ddrcc_comp_offset", "", 0x0001AC64, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields140_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", "Double the timer for VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo140_DDR[] = {{"ddrcc_vsshi_ctl", "", 0x0001AC68, 6, 0x00000000FFFFFFFF, 0x0000000000000118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields141_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo141_DDR[] = {{"ddrcc_dll_pi_test_adc_0_", "", 0x0001AC6C, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields142_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo142_DDR[] = {{"ddrcc_dll_pi_test_adc_1_", "", 0x0001AC70, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields143_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo143_DDR[] = {{"ddrcc_dll_csr_0_", "", 0x0001AC74, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields144_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq; It is half of the DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo144_DDR[] = {{"ddrcc_dll_csr_1_", "", 0x0001AC78, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields145_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "cmd_dly_adj", "CMD delay adjust value. It is added to all per bit command delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the command fubs."},
#else
{0, 7, 0x00000000, "RW", "cmd_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo145_DDR[] = {{"ddrcc_train_offset0", "", 0x0001AC7C, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields146_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo146_DDR[] = {{"ddrcc_piref_offset0_0_", "", 0x0001AC80, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields147_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo147_DDR[] = {{"ddrcc_piref_offset0_1_", "", 0x0001AC84, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields148_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo148_DDR[] = {{"ddrcc_piref_offset0_2_", "", 0x0001AC88, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields149_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", "This cmd piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each cmd_dly[6:0], so each cmd pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "cmd_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of  DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo149_DDR[] = {{"ddrcc_piref_offset0_3_", "", 0x0001AC8C, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields150_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "rx_path_ungate", "SW set this bit to 1 to ungate the DDRIO to MC RX data path."},
#else
{10, 10, 0x00000000, "RW", "rx_path_ungate", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", "Force the Rx amplifier combiner to a lower static power state during Alert and DDR-T modes,[br]\r\n"
"                    which reduces FiSH temperatures and helps RV."},
#else
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for cmd buf."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo150_DDR[] = {{"ddrcc_rx_ctl0", "", 0x0001AC90, 7, 0x0000000007FFFFFF, 0x0000000007C0900B}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields151_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable offset control in cmd buf and RX BIAS"},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo151_DDR[] = {{"ddrcc_rx_ctl1", "", 0x0001AC94, 2, 0x00000000FFFFFFFF, 0x0000000000000040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields152_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 : CMD BUF bypass SCOMP and TCO delay in the transmitter."},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", "CA Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "ca_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", "CS Binary Imode Coefficient, sets Imode current strength.[br]\r\n"
"                    (used for either Xtalk cancellation or swing boost)[br]\r\n"
"                    Imode coefficient, sets Imode current. Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{16, 21, 0x00000000, "RW", "cs_imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", "CA 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{15, 15, 0x00000000, "RW", "ca_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", "CS 2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{14, 14, 0x00000000, "RW", "cs_eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", "CA 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{13, 13, 0x00000000, "RW", "ca_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", "CS 2nd tap equalization sign bit[br]\r\n"
"                    0: +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{12, 12, 0x00000000, "RW", "cs_eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ca_imode_en", "CA Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{11, 11, 0x00000000, "RW", "ca_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "cs_imode_en", "CS Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{10, 10, 0x00000000, "RW", "cs_imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of drive segment enable for CMD buf. Also, it is used by COMP to TXEQ logic to generate the EQCODE."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of CmdCtl driver (Ron) static legs. [br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Hardware default of 0x1F has 15 static legs enabled. [br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo152_DDR[] = {{"ddrcc_tx_ctl0", "", 0x0001AC9C, 12, 0x00000000FFFFFFFF, 0x00000000800000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields153_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", "CA TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{20, 23, 0x00000000, "RW", "ca_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", "CS TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{15, 18, 0x00000000, "RW", "cs_txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", "CA TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63"},
#else
{8, 13, 0x00000000, "RW", "ca_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", "CS TxEQ 1st tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{1, 6, 0x00000000, "RW", "cs_txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "io_dir_valid", "Set by BIOS to indicate the io_dir control field is valid.[br]\r\n"
"                    - if this bit is not set, force the receive data to 0[br]\r\n"
"                    - it is used by the command buf CBB to latch the io_pwrdn_pull_low siganl when set to 1 by BIOS. That sequential is power by always on power (s3localvcc), so when analog power is down, the buf use it to determine to either pull low or tri-state the IO."},
#else
{0, 0, 0x00000000, "RW", "io_dir_valid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo153_DDR[] = {{"ddrcc_tx_ctl1", "", 0x0001ACA0, 5, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields154_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "Per bit VOC RX pass gate enable for VOC training and NTL testing."},
#else
{10, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All CMDCTL Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - CMDCTL Vref generators are switched off while in CKE power down regardless the setting of rx_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. The cmd Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - The cmd Vref generators are switched off while in Self Refresh regardless the setting of rx_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo154_DDR[] = {{"ddrcc_dfx_ctl0", "", 0x0001ACA8, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields155_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW/V", "hw_cal_en", "HW calibation enable control per FSM (cmd has 4). Set to 1 to enable the HW calibration. [br]\r\n"
"                    They are 4 HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW cal FSM will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br]\r\n"
"                    For ACIO testing, all 4 stages can be enabled by SW."},
#else
{28, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 17, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digital simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for first iteration,  24 Dclk for subsequent [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Txpiclk :  24 Dclk [br]\r\n"
"                    Loop Delay:  8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all bits."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo155_DDR[] = {{"ddrcc_hw_train_ctl0", "", 0x0001ACAC, 10, 0x00000000FFFFFFFF, 0x0000000000002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields156_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo156_DDR[] = {{"ddrcc_hwcal_sts0_0_", "", 0x0001ACB0, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields157_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo157_DDR[] = {{"ddrcc_hwcal_sts0_1_", "", 0x0001ACB4, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields158_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo158_DDR[] = {{"ddrcc_hwcal_sts0_2_", "", 0x0001ACB8, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields159_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{10, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 9, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 9, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any bit within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo159_DDR[] = {{"ddrcc_hwcal_sts0_3_", "", 0x0001ACBC, 6, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields160_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo160_DDR[] = {{"ddrcc_hwcal_sts1_0_", "", 0x0001ACC0, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields161_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo161_DDR[] = {{"ddrcc_hwcal_sts1_1_", "", 0x0001ACC4, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields162_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo162_DDR[] = {{"ddrcc_hwcal_sts1_2_", "", 0x0001ACC8, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields163_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo163_DDR[] = {{"ddrcc_hwcal_sts1_3_", "", 0x0001ACCC, 6, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields164_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rx_vref_en", "Per Vref control to enable RX Vref.[br]\r\n"
"                    Bit 0: signal index 0-11 [br]\r\n"
"                    Bit 1: signal index 12-21"},
#else
{30, 31, 0x00000000, "RW", "rx_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx Bias and Rx Bias Vref On"},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force all the CMD IO weak ODT on. The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "force_txon", "Forces all the CMD transmitter driver on."},
#else
{26, 26, 0x00000000, "RW", "force_txon", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "force_strong_odt_on", "Force all the CMD IO strong ODT on. When set, it always enable one segment for ODT regardless of the state of drive enable. [br]\r\n"
"                    The intend use case is for ACIO with burnin"},
#else
{25, 25, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", "Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. \r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rx_path_fb_en", "Set to 1 to enable sample path and unsample path feedback results. [br]\r\n"
"                    Note: It is used for SW SA training and SW ACIO txpiclk training."},
#else
{4, 4, 0x00000000, "RW", "rx_path_fb_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", "Set to 1 to enable DDR-T2 Request training"},
#else
{1, 1, 0x00000000, "RW", "ddrt2_req_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo164_DDR[] = {{"ddrcc_train_ctl1", "", 0x0001ACD4, 21, 0x00000000FFFFFFFF, 0x0000000018000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields165_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Bottom piref calibration. Legal value is 0 to 17."},
#else
{27, 31, 0x00000000, "RW", "dll1_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL1 Top piref calibration. Legal value is 0 to 11."},
#else
{22, 26, 0x00000000, "RW", "dll1_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Bottom piref calibration. Legal value is 0 to 17."},
#else
{17, 21, 0x00000000, "RW", "dll0_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL0 Top piref calibration. Legal value is 0 to 17."},
#else
{12, 16, 0x00000000, "RW", "dll0_top_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{11, 11, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "csa_trigger_en", "When set to 1, the counting window does not start until the first CS assertion (any CS assertion). This trigger only applies for the counters associated with the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{10, 10, 0x00000000, "RW", "csa_trigger_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 1.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{5, 9, 0x00000000, "RW", "train_cnt_io_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", "Select which IO to count during DCS and DCA training. The count result is stored in ddr_train_cnt_result0 register 0.[br]\r\n"
"                    Note: The current supporting mode is counting only ALERT_n or counting on both RSP_A and RSP_B signals."},
#else
{0, 4, 0x00000000, "RW", "train_cnt_io_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo165_DDR[] = {{"ddrcc_train_ctl2", "", 0x0001ACD8, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields166_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "value that sets the number of DCLK cycles that the selected CMDCTL input samples will be counted. Linear setting. This is broadcast to all the CMDCTL fub. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared."},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo166_DDR[] = {{"ddrcc_train_cnt_window0", "", 0x0001ACDC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields167_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo167_DDR[] = {{"ddrcc_train_cnt_result_0_", "", 0x0001ACE0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields168_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled..  Whten the cnt_window is set to 0, the counter will run until it saturates."},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo168_DDR[] = {{"ddrcc_train_cnt_result_1_", "", 0x0001ACE4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields169_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 25, 0x00000000, "RO/V", "sa_train_result", "Per bit senseamp train result[br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{4, 25, 0x00000000, "RO/V", "sa_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result[br]\r\n"
"                    Bit 3 : DLL 1 - piref for IO[lb]21:16[rb][br]\r\n"
"                    Bit 2 : DLL 1 - piref for IO[lb]15:12[rb][br]\r\n"
"                    Bit 1 : DLL 0 - piref for IO[lb]11:6[rb][br]\r\n"
"                    Bit 0 : DLL 0 - piref for IO[lb]5:0[rb]"},
#else
{0, 3, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo169_DDR[] = {{"ddrcc_train_result0", "", 0x0001ACE8, 2, 0x0000000003FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields170_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", "RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training. [br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{0, 21, 0x00000000, "RO/V", "rx_even_sample_path_fb", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo170_DDR[] = {{"ddrcc_train_result1", "", 0x0001ACEC, 1, 0x00000000003FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields171_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo171_DDR[] = {{"ddrcc_ctl1_bit_0_", "", 0x0001A900, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields172_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo172_DDR[] = {{"ddrcc_ctl1_bit_1_", "", 0x0001A904, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields173_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo173_DDR[] = {{"ddrcc_ctl1_bit_2_", "", 0x0001A908, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields174_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo174_DDR[] = {{"ddrcc_ctl1_bit_3_", "", 0x0001A90C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields175_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo175_DDR[] = {{"ddrcc_ctl1_bit_4_", "", 0x0001A910, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields176_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo176_DDR[] = {{"ddrcc_ctl1_bit_5_", "", 0x0001A914, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields177_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo177_DDR[] = {{"ddrcc_ctl1_bit_6_", "", 0x0001A918, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields178_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo178_DDR[] = {{"ddrcc_ctl1_bit_7_", "", 0x0001A91C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields179_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo179_DDR[] = {{"ddrcc_ctl1_bit_8_", "", 0x0001A920, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields180_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo180_DDR[] = {{"ddrcc_ctl1_bit_9_", "", 0x0001A924, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields181_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo181_DDR[] = {{"ddrcc_ctl1_bit_10_", "", 0x0001A928, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields182_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo182_DDR[] = {{"ddrcc_ctl1_bit_11_", "", 0x0001A92C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields183_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo183_DDR[] = {{"ddrcc_ctl1_bit_12_", "", 0x0001A930, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields184_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo184_DDR[] = {{"ddrcc_ctl1_bit_13_", "", 0x0001A934, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields185_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo185_DDR[] = {{"ddrcc_ctl1_bit_14_", "", 0x0001A938, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields186_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo186_DDR[] = {{"ddrcc_ctl1_bit_15_", "", 0x0001A93C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields187_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo187_DDR[] = {{"ddrcc_ctl1_bit_16_", "", 0x0001A940, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields188_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo188_DDR[] = {{"ddrcc_ctl1_bit_17_", "", 0x0001A944, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields189_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo189_DDR[] = {{"ddrcc_ctl1_bit_18_", "", 0x0001A948, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields190_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo190_DDR[] = {{"ddrcc_ctl1_bit_19_", "", 0x0001A94C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields191_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo191_DDR[] = {{"ddrcc_ctl1_bit_20_", "", 0x0001A950, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields192_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo192_DDR[] = {{"ddrcc_ctl1_bit_21_", "", 0x0001A954, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields193_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo193_DDR[] = {{"ddrcc_dll_ctl0", "", 0x0001A958, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields194_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo194_DDR[] = {{"ddrcc_ctl1_bit_0_", "", 0x00012B00, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields195_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo195_DDR[] = {{"ddrcc_ctl1_bit_1_", "", 0x00012B04, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields196_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo196_DDR[] = {{"ddrcc_ctl1_bit_2_", "", 0x00012B08, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields197_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo197_DDR[] = {{"ddrcc_ctl1_bit_3_", "", 0x00012B0C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields198_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo198_DDR[] = {{"ddrcc_ctl1_bit_4_", "", 0x00012B10, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields199_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo199_DDR[] = {{"ddrcc_ctl1_bit_5_", "", 0x00012B14, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields200_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo200_DDR[] = {{"ddrcc_ctl1_bit_6_", "", 0x00012B18, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields201_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo201_DDR[] = {{"ddrcc_ctl1_bit_7_", "", 0x00012B1C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields202_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo202_DDR[] = {{"ddrcc_ctl1_bit_8_", "", 0x00012B20, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields203_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo203_DDR[] = {{"ddrcc_ctl1_bit_9_", "", 0x00012B24, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields204_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo204_DDR[] = {{"ddrcc_ctl1_bit_10_", "", 0x00012B28, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields205_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo205_DDR[] = {{"ddrcc_ctl1_bit_11_", "", 0x00012B2C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields206_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo206_DDR[] = {{"ddrcc_ctl1_bit_12_", "", 0x00012B30, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields207_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo207_DDR[] = {{"ddrcc_ctl1_bit_13_", "", 0x00012B34, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields208_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo208_DDR[] = {{"ddrcc_ctl1_bit_14_", "", 0x00012B38, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields209_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo209_DDR[] = {{"ddrcc_ctl1_bit_15_", "", 0x00012B3C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields210_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo210_DDR[] = {{"ddrcc_ctl1_bit_16_", "", 0x00012B40, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields211_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo211_DDR[] = {{"ddrcc_ctl1_bit_17_", "", 0x00012B44, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields212_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo212_DDR[] = {{"ddrcc_ctl1_bit_18_", "", 0x00012B48, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields213_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo213_DDR[] = {{"ddrcc_ctl1_bit_19_", "", 0x00012B4C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields214_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo214_DDR[] = {{"ddrcc_ctl1_bit_20_", "", 0x00012B50, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields215_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo215_DDR[] = {{"ddrcc_ctl1_bit_21_", "", 0x00012B54, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields216_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo216_DDR[] = {{"ddrcc_dll_ctl0", "", 0x00012B58, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields217_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo217_DDR[] = {{"ddrcc_ctl1_bit_0_", "", 0x0001AD00, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields218_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo218_DDR[] = {{"ddrcc_ctl1_bit_1_", "", 0x0001AD04, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields219_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo219_DDR[] = {{"ddrcc_ctl1_bit_2_", "", 0x0001AD08, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields220_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo220_DDR[] = {{"ddrcc_ctl1_bit_3_", "", 0x0001AD0C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields221_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo221_DDR[] = {{"ddrcc_ctl1_bit_4_", "", 0x0001AD10, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields222_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo222_DDR[] = {{"ddrcc_ctl1_bit_5_", "", 0x0001AD14, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields223_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo223_DDR[] = {{"ddrcc_ctl1_bit_6_", "", 0x0001AD18, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields224_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo224_DDR[] = {{"ddrcc_ctl1_bit_7_", "", 0x0001AD1C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields225_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo225_DDR[] = {{"ddrcc_ctl1_bit_8_", "", 0x0001AD20, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields226_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo226_DDR[] = {{"ddrcc_ctl1_bit_9_", "", 0x0001AD24, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields227_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo227_DDR[] = {{"ddrcc_ctl1_bit_10_", "", 0x0001AD28, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields228_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo228_DDR[] = {{"ddrcc_ctl1_bit_11_", "", 0x0001AD2C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields229_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo229_DDR[] = {{"ddrcc_ctl1_bit_12_", "", 0x0001AD30, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields230_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo230_DDR[] = {{"ddrcc_ctl1_bit_13_", "", 0x0001AD34, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields231_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo231_DDR[] = {{"ddrcc_ctl1_bit_14_", "", 0x0001AD38, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields232_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo232_DDR[] = {{"ddrcc_ctl1_bit_15_", "", 0x0001AD3C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields233_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo233_DDR[] = {{"ddrcc_ctl1_bit_16_", "", 0x0001AD40, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields234_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo234_DDR[] = {{"ddrcc_ctl1_bit_17_", "", 0x0001AD44, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields235_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo235_DDR[] = {{"ddrcc_ctl1_bit_18_", "", 0x0001AD48, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields236_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo236_DDR[] = {{"ddrcc_ctl1_bit_19_", "", 0x0001AD4C, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields237_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo237_DDR[] = {{"ddrcc_ctl1_bit_20_", "", 0x0001AD50, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields238_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61,62,63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo238_DDR[] = {{"ddrcc_ctl1_bit_21_", "", 0x0001AD54, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields239_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo239_DDR[] = {{"ddrcc_dll_ctl0", "", 0x0001AD58, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields240_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo240_DDR[] = {{"ddrclk_ctl0_pair_0_", "", 0x00012C00, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields241_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo241_DDR[] = {{"ddrclk_ctl0_pair_1_", "", 0x00012C04, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields242_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo242_DDR[] = {{"ddrclk_ctl0_pair_2_", "", 0x00012C08, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields243_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo243_DDR[] = {{"ddrclk_ctl0_pair_3_", "", 0x00012C0C, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields244_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000BF, "RW", "rx_vref_ctl", "RX Vref control with step size is vccddr_hv/256. Default is 75% vccddr_hv."},
#else
{0, 7, 0x000000BF, "RW", "rx_vref_ctl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo244_DDR[] = {{"ddrclk_rxvref_ctl", "", 0x00012C20, 2, 0x00000000FFFFFFFF, 0x00000000000000BF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields245_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Clk Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the clkbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Clk Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the clkbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo245_DDR[] = {{"ddrclk_comp_la0", "", 0x00012C24, 2, 0x0000000000000FFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields246_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "Clk Slew Rate Comp Value.[br]\r\n"
"                    It is program by BIOS but it is not trained.[br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate.[br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "Clk TCO Comp Value. It is programmed by BIOS but it is not trained.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo246_DDR[] = {{"ddrclk_comp_la1", "", 0x00012C28, 2, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields247_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo247_DDR[] = {{"ddrclk_comp_offset", "", 0x00012C2C, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields248_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo248_DDR[] = {{"ddrclk_dll_pi_test_adc", "", 0x00012C30, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields249_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq. It is half of the DRAM transfer rate.[br]\r\n"
"                    For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo249_DDR[] = {{"ddrclk_dll_csr", "", 0x00012C34, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields250_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock lock is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo250_DDR[] = {{"ddrclk_dll_ctl0", "", 0x00012C38, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields251_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", "This clk piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each clk pair clk_dly[6:0] field, so each clk pair pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63) to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo251_DDR[] = {{"ddrclk_piref_offset0_0_", "", 0x00012C3C, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields252_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", "This clk piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each clk pair clk_dly[6:0] field, so each clk pair pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63) to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo252_DDR[] = {{"ddrclk_piref_offset0_1_", "", 0x00012C40, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields253_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "3 Rload Settings (K- 1.5, 2, and 3)"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "rx_path_ungate", "SW set this bit to 1 to ungate the DDRIO to MC RX data path."},
#else
{10, 10, 0x00000000, "RW", "rx_path_ungate", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", "Force the Rx amplifier combiner to a lower static power state during Alert and DDR-T modes,[br]\r\n"
"                    which reduces FiSH temperatures and helps RV."},
#else
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for clk buf."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo253_DDR[] = {{"ddrclk_rx_ctl0", "", 0x00012C44, 7, 0x0000000007FFFFFF, 0x0000000007C0900B}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields254_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable offset control in clk buf and RX BIAS"},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo254_DDR[] = {{"ddrclk_rx_ctl1", "", 0x00012C48, 2, 0x00000000FFFFFFFF, 0x0000000000000040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields255_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 : CLK BUF bypass SCOMP and TCO delay in the transmitter."},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of data sement enable for CLK buf."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of CLK driver (Ron) static legs.[br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1.[br]\r\n"
"                    RTL default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo255_DDR[] = {{"ddrclk_tx_ctl0", "", 0x00012C50, 4, 0x00000000FFFFFFFF, 0x00000000800000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields256_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "io_dir_valid", "IODirectionValid.[br]\r\n"
"                    SW must program the io_pwrdn_pull_low control before set this bit to 1 to ensure the analog logic capture the pwr down pin behavior."},
#else
{0, 0, 0x00000000, "RW", "io_dir_valid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo256_DDR[] = {{"ddrclk_tx_ctl1", "", 0x00012C54, 1, 0x0000000000000001, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields257_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "Per bit VOC RX pass gate enable for VOC training and NTL testing."},
#else
{24, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All CLK Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - CLK Vref generators are switched off while in CKE power down regardless the setting of rx_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. The clk Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - The clk Vref generators are switched off while in Self Refresh regardless the setting of rx_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo257_DDR[] = {{"ddrclk_dfx_ctl0", "", 0x00012C5C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields258_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW/V", "hw_cal_en", "HW calibation enable control per FSM (clk has 2). Set to 1 to enable the HW calibration. [br]\r\n"
"                    They are 4 HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW cal FSM will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br]\r\n"
"                    For ACIO testing, all 4 stages can be enabled by SW."},
#else
{30, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 17, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digital simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for first iteration,  24 Dclk for subsequent [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Txpiclk :  24 Dclk [br]\r\n"
"                    Loop Delay:  8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all clock bits."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo258_DDR[] = {{"ddrclk_hw_train_ctl0", "", 0x00012C60, 10, 0x00000000FFFFFFFF, 0x0000000000002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields259_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any clock pair within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo259_DDR[] = {{"ddrclk_hwcal_sts0_0_", "", 0x00012C64, 7, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields260_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any clock pair within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo260_DDR[] = {{"ddrclk_hwcal_sts0_1_", "", 0x00012C68, 7, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields261_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_vref_en", "set to 1 to enable CLK vref"},
#else
{31, 31, 0x00000000, "RW", "rx_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "force_strong_odt_on", "Force all the CLK IO strong ODT on. When set, it always enable one segment for ODT regardless the state of the drive enable. [br]\r\n"
"                    The intend use case is for ACIO with burnin."},
#else
{30, 30, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx Bias and Rx Bias Vref On"},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force all the CLK IO weak ODT on. The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "force_txon", "Forces all the clk transmitter driver on."},
#else
{26, 26, 0x00000000, "RW", "force_txon", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", "Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. \r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rx_path_fb_en", "Set to 1 to enable sample path and unsample path feedback results. [br]\r\n"
"                    Note: It is used for SW SA training and SW ACIO txpiclk training."},
#else
{4, 4, 0x00000000, "RW", "rx_path_fb_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo261_DDR[] = {{"ddrclk_train_ctl1", "", 0x00012C78, 18, 0x00000000FFFFFFFF, 0x0000000018000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields262_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "dll_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL Bottom piref calibration. Legal value is 0 to 9."},
#else
{4, 7, 0x00000000, "RW", "dll_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dll_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL Top piref calibration. Legal value is 0 to 9."},
#else
{0, 3, 0x00000000, "RW", "dll_top_xover_cal_mux_sel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo262_DDR[] = {{"ddrclk_train_ctl2", "", 0x00012C7C, 2, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields263_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 17, 0x00000000, "RO/V", "rx_even_sample_path_fb", "RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training. [br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{10, 17, 0x00000000, "RO/V", "rx_even_sample_path_fb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 9, 0x00000000, "RO/V", "sa_train_result", "Per bit senseamp train result"},
#else
{2, 9, 0x00000000, "RO/V", "sa_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result[br]\r\n"
"                    Bit 1 : DLL 0 - piref for clk pair [lb]3:2[rb][br]\r\n"
"                    Bit 0 : DLL 0 - piref for clk pair [lb]1:0[rb]"},
#else
{0, 1, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo263_DDR[] = {{"ddrclk_train_result0", "", 0x00012C80, 3, 0x000000000003FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields264_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo264_DDR[] = {{"ddrclk_ctl0_bit_0_", "", 0x00012CE0, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields265_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo265_DDR[] = {{"ddrclk_ctl0_bit_1_", "", 0x00012CE4, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields266_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo266_DDR[] = {{"ddrclk_ctl0_bit_2_", "", 0x00012CE8, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields267_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo267_DDR[] = {{"ddrclk_ctl0_bit_3_", "", 0x00012CEC, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields268_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo268_DDR[] = {{"ddrclk_ctl0_bit_4_", "", 0x00012CF0, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields269_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo269_DDR[] = {{"ddrclk_ctl0_bit_5_", "", 0x00012CF4, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields270_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo270_DDR[] = {{"ddrclk_ctl0_bit_6_", "", 0x00012CF8, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields271_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo271_DDR[] = {{"ddrclk_ctl0_bit_7_", "", 0x00012CFC, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields272_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo272_DDR[] = {{"ddrclk_ctl0_pair_0_", "", 0x0001BF00, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields273_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo273_DDR[] = {{"ddrclk_ctl0_pair_1_", "", 0x0001BF04, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields274_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo274_DDR[] = {{"ddrclk_ctl0_pair_2_", "", 0x0001BF08, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields275_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "sa_en", "Senseamp enable per clock pair"},
#else
{22, 22, 0x00000000, "RW", "sa_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "odt_en", "ODT enable per clock pair"},
#else
{21, 21, 0x00000000, "RW", "odt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", "IO Analog Power Down Pull low control. This control determines the IO behavior (pull low or tri-state) when analog power domain is down (C6 or S3)[br]\r\n"
"                    0: tri-state (DDRT ERID ONLY)[br]\r\n"
"                    1: pull low"},
#else
{20, 20, 0x00000000, "RW", "io_pwrdn_pull_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", "In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This bit sets the RXFIFO pointer initialization value."},
#else
{17, 19, 0x00000000, "RW", "rxfifo_ptr_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "clk_pair_en", "Enables output buffers, PI clocks and output datapaths for this clock pair."},
#else
{16, 16, 0x00000001, "RW", "clk_pair_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "io_dir", "IO direction control during normal function mode. This bit is used to qualify the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br]\r\n"
"                    0: CLK IO is used for RX [br]\r\n"
"                    1: CLK IO is used for TX [br]\r\n"
"                    Note: This signal need to be qualify by IO direction valid control.[br]\r\n"
"                    Note: For ACIO, both RX/TX are enabled by ACIO control."},
#else
{15, 15, 0x00000001, "RW", "io_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_pie_offset", "This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code) to DLL. Default value is 64."},
#else
{8, 14, 0x00000040, "RW", "clk_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "clk_dly", "CLK delay with step size of clkpi/128.[br]\r\n"
"                    This value is added with clk_piref_offset and piref_setup_adj to generate the clk_pio_code before send to DLL , so the programed value is relative to the piref odd clock.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    Note: Each clock pair P/N pin share the same delay.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "clk_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo275_DDR[] = {{"ddrclk_ctl0_pair_3_", "", 0x0001BF0C, 9, 0x00000000FFFFFFFF, 0x000000000001C000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields276_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000BF, "RW", "rx_vref_ctl", "RX Vref control with step size is vccddr_hv/256. Default is 75% vccddr_hv."},
#else
{0, 7, 0x000000BF, "RW", "rx_vref_ctl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo276_DDR[] = {{"ddrclk_rxvref_ctl", "", 0x0001BF20, 2, 0x00000000FFFFFFFF, 0x00000000000000BF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields277_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Clk Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the clkbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Clk Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the clkbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo277_DDR[] = {{"ddrclk_comp_la0", "", 0x0001BF24, 2, 0x0000000000000FFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields278_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "Clk Slew Rate Comp Value.[br]\r\n"
"                    It is program by BIOS but it is not trained.[br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate.[br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "Clk TCO Comp Value. It is programmed by BIOS but it is not trained.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo278_DDR[] = {{"ddrclk_comp_la1", "", 0x0001BF28, 2, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields279_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo279_DDR[] = {{"ddrclk_comp_offset", "", 0x0001BF2C, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields280_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo280_DDR[] = {{"ddrclk_dll_pi_test_adc", "", 0x0001BF30, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields281_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq. It is half of the DRAM transfer rate.[br]\r\n"
"                    For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo281_DDR[] = {{"ddrclk_dll_csr", "", 0x0001BF34, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields282_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock lock is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo282_DDR[] = {{"ddrclk_dll_ctl0", "", 0x0001BF38, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields283_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", "This clk piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each clk pair clk_dly[6:0] field, so each clk pair pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63) to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo283_DDR[] = {{"ddrclk_piref_offset0_0_", "", 0x0001BF3C, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields284_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will have 63 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{24, 30, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", "This clk piref offset is added with a signed piref_setup_adj (default value is 63). [br]\r\n"
"                    The result is added to each clk pair clk_dly[6:0] field, so each clk pair pi odd code to the DLL is relative to the piref odd clock.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{14, 20, 0x00000000, "RW/V", "clk_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "piref_pie_offset", "This offset is added to the piref_pio_code. The result is the piref pi even code (piref_pie_code) to DLL. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "piref_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", "It is the train PI odd code to align the PIREF odd clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default value is 63) to generate the  piref_pio_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pio_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo284_DDR[] = {{"ddrclk_piref_offset0_1_", "", 0x0001BF40, 4, 0x000000007FFFFFFF, 0x000000003F002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields285_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "3 Rload Settings (K- 1.5, 2, and 3)"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "rx_path_ungate", "SW set this bit to 1 to ungate the DDRIO to MC RX data path."},
#else
{10, 10, 0x00000000, "RW", "rx_path_ungate", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", "Force the Rx amplifier combiner to a lower static power state during Alert and DDR-T modes,[br]\r\n"
"                    which reduces FiSH temperatures and helps RV."},
#else
{3, 3, 0x00000001, "RW", "rx_combiner_alert_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for clk buf."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo285_DDR[] = {{"ddrclk_rx_ctl0", "", 0x0001BF44, 7, 0x0000000007FFFFFF, 0x0000000007C0900B}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields286_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable offset control in clk buf and RX BIAS"},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo286_DDR[] = {{"ddrclk_rx_ctl1", "", 0x0001BF48, 2, 0x00000000FFFFFFFF, 0x0000000000000040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields287_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 : CLK BUF bypass SCOMP and TCO delay in the transmitter."},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of data sement enable for CLK buf."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of CLK driver (Ron) static legs.[br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1.[br]\r\n"
"                    RTL default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo287_DDR[] = {{"ddrclk_tx_ctl0", "", 0x0001BF50, 4, 0x00000000FFFFFFFF, 0x00000000800000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields288_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "io_dir_valid", "IODirectionValid.[br]\r\n"
"                    SW must program the io_pwrdn_pull_low control before set this bit to 1 to ensure the analog logic capture the pwr down pin behavior."},
#else
{0, 0, 0x00000000, "RW", "io_dir_valid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo288_DDR[] = {{"ddrclk_tx_ctl1", "", 0x0001BF54, 1, 0x0000000000000001, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields289_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "Per bit VOC RX pass gate enable for VOC training and NTL testing."},
#else
{24, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All CLK Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - CLK Vref generators are switched off while in CKE power down regardless the setting of rx_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. The clk Vref generators is enabled by rx_vref_en.[br]\r\n"
"                    1 - The clk Vref generators are switched off while in Self Refresh regardless the setting of rx_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo289_DDR[] = {{"ddrclk_dfx_ctl0", "", 0x0001BF5C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields290_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW/V", "hw_cal_en", "HW calibation enable control per FSM (clk has 2). Set to 1 to enable the HW calibration. [br]\r\n"
"                    They are 4 HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW cal FSM will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br]\r\n"
"                    For ACIO testing, all 4 stages can be enabled by SW."},
#else
{30, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 17, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digital simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for first iteration,  24 Dclk for subsequent [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Txpiclk :  24 Dclk [br]\r\n"
"                    Loop Delay:  8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all clock bits."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo290_DDR[] = {{"ddrclk_hw_train_ctl0", "", 0x0001BF60, 10, 0x00000000FFFFFFFF, 0x0000000000002000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields291_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any clock pair within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo291_DDR[] = {{"ddrclk_hwcal_sts0_0_", "", 0x0001BF64, 7, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields292_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 11, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed for any clock pair within this piref group. SW must clear this bit to 0 when enable HW calibration."},
#else
{1, 1, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{0, 0, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo292_DDR[] = {{"ddrclk_hwcal_sts0_1_", "", 0x0001BF68, 7, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields293_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_vref_en", "set to 1 to enable CLK vref"},
#else
{31, 31, 0x00000000, "RW", "rx_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "force_strong_odt_on", "Force all the CLK IO strong ODT on. When set, it always enable one segment for ODT regardless the state of the drive enable. [br]\r\n"
"                    The intend use case is for ACIO with burnin."},
#else
{30, 30, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx Bias and Rx Bias Vref On"},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force all the CLK IO weak ODT on. The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "force_txon", "Forces all the clk transmitter driver on."},
#else
{26, 26, 0x00000000, "RW", "force_txon", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", "Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "pi_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. \r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rx_path_fb_en", "Set to 1 to enable sample path and unsample path feedback results. [br]\r\n"
"                    Note: It is used for SW SA training and SW ACIO txpiclk training."},
#else
{4, 4, 0x00000000, "RW", "rx_path_fb_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo293_DDR[] = {{"ddrclk_train_ctl1", "", 0x0001BF78, 18, 0x00000000FFFFFFFF, 0x0000000018000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields294_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "dll_bot_xover_cal_mux_sel", "Select which xover phase detect output for DLL Bottom piref calibration. Legal value is 0 to 9."},
#else
{4, 7, 0x00000000, "RW", "dll_bot_xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dll_top_xover_cal_mux_sel", "Select which xover phase detect output for DLL Top piref calibration. Legal value is 0 to 9."},
#else
{0, 3, 0x00000000, "RW", "dll_top_xover_cal_mux_sel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo294_DDR[] = {{"ddrclk_train_ctl2", "", 0x0001BF7C, 2, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields295_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 17, 0x00000000, "RO/V", "rx_even_sample_path_fb", "RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training. [br]\r\n"
"                    Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1 before reading this fields."},
#else
{10, 17, 0x00000000, "RO/V", "rx_even_sample_path_fb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 9, 0x00000000, "RO/V", "sa_train_result", "Per bit senseamp train result"},
#else
{2, 9, 0x00000000, "RO/V", "sa_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result[br]\r\n"
"                    Bit 1 : DLL 0 - piref for clk pair [lb]3:2[rb][br]\r\n"
"                    Bit 0 : DLL 0 - piref for clk pair [lb]1:0[rb]"},
#else
{0, 1, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo295_DDR[] = {{"ddrclk_train_result0", "", 0x0001BF80, 3, 0x000000000003FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields296_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo296_DDR[] = {{"ddrclk_ctl0_bit_0_", "", 0x0001BFE0, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields297_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo297_DDR[] = {{"ddrclk_ctl0_bit_1_", "", 0x0001BFE4, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields298_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo298_DDR[] = {{"ddrclk_ctl0_bit_2_", "", 0x0001BFE8, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields299_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo299_DDR[] = {{"ddrclk_ctl0_bit_3_", "", 0x0001BFEC, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields300_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo300_DDR[] = {{"ddrclk_ctl0_bit_4_", "", 0x0001BFF0, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields301_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo301_DDR[] = {{"ddrclk_ctl0_bit_5_", "", 0x0001BFF4, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields302_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo302_DDR[] = {{"ddrclk_ctl0_bit_6_", "", 0x0001BFF8, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields303_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo303_DDR[] = {{"ddrclk_ctl0_bit_7_", "", 0x0001BFFC, 1, 0x000000000000003F, 0x000000000000001E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields304_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 25, 0x00000000, "RW/V", "rcomp_odt_dn", "Sets the resistive value of the pull-dn block of DQ On die termination. When [br]\r\n"
"                    dq_odt_dn_ovr_en = 1, ODT value is programmed by software [br]\r\n"
"                    dq_odt_dn_ovr_en = 0, ODT value is computed by Comp FSM "},
#else
{21, 25, 0x00000000, "RW/V", "rcomp_odt_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 18, 0x00000000, "RW/V", "rcomp_odt_up", "Sets the resistive value of the pull-up block of DQ On die termination.When [br]\r\n"
"                    dq_odt_up_ovr_en = 1, ODT value is programmed by software[br]\r\n"
"                    dq_odt_up_ovr_en = 0, ODT value is computed by Comp FSM "},
#else
{14, 18, 0x00000000, "RW/V", "rcomp_odt_up", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Sets the resistive value (aka driving strength) of the pull-down block of the DQ/DQS transmitter. When [br]\r\n"
"                    dq_drv_dn_ovr_en = 1, drive strength value is programmed by software[br]\r\n"
"                    dq_drv_dn_ovr_en = 0, drive strength value is computed by Comp FSM "},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Sets the resistive value (aka driving strength) of the pull-up block of the DQ/DQS transmitter. When [br]\r\n"
"                    dq_drv_up_ovr_en = 1, drive strength value is programmed by software[br]\r\n"
"                    dq_drv_up_ovr_en = 0, drive strength value is computed by Comp FSM"},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo304_DDR[] = {{"ddrcomp_data_comp0", "", 0x00017F00, 4, 0x0000000003FFFFFF, 0x0000000000000408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields305_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000000, "RW/V", "rcomp_drv_dn", "Sets the resistive value (aka driving strength) of the pull-down block of the CMD transmitter. When[br]\r\n"
"                    cmd_drv_dn_ovr_en = 1, drive strength value is programmed by software[br] \r\n"
"                    cmd_drv_dn_ovr_en = 0, drive strength value is computed by Comp FSM.[br]\r\n"
"                    Note: CMD transmitter uses rcomp codes for ODT codes too."},
#else
{7, 11, 0x00000000, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW/V", "rcomp_drv_up", "Sets the resistive value (aka driving strength) of the pull-Up block of the CMD transmitter. When[br]\r\n"
"                    cmd_drv_up_ovr_en = 1, drive strength value is programmed by software[br]\r\n"
"                    cmd_drv_up_ovr_en = 0, drive strength value is computed by Comp FSM.[br] \r\n"
"                    Note: CMD transmitter uses rcomp codes for ODT codes too."},
#else
{0, 4, 0x00000000, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo305_DDR[] = {{"ddrcomp_cmd_comp0", "", 0x00017F04, 2, 0x0000000000000FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields306_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000000, "RW/V", "rcomp_drv_dn", "Sets the resistive value (aka driving strength) of the pull-down block of the CLK transmitter. When[br]\r\n"
"                    clk_drv_dn_ovr_en = 1, drive strength value is programmed by software[br]\r\n"
"                    clk_drv_dn_ovr_en = 0, drive strength value is computed by CompFSM"},
#else
{7, 11, 0x00000000, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW/V", "rcomp_drv_up", "Sets the resistive value (aka driving strength) of the pull-Up block of the CLK transmitter. When[br]\r\n"
"                    clk_drv_up_ovr_en = 1, drive strength value is programmed by software[br]\r\n"
"                    clk_drv_up_ovr_en = 0, drive strength value is computed by Comp FSM"},
#else
{0, 4, 0x00000000, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo306_DDR[] = {{"ddrcomp_clk_comp0", "", 0x00017F08, 2, 0x0000000000000FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields307_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000040, "RW", "dq_odt_pdn_vref", "DqOdtRcompDrvDown Vref with step size of Vccddr_hv/256"},
#else
{24, 30, 0x00000040, "RW", "dq_odt_pdn_vref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000040, "RW", "dq_odt_pup_vref", "DqOdtcompDrvUp Vref with step size of Vccddr_hv/256"},
#else
{16, 22, 0x00000040, "RW", "dq_odt_pup_vref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "dq_drv_pdn_vref", "DqRcompDrvDown Vref with step size of Vccddr_hv/256"},
#else
{8, 14, 0x00000040, "RW", "dq_drv_pdn_vref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000004D, "RW", "dq_drv_pup_vref", "DqRcompDrvUp Vref with step size of Vccddr_hv/256"},
#else
{0, 6, 0x0000004D, "RW", "dq_drv_pup_vref", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo307_DDR[] = {{"ddrcomp_dq_vref_ctl", "", 0x00017F0C, 4, 0x000000007FFFFFFF, 0x000000004040404D}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields308_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "cmd_drv_pdn_vref", "CmdRcompDrvDown Vref with step size of Vccddr_hv/256"},
#else
{8, 14, 0x00000040, "RW", "cmd_drv_pdn_vref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000050, "RW", "cmd_drv_pup_vref", "CmdRcompDrvUp Vref with step size of Vccddr_hv/256"},
#else
{0, 6, 0x00000050, "RW", "cmd_drv_pup_vref", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo308_DDR[] = {{"ddrcomp_cmd_vref_ctl", "", 0x00017F10, 2, 0x0000000000007FFF, 0x0000000000004050}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields309_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000040, "RW", "clk_drv_pdn_vref", "ClkRcompDrvDown Vref with step size of Vccddr_hv/256"},
#else
{8, 14, 0x00000040, "RW", "clk_drv_pdn_vref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000004D, "RW", "clk_drv_pup_vref", "ClkRcompDrvUp Vref with step size of Vccddr_hv/256"},
#else
{0, 6, 0x0000004D, "RW", "clk_drv_pup_vref", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo309_DDR[] = {{"ddrcomp_clk_vref_ctl", "", 0x00017F14, 2, 0x0000000000007FFF, 0x000000000000404D}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields310_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 19, 0x0000001F, "RW", "odt_static_leg_ctl", "ODT static leg value used for ODT comp[br]\r\n"
"                    Sets number of ODT static legs.  First 3 MSB bits have weight of 4[br]\r\n"
"                    4th MSB has weight of 2 and LSB has weight of 1.[br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{15, 19, 0x0000001F, "RW", "odt_static_leg_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 14, 0x0000001F, "RW", "clk_static_leg_ctl", "Clock Static Leg value used for CLK comp[br]\r\n"
"                    Sets number of DRV static legs.  First 3 MSB bits have weight of 4[br]\r\n"
"                    4th MSB has weight of 2 and LSB has weight of 1.[br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{10, 14, 0x0000001F, "RW", "clk_static_leg_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x0000001F, "RW", "cmd_static_leg_ctl", "Command Static Leg value used for cmd comp[br]\r\n"
"                    Sets number of DRV static legs.  First 3 MSB bits have weight of 4[br]\r\n"
"                    4th MSB has weight of 2 and LSB has weight of 1.[br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{5, 9, 0x0000001F, "RW", "cmd_static_leg_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "txdq_static_leg_ctl", "DQ Comp Loop Staic Leg Control value for data comp.[br]\r\n"
"                    Sets number of DRV static legs.  First 3 MSB bits have weight of 4[br]\r\n"
"                    4th MSB has weight of 2 and LSB has weight of 1.[br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "txdq_static_leg_ctl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo310_DDR[] = {{"ddrcomp_static_leg_ctl0", "", 0x00017F18, 4, 0x00000000000FFFFF, 0x00000000000FFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields311_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000001, "RW", "clk_dn_seg_ovr_value", "when clk_seg_ovr_en = 0; Clk down segment Enable value = 1;[br]\r\n"
"                    clk_seg_ovr_en = 1, Override value"},
#else
{22, 23, 0x00000001, "RW", "clk_dn_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 21, 0x00000001, "RW", "clk_up_seg_ovr_value", "when clk_seg_ovr_en= 0; Clk Up segment Enable value = 1;[br]\r\n"
"                    clk_seg_ovr_en = 1, Override value"},
#else
{20, 21, 0x00000001, "RW", "clk_up_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 19, 0x00000001, "RW", "cmd_dn_seg_ovr_value", "when cmd_seg_ovr_en = 0, Cmd down segment Enable value = 1;[br]\r\n"
"                    cmd_seg_ovr_en = 1, Override value"},
#else
{18, 19, 0x00000001, "RW", "cmd_dn_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 17, 0x00000001, "RW", "cmd_up_seg_ovr_value", "when cmd_seg_ovr_en = 0, Cmd Up segment Enable value = 1;[br]\r\n"
"                    cmd_seg_ovr_en = 1, Override value"},
#else
{16, 17, 0x00000001, "RW", "cmd_up_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 15, 0x00000001, "RW", "odt_dn_seg_ovr_value", "when odt_seg_ovr_en = 0, Odt down segment Enable value = 1;[br]\r\n"
"                    odt_seg_ovr_en = 1, Override value"},
#else
{14, 15, 0x00000001, "RW", "odt_dn_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "odt_up_seg_ovr_value", "when odt_seg_ovr_en = 0, Odt Up segment Enable value = 1;[br]\r\n"
"                    odt_seg_ovr_en = 1, Override value"},
#else
{12, 13, 0x00000001, "RW", "odt_up_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 11, 0x00000003, "RW", "dq_dn_seg_ovr_value", "when dq_seg_ovr_en = 0, Dq down segment Enable value = 1;[br]\r\n"
"                    dq_seg_ovr_en = 1, Override value"},
#else
{10, 11, 0x00000003, "RW", "dq_dn_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000003, "RW", "dq_up_seg_ovr_value", "when dq_seg_ovr_en = 0, Dq Up segment Enable value = 1;[br] \r\n"
"                    dq_seg_ovr_en = 1, Override value"},
#else
{8, 9, 0x00000003, "RW", "dq_up_seg_ovr_value", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "clk_seg_ovr_en", "Clk Segment Override"},
#else
{3, 3, 0x00000000, "RW", "clk_seg_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "cmd_seg_ovr_en", "Cmd Segment Override Enable"},
#else
{2, 2, 0x00000000, "RW", "cmd_seg_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "odt_seg_ovr_en", "Dq Odt Segment Override Enable"},
#else
{1, 1, 0x00000000, "RW", "odt_seg_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dq_seg_ovr_en", "Dq segment Override Enable"},
#else
{0, 0, 0x00000000, "RW", "dq_seg_ovr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo311_DDR[] = {{"ddrcomp_seg_ovr_ctl0", "", 0x00017F1C, 12, 0x0000000000FFFFFF, 0x0000000000555F00}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields312_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dqscomp_ovr_en", "DQS Comp Override"},
#else
{9, 9, 0x00000000, "RW", "dqscomp_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 8, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "clk_drv_dn_ovr_en", "Override enable for Clk Rcomp DriveDn value"},
#else
{7, 7, 0x00000000, "RW", "clk_drv_dn_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "clk_drv_up_ovr_en", "Override enable for Clk Rcomp DriveUp Value"},
#else
{6, 6, 0x00000000, "RW", "clk_drv_up_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "cmd_drv_dn_ovr_en", "Override enable for Cmd Rcomp DriveDn Value"},
#else
{5, 5, 0x00000000, "RW", "cmd_drv_dn_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "cmd_drv_up_ovr_en", "Override enable for Cmd Rcomp DriveUp Value"},
#else
{4, 4, 0x00000000, "RW", "cmd_drv_up_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "dq_odt_dn_ovr_en", "Override enable for Data Rcomp OdtDn Value"},
#else
{3, 3, 0x00000000, "RW", "dq_odt_dn_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dq_odt_up_ovr_en", "Override enable for Data Rcomp OdtUp Value"},
#else
{2, 2, 0x00000000, "RW", "dq_odt_up_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "dq_drv_dn_ovr_en", "Override enable for Data Rcomp DriveDn Value"},
#else
{1, 1, 0x00000000, "RW", "dq_drv_dn_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dq_drv_up_ovr_en", "Override enable for Data Rcomp DriveUp Value"},
#else
{0, 0, 0x00000000, "RW", "dq_drv_up_ovr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo312_DDR[] = {{"ddrcomp_drv_ovr_ctl0", "", 0x00017F20, 10, 0x00000000000003FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields313_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000001, "RW", "dram_rst_n", "software de-asserts o_reset_n_ddr_pad_hv by toggling (1 -> 0 ->1 ) this CR field "},
#else
{24, 24, 0x00000001, "RW", "dram_rst_n", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "fix_odt_dn", "Skip DqRcomOdtDn compensation and use [br]\r\n"
"                    DqOdtDn = ddrcomp_data_comp0.rcomp_odt_up + dq_odt_up_dn_offset.\r\n"
"                    Unused in wave3"},
#else
{23, 23, 0x00000000, "RW", "fix_odt_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "force_comp_vref_en", "Set to 1 to force both comp's vref enable to 1, regardless of the comp main fsm state"},
#else
{22, 22, 0x00000000, "RW", "force_comp_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "dq_odt_up_dn_offset", "Offset between DqOdt Up and Down when fix OdtDn enable is set. Unused in wave3"},
#else
{16, 21, 0x00000000, "RW", "dq_odt_up_dn_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "eval_sample_x2", "Changes the number of samples dropped during the binary FSM eval state. Setting this bit increases the number of dropped samples from 14 to 256 for RCOMP and from 7 to 14 for RXDQSCOMP"},
#else
{11, 11, 0x00000000, "RW", "eval_sample_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "bubble_cbb_clk_gate_en", "Set to 1 to enable cbb clk gating during bubble state."},
#else
{10, 10, 0x00000000, "RW", "bubble_cbb_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000002, "RW", "sw_cap_cmp_clk_sel", "0: reset = 1 cycle, PreCharge = 1, cycle, evaluate = 1 cycle[br]\r\n"
"                    1: reset = 2 cycle, PreCharge = 2, cycle, evaluate = 1 cycle[br] \r\n"
"                    2: reset = 3 cycle, PreCharge = 3, cycle, evaluate = 1 cycle[br]\r\n"
"                    3: Reserved"},
#else
{8, 9, 0x00000002, "RW", "sw_cap_cmp_clk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000000, "RW", "bubble_tmr_ext", "Extend the FSM bubble timer by.[br]\r\n"
"                    0 - 1x Default [br]\r\n"
"                    1 - 1.5x [br]\r\n"
"                    2 - 2x [br]\r\n"
"                    3 - 2.5"},
#else
{6, 7, 0x00000000, "RW", "bubble_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "force_odt_on", "Force ODT on used in dq/clk/cmd rcomp AIP for debug purpose.  Sets the pull down segment as inverted pull up."},
#else
{5, 5, 0x00000000, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "rcomp_dfx_mode", "when rcomp_dfx_mode =0; switch cap comparator clock= fsm_clk; rcomp_dfx_mode=1; switch cap comparator clock= fsm_clk/3"},
#else
{4, 4, 0x00000000, "RW", "rcomp_dfx_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{1, 1, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dclk_gate_en", "Set to 1 to enable HW to gate DCLK. Default is disable clock gating."},
#else
{0, 0, 0x00000000, "RW", "dclk_gate_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo313_DDR[] = {{"ddrcomp_ctl0", "", 0x00017F24, 15, 0x00000000FFFFFFFF, 0x0000000001000200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields314_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "ch1_dimm_vref_en", "Enables Ch1 DIMM Vref"},
#else
{23, 23, 0x00000000, "RW", "ch1_dimm_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "ch0_dimm_vref_en", "Enables Ch0 DIMM Vref"},
#else
{22, 22, 0x00000000, "RW", "ch0_dimm_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 20, 0x00000001, "RW", "ch1_vref_bias_ctl", "Current control for channel 1 DIMM Vref"},
#else
{19, 20, 0x00000001, "RW", "ch1_vref_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 17, 0x00000001, "RW", "ch0_vref_bias_ctl", "Current control for channel 0 DIMM Vref"},
#else
{16, 17, 0x00000001, "RW", "ch0_vref_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000000, "RW", "ch1_dimm_vref_ctl", "CH1 DIMM Vref Control.[br]\r\n"
"                    For 10nm Vref Gen step size is Vccddr_hv/256 and valid range for DimmVref is Vccddr_hv/3  2*Vccddr_hv/3. The target code to vref decoding: Vref = VrefCtrl*Vccddr_hv/256"},
#else
{8, 15, 0x00000000, "RW", "ch1_dimm_vref_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "ch0_dimm_vref_ctl", "CH0 DIMM Vref Control.[br]\r\n"
"                    For 10nm Vref Gen step size is Vccddr_hv/256 and valid range for DimmVref is Vccddr_hv/3  2*Vccddr_hv/3. The target code to vref decoding: Vref = VrefCtrl*Vccddr_hv/256"},
#else
{0, 7, 0x00000000, "RW", "ch0_dimm_vref_ctl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo314_DDR[] = {{"ddrcomp_dimm_vref_ctl0", "", 0x00017F28, 6, 0x0000000000FFFFFF, 0x0000000000090000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields315_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rxrt_en", "Set to 1 to enable Rx DQS retraining"},
#else
{31, 31, 0x00000000, "RW", "rxrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000001, "RW", "rxdqscomp_rxgain_ctl", "00 - 1.5x (default for CMD/CLK)[br]\r\n"
"                    01 - 2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11 - 3x"},
#else
{27, 28, 0x00000001, "RW", "rxdqscomp_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 25, 0x00000000, "RW", "pbias_stg2amp_trim", "pbias current mirror for the 2nd stage amplifier in the DQS COMP CBB. Adjusts the bias current. 0=min, 7=max."},
#else
{23, 25, 0x00000000, "RW", "pbias_stg2amp_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 21, 0x00000000, "RW/V", "rxrt_init_picode", "This is the initial RX training unmatch reciever delay in PI ticks. It is used by HW logic to calculate the rxrt_dqs_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{14, 21, 0x00000000, "RW/V", "rxrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 12, 0x00000004, "RW/V", "rxrt_logic_delay", "Set this to 100 for 1 DCLK delay. 010 for 2 DCLK delay and 001 for 3 DCLK delay"},
#else
{10, 12, 0x00000004, "RW/V", "rxrt_logic_delay", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 8, 0x00000000, "RW/V", "rxrt_dqs_dly_adj", "Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated by DDRCOMP fub and broadcast to all the data fub.  The adjust range is -64 to 63."},
#else
{2, 8, 0x00000000, "RW/V", "rxrt_dqs_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/V", "logicpath_train_en", "HW only auto train the RxDqs logic path after prim reset deassertion. For debug purpose, SW can set this bit to enable logic path training. HW clear this bit after logic path training is completed."},
#else
{1, 1, 0x00000000, "RW/V", "logicpath_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "rxrt_init", "Set to 1 to indicate this is the 1st retraining to initialize the rxrt_init_picode. HW will not calculate and apply the rxrt_dqs_dly_adj. Once HW finish the initialization, it clears this bit."},
#else
{0, 0, 0x00000000, "RW/V", "rxrt_init", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo315_DDR[] = {{"ddrcomp_rx_retrain0", "", 0x00017F2C, 8, 0x00000000FFFFFFFF, 0x0000000008001000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields316_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000018, "RW", "rxrt_logic_path_train_picode", "Rx Retrain logic path training PI code starting value"},
#else
{0, 7, 0x00000018, "RW", "rxrt_logic_path_train_picode", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo316_DDR[] = {{"ddrcomp_rx_retrain1", "", 0x00017F30, 1, 0x00000000000000FF, 0x0000000000000018}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields317_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{6, 10, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo317_DDR[] = {{"ddrcomp_view_comp0", "", 0x00017F34, 2, 0x00000000000007FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields318_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo318_DDR[] = {{"ddrd_n0_rx_ctl0_rank_0_", "", 0x0001B000, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields319_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo319_DDR[] = {{"ddrd_n0_rx_ctl0_rank_1_", "", 0x0001B004, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields320_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo320_DDR[] = {{"ddrd_n0_rx_ctl0_rank_2_", "", 0x0001B008, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields321_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo321_DDR[] = {{"ddrd_n0_rx_ctl0_rank_3_", "", 0x0001B00C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields322_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo322_DDR[] = {{"ddrd_n0_rx_ctl0_rank_4_", "", 0x0001B010, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields323_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo323_DDR[] = {{"ddrd_n0_rx_ctl0_rank_5_", "", 0x0001B014, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields324_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo324_DDR[] = {{"ddrd_n0_rx_ctl0_rank_6_", "", 0x0001B018, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields325_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo325_DDR[] = {{"ddrd_n0_rx_ctl0_rank_7_", "", 0x0001B01C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields326_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo326_DDR[] = {{"ddrd_n0_rx_ctl1_rank_0_", "", 0x0001B020, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields327_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo327_DDR[] = {{"ddrd_n0_rx_ctl1_rank_1_", "", 0x0001B024, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields328_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo328_DDR[] = {{"ddrd_n0_rx_ctl1_rank_2_", "", 0x0001B028, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields329_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo329_DDR[] = {{"ddrd_n0_rx_ctl1_rank_3_", "", 0x0001B02C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields330_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo330_DDR[] = {{"ddrd_n0_rx_ctl1_rank_4_", "", 0x0001B030, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields331_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo331_DDR[] = {{"ddrd_n0_rx_ctl1_rank_5_", "", 0x0001B034, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields332_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo332_DDR[] = {{"ddrd_n0_rx_ctl1_rank_6_", "", 0x0001B038, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields333_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo333_DDR[] = {{"ddrd_n0_rx_ctl1_rank_7_", "", 0x0001B03C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields334_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo334_DDR[] = {{"ddrd_n0_rx_ctl2_rank_0_", "", 0x0001B040, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields335_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo335_DDR[] = {{"ddrd_n0_rx_ctl2_rank_1_", "", 0x0001B044, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields336_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo336_DDR[] = {{"ddrd_n0_rx_ctl2_rank_2_", "", 0x0001B048, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields337_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo337_DDR[] = {{"ddrd_n0_rx_ctl2_rank_3_", "", 0x0001B04C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields338_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo338_DDR[] = {{"ddrd_n0_rx_ctl2_rank_4_", "", 0x0001B050, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields339_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo339_DDR[] = {{"ddrd_n0_rx_ctl2_rank_5_", "", 0x0001B054, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields340_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo340_DDR[] = {{"ddrd_n0_rx_ctl2_rank_6_", "", 0x0001B058, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields341_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo341_DDR[] = {{"ddrd_n0_rx_ctl2_rank_7_", "", 0x0001B05C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields342_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo342_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_0_", "", 0x0001B060, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields343_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo343_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_1_", "", 0x0001B064, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields344_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo344_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_2_", "", 0x0001B068, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields345_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo345_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_3_", "", 0x0001B06C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields346_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo346_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_0_", "", 0x0001B070, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields347_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo347_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_1_", "", 0x0001B074, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields348_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo348_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_2_", "", 0x0001B078, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields349_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo349_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_3_", "", 0x0001B07C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields350_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo350_DDR[] = {{"ddrd_n0_tx_ctl0_rank_0_", "", 0x0001B080, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields351_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo351_DDR[] = {{"ddrd_n0_tx_ctl0_rank_1_", "", 0x0001B084, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields352_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo352_DDR[] = {{"ddrd_n0_tx_ctl0_rank_2_", "", 0x0001B088, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields353_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo353_DDR[] = {{"ddrd_n0_tx_ctl0_rank_3_", "", 0x0001B08C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields354_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo354_DDR[] = {{"ddrd_n0_tx_ctl0_rank_4_", "", 0x0001B090, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields355_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo355_DDR[] = {{"ddrd_n0_tx_ctl0_rank_5_", "", 0x0001B094, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields356_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo356_DDR[] = {{"ddrd_n0_tx_ctl0_rank_6_", "", 0x0001B098, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields357_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo357_DDR[] = {{"ddrd_n0_tx_ctl0_rank_7_", "", 0x0001B09C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields358_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo358_DDR[] = {{"ddrd_n0_tx_ctl1_rank_0_", "", 0x0001B0A0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields359_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo359_DDR[] = {{"ddrd_n0_tx_ctl1_rank_1_", "", 0x0001B0A4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields360_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo360_DDR[] = {{"ddrd_n0_tx_ctl1_rank_2_", "", 0x0001B0A8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields361_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo361_DDR[] = {{"ddrd_n0_tx_ctl1_rank_3_", "", 0x0001B0AC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields362_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo362_DDR[] = {{"ddrd_n0_tx_ctl1_rank_4_", "", 0x0001B0B0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields363_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo363_DDR[] = {{"ddrd_n0_tx_ctl1_rank_5_", "", 0x0001B0B4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields364_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo364_DDR[] = {{"ddrd_n0_tx_ctl1_rank_6_", "", 0x0001B0B8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields365_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo365_DDR[] = {{"ddrd_n0_tx_ctl1_rank_7_", "", 0x0001B0BC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields366_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo366_DDR[] = {{"ddrd_n0_tx_ctl2_rank_0_", "", 0x0001B0C0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields367_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo367_DDR[] = {{"ddrd_n0_tx_ctl2_rank_1_", "", 0x0001B0C4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields368_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo368_DDR[] = {{"ddrd_n0_tx_ctl2_rank_2_", "", 0x0001B0C8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields369_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo369_DDR[] = {{"ddrd_n0_tx_ctl2_rank_3_", "", 0x0001B0CC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields370_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo370_DDR[] = {{"ddrd_n0_tx_ctl2_rank_4_", "", 0x0001B0D0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields371_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo371_DDR[] = {{"ddrd_n0_tx_ctl2_rank_5_", "", 0x0001B0D4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields372_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo372_DDR[] = {{"ddrd_n0_tx_ctl2_rank_6_", "", 0x0001B0D8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields373_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo373_DDR[] = {{"ddrd_n0_tx_ctl2_rank_7_", "", 0x0001B0DC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields374_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo374_DDR[] = {{"ddrd_n0_tx_retrain_rank_0_", "", 0x0001B0E0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields375_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo375_DDR[] = {{"ddrd_n0_tx_retrain_rank_1_", "", 0x0001B0E4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields376_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo376_DDR[] = {{"ddrd_n0_tx_retrain_rank_2_", "", 0x0001B0E8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields377_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo377_DDR[] = {{"ddrd_n0_tx_retrain_rank_3_", "", 0x0001B0EC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields378_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo378_DDR[] = {{"ddrd_n0_tx_retrain_rank_4_", "", 0x0001B0F0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields379_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo379_DDR[] = {{"ddrd_n0_tx_retrain_rank_5_", "", 0x0001B0F4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields380_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo380_DDR[] = {{"ddrd_n0_tx_retrain_rank_6_", "", 0x0001B0F8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields381_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo381_DDR[] = {{"ddrd_n0_tx_retrain_rank_7_", "", 0x0001B0FC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields382_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo382_DDR[] = {{"ddrd_n0_rx_ctl0_rank_0_", "", 0x00011400, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields383_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo383_DDR[] = {{"ddrd_n0_rx_ctl0_rank_1_", "", 0x00011404, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields384_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo384_DDR[] = {{"ddrd_n0_rx_ctl0_rank_2_", "", 0x00011408, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields385_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo385_DDR[] = {{"ddrd_n0_rx_ctl0_rank_3_", "", 0x0001140C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields386_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo386_DDR[] = {{"ddrd_n0_rx_ctl0_rank_4_", "", 0x00011410, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields387_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo387_DDR[] = {{"ddrd_n0_rx_ctl0_rank_5_", "", 0x00011414, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields388_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo388_DDR[] = {{"ddrd_n0_rx_ctl0_rank_6_", "", 0x00011418, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields389_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo389_DDR[] = {{"ddrd_n0_rx_ctl0_rank_7_", "", 0x0001141C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields390_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo390_DDR[] = {{"ddrd_n0_rx_ctl1_rank_0_", "", 0x00011420, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields391_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo391_DDR[] = {{"ddrd_n0_rx_ctl1_rank_1_", "", 0x00011424, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields392_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo392_DDR[] = {{"ddrd_n0_rx_ctl1_rank_2_", "", 0x00011428, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields393_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo393_DDR[] = {{"ddrd_n0_rx_ctl1_rank_3_", "", 0x0001142C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields394_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo394_DDR[] = {{"ddrd_n0_rx_ctl1_rank_4_", "", 0x00011430, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields395_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo395_DDR[] = {{"ddrd_n0_rx_ctl1_rank_5_", "", 0x00011434, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields396_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo396_DDR[] = {{"ddrd_n0_rx_ctl1_rank_6_", "", 0x00011438, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields397_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo397_DDR[] = {{"ddrd_n0_rx_ctl1_rank_7_", "", 0x0001143C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields398_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo398_DDR[] = {{"ddrd_n0_rx_ctl2_rank_0_", "", 0x00011440, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields399_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo399_DDR[] = {{"ddrd_n0_rx_ctl2_rank_1_", "", 0x00011444, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields400_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo400_DDR[] = {{"ddrd_n0_rx_ctl2_rank_2_", "", 0x00011448, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields401_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo401_DDR[] = {{"ddrd_n0_rx_ctl2_rank_3_", "", 0x0001144C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields402_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo402_DDR[] = {{"ddrd_n0_rx_ctl2_rank_4_", "", 0x00011450, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields403_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo403_DDR[] = {{"ddrd_n0_rx_ctl2_rank_5_", "", 0x00011454, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields404_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo404_DDR[] = {{"ddrd_n0_rx_ctl2_rank_6_", "", 0x00011458, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields405_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo405_DDR[] = {{"ddrd_n0_rx_ctl2_rank_7_", "", 0x0001145C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields406_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo406_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_0_", "", 0x00011460, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields407_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo407_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_1_", "", 0x00011464, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields408_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo408_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_2_", "", 0x00011468, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields409_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo409_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_3_", "", 0x0001146C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields410_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo410_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_0_", "", 0x00011470, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields411_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo411_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_1_", "", 0x00011474, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields412_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo412_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_2_", "", 0x00011478, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields413_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo413_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_3_", "", 0x0001147C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields414_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo414_DDR[] = {{"ddrd_n0_tx_ctl0_rank_0_", "", 0x00011480, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields415_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo415_DDR[] = {{"ddrd_n0_tx_ctl0_rank_1_", "", 0x00011484, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields416_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo416_DDR[] = {{"ddrd_n0_tx_ctl0_rank_2_", "", 0x00011488, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields417_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo417_DDR[] = {{"ddrd_n0_tx_ctl0_rank_3_", "", 0x0001148C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields418_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo418_DDR[] = {{"ddrd_n0_tx_ctl0_rank_4_", "", 0x00011490, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields419_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo419_DDR[] = {{"ddrd_n0_tx_ctl0_rank_5_", "", 0x00011494, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields420_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo420_DDR[] = {{"ddrd_n0_tx_ctl0_rank_6_", "", 0x00011498, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields421_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo421_DDR[] = {{"ddrd_n0_tx_ctl0_rank_7_", "", 0x0001149C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields422_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo422_DDR[] = {{"ddrd_n0_tx_ctl1_rank_0_", "", 0x000114A0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields423_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo423_DDR[] = {{"ddrd_n0_tx_ctl1_rank_1_", "", 0x000114A4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields424_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo424_DDR[] = {{"ddrd_n0_tx_ctl1_rank_2_", "", 0x000114A8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields425_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo425_DDR[] = {{"ddrd_n0_tx_ctl1_rank_3_", "", 0x000114AC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields426_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo426_DDR[] = {{"ddrd_n0_tx_ctl1_rank_4_", "", 0x000114B0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields427_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo427_DDR[] = {{"ddrd_n0_tx_ctl1_rank_5_", "", 0x000114B4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields428_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo428_DDR[] = {{"ddrd_n0_tx_ctl1_rank_6_", "", 0x000114B8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields429_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo429_DDR[] = {{"ddrd_n0_tx_ctl1_rank_7_", "", 0x000114BC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields430_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo430_DDR[] = {{"ddrd_n0_tx_ctl2_rank_0_", "", 0x000114C0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields431_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo431_DDR[] = {{"ddrd_n0_tx_ctl2_rank_1_", "", 0x000114C4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields432_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo432_DDR[] = {{"ddrd_n0_tx_ctl2_rank_2_", "", 0x000114C8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields433_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo433_DDR[] = {{"ddrd_n0_tx_ctl2_rank_3_", "", 0x000114CC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields434_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo434_DDR[] = {{"ddrd_n0_tx_ctl2_rank_4_", "", 0x000114D0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields435_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo435_DDR[] = {{"ddrd_n0_tx_ctl2_rank_5_", "", 0x000114D4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields436_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo436_DDR[] = {{"ddrd_n0_tx_ctl2_rank_6_", "", 0x000114D8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields437_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo437_DDR[] = {{"ddrd_n0_tx_ctl2_rank_7_", "", 0x000114DC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields438_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo438_DDR[] = {{"ddrd_n0_tx_retrain_rank_0_", "", 0x000114E0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields439_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo439_DDR[] = {{"ddrd_n0_tx_retrain_rank_1_", "", 0x000114E4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields440_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo440_DDR[] = {{"ddrd_n0_tx_retrain_rank_2_", "", 0x000114E8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields441_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo441_DDR[] = {{"ddrd_n0_tx_retrain_rank_3_", "", 0x000114EC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields442_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo442_DDR[] = {{"ddrd_n0_tx_retrain_rank_4_", "", 0x000114F0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields443_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo443_DDR[] = {{"ddrd_n0_tx_retrain_rank_5_", "", 0x000114F4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields444_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo444_DDR[] = {{"ddrd_n0_tx_retrain_rank_6_", "", 0x000114F8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields445_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo445_DDR[] = {{"ddrd_n0_tx_retrain_rank_7_", "", 0x000114FC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields446_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo446_DDR[] = {{"ddrd_n0_rx_ctl0_rank_0_", "", 0x0001B800, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields447_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo447_DDR[] = {{"ddrd_n0_rx_ctl0_rank_1_", "", 0x0001B804, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields448_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo448_DDR[] = {{"ddrd_n0_rx_ctl0_rank_2_", "", 0x0001B808, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields449_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo449_DDR[] = {{"ddrd_n0_rx_ctl0_rank_3_", "", 0x0001B80C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields450_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo450_DDR[] = {{"ddrd_n0_rx_ctl0_rank_4_", "", 0x0001B810, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields451_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo451_DDR[] = {{"ddrd_n0_rx_ctl0_rank_5_", "", 0x0001B814, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields452_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo452_DDR[] = {{"ddrd_n0_rx_ctl0_rank_6_", "", 0x0001B818, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields453_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_strobe_inv", "RX Strobe Inversion for DFE"},
#else
{31, 31, 0x00000000, "RW", "rx_strobe_inv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "rxdq_dly", "It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]\r\n"
"                    0: 1/16 UI offset,[br] \r\n"
"                    1: 3/16 UI offset,[br] \r\n"
"                    2: 5/16 UI offset,[br] \r\n"
"                    3: 7/16 UI offset,[br] \r\n"
"                    4: 9/16 UI offset,[br] \r\n"
"                    5: 11/16 UI offset,[br] \r\n"
"                    6,7: 13/16 UI offset.[br] \r\n"
"                    When DFE is enabled, adds delay on the DFE feedback path (after the DFE sampler).[br] \r\n"
"                    0: 0 offset (bypass),[br] \r\n"
"                    1: 2/16 UI offset,[br] \r\n"
"                    2: 4/16 UI offset,[br] \r\n"
"                    3: 6/16 UI offset,[br] \r\n"
"                    4: 8/16 UI offset,[br] \r\n"
"                    5: 10/16 UI offset,[br] \r\n"
"                    6,7: 12/16 UI offset)."},
#else
{27, 29, 0x00000000, "RW", "rxdq_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 26, 0x00000000, "RW", "rxdqsn_dly", "It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 26, 0x00000000, "RW", "rxdqsn_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 18, 0x00000000, "RW", "rxdqsp_dly", "It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival DQ.[br]\r\n"
"                    The per bit range is 0 to 1.375 dclk with step size clkpi/128. [br]\r\n"
"                    The per bit calculation is [br]\r\n"
"                    rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed number for BIOS margining sweep. Range is -128 to 127)[br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{11, 18, 0x00000000, "RW", "rxdqsp_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "rcven_dly", "Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with rcven_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. The result is sent to the rcven crossover logic and DLL.[br] \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "rcven_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo453_DDR[] = {{"ddrd_n0_rx_ctl0_rank_7_", "", 0x0001B81C, 5, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields454_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo454_DDR[] = {{"ddrd_n0_rx_ctl1_rank_0_", "", 0x0001B820, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields455_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo455_DDR[] = {{"ddrd_n0_rx_ctl1_rank_1_", "", 0x0001B824, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields456_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo456_DDR[] = {{"ddrd_n0_rx_ctl1_rank_2_", "", 0x0001B828, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields457_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo457_DDR[] = {{"ddrd_n0_rx_ctl1_rank_3_", "", 0x0001B82C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields458_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo458_DDR[] = {{"ddrd_n0_rx_ctl1_rank_4_", "", 0x0001B830, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields459_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo459_DDR[] = {{"ddrd_n0_rx_ctl1_rank_5_", "", 0x0001B834, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields460_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo460_DDR[] = {{"ddrd_n0_rx_ctl1_rank_6_", "", 0x0001B838, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields461_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "ctle_res_en", "CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]\r\n"
"                    Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]\r\n"
"                    where R is ~500 Ohms and depends on process."},
#else
{28, 30, 0x00000000, "RW", "ctle_res_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 26, 0x00000000, "RW", "ctle_cap_en", "CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C."},
#else
{25, 26, 0x00000000, "RW", "ctle_cap_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsn_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsn_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsn_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", "Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsn_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo461_DDR[] = {{"ddrd_n0_rx_ctl1_rank_7_", "", 0x0001B83C, 6, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields462_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo462_DDR[] = {{"ddrd_n0_rx_ctl2_rank_0_", "", 0x0001B840, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields463_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo463_DDR[] = {{"ddrd_n0_rx_ctl2_rank_1_", "", 0x0001B844, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields464_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo464_DDR[] = {{"ddrd_n0_rx_ctl2_rank_2_", "", 0x0001B848, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields465_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo465_DDR[] = {{"ddrd_n0_rx_ctl2_rank_3_", "", 0x0001B84C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields466_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo466_DDR[] = {{"ddrd_n0_rx_ctl2_rank_4_", "", 0x0001B850, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields467_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo467_DDR[] = {{"ddrd_n0_rx_ctl2_rank_5_", "", 0x0001B854, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields468_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo468_DDR[] = {{"ddrd_n0_rx_ctl2_rank_6_", "", 0x0001B858, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields469_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ3. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{19, 23, 0x00000000, "RW", "rxdqsp_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ2. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{13, 17, 0x00000000, "RW", "rxdqsp_dly2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ1. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{6, 10, 0x00000000, "RW", "rxdqsp_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", "Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on DQ0. [br]\r\n"
"                    The range is 0 to 0.25 dclk with step size clkpi/128. [br]\r\n"
"                    Note: BIOS must make sure the total delay not more than 1.375 dclk."},
#else
{0, 4, 0x00000000, "RW", "rxdqsp_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo469_DDR[] = {{"ddrd_n0_rx_ctl2_rank_7_", "", 0x0001B85C, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields470_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo470_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_0_", "", 0x0001B860, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields471_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo471_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_1_", "", 0x0001B864, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields472_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo472_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_2_", "", 0x0001B868, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields473_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", "DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c2_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", "DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c2_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", "DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c2_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", "DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c2_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", "DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c1_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", "DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c1_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", "DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c1_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", "DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c1_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo473_DDR[] = {{"ddrd_n0_dfe_coeff_offset0_rank_3_", "", 0x0001B86C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields474_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo474_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_0_", "", 0x0001B870, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields475_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo475_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_1_", "", 0x0001B874, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields476_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo476_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_2_", "", 0x0001B878, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields477_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", "DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{21, 23, 0x00000000, "RW", "dfe_c4_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", "DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{18, 20, 0x00000000, "RW", "dfe_c4_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", "DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{15, 17, 0x00000000, "RW", "dfe_c4_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", "DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{12, 14, 0x00000000, "RW", "dfe_c4_offset0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", "DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value."},
#else
{9, 11, 0x00000000, "RW", "dfe_c3_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", "DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value."},
#else
{6, 8, 0x00000000, "RW", "dfe_c3_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", "DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value."},
#else
{3, 5, 0x00000000, "RW", "dfe_c3_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", "DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value."},
#else
{0, 2, 0x00000000, "RW", "dfe_c3_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo477_DDR[] = {{"ddrd_n0_dfe_coeff_offset1_rank_3_", "", 0x0001B87C, 8, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields478_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo478_DDR[] = {{"ddrd_n0_tx_ctl0_rank_0_", "", 0x0001B880, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields479_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo479_DDR[] = {{"ddrd_n0_tx_ctl0_rank_1_", "", 0x0001B884, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields480_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo480_DDR[] = {{"ddrd_n0_tx_ctl0_rank_2_", "", 0x0001B888, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields481_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo481_DDR[] = {{"ddrd_n0_tx_ctl0_rank_3_", "", 0x0001B88C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields482_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo482_DDR[] = {{"ddrd_n0_tx_ctl0_rank_4_", "", 0x0001B890, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields483_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo483_DDR[] = {{"ddrd_n0_tx_ctl0_rank_5_", "", 0x0001B894, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields484_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo484_DDR[] = {{"ddrd_n0_tx_ctl0_rank_6_", "", 0x0001B898, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields485_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 29, 0x00000000, "RW", "txeq_1st_tap", "TxEQ 1st tap coefficient.\r\n"
"                    The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63 "},
#else
{24, 29, 0x00000000, "RW", "txeq_1st_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", "TxEQ 2nd tap coefficient.The following list all the legal programming values. During TxEQ training BIOS should sweep the following codes in accending order:\r\n"
"                    txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 "},
#else
{19, 22, 0x00000000, "RW", "txeq_2nd_tap", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", "This offset is add to the txdqs_pio_code . The result is the txdqs pi even code (txdqs_pie_code) to DLL.. Default value is 64."},
#else
{11, 17, 0x00000040, "RW", "txdqs_pie_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdqs_dly", "Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128. [br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    10:7 - It is used for logic delay.[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdqs_piref_offset and piref_setup_adj, so the programed value is relative to the piref clock. Then The result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover logic and DLL. \r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdqs_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo485_DDR[] = {{"ddrd_n0_tx_ctl0_rank_7_", "", 0x0001B89C, 4, 0x000000003FFFFFFF, 0x0000000000020000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields486_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo486_DDR[] = {{"ddrd_n0_tx_ctl1_rank_0_", "", 0x0001B8A0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields487_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo487_DDR[] = {{"ddrd_n0_tx_ctl1_rank_1_", "", 0x0001B8A4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields488_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo488_DDR[] = {{"ddrd_n0_tx_ctl1_rank_2_", "", 0x0001B8A8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields489_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo489_DDR[] = {{"ddrd_n0_tx_ctl1_rank_3_", "", 0x0001B8AC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields490_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo490_DDR[] = {{"ddrd_n0_tx_ctl1_rank_4_", "", 0x0001B8B0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields491_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo491_DDR[] = {{"ddrd_n0_tx_ctl1_rank_5_", "", 0x0001B8B4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields492_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo492_DDR[] = {{"ddrd_n0_tx_ctl1_rank_6_", "", 0x0001B8B8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields493_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "pxc_delta3", "PXC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "pxc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "pxc_delta2", "PXC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "pxc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "pxc_delta1", "PXC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "pxc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "pxc_delta0", "PXC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "pxc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly1", "Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly0", "Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo493_DDR[] = {{"ddrd_n0_tx_ctl1_rank_7_", "", 0x0001B8BC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields494_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo494_DDR[] = {{"ddrd_n0_tx_ctl2_rank_0_", "", 0x0001B8C0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields495_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo495_DDR[] = {{"ddrd_n0_tx_ctl2_rank_1_", "", 0x0001B8C4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields496_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo496_DDR[] = {{"ddrd_n0_tx_ctl2_rank_2_", "", 0x0001B8C8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields497_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo497_DDR[] = {{"ddrd_n0_tx_ctl2_rank_3_", "", 0x0001B8CC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields498_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo498_DDR[] = {{"ddrd_n0_tx_ctl2_rank_4_", "", 0x0001B8D0, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields499_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo499_DDR[] = {{"ddrd_n0_tx_ctl2_rank_5_", "", 0x0001B8D4, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields500_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo500_DDR[] = {{"ddrd_n0_tx_ctl2_rank_6_", "", 0x0001B8D8, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields501_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "ddjc_delta3", "DDJC delta for DQ3 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{28, 29, 0x00000000, "RW", "ddjc_delta3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000000, "RW", "ddjc_delta2", "DDJC delta for DQ2 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{26, 27, 0x00000000, "RW", "ddjc_delta2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RW", "ddjc_delta1", "DDJC delta for DQ1 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{24, 25, 0x00000000, "RW", "ddjc_delta1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 23, 0x00000000, "RW", "ddjc_delta0", "DDJC delta for DQ0 inside the nibble.[br]\r\n"
"                    Note: BIOS msut make sure the combine DDJC and PXC delta value doesnt overflow or underflow the analog logic support range."},
#else
{22, 23, 0x00000000, "RW", "ddjc_delta0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 21, 0x00000000, "RW/V", "txdq_dly3", "Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{11, 21, 0x00000000, "RW/V", "txdq_dly3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 10, 0x00000000, "RW/V", "txdq_dly2", "Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]\r\n"
"                    DDR4 range is < 10UI. (max of 4 logic delay) [br]\r\n"
"                    DDR5 range is < 16UI. (max of 7 logic delay) [br]\r\n"
"                    This field is added with txdq_dly_adj to allow BIOS for margining sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning (signed numer -64 to 63).[br]\r\n"
"                    The final delay - [br]\r\n"
"                    10:7 - is used for logic delay[br]\r\n"
"                    6:0 - The lower 7 bit is added with txdq_piref offset and piref_setup_adj, so the programmed value is relative to the piref clock. The result is the txdq pi odd code. [br]\r\n"
"                    Note: bit 6 (MSB) is inverted before the addition, so the delay see by BIOS is linear.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 10, 0x00000000, "RW/V", "txdq_dly2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo501_DDR[] = {{"ddrd_n0_tx_ctl2_rank_7_", "", 0x0001B8DC, 6, 0x000000003FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields502_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo502_DDR[] = {{"ddrd_n0_tx_retrain_rank_0_", "", 0x0001B8E0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields503_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo503_DDR[] = {{"ddrd_n0_tx_retrain_rank_1_", "", 0x0001B8E4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields504_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo504_DDR[] = {{"ddrd_n0_tx_retrain_rank_2_", "", 0x0001B8E8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields505_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo505_DDR[] = {{"ddrd_n0_tx_retrain_rank_3_", "", 0x0001B8EC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields506_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo506_DDR[] = {{"ddrd_n0_tx_retrain_rank_4_", "", 0x0001B8F0, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields507_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo507_DDR[] = {{"ddrd_n0_tx_retrain_rank_5_", "", 0x0001B8F4, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields508_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo508_DDR[] = {{"ddrd_n0_tx_retrain_rank_6_", "", 0x0001B8F8, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields509_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", "Selects between the local byte or the adjacent byte to generate the RO count for tx retraining calculation. Used for x16 devices.[br]\r\n"
"                    Note: This control doesn't apply for ECC byte."},
#else
{31, 31, 0x00000000, "RW", "txrt_adj_byte_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "txrt_en", "TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX retraining."},
#else
{30, 30, 0x00000000, "RW", "txrt_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", "This is the initial MRC training unmatch DRAM reciever delay in PI ticks with 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj for each retraining.[br]\r\n"
"                    Note: The attribte is RW/V to allow SW to write to this field but we don't have any use case yet."},
#else
{8, 17, 0x00000000, "RW/V", "txrt_init_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", "Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated by tx retraining HW logic. The adjust range is -64 to 63"},
#else
{0, 6, 0x00000000, "RO/V", "txrt_dq_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo509_DDR[] = {{"ddrd_n0_tx_retrain_rank_7_", "", 0x0001B8FC, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields510_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo510_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_0_", "", 0x0001B100, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields511_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo511_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_1_", "", 0x0001B104, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields512_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo512_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_2_", "", 0x0001B108, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields513_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo513_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_3_", "", 0x0001B10C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields514_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo514_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_4_", "", 0x0001B110, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields515_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo515_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_5_", "", 0x0001B114, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields516_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo516_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_6_", "", 0x0001B118, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields517_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo517_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_7_", "", 0x0001B11C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields518_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo518_DDR[] = {{"ddrd_n0_sa_offset_rank_0_", "", 0x0001B120, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields519_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo519_DDR[] = {{"ddrd_n0_sa_offset_rank_1_", "", 0x0001B124, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields520_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo520_DDR[] = {{"ddrd_n0_sa_offset_rank_2_", "", 0x0001B128, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields521_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo521_DDR[] = {{"ddrd_n0_sa_offset_rank_3_", "", 0x0001B12C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields522_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo522_DDR[] = {{"ddrd_n0_sa_offset_rank_4_", "", 0x0001B130, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields523_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo523_DDR[] = {{"ddrd_n0_sa_offset_rank_5_", "", 0x0001B134, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields524_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo524_DDR[] = {{"ddrd_n0_sa_offset_rank_6_", "", 0x0001B138, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields525_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo525_DDR[] = {{"ddrd_n0_sa_offset_rank_7_", "", 0x0001B13C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields526_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo526_DDR[] = {{"ddrd_n0_dfe_coeff_rank_0_", "", 0x0001B140, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields527_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo527_DDR[] = {{"ddrd_n0_dfe_coeff_rank_1_", "", 0x0001B144, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields528_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo528_DDR[] = {{"ddrd_n0_dfe_coeff_rank_2_", "", 0x0001B148, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields529_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo529_DDR[] = {{"ddrd_n0_dfe_coeff_rank_3_", "", 0x0001B14C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields530_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo530_DDR[] = {{"ddrd_n0_dfe_coeff_rank_4_", "", 0x0001B150, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields531_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo531_DDR[] = {{"ddrd_n0_dfe_coeff_rank_5_", "", 0x0001B154, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields532_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo532_DDR[] = {{"ddrd_n0_dfe_coeff_rank_6_", "", 0x0001B158, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields533_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo533_DDR[] = {{"ddrd_n0_dfe_coeff_rank_7_", "", 0x0001B15C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields534_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo534_DDR[] = {{"ddrd_n0_dll_ctl0", "", 0x0001B170, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields535_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", "Reads back the MRR that the TXRT FSM is waiting on. [br]\r\n"
"                    bit 0: MR46. 1 indicates that the FSM is waiting for this read. [br]\r\n"
"                    bit 1: MR47. 1 indicates that the FSM is waiting for this read."},
#else
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", "Reads back the TXRT FSM state. [br]\r\n"
"                    0: IDLE [br]\r\n"
"                    1: WAIT_MR [br]\r\n"
"                    2: CALC [br]\r\n"
"                    3: UPDATE"},
#else
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", "Set to 1 by HW to indicate MR46 rank did not match MR47 rank when txrt_update or spid_update_req/ack occurs. [br]\r\n"
"                    SW must clear this bit to 0 when enable HW calibration."},
#else
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW/V", "txrt_update", "Set to 1 to apply the calculation results to txrt_init_picode or txrt_dq_dly_adj. HW will clear this bit once it is applied. [br]\r\n"
"                    HW does not require the spid_update_req/ack handshake to apply the results if this CSR is used. [br]\r\n"
"                    SW needs to guarantee that there are no CAP errors, and there is no write traffic to the targeted rank before setting this bit."},
#else
{22, 22, 0x00000000, "RW/V", "txrt_update", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", "This is the last TX retraining Ring Oscillator count value captured by HW. HW only capture the rank sepcify in txrt_debug_rank."},
#else
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 7, 0x00000000, "RW", "txrt_debug_rank", "Select which rank of RO count value to capture in txrt_ro_count for debug."},
#else
{5, 7, 0x00000000, "RW", "txrt_debug_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "txrt_init", "Set to 1 to indicate this is the 1st retraining to initialize the txrt_init_picode. HW will not calculate and apply the txrt_dq_dly_adj."},
#else
{4, 4, 0x00000000, "RW", "txrt_init", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "txrt_dur", "TX retraining duration. SW must programs the same TCK duration value as progammed in the memory device.[br]\r\n"
"                    001: 128 x 16 TCK[br]\r\n"
"                    010: 256 x 16 TCK[br]\r\n"
"                    100: 512 x 16 TCK[br]\r\n"
"                    others: Reserved"},
#else
{0, 2, 0x00000001, "RW", "txrt_dur", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo535_DDR[] = {{"ddrd_n0_tx_retrain0", "", 0x0001B174, 8, 0x000000000FFFFFFF, 0x000000000C000001}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields536_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo536_DDR[] = {{"ddrd_n0_sampler_odd_offset", "", 0x0001B178, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields537_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo537_DDR[] = {{"ddrd_n0_sampler_even_offset", "", 0x0001B17C, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields538_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x0000003F, "RW", "vref_ctl3", "Per bit Rx Vref Control for DQ3. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{21, 27, 0x0000003F, "RW", "vref_ctl3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x0000003F, "RW", "vref_ctl2", "Per bit Rx Vref Control for DQ2. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{14, 20, 0x0000003F, "RW", "vref_ctl2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003F, "RW", "vref_ctl1", "Per bit Rx Vref Control for DQ1. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{7, 13, 0x0000003F, "RW", "vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW", "vref_ctl0", "Per bit Rx Vref Control for DQ0. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{0, 6, 0x0000003F, "RW", "vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo538_DDR[] = {{"ddrd_n0_rxvref_ctl", "", 0x0001B180, 5, 0x00000000FFFFFFFF, 0x0000000007EFDFBF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields539_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", "Data Rcomp Odt-Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", "Data Rcomp OdtUp Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Data Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Data Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo539_DDR[] = {{"ddrd_n0_comp_la0", "", 0x0001B184, 4, 0x0000000003FFFFFF, 0x0000000001020408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields540_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", "Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated by DDRCOMP fub and broadcast to all the data fub. The adjust range is -64 to 63."},
#else
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "Data Slew Rate Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate.[br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "Data TCO Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo540_DDR[] = {{"ddrd_n0_comp_la1", "", 0x0001B188, 3, 0x00000000001FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields541_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", "Signed number add to rcomp_odt_dn to generate the RCOMP ODT down code. The adjust range is -8 to 7"},
#else
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", "Signed number add to rcomp_odt_up to generate the RCOMP ODT up code. The adjust range is -8 to 7"},
#else
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo541_DDR[] = {{"ddrd_n0_comp_offset", "", 0x0001B18C, 6, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields542_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", "Double the timer for LDO/VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the LDO/VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "ldo_close_loop", "Operate LDO in close loop mode"},
#else
{29, 29, 0x00000000, "RW", "ldo_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", "LDO Cap Trim Loop"},
#else
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 24, 0x00000018, "RW", "ldo_codetarget", "Sets the LDO reference voltage when ldo_vref_sel_ddra=0.[br]\r\n"
"                    Range is (vccddr_hv/2 to vccddr_hv), with step size of vccddr_hv/256.[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 1 inside LDO. Only the lower 7-bit is controlled by this field."},
#else
{18, 24, 0x00000018, "RW", "ldo_codetarget", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", "LDO RC Filter Trim"},
#else
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", "LDO driver strength based on process variation. Bit 1 is unused. Bit 0 used for LDO Driver Strength[br]\r\n"
"                    This field should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                    (Fast) 3'd3: 0x0[br]\r\n"
"                    (Typ) 3'd1,3'd2: 0x0[br]\r\n"
"                    (Slow) 3'd0: 0x1[br]"},
#else
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", "Use vccddra as LDO vref "},
#else
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", "LDO output is bypassed to VCCDDRA"},
#else
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo542_DDR[] = {{"ddrd_n0_vsshi_ctl", "", 0x0001B190, 13, 0x00000000FFFFFFFF, 0x0000000000600118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields543_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo543_DDR[] = {{"ddrd_n0_dll_pi_test_adc", "", 0x0001B194, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields544_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq. It is half of the DRAM transfer rate.[br]\r\n"
"                    For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo544_DDR[] = {{"ddrd_n0_dll_csr", "", 0x0001B198, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields545_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", "Sticky error count. Reset by power good reset.[br]\r\n"
"                    Increment when data fub detect rxfifo read and write pointer is out of sync."},
#else
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo545_DDR[] = {{"ddrd_n0_rxfifo_ptr_log", "", 0x0001B19C, 1, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields546_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "sampler_offset_adj", "Rx Sampler Offset adjust value. It is added to all sampler_even/odd_offset. It is used by BIOS for sampler offsets margining. The adjust range is -32 to 31. The expected usage model is BIOS broadcast the same value to all the bytes."},
#else
{23, 28, 0x00000000, "RW", "sampler_offset_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "vref_adj", "Signed number with range from -64 to 63. It is used by BIOS for marging sweep. This value is added to the vref_ctrl before sending to the DQ VREF. [br]\r\n"
"                    Note: HW doesn't check for overflow and underflow. BIOS must ensure the adjust value doesn't overflow or underflow the final vref control value."},
#else
{16, 22, 0x00000000, "RW", "vref_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000000, "RW", "txdq_dly_adj", "Tx DQ delay adjust value. It is added to all per bit TXDQ delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{8, 15, 0x00000000, "RW", "txdq_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", "Rx DQS delay adjust value. It is added to all per bit RXDQS delay. It is used by BIOS for margining sweep or ACIO HW training. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo546_DDR[] = {{"ddrd_n0_train_offset0", "", 0x0001B1A0, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields547_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", "This txdqs piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the txdqs_dly[6:0], so the txdqs PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM."},
#else
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", "This txdq piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the per bit txdq_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", "This rcven piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the rcven_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", "It is the train PI code to align the PIREF clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default  value is 63) to generate the piref_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo547_DDR[] = {{"ddrd_n0_piref_offset0", "", 0x0001B1A4, 4, 0x000000000FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields548_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 64 ticks, and we will have 64 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo548_DDR[] = {{"ddrd_n0_piref_offset1", "", 0x0001B1A8, 1, 0x000000000000007F, 0x000000000000003F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields549_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RW", "rx_preamble_type", "This field is used by rxdeskew logic to determine preamble pattern type.[br]\r\n"
"                    0: 1 tclk - 10 Pattern (MSB is the 1st UI)[br]\r\n"
"                    1: 2 tclk - 0010 Pattern[br]\r\n"
"                    2: 2 tclk - 1110 Pattern [br]\r\n"
"                    3: 3 tclk - 000010 Pattern[br]\r\n"
"                    4: 4 tclk - 00001010 Pattern[br]\r\n"
"                    Others : Reserved"},
#else
{29, 31, 0x00000000, "RW", "rx_preamble_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "rx_postamble_len", "RX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is toggle)"},
#else
{28, 28, 0x00000000, "RW", "rx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "ctle_en", "CTLE enable"},
#else
{27, 27, 0x00000000, "RW", "ctle_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", "Amplifier control.  The bits in this field control: [br]\r\n"
"                    2:1 - is used to adjust the bias current for the 2nd stage amplifier in the DQS amplifier path. 0=min, 3=max. [br]\r\n"
"                    0 - is used to force local receiver bias to on.  Otherwise, local receiver bias is enabled through senseamp enable."},
#else
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for DQ and DQS. ODT rotation is applied before sending the control to CBB. The rotation is used to ensure the segment is evenly burn. Rotation is happened when odten is deasserted. [br]\r\n"
"                    Note: Setting this field to 0x3 means enable all segments and rotation has no meaning."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo549_DDR[] = {{"ddrd_n0_rx_ctl0", "", 0x0001B1AC, 9, 0x00000000FFFFFFFF, 0x0000000007C09003}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields550_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "bwextend", "Negative cap BW extension"},
#else
{30, 31, 0x00000000, "RW", "bwextend", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "loadtrim", "Rload trimming in rx decoder"},
#else
{29, 29, 0x00000000, "RW", "loadtrim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", "Set to 1 to enable HW reset RXFIFO Pointer when there is no outstanding read in DDRIO."},
#else
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sdl_gating_en", "Set to 1 to enable gating of delay elements in SDL. Default is disable gating.\r\n"
"                    Note : gating must be disabled during any training steps. BIOS can enable gating for power saving after all the training steps are done."},
#else
{27, 27, 0x00000000, "RW", "sdl_gating_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "sdl_max_picode", "After training , this max value of picode is used for \r\n"
"                    enabling appropriate number of delay cells in SDL for power saving . It should be programmed with the max sdl picode from the nibble"},
#else
{24, 26, 0x00000000, "RW", "sdl_max_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", "Set to 0 by default to enable all the devices in the current source legs across all skews.[br]\r\n"
"                    Set to 1 to reduce number of current sources for any sensitivity issues during post silicon testing."},
#else
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", "When set, the VCDL is removed from the DQ path from Amp to samplers[br]\r\n"
"                    When cleared, the DQ passes from Amp to VCDL and then to samplers"},
#else
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", "When set the feedback data is muxed into the VCDL[br]\r\n"
"                    When cleared the DQ data from Amp is muxed into the VCDL"},
#else
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "dfe_en", "Enable DFE in DQ. Also it is used in RXBIASANA."},
#else
{10, 10, 0x00000000, "RW", "dfe_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", "Extend DDR4 RxDFE serializer pulse width.[br]\r\n"
"                    Set to 1 to extend the pulse width of the pulsed clocks to the DDR4 RxDFE serializers.[br]\r\n"
"                    Value of 1 seems to work across PVT. May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", "Rx Sampler offset enable. Also enables the RDAC for the sampler offset correction. Needs to be 1 for DDR5/DDRT2."},
#else
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RW", "sdll_en", "Controls if the slave DLL is enabled in the Deskew logic."},
#else
{7, 7, 0x00000001, "RW", "sdll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable the offset control in DQ/DQS RxAmp and RX BIAS."},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", "strobe Rx Amp offset control in DQS RxAmp"},
#else
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo550_DDR[] = {{"ddrd_n0_rx_ctl1", "", 0x0001B1B0, 14, 0x00000000FFFFFFFF, 0x00000000000001DE}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields551_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 -DQBUF and DQSBUF bypass SCOMP and TCO delay in the transmitter. "},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "imode_eq_code", "Imode coefficient, sets Imode current.[br]\r\n"
"                    Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000001, "RW", "eq_post2_sel", "2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{21, 21, 0x00000001, "RW", "eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "eq_post2_sign", "2nd tap equalization sign bit[br]\r\n"
"                    0 +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{19, 19, 0x00000000, "RW", "eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "imode_en", "Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{17, 17, 0x00000000, "RW", "imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of data sement enable for DQ and DQS."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of DQ/DQS driver (Ron) static legs.[br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1.[br]\r\n"
"                    RTL default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo551_DDR[] = {{"ddrd_n0_tx_ctl0", "", 0x0001B1B8, 8, 0x00000000FFFFFFFF, 0x00000000802000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields552_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_postamble_len", "TX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is always differentially low)"},
#else
{16, 16, 0x00000000, "RW", "tx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 11, 0x00000001, "RW", "tx_preamble_pat", "Programmable Preamble pattern. Each bit represents a UI of the preamble pattern starting at LSB for 1st UI.[br]\r\n"
"                    Note: For DDR5 write leveling training, which require to mask off the preamble strobe, BIOS can program the pattern to all 0's.[br]\r\n"
"                    [br]\r\n"
"                    Legal value is listed below. [br]\r\n"
"                    DDR4-[br]\r\n"
"                    1 TCK: 8'bXXXX_XX01[br]\r\n"
"                    2 TCK: 8'bXXXX_0111 (Long Preamble)[br]\r\n"
"                    DDR5-[br]\r\n"
"                    2 TCK: 8'XXXX_0100[br]\r\n"
"                    3 TCK: 8'bXX01_0000 or 8'bXX01_0100[br]\r\n"
"                    4 TCK: 8'b0101_0000"},
#else
{4, 11, 0x00000001, "RW", "tx_preamble_pat", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "tx_preamble_len", "TX Preenable Length. [br]\r\n"
"                    Legal programming value for [br] \r\n"
"                    DDR4: 1-2 TCK [br]\r\n"
"                    DDR5: 2-4 TCK"},
#else
{0, 2, 0x00000001, "RW", "tx_preamble_len", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo552_DDR[] = {{"ddrd_n0_tx_ctl1", "", 0x0001B1BC, 3, 0x000000000001FFFF, 0x0000000000000011}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields553_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "pxc_en", "Phase base cross talk cancellaton enable"},
#else
{31, 31, 0x00000000, "RW", "pxc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "ddjc_en", "DDJC enable"},
#else
{30, 30, 0x00000000, "RW", "ddjc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "pxc_coupling_type", "Select PXC is inductive or capacitive coupling cross talk dominant type[br]\r\n"
"                    0: capacitive coupling. If victim and attacker data have the same transition phase, the xtalk delta is added; otherwise (oppsite transition phase) the xtalk delta is subtracted.[br]\r\n"
"                    1: inductive coupling. If victim and attacker data have the same transition phase, the xtalk delta is subtracted ; otherwise (oppsite transition phase) the xtalk delta is added."},
#else
{29, 29, 0x00000000, "RW", "pxc_coupling_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{13, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "attacker_sel3", "Select which bit within a byte is the attacker for dq3 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{9, 11, 0x00000000, "RW", "attacker_sel3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "attacker_sel2", "Select which bit within a byte is the attacker for dq2 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{6, 8, 0x00000000, "RW", "attacker_sel2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "attacker_sel1", "Select which bit within a byte is the attacker for dq1 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{3, 5, 0x00000000, "RW", "attacker_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "attacker_sel0", "Select which bit within a byte is the attacker for dq0 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{0, 2, 0x00000000, "RW", "attacker_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo553_DDR[] = {{"ddrd_n0_pxc_ctl0", "", 0x0001B1C4, 9, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields554_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "VOC RX pass gate enable for VOC training and NTL testing."},
#else
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", "Disable using rcvenpost early to control the rx rank switch latch.[br]\r\n"
"                    If this bit is set to 1, minimum Rd-Rd TR time will need to increase by 1."},
#else
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{9, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 8, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for rx rank switching"},
#else
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for tx rank switching"},
#else
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in CKE power down regardless the setting of dq_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in Self Refresh regardless the setting of dq_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo554_DDR[] = {{"ddrd_n0_dfx_ctl0", "", 0x0001B1C8, 11, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields555_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "vreftrack_en", "Vref Track enable"},
#else
{31, 31, 0x00000001, "RW", "vreftrack_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", "Code for Vref Cap to gnd. 0=min, 15=max. Sweep codes 0-7,11-15"},
#else
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", "Code for Vref Cap to supply. 0=min, 15=max. Sweep codes 0-15."},
#else
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo555_DDR[] = {{"ddrd_n0_vref_track_ctl", "", 0x0001B1CC, 3, 0x00000000FFFFFFFF, 0x00000000800001EF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields556_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW/V", "hw_cal_en", "Set to 1 to enable HW calibration. They are five HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br] \r\n"
"                    For ACIO testing, all 5 stages can be enabled by SW."},
#else
{31, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 29, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 28, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", "Set to 1 by HW to indicate odd sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", "Set to 1 by HW to indicate even sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{24, 24, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{19, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 18, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digitial simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for 1st, 24 Dclk for subsequent [br]\r\n"
"                    Sampler offset : 528 Dclk for 1st time; 144 Dlck for subsequent steps [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Rcven fine/coarse : 16 Dclk / 8 Dclk [br]\r\n"
"                    Dqdqs fine / coarse : 16 Dclk / 8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all DQ bits.[br]\r\n"
"                    Note: the training result is applied to all ranks. BIOS will adjust later for all ranks setting based on eye centering."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", "Set to 1 to enable even/odd sampler training stage for all DQ bits.[br]\r\n"
"                    Note: The result is only logged to the sampler even/odd offset register when both even and odd training are done."},
#else
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo556_DDR[] = {{"ddrd_n0_hw_train_ctl0", "", 0x0001B1D0, 17, 0x00000000FFFFFFFF, 0x0000000000042000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields557_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo557_DDR[] = {{"ddrd_n0_hwcal_sweep_result0", "", 0x0001B1D8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields558_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo558_DDR[] = {{"ddrd_n0_hwcal_sweep_result1", "", 0x0001B1DC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields559_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo559_DDR[] = {{"ddrd_n0_hwcal_sweep_result2", "", 0x0001B1E0, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields560_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dqs_sa_dur", "Control how long the DQS Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dqs_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dqs_sa_dly", "Logic delay to turn on DQS Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dqs_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dqs_odt_dur", "Control how long the DQS ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dqs_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dqs_odt_dly", "Logic delay to turn on DQS ODT base on receive enable signal. Unit is DLCK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dqs_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo560_DDR[] = {{"ddrd_n0_train_ctl0", "", 0x0001B1E4, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields561_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "dq_vref_en", "Vref generator Enable. Set to 1 to enable all DQ bits vref.[br]\r\n"
"                    Note: The self refresh VREF disable control (sr_vref_dis) can disable vref during DIMM in self refresh.[br]\r\n"
"                    To force VREF on all the time in SPR, user must program sr_vref_dis to 0 and ckepd_vref_dis to 0. [br]\r\n"
"                    Note: Unlike wave 1 design, ForceBiasOn doesn't force verf enable anymore."},
#else
{31, 31, 0x00000001, "RW", "dq_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "force_strong_odt_on", "Force Strong DQS/DQ ODT on. when set, it always enable one segement for ODT regardless of the state of drive enable.[br]\r\n"
"                    The intend use case is for ACIO with burnin."},
#else
{30, 30, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx bias circuit on.[br]\r\n"
"                    Note: In SPR setting this bit to 1 doesnt force vref on. To force vref on, user must set dq_vref_en to 1 and sr_vref_dis to 0."},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force Weak DQS/DQ ODT on. It is used before ODT enable window is trained and program by BIOS. [br]\r\n"
"                    The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{24, 26, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{23, 23, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", "Set to 1 to enable HW to gate RX PI CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", "Set to 1 to enable HW to gate TX PI CLK for transmit path logic. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", "Set to 1 to enable HW to gate tx retraining logic for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2.[br]\r\n"
"                    Fub use this bit to determine the training level different between DDR4 vs DDR5."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "nibble_dis", "BIOS can disable a nibble within a byte. This can be used to disable 1 nibble of the ECC for 9x4 DIMM support.[br]\r\n"
"                    The entire ECC byte can also be disabled for DIMMs that doesn't support ECC.  In DDR4, the unused byte can be disabled as well."},
#else
{11, 11, 0x00000000, "RW", "nibble_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "elr_dimm", "Set this bit to 1 for DDR5 ELR DIMM type"},
#else
{10, 10, 0x00000000, "RW", "elr_dimm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", "Should be set only during DFE coefficient initial training (pulse response). Increases sampler offset range by 2X."},
#else
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", "Used for odd sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", "Used for even sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. [br]\r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rd_level_train_type", "0 : Front side[br]\r\n"
"                    1: Back side (DDR5 LRDIMM / 3D Xpoint DIMM)[br]\r\n"
"                    [br]\r\n"
"                    When rd_level_train_type is set to 1 and rd_level_train_en is set to 1, the training counter increments based on the sampling of DQ with the rising edge of rcven (DB sends feedback to host through DQ pins, DB samples MDQS with its internal rcven signal). [br]\r\n"
"                    When rd_level_train_type is set to 0 and rd_level_train_en is set to 1,  the training counter increments based on the sampling of DQS with the rising edge of rcven."},
#else
{3, 3, 0x00000000, "RW", "rd_level_train_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "rd_level_train_en", "Enables Read Leveling Training Mode. Read Leveling training step is the same for DDR4 and DDR5.[br]\r\n"
"                    Note: all clock gate enable must 0 during Read Level training mode."},
#else
{2, 2, 0x00000000, "RW", "rd_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "wr_level_train_en", "Enables Write Leveling Training Mode. Write Leveling training is not the same for both DDR4 and DDR5. BIOS must set the ddr4 control bit to indicate write leveling for DDR4 or DDR5.[br]\r\n"
"                    For DDR5, when set, the strobes have their transmitter enable, while the DQ signals have their receivers enabled. The Received value from the DQ signals is sampled and stored in the training result register. This is a continously sampled valued.[br]\r\n"
"                    Note: all clock gate enable must 0 during Write Level training mode."},
#else
{1, 1, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (DQ receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo561_DDR[] = {{"ddrd_n0_train_ctl1", "", 0x0001B1E8, 29, 0x00000000FFFFFFFF, 0x0000000098000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields562_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", "Select which xover phase detect output for calibration. For each nibble, we have 8 xover per DLL piref."},
#else
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "unsampled_path_en", "The unsampled path is automatically enabled in DDR4, but not for DDR5.  In DDR5, set this bit to 0x1 during write level, and cmd training (DQ feedback is used)."},
#else
{21, 21, 0x00000000, "RW", "unsampled_path_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "sampler_feedback_en", "Enables feedback from DQ SAL for any DDR5 training modes, requiring feedback from DQ lanes."},
#else
{20, 20, 0x00000000, "RW", "sampler_feedback_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "dq_sample_mask", "Mask off any DQ bits not considered in the OR computation for the command training counting."},
#else
{16, 19, 0x00000000, "RW", "dq_sample_mask", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{15, 15, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "dq_ovr_en", "This setting enables the over-ride operation associated with the DQ Value Override setting.[br]\r\n"
"                    Note: Once this bit is set, it turns on the TX driver and drives the dq_value_ovr on all DQs pins "},
#else
{14, 14, 0x00000000, "RW", "dq_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "dq_value_ovr", "When the DQ Override Enable bit is set, this setting determines the value that is driven by the DQ transmitter at all time. The value is constant over all UIs, but can be set per DQ in the nibble."},
#else
{10, 13, 0x00000000, "RW", "dq_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", "When set, the strobe is driven differentially high, other than when a WRITE strobe sequence is sent to the DRAM. "},
#else
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", "When set, the strobe is driven differentially low, other than when a WRITE strobe sequence is sent to the DRAM"},
#else
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "tx_strobe_mask", "Each bit in the TX strobe mask will mask out the strobe pulse associated with each location in the write burst (i.e. for a BL16 there are 8 strobe pulses (rising/falling combination)). A value of 00000000b will enable all strobes. A value of 1111_1110b will enable a single strobe pulse at the first 2 UIs in the BL. [br]\r\n"
"                    The current use case is for DDR5 write leveling training which only enable the 1st TCK DQS strobe (0xFE)[br]\r\n"
"                    Note: When drv_dqs_diff_high is set, the masked Strobe is driven differentially high. On the other hand, when drv_dqs_diff_low is set, the masked stobe is driven differentially low."},
#else
{0, 7, 0x00000000, "RW", "tx_strobe_mask", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo562_DDR[] = {{"ddrd_n0_train_ctl2", "", 0x0001B1EC, 10, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields563_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dq_sa_dur", "Control how long the DQ Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dq_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dq_sa_dly", "Logic delay to turn on DQ Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dq_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dq_odt_dur", "Control how long the DQ ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dq_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dq_odt_dly", "Logic delay to turn on DQ ODT base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dq_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo563_DDR[] = {{"ddrd_n0_train_ctl3", "", 0x0001B1F0, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields564_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "cmd_train_ctr_en:[br]\r\n"
"                    value that sets the number of DCLK cycles that the DQ samples will be counted. Linear setting. This is broadcast to all bytes  one register per byte. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared.[br]\r\n"
"                    wr_level_train_en: [br]\r\n"
"                    control when to increment the coutner after the trigger event (DQS OE)[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    control when to increment the coutner after the sampling event (rising edge of receive enable)"},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo564_DDR[] = {{"ddrd_n0_train_cnt_window0", "", 0x0001B1F4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields565_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "cmd_train_ctr_en:[br]\r\n"
"                    Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled. This count is the result of the OR of all DQs in the nibble, for those DQs that are not masked off.  Whten the cnt_window is set to 0, the counter will run until it saturates.[br]\r\n"
"                    wr_level_train_en:[br]\r\n"
"                    DQ sample count[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    Receive enable sample count"},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo565_DDR[] = {{"ddrd_n0_train_cnt_result", "", 0x0001B1F8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields566_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", "Per bit senseamp train result for DDR4 only"},
#else
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", "Per bit odd sampler value for senseamp training. It is used only for DDR5 sampler training stage."},
#else
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", "Per bit even sampler value for senseamp training. It is used for DDR5 sampler and DFE summer VOC training stage"},
#else
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result"},
#else
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo566_DDR[] = {{"ddrd_n0_train_result0", "", 0x0001B1FC, 4, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields567_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo567_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_0_", "", 0x00011500, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields568_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo568_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_1_", "", 0x00011504, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields569_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo569_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_2_", "", 0x00011508, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields570_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo570_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_3_", "", 0x0001150C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields571_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo571_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_4_", "", 0x00011510, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields572_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo572_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_5_", "", 0x00011514, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields573_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo573_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_6_", "", 0x00011518, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields574_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo574_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_7_", "", 0x0001151C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields575_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo575_DDR[] = {{"ddrd_n0_sa_offset_rank_0_", "", 0x00011520, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields576_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo576_DDR[] = {{"ddrd_n0_sa_offset_rank_1_", "", 0x00011524, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields577_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo577_DDR[] = {{"ddrd_n0_sa_offset_rank_2_", "", 0x00011528, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields578_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo578_DDR[] = {{"ddrd_n0_sa_offset_rank_3_", "", 0x0001152C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields579_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo579_DDR[] = {{"ddrd_n0_sa_offset_rank_4_", "", 0x00011530, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields580_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo580_DDR[] = {{"ddrd_n0_sa_offset_rank_5_", "", 0x00011534, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields581_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo581_DDR[] = {{"ddrd_n0_sa_offset_rank_6_", "", 0x00011538, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields582_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo582_DDR[] = {{"ddrd_n0_sa_offset_rank_7_", "", 0x0001153C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields583_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo583_DDR[] = {{"ddrd_n0_dfe_coeff_rank_0_", "", 0x00011540, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields584_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo584_DDR[] = {{"ddrd_n0_dfe_coeff_rank_1_", "", 0x00011544, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields585_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo585_DDR[] = {{"ddrd_n0_dfe_coeff_rank_2_", "", 0x00011548, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields586_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo586_DDR[] = {{"ddrd_n0_dfe_coeff_rank_3_", "", 0x0001154C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields587_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo587_DDR[] = {{"ddrd_n0_dfe_coeff_rank_4_", "", 0x00011550, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields588_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo588_DDR[] = {{"ddrd_n0_dfe_coeff_rank_5_", "", 0x00011554, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields589_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo589_DDR[] = {{"ddrd_n0_dfe_coeff_rank_6_", "", 0x00011558, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields590_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo590_DDR[] = {{"ddrd_n0_dfe_coeff_rank_7_", "", 0x0001155C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields591_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo591_DDR[] = {{"ddrd_n0_dll_ctl0", "", 0x00011570, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields592_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", "Reads back the MRR that the TXRT FSM is waiting on. [br]\r\n"
"                    bit 0: MR46. 1 indicates that the FSM is waiting for this read. [br]\r\n"
"                    bit 1: MR47. 1 indicates that the FSM is waiting for this read."},
#else
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", "Reads back the TXRT FSM state. [br]\r\n"
"                    0: IDLE [br]\r\n"
"                    1: WAIT_MR [br]\r\n"
"                    2: CALC [br]\r\n"
"                    3: UPDATE"},
#else
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", "Set to 1 by HW to indicate MR46 rank did not match MR47 rank when txrt_update or spid_update_req/ack occurs. [br]\r\n"
"                    SW must clear this bit to 0 when enable HW calibration."},
#else
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW/V", "txrt_update", "Set to 1 to apply the calculation results to txrt_init_picode or txrt_dq_dly_adj. HW will clear this bit once it is applied. [br]\r\n"
"                    HW does not require the spid_update_req/ack handshake to apply the results if this CSR is used. [br]\r\n"
"                    SW needs to guarantee that there are no CAP errors, and there is no write traffic to the targeted rank before setting this bit."},
#else
{22, 22, 0x00000000, "RW/V", "txrt_update", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", "This is the last TX retraining Ring Oscillator count value captured by HW. HW only capture the rank sepcify in txrt_debug_rank."},
#else
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 7, 0x00000000, "RW", "txrt_debug_rank", "Select which rank of RO count value to capture in txrt_ro_count for debug."},
#else
{5, 7, 0x00000000, "RW", "txrt_debug_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "txrt_init", "Set to 1 to indicate this is the 1st retraining to initialize the txrt_init_picode. HW will not calculate and apply the txrt_dq_dly_adj."},
#else
{4, 4, 0x00000000, "RW", "txrt_init", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "txrt_dur", "TX retraining duration. SW must programs the same TCK duration value as progammed in the memory device.[br]\r\n"
"                    001: 128 x 16 TCK[br]\r\n"
"                    010: 256 x 16 TCK[br]\r\n"
"                    100: 512 x 16 TCK[br]\r\n"
"                    others: Reserved"},
#else
{0, 2, 0x00000001, "RW", "txrt_dur", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo592_DDR[] = {{"ddrd_n0_tx_retrain0", "", 0x00011574, 8, 0x000000000FFFFFFF, 0x000000000C000001}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields593_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo593_DDR[] = {{"ddrd_n0_sampler_odd_offset", "", 0x00011578, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields594_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo594_DDR[] = {{"ddrd_n0_sampler_even_offset", "", 0x0001157C, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields595_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x0000003F, "RW", "vref_ctl3", "Per bit Rx Vref Control for DQ3. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{21, 27, 0x0000003F, "RW", "vref_ctl3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x0000003F, "RW", "vref_ctl2", "Per bit Rx Vref Control for DQ2. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{14, 20, 0x0000003F, "RW", "vref_ctl2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003F, "RW", "vref_ctl1", "Per bit Rx Vref Control for DQ1. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{7, 13, 0x0000003F, "RW", "vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW", "vref_ctl0", "Per bit Rx Vref Control for DQ0. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{0, 6, 0x0000003F, "RW", "vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo595_DDR[] = {{"ddrd_n0_rxvref_ctl", "", 0x00011580, 5, 0x00000000FFFFFFFF, 0x0000000007EFDFBF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields596_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", "Data Rcomp Odt-Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", "Data Rcomp OdtUp Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Data Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Data Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo596_DDR[] = {{"ddrd_n0_comp_la0", "", 0x00011584, 4, 0x0000000003FFFFFF, 0x0000000001020408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields597_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", "Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated by DDRCOMP fub and broadcast to all the data fub. The adjust range is -64 to 63."},
#else
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "Data Slew Rate Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate.[br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "Data TCO Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo597_DDR[] = {{"ddrd_n0_comp_la1", "", 0x00011588, 3, 0x00000000001FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields598_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", "Signed number add to rcomp_odt_dn to generate the RCOMP ODT down code. The adjust range is -8 to 7"},
#else
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", "Signed number add to rcomp_odt_up to generate the RCOMP ODT up code. The adjust range is -8 to 7"},
#else
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo598_DDR[] = {{"ddrd_n0_comp_offset", "", 0x0001158C, 6, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields599_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", "Double the timer for LDO/VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the LDO/VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "ldo_close_loop", "Operate LDO in close loop mode"},
#else
{29, 29, 0x00000000, "RW", "ldo_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", "LDO Cap Trim Loop"},
#else
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 24, 0x00000018, "RW", "ldo_codetarget", "Sets the LDO reference voltage when ldo_vref_sel_ddra=0.[br]\r\n"
"                    Range is (vccddr_hv/2 to vccddr_hv), with step size of vccddr_hv/256.[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 1 inside LDO. Only the lower 7-bit is controlled by this field."},
#else
{18, 24, 0x00000018, "RW", "ldo_codetarget", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", "LDO RC Filter Trim"},
#else
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", "LDO driver strength based on process variation. Bit 1 is unused. Bit 0 used for LDO Driver Strength[br]\r\n"
"                    This field should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                    (Fast) 3'd3: 0x0[br]\r\n"
"                    (Typ) 3'd1,3'd2: 0x0[br]\r\n"
"                    (Slow) 3'd0: 0x1[br]"},
#else
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", "Use vccddra as LDO vref "},
#else
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", "LDO output is bypassed to VCCDDRA"},
#else
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo599_DDR[] = {{"ddrd_n0_vsshi_ctl", "", 0x00011590, 13, 0x00000000FFFFFFFF, 0x0000000000600118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields600_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo600_DDR[] = {{"ddrd_n0_dll_pi_test_adc", "", 0x00011594, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields601_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq. It is half of the DRAM transfer rate.[br]\r\n"
"                    For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo601_DDR[] = {{"ddrd_n0_dll_csr", "", 0x00011598, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields602_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", "Sticky error count. Reset by power good reset.[br]\r\n"
"                    Increment when data fub detect rxfifo read and write pointer is out of sync."},
#else
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo602_DDR[] = {{"ddrd_n0_rxfifo_ptr_log", "", 0x0001159C, 1, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields603_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "sampler_offset_adj", "Rx Sampler Offset adjust value. It is added to all sampler_even/odd_offset. It is used by BIOS for sampler offsets margining. The adjust range is -32 to 31. The expected usage model is BIOS broadcast the same value to all the bytes."},
#else
{23, 28, 0x00000000, "RW", "sampler_offset_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "vref_adj", "Signed number with range from -64 to 63. It is used by BIOS for marging sweep. This value is added to the vref_ctrl before sending to the DQ VREF. [br]\r\n"
"                    Note: HW doesn't check for overflow and underflow. BIOS must ensure the adjust value doesn't overflow or underflow the final vref control value."},
#else
{16, 22, 0x00000000, "RW", "vref_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000000, "RW", "txdq_dly_adj", "Tx DQ delay adjust value. It is added to all per bit TXDQ delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{8, 15, 0x00000000, "RW", "txdq_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", "Rx DQS delay adjust value. It is added to all per bit RXDQS delay. It is used by BIOS for margining sweep or ACIO HW training. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo603_DDR[] = {{"ddrd_n0_train_offset0", "", 0x000115A0, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields604_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", "This txdqs piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the txdqs_dly[6:0], so the txdqs PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM."},
#else
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", "This txdq piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the per bit txdq_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", "This rcven piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the rcven_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", "It is the train PI code to align the PIREF clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default  value is 63) to generate the piref_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo604_DDR[] = {{"ddrd_n0_piref_offset0", "", 0x000115A4, 4, 0x000000000FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields605_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 64 ticks, and we will have 64 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo605_DDR[] = {{"ddrd_n0_piref_offset1", "", 0x000115A8, 1, 0x000000000000007F, 0x000000000000003F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields606_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RW", "rx_preamble_type", "This field is used by rxdeskew logic to determine preamble pattern type.[br]\r\n"
"                    0: 1 tclk - 10 Pattern (MSB is the 1st UI)[br]\r\n"
"                    1: 2 tclk - 0010 Pattern[br]\r\n"
"                    2: 2 tclk - 1110 Pattern [br]\r\n"
"                    3: 3 tclk - 000010 Pattern[br]\r\n"
"                    4: 4 tclk - 00001010 Pattern[br]\r\n"
"                    Others : Reserved"},
#else
{29, 31, 0x00000000, "RW", "rx_preamble_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "rx_postamble_len", "RX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is toggle)"},
#else
{28, 28, 0x00000000, "RW", "rx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "ctle_en", "CTLE enable"},
#else
{27, 27, 0x00000000, "RW", "ctle_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", "Amplifier control.  The bits in this field control: [br]\r\n"
"                    2:1 - is used to adjust the bias current for the 2nd stage amplifier in the DQS amplifier path. 0=min, 3=max. [br]\r\n"
"                    0 - is used to force local receiver bias to on.  Otherwise, local receiver bias is enabled through senseamp enable."},
#else
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for DQ and DQS. ODT rotation is applied before sending the control to CBB. The rotation is used to ensure the segment is evenly burn. Rotation is happened when odten is deasserted. [br]\r\n"
"                    Note: Setting this field to 0x3 means enable all segments and rotation has no meaning."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo606_DDR[] = {{"ddrd_n0_rx_ctl0", "", 0x000115AC, 9, 0x00000000FFFFFFFF, 0x0000000007C09003}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields607_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "bwextend", "Negative cap BW extension"},
#else
{30, 31, 0x00000000, "RW", "bwextend", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "loadtrim", "Rload trimming in rx decoder"},
#else
{29, 29, 0x00000000, "RW", "loadtrim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", "Set to 1 to enable HW reset RXFIFO Pointer when there is no outstanding read in DDRIO."},
#else
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sdl_gating_en", "Set to 1 to enable gating of delay elements in SDL. Default is disable gating.\r\n"
"                    Note : gating must be disabled during any training steps. BIOS can enable gating for power saving after all the training steps are done."},
#else
{27, 27, 0x00000000, "RW", "sdl_gating_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "sdl_max_picode", "After training , this max value of picode is used for \r\n"
"                    enabling appropriate number of delay cells in SDL for power saving . It should be programmed with the max sdl picode from the nibble"},
#else
{24, 26, 0x00000000, "RW", "sdl_max_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", "Set to 0 by default to enable all the devices in the current source legs across all skews.[br]\r\n"
"                    Set to 1 to reduce number of current sources for any sensitivity issues during post silicon testing."},
#else
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", "When set, the VCDL is removed from the DQ path from Amp to samplers[br]\r\n"
"                    When cleared, the DQ passes from Amp to VCDL and then to samplers"},
#else
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", "When set the feedback data is muxed into the VCDL[br]\r\n"
"                    When cleared the DQ data from Amp is muxed into the VCDL"},
#else
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "dfe_en", "Enable DFE in DQ. Also it is used in RXBIASANA."},
#else
{10, 10, 0x00000000, "RW", "dfe_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", "Extend DDR4 RxDFE serializer pulse width.[br]\r\n"
"                    Set to 1 to extend the pulse width of the pulsed clocks to the DDR4 RxDFE serializers.[br]\r\n"
"                    Value of 1 seems to work across PVT. May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", "Rx Sampler offset enable. Also enables the RDAC for the sampler offset correction. Needs to be 1 for DDR5/DDRT2."},
#else
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RW", "sdll_en", "Controls if the slave DLL is enabled in the Deskew logic."},
#else
{7, 7, 0x00000001, "RW", "sdll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable the offset control in DQ/DQS RxAmp and RX BIAS."},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", "strobe Rx Amp offset control in DQS RxAmp"},
#else
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo607_DDR[] = {{"ddrd_n0_rx_ctl1", "", 0x000115B0, 14, 0x00000000FFFFFFFF, 0x00000000000001DE}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields608_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 -DQBUF and DQSBUF bypass SCOMP and TCO delay in the transmitter. "},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "imode_eq_code", "Imode coefficient, sets Imode current.[br]\r\n"
"                    Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000001, "RW", "eq_post2_sel", "2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{21, 21, 0x00000001, "RW", "eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "eq_post2_sign", "2nd tap equalization sign bit[br]\r\n"
"                    0 +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{19, 19, 0x00000000, "RW", "eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "imode_en", "Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{17, 17, 0x00000000, "RW", "imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of data sement enable for DQ and DQS."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of DQ/DQS driver (Ron) static legs.[br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1.[br]\r\n"
"                    RTL default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo608_DDR[] = {{"ddrd_n0_tx_ctl0", "", 0x000115B8, 8, 0x00000000FFFFFFFF, 0x00000000802000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields609_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_postamble_len", "TX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is always differentially low)"},
#else
{16, 16, 0x00000000, "RW", "tx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 11, 0x00000001, "RW", "tx_preamble_pat", "Programmable Preamble pattern. Each bit represents a UI of the preamble pattern starting at LSB for 1st UI.[br]\r\n"
"                    Note: For DDR5 write leveling training, which require to mask off the preamble strobe, BIOS can program the pattern to all 0's.[br]\r\n"
"                    [br]\r\n"
"                    Legal value is listed below. [br]\r\n"
"                    DDR4-[br]\r\n"
"                    1 TCK: 8'bXXXX_XX01[br]\r\n"
"                    2 TCK: 8'bXXXX_0111 (Long Preamble)[br]\r\n"
"                    DDR5-[br]\r\n"
"                    2 TCK: 8'XXXX_0100[br]\r\n"
"                    3 TCK: 8'bXX01_0000 or 8'bXX01_0100[br]\r\n"
"                    4 TCK: 8'b0101_0000"},
#else
{4, 11, 0x00000001, "RW", "tx_preamble_pat", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "tx_preamble_len", "TX Preenable Length. [br]\r\n"
"                    Legal programming value for [br] \r\n"
"                    DDR4: 1-2 TCK [br]\r\n"
"                    DDR5: 2-4 TCK"},
#else
{0, 2, 0x00000001, "RW", "tx_preamble_len", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo609_DDR[] = {{"ddrd_n0_tx_ctl1", "", 0x000115BC, 3, 0x000000000001FFFF, 0x0000000000000011}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields610_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "pxc_en", "Phase base cross talk cancellaton enable"},
#else
{31, 31, 0x00000000, "RW", "pxc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "ddjc_en", "DDJC enable"},
#else
{30, 30, 0x00000000, "RW", "ddjc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "pxc_coupling_type", "Select PXC is inductive or capacitive coupling cross talk dominant type[br]\r\n"
"                    0: capacitive coupling. If victim and attacker data have the same transition phase, the xtalk delta is added; otherwise (oppsite transition phase) the xtalk delta is subtracted.[br]\r\n"
"                    1: inductive coupling. If victim and attacker data have the same transition phase, the xtalk delta is subtracted ; otherwise (oppsite transition phase) the xtalk delta is added."},
#else
{29, 29, 0x00000000, "RW", "pxc_coupling_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{13, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "attacker_sel3", "Select which bit within a byte is the attacker for dq3 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{9, 11, 0x00000000, "RW", "attacker_sel3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "attacker_sel2", "Select which bit within a byte is the attacker for dq2 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{6, 8, 0x00000000, "RW", "attacker_sel2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "attacker_sel1", "Select which bit within a byte is the attacker for dq1 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{3, 5, 0x00000000, "RW", "attacker_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "attacker_sel0", "Select which bit within a byte is the attacker for dq0 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{0, 2, 0x00000000, "RW", "attacker_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo610_DDR[] = {{"ddrd_n0_pxc_ctl0", "", 0x000115C4, 9, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields611_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "VOC RX pass gate enable for VOC training and NTL testing."},
#else
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", "Disable using rcvenpost early to control the rx rank switch latch.[br]\r\n"
"                    If this bit is set to 1, minimum Rd-Rd TR time will need to increase by 1."},
#else
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{9, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 8, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for rx rank switching"},
#else
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for tx rank switching"},
#else
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in CKE power down regardless the setting of dq_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in Self Refresh regardless the setting of dq_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo611_DDR[] = {{"ddrd_n0_dfx_ctl0", "", 0x000115C8, 11, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields612_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "vreftrack_en", "Vref Track enable"},
#else
{31, 31, 0x00000001, "RW", "vreftrack_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", "Code for Vref Cap to gnd. 0=min, 15=max. Sweep codes 0-7,11-15"},
#else
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", "Code for Vref Cap to supply. 0=min, 15=max. Sweep codes 0-15."},
#else
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo612_DDR[] = {{"ddrd_n0_vref_track_ctl", "", 0x000115CC, 3, 0x00000000FFFFFFFF, 0x00000000800001EF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields613_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW/V", "hw_cal_en", "Set to 1 to enable HW calibration. They are five HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br] \r\n"
"                    For ACIO testing, all 5 stages can be enabled by SW."},
#else
{31, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 29, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 28, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", "Set to 1 by HW to indicate odd sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", "Set to 1 by HW to indicate even sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{24, 24, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{19, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 18, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digitial simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for 1st, 24 Dclk for subsequent [br]\r\n"
"                    Sampler offset : 528 Dclk for 1st time; 144 Dlck for subsequent steps [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Rcven fine/coarse : 16 Dclk / 8 Dclk [br]\r\n"
"                    Dqdqs fine / coarse : 16 Dclk / 8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all DQ bits.[br]\r\n"
"                    Note: the training result is applied to all ranks. BIOS will adjust later for all ranks setting based on eye centering."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", "Set to 1 to enable even/odd sampler training stage for all DQ bits.[br]\r\n"
"                    Note: The result is only logged to the sampler even/odd offset register when both even and odd training are done."},
#else
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo613_DDR[] = {{"ddrd_n0_hw_train_ctl0", "", 0x000115D0, 17, 0x00000000FFFFFFFF, 0x0000000000042000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields614_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo614_DDR[] = {{"ddrd_n0_hwcal_sweep_result0", "", 0x000115D8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields615_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo615_DDR[] = {{"ddrd_n0_hwcal_sweep_result1", "", 0x000115DC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields616_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo616_DDR[] = {{"ddrd_n0_hwcal_sweep_result2", "", 0x000115E0, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields617_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dqs_sa_dur", "Control how long the DQS Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dqs_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dqs_sa_dly", "Logic delay to turn on DQS Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dqs_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dqs_odt_dur", "Control how long the DQS ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dqs_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dqs_odt_dly", "Logic delay to turn on DQS ODT base on receive enable signal. Unit is DLCK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dqs_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo617_DDR[] = {{"ddrd_n0_train_ctl0", "", 0x000115E4, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields618_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "dq_vref_en", "Vref generator Enable. Set to 1 to enable all DQ bits vref.[br]\r\n"
"                    Note: The self refresh VREF disable control (sr_vref_dis) can disable vref during DIMM in self refresh.[br]\r\n"
"                    To force VREF on all the time in SPR, user must program sr_vref_dis to 0 and ckepd_vref_dis to 0. [br]\r\n"
"                    Note: Unlike wave 1 design, ForceBiasOn doesn't force verf enable anymore."},
#else
{31, 31, 0x00000001, "RW", "dq_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "force_strong_odt_on", "Force Strong DQS/DQ ODT on. when set, it always enable one segement for ODT regardless of the state of drive enable.[br]\r\n"
"                    The intend use case is for ACIO with burnin."},
#else
{30, 30, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx bias circuit on.[br]\r\n"
"                    Note: In SPR setting this bit to 1 doesnt force vref on. To force vref on, user must set dq_vref_en to 1 and sr_vref_dis to 0."},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force Weak DQS/DQ ODT on. It is used before ODT enable window is trained and program by BIOS. [br]\r\n"
"                    The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{24, 26, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{23, 23, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", "Set to 1 to enable HW to gate RX PI CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", "Set to 1 to enable HW to gate TX PI CLK for transmit path logic. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", "Set to 1 to enable HW to gate tx retraining logic for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2.[br]\r\n"
"                    Fub use this bit to determine the training level different between DDR4 vs DDR5."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "nibble_dis", "BIOS can disable a nibble within a byte. This can be used to disable 1 nibble of the ECC for 9x4 DIMM support.[br]\r\n"
"                    The entire ECC byte can also be disabled for DIMMs that doesn't support ECC.  In DDR4, the unused byte can be disabled as well."},
#else
{11, 11, 0x00000000, "RW", "nibble_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "elr_dimm", "Set this bit to 1 for DDR5 ELR DIMM type"},
#else
{10, 10, 0x00000000, "RW", "elr_dimm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", "Should be set only during DFE coefficient initial training (pulse response). Increases sampler offset range by 2X."},
#else
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", "Used for odd sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", "Used for even sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. [br]\r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rd_level_train_type", "0 : Front side[br]\r\n"
"                    1: Back side (DDR5 LRDIMM / 3D Xpoint DIMM)[br]\r\n"
"                    [br]\r\n"
"                    When rd_level_train_type is set to 1 and rd_level_train_en is set to 1, the training counter increments based on the sampling of DQ with the rising edge of rcven (DB sends feedback to host through DQ pins, DB samples MDQS with its internal rcven signal). [br]\r\n"
"                    When rd_level_train_type is set to 0 and rd_level_train_en is set to 1,  the training counter increments based on the sampling of DQS with the rising edge of rcven."},
#else
{3, 3, 0x00000000, "RW", "rd_level_train_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "rd_level_train_en", "Enables Read Leveling Training Mode. Read Leveling training step is the same for DDR4 and DDR5.[br]\r\n"
"                    Note: all clock gate enable must 0 during Read Level training mode."},
#else
{2, 2, 0x00000000, "RW", "rd_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "wr_level_train_en", "Enables Write Leveling Training Mode. Write Leveling training is not the same for both DDR4 and DDR5. BIOS must set the ddr4 control bit to indicate write leveling for DDR4 or DDR5.[br]\r\n"
"                    For DDR5, when set, the strobes have their transmitter enable, while the DQ signals have their receivers enabled. The Received value from the DQ signals is sampled and stored in the training result register. This is a continously sampled valued.[br]\r\n"
"                    Note: all clock gate enable must 0 during Write Level training mode."},
#else
{1, 1, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (DQ receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo618_DDR[] = {{"ddrd_n0_train_ctl1", "", 0x000115E8, 29, 0x00000000FFFFFFFF, 0x0000000098000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields619_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", "Select which xover phase detect output for calibration. For each nibble, we have 8 xover per DLL piref."},
#else
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "unsampled_path_en", "The unsampled path is automatically enabled in DDR4, but not for DDR5.  In DDR5, set this bit to 0x1 during write level, and cmd training (DQ feedback is used)."},
#else
{21, 21, 0x00000000, "RW", "unsampled_path_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "sampler_feedback_en", "Enables feedback from DQ SAL for any DDR5 training modes, requiring feedback from DQ lanes."},
#else
{20, 20, 0x00000000, "RW", "sampler_feedback_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "dq_sample_mask", "Mask off any DQ bits not considered in the OR computation for the command training counting."},
#else
{16, 19, 0x00000000, "RW", "dq_sample_mask", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{15, 15, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "dq_ovr_en", "This setting enables the over-ride operation associated with the DQ Value Override setting.[br]\r\n"
"                    Note: Once this bit is set, it turns on the TX driver and drives the dq_value_ovr on all DQs pins "},
#else
{14, 14, 0x00000000, "RW", "dq_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "dq_value_ovr", "When the DQ Override Enable bit is set, this setting determines the value that is driven by the DQ transmitter at all time. The value is constant over all UIs, but can be set per DQ in the nibble."},
#else
{10, 13, 0x00000000, "RW", "dq_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", "When set, the strobe is driven differentially high, other than when a WRITE strobe sequence is sent to the DRAM. "},
#else
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", "When set, the strobe is driven differentially low, other than when a WRITE strobe sequence is sent to the DRAM"},
#else
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "tx_strobe_mask", "Each bit in the TX strobe mask will mask out the strobe pulse associated with each location in the write burst (i.e. for a BL16 there are 8 strobe pulses (rising/falling combination)). A value of 00000000b will enable all strobes. A value of 1111_1110b will enable a single strobe pulse at the first 2 UIs in the BL. [br]\r\n"
"                    The current use case is for DDR5 write leveling training which only enable the 1st TCK DQS strobe (0xFE)[br]\r\n"
"                    Note: When drv_dqs_diff_high is set, the masked Strobe is driven differentially high. On the other hand, when drv_dqs_diff_low is set, the masked stobe is driven differentially low."},
#else
{0, 7, 0x00000000, "RW", "tx_strobe_mask", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo619_DDR[] = {{"ddrd_n0_train_ctl2", "", 0x000115EC, 10, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields620_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dq_sa_dur", "Control how long the DQ Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dq_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dq_sa_dly", "Logic delay to turn on DQ Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dq_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dq_odt_dur", "Control how long the DQ ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dq_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dq_odt_dly", "Logic delay to turn on DQ ODT base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dq_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo620_DDR[] = {{"ddrd_n0_train_ctl3", "", 0x000115F0, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields621_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "cmd_train_ctr_en:[br]\r\n"
"                    value that sets the number of DCLK cycles that the DQ samples will be counted. Linear setting. This is broadcast to all bytes  one register per byte. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared.[br]\r\n"
"                    wr_level_train_en: [br]\r\n"
"                    control when to increment the coutner after the trigger event (DQS OE)[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    control when to increment the coutner after the sampling event (rising edge of receive enable)"},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo621_DDR[] = {{"ddrd_n0_train_cnt_window0", "", 0x000115F4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields622_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "cmd_train_ctr_en:[br]\r\n"
"                    Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled. This count is the result of the OR of all DQs in the nibble, for those DQs that are not masked off.  Whten the cnt_window is set to 0, the counter will run until it saturates.[br]\r\n"
"                    wr_level_train_en:[br]\r\n"
"                    DQ sample count[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    Receive enable sample count"},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo622_DDR[] = {{"ddrd_n0_train_cnt_result", "", 0x000115F8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields623_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", "Per bit senseamp train result for DDR4 only"},
#else
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", "Per bit odd sampler value for senseamp training. It is used only for DDR5 sampler training stage."},
#else
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", "Per bit even sampler value for senseamp training. It is used for DDR5 sampler and DFE summer VOC training stage"},
#else
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result"},
#else
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo623_DDR[] = {{"ddrd_n0_train_result0", "", 0x000115FC, 4, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields624_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo624_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_0_", "", 0x0001B900, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields625_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo625_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_1_", "", 0x0001B904, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields626_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo626_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_2_", "", 0x0001B908, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields627_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo627_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_3_", "", 0x0001B90C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields628_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo628_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_4_", "", 0x0001B910, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields629_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo629_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_5_", "", 0x0001B914, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields630_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo630_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_6_", "", 0x0001B918, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields631_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "x8_device", "x8 device enable"},
#else
{31, 31, 0x00000000, "RW", "x8_device", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", "This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code (txdq_pie_code3) to DLL.. Default value is 64."},
#else
{21, 27, 0x00000040, "RW", "txdq_pie_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", "This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code (txdq_pie_code2) to DLL.. Default value is 64."},
#else
{14, 20, 0x00000040, "RW", "txdq_pie_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", "This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code (txdq_pie_code1) to DLL.. Default value is 64."},
#else
{7, 13, 0x00000040, "RW", "txdq_pie_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", "This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code (txdq_pie_code0) to DLL.. Default value is 64."},
#else
{0, 6, 0x00000040, "RW", "txdq_pie_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo631_DDR[] = {{"ddrd_n0_txdq_pie_offset_rank_7_", "", 0x0001B91C, 5, 0x00000000FFFFFFFF, 0x0000000008102040}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields632_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo632_DDR[] = {{"ddrd_n0_sa_offset_rank_0_", "", 0x0001B920, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields633_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo633_DDR[] = {{"ddrd_n0_sa_offset_rank_1_", "", 0x0001B924, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields634_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo634_DDR[] = {{"ddrd_n0_sa_offset_rank_2_", "", 0x0001B928, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields635_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo635_DDR[] = {{"ddrd_n0_sa_offset_rank_3_", "", 0x0001B92C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields636_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo636_DDR[] = {{"ddrd_n0_sa_offset_rank_4_", "", 0x0001B930, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields637_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo637_DDR[] = {{"ddrd_n0_sa_offset_rank_5_", "", 0x0001B934, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields638_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo638_DDR[] = {{"ddrd_n0_sa_offset_rank_6_", "", 0x0001B938, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields639_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "rxdqsn_sel", "selects which skewed DQS N for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS N."},
#else
{30, 31, 0x00000000, "RW", "rxdqsn_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000000, "RW", "rxdqsp_sel", "selects which skewed DQS P for post receive enable counter clock in the RX Deskew logic. For proper operation, always pick latest DQS P."},
#else
{28, 29, 0x00000000, "RW", "rxdqsp_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001E, "RW/V", "sa_offset3", "Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset, 60=max -ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001E, "RW/V", "sa_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001E, "RW/V", "sa_offset2", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001E, "RW/V", "sa_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001E, "RW/V", "sa_offset1", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001E, "RW/V", "sa_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW/V", "sa_offset0", "Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset, 60=max +ve offset, 61, 62, 63=not used)[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001E, "RW/V", "sa_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo639_DDR[] = {{"ddrd_n0_sa_offset_rank_7_", "", 0x0001B93C, 6, 0x00000000FFFFFFFF, 0x0000000003C78F1E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields640_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo640_DDR[] = {{"ddrd_n0_dfe_coeff_rank_0_", "", 0x0001B940, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields641_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo641_DDR[] = {{"ddrd_n0_dfe_coeff_rank_1_", "", 0x0001B944, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields642_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo642_DDR[] = {{"ddrd_n0_dfe_coeff_rank_2_", "", 0x0001B948, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields643_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo643_DDR[] = {{"ddrd_n0_dfe_coeff_rank_3_", "", 0x0001B94C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields644_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo644_DDR[] = {{"ddrd_n0_dfe_coeff_rank_4_", "", 0x0001B950, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields645_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo645_DDR[] = {{"ddrd_n0_dfe_coeff_rank_5_", "", 0x0001B954, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields646_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo646_DDR[] = {{"ddrd_n0_dfe_coeff_rank_6_", "", 0x0001B958, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields647_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000008, "RW", "dfe_coeff4", "DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{16, 19, 0x00000008, "RW", "dfe_coeff4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 14, 0x00000008, "RW", "dfe_coeff3", "DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5 mV steps"},
#else
{11, 14, 0x00000008, "RW", "dfe_coeff3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 9, 0x00000006, "RW", "dfe_coeff2", "DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -40mV to +35mV in 5mV steps"},
#else
{6, 9, 0x00000006, "RW", "dfe_coeff2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "dfe_coeff1", "DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]\r\n"
"                    -120mV to +35mV in 5mV steps."},
#else
{0, 4, 0x00000008, "RW", "dfe_coeff1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo647_DDR[] = {{"ddrd_n0_dfe_coeff_rank_7_", "", 0x0001B95C, 4, 0x00000000000FFFFF, 0x0000000000084188}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields648_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", "BIOS must program this DLL lock timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and lock time is 50ns."},
#else
{7, 13, 0x0000003C, "RW", "dll_lock_tmr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", "BIOS must program this DLL  discharge timer based on the analog tuning value and hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz and discharge time is 30ns."},
#else
{0, 5, 0x00000024, "RW", "dll_discharge_tmr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo648_DDR[] = {{"ddrd_n0_dll_ctl0", "", 0x0001B970, 2, 0x0000000000003FFF, 0x0000000000001E24}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields649_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", "Reads back the MRR that the TXRT FSM is waiting on. [br]\r\n"
"                    bit 0: MR46. 1 indicates that the FSM is waiting for this read. [br]\r\n"
"                    bit 1: MR47. 1 indicates that the FSM is waiting for this read."},
#else
{26, 27, 0x00000003, "RO/V", "txrt_mrr_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", "Reads back the TXRT FSM state. [br]\r\n"
"                    0: IDLE [br]\r\n"
"                    1: WAIT_MR [br]\r\n"
"                    2: CALC [br]\r\n"
"                    3: UPDATE"},
#else
{24, 25, 0x00000000, "RO/V", "txrt_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", "Set to 1 by HW to indicate MR46 rank did not match MR47 rank when txrt_update or spid_update_req/ack occurs. [br]\r\n"
"                    SW must clear this bit to 0 when enable HW calibration."},
#else
{23, 23, 0x00000000, "RW/1C/V", "txrt_rank_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW/V", "txrt_update", "Set to 1 to apply the calculation results to txrt_init_picode or txrt_dq_dly_adj. HW will clear this bit once it is applied. [br]\r\n"
"                    HW does not require the spid_update_req/ack handshake to apply the results if this CSR is used. [br]\r\n"
"                    SW needs to guarantee that there are no CAP errors, and there is no write traffic to the targeted rank before setting this bit."},
#else
{22, 22, 0x00000000, "RW/V", "txrt_update", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", "This is the last TX retraining Ring Oscillator count value captured by HW. HW only capture the rank sepcify in txrt_debug_rank."},
#else
{8, 21, 0x00000000, "RO/V", "txrt_ro_count", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 7, 0x00000000, "RW", "txrt_debug_rank", "Select which rank of RO count value to capture in txrt_ro_count for debug."},
#else
{5, 7, 0x00000000, "RW", "txrt_debug_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "txrt_init", "Set to 1 to indicate this is the 1st retraining to initialize the txrt_init_picode. HW will not calculate and apply the txrt_dq_dly_adj."},
#else
{4, 4, 0x00000000, "RW", "txrt_init", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "txrt_dur", "TX retraining duration. SW must programs the same TCK duration value as progammed in the memory device.[br]\r\n"
"                    001: 128 x 16 TCK[br]\r\n"
"                    010: 256 x 16 TCK[br]\r\n"
"                    100: 512 x 16 TCK[br]\r\n"
"                    others: Reserved"},
#else
{0, 2, 0x00000001, "RW", "txrt_dur", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo649_DDR[] = {{"ddrd_n0_tx_retrain0", "", 0x0001B974, 8, 0x000000000FFFFFFF, 0x000000000C000001}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields650_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_odd_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_odd_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_odd_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", "Rx Odd Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_odd_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo650_DDR[] = {{"ddrd_n0_sampler_odd_offset", "", 0x0001B978, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields651_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{21, 26, 0x0000001F, "RW/V", "sampler_even_offset3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{14, 19, 0x0000001F, "RW/V", "sampler_even_offset2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{7, 12, 0x0000001F, "RW/V", "sampler_even_offset1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", "Rx Even Sampler Offset Control.[br]\r\n"
"                    Normal operation (dfe_coeff_training_en=0): -155mV to +155mV in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]\r\n"
"                    Extended range (dfe_coeff_training_en=1): -620mV to +620mV in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br]\r\n"
"                    Real range may be smaller due to limited signal swing & common-mode.[br]\r\n"
"                    This value is added with sampler_offset_adj to allow BIOS for margining sweep (Signed number. The Range is -32 to 31).[br] \r\n"
"                    Note: BIOS must make sure the sampler_offset_adj value doesn't cause an overflow or underflow.[br]\r\n"
"                    This field can be programmed by BIOS or HW cal FSM."},
#else
{0, 5, 0x0000001F, "RW/V", "sampler_even_offset0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo651_DDR[] = {{"ddrd_n0_sampler_even_offset", "", 0x0001B97C, 4, 0x0000000007FFFFFF, 0x0000000003E7CF9F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields652_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x0000003F, "RW", "vref_ctl3", "Per bit Rx Vref Control for DQ3. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{21, 27, 0x0000003F, "RW", "vref_ctl3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x0000003F, "RW", "vref_ctl2", "Per bit Rx Vref Control for DQ2. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{14, 20, 0x0000003F, "RW", "vref_ctl2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x0000003F, "RW", "vref_ctl1", "Per bit Rx Vref Control for DQ1. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{7, 13, 0x0000003F, "RW", "vref_ctl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW", "vref_ctl0", "Per bit Rx Vref Control for DQ0. This value is added with vref_adj to allow BIOS for margining sweep (Signed number. The Range is -64 to 63). The final result is sent to vref CBB. [br]\r\n"
"                    Note: The vref CBB control input is 8-bit. The MSB (Bit 8 is tie to 1). It means the default value is 75% of vccddr_hv[br]\r\n"
"                    Note: BIOS must make sure the vref_adj value doens't cause an overflow or underflow. "},
#else
{0, 6, 0x0000003F, "RW", "vref_ctl0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo652_DDR[] = {{"ddrd_n0_rxvref_ctl", "", 0x0001B980, 5, 0x00000000FFFFFFFF, 0x0000000007EFDFBF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields653_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", "Data Rcomp Odt-Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{21, 25, 0x00000008, "RW/V", "rcomp_odt_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", "Data Rcomp OdtUp Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_odt_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{14, 18, 0x00000008, "RW/V", "rcomp_odt_up", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", "Data Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_dn_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{7, 11, 0x00000008, "RW/V", "rcomp_drv_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", "Data Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]\r\n"
"                    This value is added with rcomp_drv_up_adj (signed number. Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{0, 4, 0x00000008, "RW/V", "rcomp_drv_up", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo653_DDR[] = {{"ddrd_n0_comp_la0", "", 0x0001B984, 4, 0x0000000003FFFFFF, 0x0000000001020408}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields654_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", "Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated by DDRCOMP fub and broadcast to all the data fub. The adjust range is -64 to 63."},
#else
{14, 20, 0x00000000, "RO/V", "rxrt_dqs_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW", "scomp", "Data Slew Rate Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    [br]\r\n"
"                    0 is fastest slew rate, 31 is slowest slew rate.[br]\r\n"
"                    The SCOMP Up/Down Code are generated from the following equation:[br]\r\n"
"                    SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]\r\n"
"                    SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]\r\n"
"                    Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br]\r\n"
"                    Note: HW checks for overflow and underflow condition."},
#else
{8, 12, 0x00000000, "RW", "scomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "tco_comp", "Data TCO Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]\r\n"
"                    0/64: fastest rise & fall delay[br]\r\n"
"                    0->31: increasing fall delay[br]\r\n"
"                    64->95: increasing rise delay[br]\r\n"
"                    Other values are not used (32-63 & 96-127).[br]\r\n"
"                    To get monotonic increasing sweep of dutycycle, sweep from (95 to 65, 0 to 31)"},
#else
{0, 6, 0x00000000, "RW", "tco_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo654_DDR[] = {{"ddrd_n0_comp_la1", "", 0x0001B988, 3, 0x00000000001FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields655_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "scomp_dn_adj", "Signed number add to scomp to generate the SCOMP Down Code. The adjust range is -8 to 7."},
#else
{25, 28, 0x00000000, "RW", "scomp_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "scomp_up_adj", "Signed number add to scomp to generate the SCOMP Up Code. The adjust range is -8 to 7."},
#else
{20, 23, 0x00000000, "RW", "scomp_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", "Signed number add to rcomp_odt_dn to generate the RCOMP ODT down code. The adjust range is -8 to 7"},
#else
{15, 18, 0x00000000, "RW", "rcomp_odt_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", "Signed number add to rcomp_odt_up to generate the RCOMP ODT up code. The adjust range is -8 to 7"},
#else
{10, 13, 0x00000000, "RW", "rcomp_odt_up_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", "Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust range is -8 to 7."},
#else
{5, 8, 0x00000000, "RW", "rcomp_drv_dn_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", "Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust range is -8 to 7."},
#else
{0, 3, 0x00000000, "RW", "rcomp_drv_up_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo655_DDR[] = {{"ddrd_n0_comp_offset", "", 0x0001B98C, 6, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields656_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", "Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable clock gating."},
#else
{31, 31, 0x00000000, "RW", "vsshi_dclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", "Double the timer for LDO/VSSHI settle time. Use for failsafe in case settle time was underestimated.[br]\r\n"
"                    0: 8K+1K=9K Dclk cycles[br]\r\n"
"                    1: 16K+2K=18K Dclk cycles[br]\r\n"
"                    Doubles the LDO/VSSHI settle time counter in case hard-coded value is not adequate"},
#else
{30, 30, 0x00000000, "RW", "vsshi_ldo_tmr_ext", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "ldo_close_loop", "Operate LDO in close loop mode"},
#else
{29, 29, 0x00000000, "RW", "ldo_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", "LDO Cap Trim Loop"},
#else
{25, 28, 0x00000000, "RW", "ldo_captrim_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 24, 0x00000018, "RW", "ldo_codetarget", "Sets the LDO reference voltage when ldo_vref_sel_ddra=0.[br]\r\n"
"                    Range is (vccddr_hv/2 to vccddr_hv), with step size of vccddr_hv/256.[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 1 inside LDO. Only the lower 7-bit is controlled by this field."},
#else
{18, 24, 0x00000018, "RW", "ldo_codetarget", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", "LDO RC Filter Trim"},
#else
{15, 17, 0x00000000, "RW", "ldo_rcfilter_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", "LDO driver strength based on process variation. Bit 1 is unused. Bit 0 used for LDO Driver Strength[br]\r\n"
"                    This field should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                    (Fast) 3'd3: 0x0[br]\r\n"
"                    (Typ) 3'd1,3'd2: 0x0[br]\r\n"
"                    (Slow) 3'd0: 0x1[br]"},
#else
{13, 14, 0x00000000, "RW", "ldo_bw_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", "Use vccddra as LDO vref "},
#else
{12, 12, 0x00000000, "RW", "ldo_vref_sel_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", "LDO output is bypassed to VCCDDRA"},
#else
{11, 11, 0x00000000, "RW", "ldo_bypass_ddra", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "vsshi_close_loop", "Operates VssHi in Close loop mode"},
#else
{10, 10, 0x00000000, "RW", "vsshi_close_loop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", "Pull VSSHI to VSS"},
#else
{9, 9, 0x00000000, "RW", "vsshi_pulldown_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", "Vsshi Bias Current trim.[br]\r\n"
"                    The field should be programmed according to analog_tuning field.[br]\r\n"
"                    00: min current (if analog_tuning=3d3, fast skew)[br]\r\n"
"                    01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]\r\n"
"                    11: max current (if analog_tuning=3d0, slow skew)"},
#else
{7, 8, 0x00000002, "RW", "vsshi_bias_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000018, "RW", "vsshi_target_code", "VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]\r\n"
"                    Code should be programmed according to analog_tuning field in dll status register:[br]\r\n"
"                                 DDR5/T2   DDR4/T[br]\r\n"
"                    3'd3:        0x45      0x55[br]\r\n"
"                    3'd1,3'd2:   0x3a      0x4a[br]\r\n"
"                    3'd0:        0x2e      0x40[br]\r\n"
"                    Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI. Only the lower 7-bit is controlled by this field."},
#else
{0, 6, 0x00000018, "RW", "vsshi_target_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo656_DDR[] = {{"ddrd_n0_vsshi_ctl", "", 0x0001B990, 13, 0x00000000FFFFFFFF, 0x0000000000600118}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields657_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 24, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 24, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo657_DDR[] = {{"ddrd_n0_dll_pi_test_adc", "", 0x0001B994, 7, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields658_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dll_en", "BIOS must enable DLL when program the IO freq range."},
#else
{31, 31, 0x00000000, "RW", "dll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 29, 0x00000002, "RW", "iofreq_range", "BIOS program this IO Frequency range field based on PLL freq. It is half of the DRAM transfer rate.[br]\r\n"
"                    For example DDR 4800. The PLL freq is 2400.[br]\r\n"
"                    2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]\r\n"
"                    2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]\r\n"
"                    2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]\r\n"
"                    2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)"},
#else
{28, 29, 0x00000002, "RW", "iofreq_range", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "flybyclk_sel", "Bypasses flyby clock and selects H-tree clock when disbled"},
#else
{27, 27, 0x00000001, "RW", "flybyclk_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 23, 0x00000000, "RO/V", "analog_tuning", "BIOS should configure certain analog components based on the value of this register.[br]\r\n"
"                    Details will be found in the description of any CSR that relies on this value"},
#else
{21, 23, 0x00000000, "RO/V", "analog_tuning", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "lockrst_b", "Detect lock CBB lock reset output"},
#else
{20, 20, 0x00000000, "RO/V", "lockrst_b", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "openloop", "MDLL open loop output"},
#else
{19, 19, 0x00000000, "RO/V", "openloop", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "pilags", "DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register, clock gating must be disabled."},
#else
{18, 18, 0x00000000, "RO/V", "pilags", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "adc_done", "DLL ADC done."},
#else
{17, 17, 0x00000000, "RO/V", "adc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "weak_lock", "DLL Weak Lock Status."},
#else
{16, 16, 0x00000000, "RO/V", "weak_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", "Detect lock CBB early lock sticky output"},
#else
{15, 15, 0x00000000, "RO/V", "detlock_earlylockstky", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "long_lock", "DLL Long Lock Status."},
#else
{14, 14, 0x00000000, "RO/V", "long_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 13, 0x00000000, "RO/V", "adcout", "DLL ADC out."},
#else
{4, 13, 0x00000000, "RO/V", "adcout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "dll_reset", "DLL Reset."},
#else
{3, 3, 0x00000000, "RO/V", "dll_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "lock_timeout", "DLL Lock timeout."},
#else
{2, 2, 0x00000000, "RO/V", "lock_timeout", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "raw_lock", "DLL Raw Lock Status Sticky bit."},
#else
{1, 1, 0x00000000, "RO/V", "raw_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "detrm_lock", "DLL Deterministic Lock Status"},
#else
{0, 0, 0x00000000, "RO/V", "detrm_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo658_DDR[] = {{"ddrd_n0_dll_csr", "", 0x0001B998, 16, 0x00000000FFFFFFFF, 0x0000000028000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields659_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", "Sticky error count. Reset by power good reset.[br]\r\n"
"                    Increment when data fub detect rxfifo read and write pointer is out of sync."},
#else
{0, 2, 0x00000000, "RW/1C/V", "rxfifo_ptr_err_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo659_DDR[] = {{"ddrd_n0_rxfifo_ptr_log", "", 0x0001B99C, 1, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields660_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "sampler_offset_adj", "Rx Sampler Offset adjust value. It is added to all sampler_even/odd_offset. It is used by BIOS for sampler offsets margining. The adjust range is -32 to 31. The expected usage model is BIOS broadcast the same value to all the bytes."},
#else
{23, 28, 0x00000000, "RW", "sampler_offset_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "vref_adj", "Signed number with range from -64 to 63. It is used by BIOS for marging sweep. This value is added to the vref_ctrl before sending to the DQ VREF. [br]\r\n"
"                    Note: HW doesn't check for overflow and underflow. BIOS must ensure the adjust value doesn't overflow or underflow the final vref control value."},
#else
{16, 22, 0x00000000, "RW", "vref_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000000, "RW", "txdq_dly_adj", "Tx DQ delay adjust value. It is added to all per bit TXDQ delay. It is used by BIOS for margining sweep. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{8, 15, 0x00000000, "RW", "txdq_dly_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", "Rx DQS delay adjust value. It is added to all per bit RXDQS delay. It is used by BIOS for margining sweep or ACIO HW training. The adjust range is -128 to 127. The expected usage model is BIOS broadcast the same adjust value to all the bytes."},
#else
{0, 7, 0x00000000, "RW", "rxdqs_dly_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo660_DDR[] = {{"ddrd_n0_train_offset0", "", 0x0001B9A0, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields661_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", "This txdqs piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the txdqs_dly[6:0], so the txdqs PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM."},
#else
{21, 27, 0x00000000, "RW/V", "txdqs_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", "This txdq piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the per bit txdq_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{14, 20, 0x00000000, "RW/V", "txdq_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", "This rcven piref offset is added with a signed piref_setup_adj (default value is 63). The result is added to the rcven_dly[6:0], so the txdq PI odd code is relative to the piref clock. This field can be programed by BIOS or HW cal FSM. "},
#else
{7, 13, 0x00000000, "RW/V", "rcven_piref_offset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", "It is the train PI code to align the PIREF clock to the failing edge of DCLK with data propagation delay after xover training. [br]\r\n"
"                    This value is added with a signed piref_setup_adj (default  value is 63) to generate the piref_code to DLL. The xover input is driven from a failing edge of DCLK flop. [br]\r\n"
"                    By moving the piref odd clock to the right by 63 ticks, we will have 63 pi tick of setup margin.[br]\r\n"
"                    This field can be programed by BIOS or HW cal FSM."},
#else
{0, 6, 0x00000000, "RW/V", "piref_train_pi_code", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo661_DDR[] = {{"ddrd_n0_piref_offset0", "", 0x0001B9A4, 4, 0x000000000FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields662_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", "A singed number for piref setup adjust. Range is -64 to 63. [br]\r\n"
"                    The xover input is driven from a inverted DCLK flop. This conrol allows BIOS to adjust the setup time to the input of the xover piref odd clock flop. [br]\r\n"
"                    Default value is 63. [br]\r\n"
"                    It means after xover training to align the piref odd clock to the dclk. The piref odd clock is moved to the right by 64 ticks, and we will have 64 pi tick of setup margin. [br]\r\n"
"                    HW will add this value to all the pi codes before send to DLL."},
#else
{0, 6, 0x0000003F, "RW/V", "piref_setup_adj", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo662_DDR[] = {{"ddrd_n0_piref_offset1", "", 0x0001B9A8, 1, 0x000000000000007F, 0x000000000000003F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields663_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 31, 0x00000000, "RW", "rx_preamble_type", "This field is used by rxdeskew logic to determine preamble pattern type.[br]\r\n"
"                    0: 1 tclk - 10 Pattern (MSB is the 1st UI)[br]\r\n"
"                    1: 2 tclk - 0010 Pattern[br]\r\n"
"                    2: 2 tclk - 1110 Pattern [br]\r\n"
"                    3: 3 tclk - 000010 Pattern[br]\r\n"
"                    4: 4 tclk - 00001010 Pattern[br]\r\n"
"                    Others : Reserved"},
#else
{29, 31, 0x00000000, "RW", "rx_preamble_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "rx_postamble_len", "RX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is toggle)"},
#else
{28, 28, 0x00000000, "RW", "rx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "ctle_en", "CTLE enable"},
#else
{27, 27, 0x00000000, "RW", "ctle_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", "Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1. [br]\r\n"
"                    Default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{22, 26, 0x0000001F, "RW", "odt_static_leg_cfg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", "00  1.5x (default for CMD/CLK)[br]\r\n"
"                    01  2x[br]\r\n"
"                    10 - 2.5x (default for DQ)[br]\r\n"
"                    11  3x"},
#else
{15, 16, 0x00000001, "RW", "rxbias_rxgain_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", "Rx summer output common mode control[br]\r\n"
"                    0: 0.25*vccddra[br]\r\n"
"                    1: 0.3*vccddra (default)[br]\r\n"
"                    2: 0.35*vccddra[br]\r\n"
"                    3: 0.4*vccddra"},
#else
{12, 13, 0x00000001, "RW", "rxbias_vcm_ctl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", "Repurposed for force local receiver bias on for DQbuf.[br]\r\n"
"                    When set to 1, it will keep the local bias mirror always enabled.[br]\r\n"
"                    When set to 0, local bias gets enabled with senseamp_enable."},
#else
{11, 11, 0x00000000, "RW", "rxgainfuse_ovrd", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", "Amplifier control.  The bits in this field control: [br]\r\n"
"                    2:1 - is used to adjust the bias current for the 2nd stage amplifier in the DQS amplifier path. 0=min, 3=max. [br]\r\n"
"                    0 - is used to force local receiver bias to on.  Otherwise, local receiver bias is enabled through senseamp enable."},
#else
{7, 9, 0x00000000, "RW", "pbias_stg2amp_trim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "odt_seg_en", "Control number of ODT segment enable for DQ and DQS. ODT rotation is applied before sending the control to CBB. The rotation is used to ensure the segment is evenly burn. Rotation is happened when odten is deasserted. [br]\r\n"
"                    Note: Setting this field to 0x3 means enable all segments and rotation has no meaning."},
#else
{0, 1, 0x00000003, "RW", "odt_seg_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo663_DDR[] = {{"ddrd_n0_rx_ctl0", "", 0x0001B9AC, 9, 0x00000000FFFFFFFF, 0x0000000007C09003}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields664_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "bwextend", "Negative cap BW extension"},
#else
{30, 31, 0x00000000, "RW", "bwextend", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "loadtrim", "Rload trimming in rx decoder"},
#else
{29, 29, 0x00000000, "RW", "loadtrim", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", "Set to 1 to enable HW reset RXFIFO Pointer when there is no outstanding read in DDRIO."},
#else
{28, 28, 0x00000000, "RW", "hw_rxfifo_ptr_rst_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "sdl_gating_en", "Set to 1 to enable gating of delay elements in SDL. Default is disable gating.\r\n"
"                    Note : gating must be disabled during any training steps. BIOS can enable gating for power saving after all the training steps are done."},
#else
{27, 27, 0x00000000, "RW", "sdl_gating_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "sdl_max_picode", "After training , this max value of picode is used for \r\n"
"                    enabling appropriate number of delay cells in SDL for power saving . It should be programmed with the max sdl picode from the nibble"},
#else
{24, 26, 0x00000000, "RW", "sdl_max_picode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", "Set to 0 by default to enable all the devices in the current source legs across all skews.[br]\r\n"
"                    Set to 1 to reduce number of current sources for any sensitivity issues during post silicon testing."},
#else
{13, 13, 0x00000000, "RW", "rx_sampler_tailtune", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", "When set, the VCDL is removed from the DQ path from Amp to samplers[br]\r\n"
"                    When cleared, the DQ passes from Amp to VCDL and then to samplers"},
#else
{12, 12, 0x00000000, "RW", "byp_vcdl_fwd_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", "When set the feedback data is muxed into the VCDL[br]\r\n"
"                    When cleared the DQ data from Amp is muxed into the VCDL"},
#else
{11, 11, 0x00000000, "RW", "set_vcdl_fdbk_path", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "dfe_en", "Enable DFE in DQ. Also it is used in RXBIASANA."},
#else
{10, 10, 0x00000000, "RW", "dfe_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", "Extend DDR4 RxDFE serializer pulse width.[br]\r\n"
"                    Set to 1 to extend the pulse width of the pulsed clocks to the DDR4 RxDFE serializers.[br]\r\n"
"                    Value of 1 seems to work across PVT. May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{9, 9, 0x00000000, "RW", "ext_rx_pulse_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", "Rx Sampler offset enable. Also enables the RDAC for the sampler offset correction. Needs to be 1 for DDR5/DDRT2."},
#else
{8, 8, 0x00000001, "RW", "rx_sampler_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RW", "sdll_en", "Controls if the slave DLL is enabled in the Deskew logic."},
#else
{7, 7, 0x00000001, "RW", "sdll_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "rx_offset_en", "enable the offset control in DQ/DQS RxAmp and RX BIAS."},
#else
{6, 6, 0x00000001, "RW", "rx_offset_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", "strobe Rx Amp offset control in DQS RxAmp"},
#else
{0, 5, 0x0000001E, "RW", "rx_dqs_sa_offset", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo664_DDR[] = {{"ddrd_n0_rx_ctl1", "", 0x0001B9B0, 14, 0x00000000FFFFFFFF, 0x00000000000001DE}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields665_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", "0 -DQBUF and DQSBUF bypass SCOMP and TCO delay in the transmitter. "},
#else
{31, 31, 0x00000001, "RW", "scomp_tco_bypass_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", "Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]\r\n"
"                    No need skew based settings, value of 1 seems to work across PVT.[br]\r\n"
"                    May need to set to 0 for slow silicon if we see issues in post silicon."},
#else
{30, 30, 0x00000000, "RW", "tx_serializer_pwradj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 28, 0x00000000, "RW", "imode_eq_code", "Imode coefficient, sets Imode current.[br]\r\n"
"                    Sweep values: (0-15, 40-42, 48-63) for a linear increase of current from 0 to max."},
#else
{23, 28, 0x00000000, "RW", "imode_eq_code", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000001, "RW", "eq_post2_sel", "2nd tap selection:[br]\r\n"
"                    0  txeq_2nd_tap used for 2nd post cursor tap[br]\r\n"
"                    1  txeq_2nd_tap used for extending range of 1st tap."},
#else
{21, 21, 0x00000001, "RW", "eq_post2_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "eq_post2_sign", "2nd tap equalization sign bit[br]\r\n"
"                    0 +ve equalization[br]\r\n"
"                    1: -ve equalization"},
#else
{19, 19, 0x00000000, "RW", "eq_post2_sign", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "imode_en", "Enable Imode EQ per byte lane. [br]\r\n"
"                    0: Imode completely off [br]\r\n"
"                    1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg"},
#else
{17, 17, 0x00000000, "RW", "imode_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000003, "RW", "data_seg_en", "Control number of data sement enable for DQ and DQS."},
#else
{6, 7, 0x00000003, "RW", "data_seg_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", "Sets number of DQ/DQS driver (Ron) static legs.[br]\r\n"
"                    First 3 MSB bits has weight of 4, 4th MSB has weight of 2 and LSB bit has weight of 1.[br]\r\n"
"                    RTL default of 0x1F has 15 static legs enabled.[br]\r\n"
"                    Static leg training starts with 0x1F (all 15 legs enabled)"},
#else
{0, 4, 0x0000001F, "RW", "drv_static_leg_cfg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo665_DDR[] = {{"ddrd_n0_tx_ctl0", "", 0x0001B9B8, 8, 0x00000000FFFFFFFF, 0x00000000802000DF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields666_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_postamble_len", "TX Postamble Length.[br]\r\n"
"                    0: 0.5 TCK Postamble (default case)[br]\r\n"
"                    1: 1.5 TCK Postamble  (the extra 1 TCK pattern is always differentially low)"},
#else
{16, 16, 0x00000000, "RW", "tx_postamble_len", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 11, 0x00000001, "RW", "tx_preamble_pat", "Programmable Preamble pattern. Each bit represents a UI of the preamble pattern starting at LSB for 1st UI.[br]\r\n"
"                    Note: For DDR5 write leveling training, which require to mask off the preamble strobe, BIOS can program the pattern to all 0's.[br]\r\n"
"                    [br]\r\n"
"                    Legal value is listed below. [br]\r\n"
"                    DDR4-[br]\r\n"
"                    1 TCK: 8'bXXXX_XX01[br]\r\n"
"                    2 TCK: 8'bXXXX_0111 (Long Preamble)[br]\r\n"
"                    DDR5-[br]\r\n"
"                    2 TCK: 8'XXXX_0100[br]\r\n"
"                    3 TCK: 8'bXX01_0000 or 8'bXX01_0100[br]\r\n"
"                    4 TCK: 8'b0101_0000"},
#else
{4, 11, 0x00000001, "RW", "tx_preamble_pat", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "tx_preamble_len", "TX Preenable Length. [br]\r\n"
"                    Legal programming value for [br] \r\n"
"                    DDR4: 1-2 TCK [br]\r\n"
"                    DDR5: 2-4 TCK"},
#else
{0, 2, 0x00000001, "RW", "tx_preamble_len", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo666_DDR[] = {{"ddrd_n0_tx_ctl1", "", 0x0001B9BC, 3, 0x000000000001FFFF, 0x0000000000000011}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields667_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "pxc_en", "Phase base cross talk cancellaton enable"},
#else
{31, 31, 0x00000000, "RW", "pxc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "ddjc_en", "DDJC enable"},
#else
{30, 30, 0x00000000, "RW", "ddjc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "pxc_coupling_type", "Select PXC is inductive or capacitive coupling cross talk dominant type[br]\r\n"
"                    0: capacitive coupling. If victim and attacker data have the same transition phase, the xtalk delta is added; otherwise (oppsite transition phase) the xtalk delta is subtracted.[br]\r\n"
"                    1: inductive coupling. If victim and attacker data have the same transition phase, the xtalk delta is subtracted ; otherwise (oppsite transition phase) the xtalk delta is added."},
#else
{29, 29, 0x00000000, "RW", "pxc_coupling_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{13, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{12, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "attacker_sel3", "Select which bit within a byte is the attacker for dq3 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{9, 11, 0x00000000, "RW", "attacker_sel3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW", "attacker_sel2", "Select which bit within a byte is the attacker for dq2 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{6, 8, 0x00000000, "RW", "attacker_sel2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "attacker_sel1", "Select which bit within a byte is the attacker for dq1 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{3, 5, 0x00000000, "RW", "attacker_sel1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "attacker_sel0", "Select which bit within a byte is the attacker for dq0 in this nibble. [br]\r\n"
"                    Note: Attacker can be from the other nibble inside a byte.  BIOS must not set the attacker to itself."},
#else
{0, 2, 0x00000000, "RW", "attacker_sel0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo667_DDR[] = {{"ddrd_n0_pxc_ctl0", "", 0x0001B9C4, 9, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields668_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", "VOC RX pass gate enable for VOC training and NTL testing."},
#else
{31, 31, 0x00000000, "RW", "rx_voc_pass_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", "Disable using rcvenpost early to control the rx rank switch latch.[br]\r\n"
"                    If this bit is set to 1, minimum Rd-Rd TR time will need to increase by 1."},
#else
{13, 13, 0x00000000, "RW", "dis_rcvenpost_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{9, 12, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{8, 8, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for rx rank switching"},
#else
{7, 7, 0x00000000, "RW", "rx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", "A value of 1 add extra 1 cycle of hold time for tx rank switching"},
#else
{6, 6, 0x00000000, "RW", "tx_rank_chg_hold_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", "0 - No Vref power saving in CKE power down. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in CKE power down regardless the setting of dq_vref_en."},
#else
{5, 5, 0x00000000, "RW", "ckepd_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sr_vref_dis", "0 - No Vref power saving in Self Refresh. All DQ Vref generators is enabled by dq_vref_en.[br]\r\n"
"                    1 - DQ Vref generators are switched off while in Self Refresh regardless the setting of dq_vref_en."},
#else
{4, 4, 0x00000000, "RW", "sr_vref_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo668_DDR[] = {{"ddrd_n0_dfx_ctl0", "", 0x0001B9C8, 11, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields669_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "vreftrack_en", "Vref Track enable"},
#else
{31, 31, 0x00000001, "RW", "vreftrack_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", "Code for Vref Cap to gnd. 0=min, 15=max. Sweep codes 0-7,11-15"},
#else
{5, 8, 0x0000000F, "RW", "vref_cntrl_cn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", "Code for Vref Cap to supply. 0=min, 15=max. Sweep codes 0-15."},
#else
{0, 3, 0x0000000F, "RW", "vref_cntrl_cp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo669_DDR[] = {{"ddrd_n0_vref_track_ctl", "", 0x0001B9CC, 3, 0x00000000FFFFFFFF, 0x00000000800001EF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields670_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW/V", "hw_cal_en", "Set to 1 to enable HW calibration. They are five HW calibration stages that SW can request HW to perform. It is defined in bit 0 to 4 in this register. [br]\r\n"
"                    HW will self clear this bit when all the enabled calibration stages are completed. [br]\r\n"
"                    For BIOS training, XOVER, sampler offset, and DFE summer offset training can be enabled by SW.[br] \r\n"
"                    For ACIO testing, all 5 stages can be enabled by SW."},
#else
{31, 31, 0x00000000, "RW/V", "hw_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 29, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 28, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", "Set to 1 by HW to indicate dfe summer offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{27, 27, 0x00000000, "RW/1C/V", "dfe_summer_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", "Set to 1 by HW to indicate odd sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{26, 26, 0x00000000, "RW/1C/V", "odd_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", "Set to 1 by HW to indicate even sampler offset training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{25, 25, 0x00000000, "RW/1C/V", "even_sampler_offset_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/1C/V", "xover_err", "Set to 1 by HW to indicate xover training is failed. SW must clear this bit to 0 when enable HW calibration."},
#else
{24, 24, 0x00000000, "RW/1C/V", "xover_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{19, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 18, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 15, 0x00000008, "RW", "sample_thresh", "Sample threshold value for voting logic."},
#else
{10, 15, 0x00000008, "RW", "sample_thresh", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "sample_cnt", "Number of Sample to evaluate for each iteration step. It applied for all training stages. [br]\r\n"
"                    0: 16[br]\r\n"
"                    1: 32[br]\r\n"
"                    2: 64[br]\r\n"
"                    3: 2 (Should only used to speed up digitial simulation)"},
#else
{8, 9, 0x00000000, "RW", "sample_cnt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "settling_time_x2", "Set to 1  to double the analog settling time. [br]\r\n"
"                    The default settling time for each stage are [br]\r\n"
"                    Xover : 32 Dclk for 1st, 24 Dclk for subsequent [br]\r\n"
"                    Sampler offset : 528 Dclk for 1st time; 144 Dlck for subsequent steps [br]\r\n"
"                    DFE summer offset : 24 Dclk [br]\r\n"
"                    Rcven fine/coarse : 16 Dclk / 8 Dclk [br]\r\n"
"                    Dqdqs fine / coarse : 16 Dclk / 8 Dclk"},
#else
{7, 7, 0x00000000, "RW", "settling_time_x2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", "Set to 1 to enable DFE summer offset training stage for all DQ bits.[br]\r\n"
"                    Note: the training result is applied to all ranks. BIOS will adjust later for all ranks setting based on eye centering."},
#else
{2, 2, 0x00000000, "RW", "dfe_summer_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", "Set to 1 to enable even/odd sampler training stage for all DQ bits.[br]\r\n"
"                    Note: The result is only logged to the sampler even/odd offset register when both even and odd training are done."},
#else
{1, 1, 0x00000000, "RW", "sampler_offset_stage_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "xover_stage_en", "Set to 1 to enable xover training stage"},
#else
{0, 0, 0x00000000, "RW", "xover_stage_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo670_DDR[] = {{"ddrd_n0_hw_train_ctl0", "", 0x0001B9D0, 17, 0x00000000FFFFFFFF, 0x0000000000042000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields671_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo671_DDR[] = {{"ddrd_n0_hwcal_sweep_result0", "", 0x0001B9D8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields672_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 31, 0x00000000, "RO/V", "hwcal_sweep_result1", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo672_DDR[] = {{"ddrd_n0_hwcal_sweep_result1", "", 0x0001B9DC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields673_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", "The sweep result 0-2 register is used for debug to observe the full sweep result for rcven or dqdqs fine training, so both stages can't be enabled at the same time. For DQDQS training, it only valid if one DQ bit is enabled.[br]\r\n"
"                    Note : we log every other step only. (0-143 step, only even number of step is logged)"},
#else
{0, 7, 0x00000000, "RO/V", "hwcal_sweep_result2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo673_DDR[] = {{"ddrd_n0_hwcal_sweep_result2", "", 0x0001B9E0, 1, 0x00000000000000FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields674_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dqs_sa_dur", "Control how long the DQS Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dqs_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dqs_sa_dly", "Logic delay to turn on DQS Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dqs_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dqs_odt_dur", "Control how long the DQS ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dqs_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dqs_odt_dly", "Logic delay to turn on DQS ODT base on receive enable signal. Unit is DLCK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dqs_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo674_DDR[] = {{"ddrd_n0_train_ctl0", "", 0x0001B9E4, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields675_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "dq_vref_en", "Vref generator Enable. Set to 1 to enable all DQ bits vref.[br]\r\n"
"                    Note: The self refresh VREF disable control (sr_vref_dis) can disable vref during DIMM in self refresh.[br]\r\n"
"                    To force VREF on all the time in SPR, user must program sr_vref_dis to 0 and ckepd_vref_dis to 0. [br]\r\n"
"                    Note: Unlike wave 1 design, ForceBiasOn doesn't force verf enable anymore."},
#else
{31, 31, 0x00000001, "RW", "dq_vref_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "force_strong_odt_on", "Force Strong DQS/DQ ODT on. when set, it always enable one segement for ODT regardless of the state of drive enable.[br]\r\n"
"                    The intend use case is for ACIO with burnin."},
#else
{30, 30, 0x00000000, "RW", "force_strong_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "force_sa_on", "Force Senseamp on. Use for overclocking support where we may not be able to hit the fast exit latency."},
#else
{29, 29, 0x00000000, "RW", "force_sa_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_rxbias_on", "Force Rx bias circuit on.[br]\r\n"
"                    Note: In SPR setting this bit to 1 doesnt force vref on. To force vref on, user must set dq_vref_en to 1 and sr_vref_dis to 0."},
#else
{28, 28, 0x00000001, "RW", "force_rxbias_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "force_odt_on", "Force Weak DQS/DQ ODT on. It is used before ODT enable window is trained and program by BIOS. [br]\r\n"
"                    The weak ODT is ignored when drive enable is asserted. [br]\r\n"
"                    Note: For ACIO, ODT is provided by different DDR channel. "},
#else
{27, 27, 0x00000001, "RW", "force_odt_on", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{24, 26, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{23, 23, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{22, 22, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "train_clk_gate_en", "Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training logics). Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{21, 21, 0x00000000, "RW", "train_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", "Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{20, 20, 0x00000000, "RW", "rx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", "Set to 1 to enable HW to gate TX CLK for transmit path logics. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{19, 19, 0x00000000, "RW", "tx_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", "Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{18, 18, 0x00000000, "RW", "piref_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", "Set to 1 to enable HW to gate RX PI CLK for receive path logics. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{17, 17, 0x00000000, "RW", "rx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", "Set to 1 to enable HW to gate TX PI CLK for transmit path logic. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{16, 16, 0x00000000, "RW", "tx_piclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "bclk_gate_en", "Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power saving."},
#else
{15, 15, 0x00000000, "RW", "bclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", "Set to 1 to enable HW to gate effective register update CLK for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{14, 14, 0x00000000, "RW", "compeff_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", "Set to 1 to enable HW to gate tx retraining logic for power saving. Default is disable clock gating.[br] \r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{13, 13, 0x00000000, "RW", "txrt_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR4/DDR-T. 0 inidate it is operating in DDR5/DDR-T2.[br]\r\n"
"                    Fub use this bit to determine the training level different between DDR4 vs DDR5."},
#else
{12, 12, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "nibble_dis", "BIOS can disable a nibble within a byte. This can be used to disable 1 nibble of the ECC for 9x4 DIMM support.[br]\r\n"
"                    The entire ECC byte can also be disabled for DIMMs that doesn't support ECC.  In DDR4, the unused byte can be disabled as well."},
#else
{11, 11, 0x00000000, "RW", "nibble_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "elr_dimm", "Set this bit to 1 for DDR5 ELR DIMM type"},
#else
{10, 10, 0x00000000, "RW", "elr_dimm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", "Should be set only during DFE coefficient initial training (pulse response). Increases sampler offset range by 2X."},
#else
{9, 9, 0x00000000, "RW", "dfe_coeff_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", "Used for odd sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{8, 8, 0x00000000, "RW", "odd_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", "Used for even sampler offset calibration mode. Shorts inputs of samplers to Vcm"},
#else
{7, 7, 0x00000000, "RW", "even_sampler_offset_cal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "vref_highz", "Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal."},
#else
{6, 6, 0x00000000, "RW", "vref_highz", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "xover_cal", "Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform Xover calibraton training. [br]\r\n"
"                    - enable all the DCLK And PI clocks. (may remove clock gating function)"},
#else
{5, 5, 0x00000000, "RW", "xover_cal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rd_level_train_type", "0 : Front side[br]\r\n"
"                    1: Back side (DDR5 LRDIMM / 3D Xpoint DIMM)[br]\r\n"
"                    [br]\r\n"
"                    When rd_level_train_type is set to 1 and rd_level_train_en is set to 1, the training counter increments based on the sampling of DQ with the rising edge of rcven (DB sends feedback to host through DQ pins, DB samples MDQS with its internal rcven signal). [br]\r\n"
"                    When rd_level_train_type is set to 0 and rd_level_train_en is set to 1,  the training counter increments based on the sampling of DQS with the rising edge of rcven."},
#else
{3, 3, 0x00000000, "RW", "rd_level_train_type", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "rd_level_train_en", "Enables Read Leveling Training Mode. Read Leveling training step is the same for DDR4 and DDR5.[br]\r\n"
"                    Note: all clock gate enable must 0 during Read Level training mode."},
#else
{2, 2, 0x00000000, "RW", "rd_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "wr_level_train_en", "Enables Write Leveling Training Mode. Write Leveling training is not the same for both DDR4 and DDR5. BIOS must set the ddr4 control bit to indicate write leveling for DDR4 or DDR5.[br]\r\n"
"                    For DDR5, when set, the strobes have their transmitter enable, while the DQ signals have their receivers enabled. The Received value from the DQ signals is sampled and stored in the training result register. This is a continously sampled valued.[br]\r\n"
"                    Note: all clock gate enable must 0 during Write Level training mode."},
#else
{1, 1, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", "Enables the Command Training Counter mode (DQ receivers, ODT needs to be enabled separately before setting this bit), resets the sample counter and starts the counting of the samples. One of these per nibble that is used for feedback (i.e. all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with broadcast). The value of this field remains at 1 until after the Counting Window expires, then returns to 0. Can be polled to determine when the counting has completed. When the Counting Window field is set to 0, this field will not return to 0. In that case, this field must be set to 0 to disable.[br]\r\n"
"                    When the CS Assertion Trigger Enable is set, the counting window start is delayed until the first CS Assertion event  but this delay only applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters."},
#else
{0, 0, 0x00000000, "RW/V", "cmd_train_ctr_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo675_DDR[] = {{"ddrd_n0_train_ctl1", "", 0x0001B9E8, 29, 0x00000000FFFFFFFF, 0x0000000098000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields676_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", "Select which xover phase detect output for calibration. For each nibble, we have 8 xover per DLL piref."},
#else
{28, 30, 0x00000000, "RW", "xover_cal_mux_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "unsampled_path_en", "The unsampled path is automatically enabled in DDR4, but not for DDR5.  In DDR5, set this bit to 0x1 during write level, and cmd training (DQ feedback is used)."},
#else
{21, 21, 0x00000000, "RW", "unsampled_path_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "sampler_feedback_en", "Enables feedback from DQ SAL for any DDR5 training modes, requiring feedback from DQ lanes."},
#else
{20, 20, 0x00000000, "RW", "sampler_feedback_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "dq_sample_mask", "Mask off any DQ bits not considered in the OR computation for the command training counting."},
#else
{16, 19, 0x00000000, "RW", "dq_sample_mask", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "sample_sel", "Determines if the command training counter will count 1 or 0.[br]\r\n"
"                    0: count 1[br]\r\n"
"                    1: count 0"},
#else
{15, 15, 0x00000000, "RW", "sample_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "dq_ovr_en", "This setting enables the over-ride operation associated with the DQ Value Override setting.[br]\r\n"
"                    Note: Once this bit is set, it turns on the TX driver and drives the dq_value_ovr on all DQs pins "},
#else
{14, 14, 0x00000000, "RW", "dq_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 13, 0x00000000, "RW", "dq_value_ovr", "When the DQ Override Enable bit is set, this setting determines the value that is driven by the DQ transmitter at all time. The value is constant over all UIs, but can be set per DQ in the nibble."},
#else
{10, 13, 0x00000000, "RW", "dq_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", "When set, the strobe is driven differentially high, other than when a WRITE strobe sequence is sent to the DRAM. "},
#else
{9, 9, 0x00000000, "RW", "drv_dqs_diff_high", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", "When set, the strobe is driven differentially low, other than when a WRITE strobe sequence is sent to the DRAM"},
#else
{8, 8, 0x00000000, "RW", "drv_dqs_diff_low", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "tx_strobe_mask", "Each bit in the TX strobe mask will mask out the strobe pulse associated with each location in the write burst (i.e. for a BL16 there are 8 strobe pulses (rising/falling combination)). A value of 00000000b will enable all strobes. A value of 1111_1110b will enable a single strobe pulse at the first 2 UIs in the BL. [br]\r\n"
"                    The current use case is for DDR5 write leveling training which only enable the 1st TCK DQS strobe (0xFE)[br]\r\n"
"                    Note: When drv_dqs_diff_high is set, the masked Strobe is driven differentially high. On the other hand, when drv_dqs_diff_low is set, the masked stobe is driven differentially low."},
#else
{0, 7, 0x00000000, "RW", "tx_strobe_mask", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo676_DDR[] = {{"ddrd_n0_train_ctl2", "", 0x0001B9EC, 10, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields677_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 23, 0x00000000, "RW", "dq_sa_dur", "Control how long the DQ Sense Amp stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{19, 23, 0x00000000, "RW", "dq_sa_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW", "dq_sa_dly", "Logic delay to turn on DQ Sense Amp base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{13, 16, 0x00000000, "RW", "dq_sa_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 10, 0x00000000, "RW", "dq_odt_dur", "Control how long the DQ ODT stay on after receive enable signal deasserted in DCLK domain. Unit is DCLK. Range is 0-31."},
#else
{6, 10, 0x00000000, "RW", "dq_odt_dur", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "dq_odt_dly", "Logic delay to turn on DQ ODT base on receive enable signal. Unit is DCLK. Range is 0-12."},
#else
{0, 3, 0x00000000, "RW", "dq_odt_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo677_DDR[] = {{"ddrd_n0_train_ctl3", "", 0x0001B9F0, 4, 0x0000000000FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields678_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "cnt_window", "cmd_train_ctr_en:[br]\r\n"
"                    value that sets the number of DCLK cycles that the DQ samples will be counted. Linear setting. This is broadcast to all bytes  one register per byte. When this field is set to 0 the counter will run until it saturates, or until it the CMD Training Counter Mode field is cleared.[br]\r\n"
"                    wr_level_train_en: [br]\r\n"
"                    control when to increment the coutner after the trigger event (DQS OE)[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    control when to increment the coutner after the sampling event (rising edge of receive enable)"},
#else
{0, 31, 0x00000000, "RW", "cnt_window", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo678_DDR[] = {{"ddrd_n0_train_cnt_window0", "", 0x0001B9F4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields679_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "train_cnt", "cmd_train_ctr_en:[br]\r\n"
"                    Value that indicates the number of logic 1  or 0 values sampled during the Counting Window (based on sample_sel). This is cleared when the CMD Training Counter mode is enabled. This count is the result of the OR of all DQs in the nibble, for those DQs that are not masked off.  Whten the cnt_window is set to 0, the counter will run until it saturates.[br]\r\n"
"                    wr_level_train_en:[br]\r\n"
"                    DQ sample count[br]\r\n"
"                    rd_level_train_en:[br]\r\n"
"                    Receive enable sample count"},
#else
{0, 31, 0x00000000, "RO/V", "train_cnt", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo679_DDR[] = {{"ddrd_n0_train_cnt_result", "", 0x0001B9F8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields680_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", "Per bit senseamp train result for DDR4 only"},
#else
{9, 12, 0x00000000, "RO/V", "sa_ddr4_train_result", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", "Per bit odd sampler value for senseamp training. It is used only for DDR5 sampler training stage."},
#else
{5, 8, 0x00000000, "RO/V", "sa_odd_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", "Per bit even sampler value for senseamp training. It is used for DDR5 sampler and DFE summer VOC training stage"},
#else
{1, 4, 0x00000000, "RO/V", "sa_even_sampler", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", "Xover Calibration Phase Detected Result"},
#else
{0, 0, 0x00000000, "RO/V", "xover_cal_pd_result", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo680_DDR[] = {{"ddrd_n0_train_result0", "", 0x0001B9FC, 4, 0x0000000000001FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields681_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "txclk_gate_en", "Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock gating. "},
#else
{8, 8, 0x00000000, "RW", "txclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "wr_level_train_en", "DDR5: Set to 1 to gate txfifo_wren during write leveling[br]\r\n"
"                    DDR4: Set to 1 to enable INTF to generate a BL8 DQS output enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write leveling.[br]\r\n"
"                    Note: For DDR4, setting any sub-channel control bit will start the write leveling logic in INTF for the entire channel."},
#else
{7, 7, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{4, 6, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{3, 3, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "wr_crc_en", "Enable write crc mode.[br]\r\n"
"                    DDR4: extend BL8 write to BL10.[br]\r\n"
"                    DDR5: extend BL16 write to BL18."},
#else
{2, 2, 0x00000000, "RW", "wr_crc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ch_dis", "Channel Disable[br]\r\n"
"                    - shut off all analog/DCLK/DLL"},
#else
{1, 1, 0x00000000, "RW", "ch_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dclk_gate_en", "Set to 1 to enable HW to gate DCLK. Default is disable clock gating. "},
#else
{0, 0, 0x00000000, "RW", "dclk_gate_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo681_DDR[] = {{"ddrintf_ctl0_ch_0_", "", 0x00013F00, 7, 0x00000000000001FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields682_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "txclk_gate_en", "Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock gating. "},
#else
{8, 8, 0x00000000, "RW", "txclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "wr_level_train_en", "DDR5: Set to 1 to gate txfifo_wren during write leveling[br]\r\n"
"                    DDR4: Set to 1 to enable INTF to generate a BL8 DQS output enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write leveling.[br]\r\n"
"                    Note: For DDR4, setting any sub-channel control bit will start the write leveling logic in INTF for the entire channel."},
#else
{7, 7, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{4, 6, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{3, 3, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "wr_crc_en", "Enable write crc mode.[br]\r\n"
"                    DDR4: extend BL8 write to BL10.[br]\r\n"
"                    DDR5: extend BL16 write to BL18."},
#else
{2, 2, 0x00000000, "RW", "wr_crc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ch_dis", "Channel Disable[br]\r\n"
"                    - shut off all analog/DCLK/DLL"},
#else
{1, 1, 0x00000000, "RW", "ch_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dclk_gate_en", "Set to 1 to enable HW to gate DCLK. Default is disable clock gating. "},
#else
{0, 0, 0x00000000, "RW", "dclk_gate_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo682_DDR[] = {{"ddrintf_ctl0_ch_1_", "", 0x00013F04, 7, 0x00000000000001FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields683_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "txclk_gate_en", "Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock gating. "},
#else
{8, 8, 0x00000000, "RW", "txclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "wr_level_train_en", "DDR5: Set to 1 to gate txfifo_wren during write leveling[br]\r\n"
"                    DDR4: Set to 1 to enable INTF to generate a BL8 DQS output enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write leveling.[br]\r\n"
"                    Note: For DDR4, setting any sub-channel control bit will start the write leveling logic in INTF for the entire channel."},
#else
{7, 7, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{4, 6, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{3, 3, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "wr_crc_en", "Enable write crc mode.[br]\r\n"
"                    DDR4: extend BL8 write to BL10.[br]\r\n"
"                    DDR5: extend BL16 write to BL18."},
#else
{2, 2, 0x00000000, "RW", "wr_crc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ch_dis", "Channel Disable[br]\r\n"
"                    - shut off all analog/DCLK/DLL"},
#else
{1, 1, 0x00000000, "RW", "ch_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dclk_gate_en", "Set to 1 to enable HW to gate DCLK. Default is disable clock gating. "},
#else
{0, 0, 0x00000000, "RW", "dclk_gate_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo683_DDR[] = {{"ddrintf_ctl0_ch_2_", "", 0x00013F08, 7, 0x00000000000001FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields684_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "txclk_gate_en", "Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock gating. "},
#else
{8, 8, 0x00000000, "RW", "txclk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "wr_level_train_en", "DDR5: Set to 1 to gate txfifo_wren during write leveling[br]\r\n"
"                    DDR4: Set to 1 to enable INTF to generate a BL8 DQS output enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write leveling.[br]\r\n"
"                    Note: For DDR4, setting any sub-channel control bit will start the write leveling logic in INTF for the entire channel."},
#else
{7, 7, 0x00000000, "RW", "wr_level_train_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank_value_ovr", "When rank_ovr_en is set, this rank override value is used by HW to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{4, 6, 0x00000000, "RW", "rank_value_ovr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "rank_ovr_en", "When set to 1, HW uses the rank_value_ovr field to select rank parameters instead of rank number from MC. It is used for training step that require to read out rank specific infomration without MC command.[br]\r\n"
"                    Note: The current use case is for DDR4 Write leveling training."},
#else
{3, 3, 0x00000000, "RW", "rank_ovr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "wr_crc_en", "Enable write crc mode.[br]\r\n"
"                    DDR4: extend BL8 write to BL10.[br]\r\n"
"                    DDR5: extend BL16 write to BL18."},
#else
{2, 2, 0x00000000, "RW", "wr_crc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "ch_dis", "Channel Disable[br]\r\n"
"                    - shut off all analog/DCLK/DLL"},
#else
{1, 1, 0x00000000, "RW", "ch_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dclk_gate_en", "Set to 1 to enable HW to gate DCLK. Default is disable clock gating. "},
#else
{0, 0, 0x00000000, "RW", "dclk_gate_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo684_DDR[] = {{"ddrintf_ctl0_ch_3_", "", 0x00013F0C, 7, 0x00000000000001FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields685_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat3", "Roundtrip Latency for rank 3 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat2", "Roundtrip Latency for rank 2 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat1", "Roundtrip Latency for rank 1 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat0", "Roundtrip Latency for rank 0 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo685_DDR[] = {{"ddrintf_rt_lat0_ch_0_", "", 0x00013F10, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields686_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat3", "Roundtrip Latency for rank 3 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat2", "Roundtrip Latency for rank 2 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat1", "Roundtrip Latency for rank 1 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat0", "Roundtrip Latency for rank 0 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo686_DDR[] = {{"ddrintf_rt_lat0_ch_1_", "", 0x00013F14, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields687_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat3", "Roundtrip Latency for rank 3 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat2", "Roundtrip Latency for rank 2 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat1", "Roundtrip Latency for rank 1 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat0", "Roundtrip Latency for rank 0 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo687_DDR[] = {{"ddrintf_rt_lat0_ch_2_", "", 0x00013F18, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields688_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat3", "Roundtrip Latency for rank 3 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat2", "Roundtrip Latency for rank 2 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat1", "Roundtrip Latency for rank 1 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat0", "Roundtrip Latency for rank 0 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo688_DDR[] = {{"ddrintf_rt_lat0_ch_3_", "", 0x00013F1C, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields689_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat7", "Roundtrip Latency for rank 7 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat6", "Roundtrip Latency for rank 6 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat5", "Roundtrip Latency for rank 5 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat4", "Roundtrip Latency for rank 4 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat4", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo689_DDR[] = {{"ddrintf_rt_lat1_ch_0_", "", 0x00013F20, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields690_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat7", "Roundtrip Latency for rank 7 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat6", "Roundtrip Latency for rank 6 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat5", "Roundtrip Latency for rank 5 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat4", "Roundtrip Latency for rank 4 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat4", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo690_DDR[] = {{"ddrintf_rt_lat1_ch_1_", "", 0x00013F24, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields691_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat7", "Roundtrip Latency for rank 7 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat6", "Roundtrip Latency for rank 6 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat5", "Roundtrip Latency for rank 5 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat4", "Roundtrip Latency for rank 4 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat4", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo691_DDR[] = {{"ddrintf_rt_lat1_ch_2_", "", 0x00013F28, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields692_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 30, 0x00000000, "RW", "rt_lat7", "Roundtrip Latency for rank 7 (in DCLKs)"},
#else
{24, 30, 0x00000000, "RW", "rt_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 22, 0x00000000, "RW", "rt_lat6", "Roundtrip Latency for rank 6 (in DCLKs)"},
#else
{16, 22, 0x00000000, "RW", "rt_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 14, 0x00000000, "RW", "rt_lat5", "Roundtrip Latency for rank 5 (in DCLKs)"},
#else
{8, 14, 0x00000000, "RW", "rt_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 6, 0x00000000, "RW", "rt_lat4", "Roundtrip Latency for rank 4 (in DCLKs)"},
#else
{0, 6, 0x00000000, "RW", "rt_lat4", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo692_DDR[] = {{"ddrintf_rt_lat1_ch_3_", "", 0x00013F2C, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields693_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW", "io_lat7", "IO Latency for rank 7 (in DCLKs)"},
#else
{28, 31, 0x00000000, "RW", "io_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RW", "io_lat6", "IO Latency for rank 6 (in DCLKs)"},
#else
{24, 27, 0x00000000, "RW", "io_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "io_lat5", "IO Latency for rank 5 (in DCLKs)"},
#else
{20, 23, 0x00000000, "RW", "io_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "io_lat4", "IO Latency for rank 4 (in DCLKs)"},
#else
{16, 19, 0x00000000, "RW", "io_lat4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "io_lat3", "IO Latency for rank 3 (in DCLKs)"},
#else
{12, 15, 0x00000000, "RW", "io_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "io_lat2", "IO Latency for rank 2 (in DCLKs)"},
#else
{8, 11, 0x00000000, "RW", "io_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "io_lat1", "IO Latency for rank 1 (in DCLKs)"},
#else
{4, 7, 0x00000000, "RW", "io_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "io_lat0", "IO Latency for rank 0 (in DCLKs)"},
#else
{0, 3, 0x00000000, "RW", "io_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo693_DDR[] = {{"ddrintf_io_lat0_ch_0_", "", 0x00013F30, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields694_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW", "io_lat7", "IO Latency for rank 7 (in DCLKs)"},
#else
{28, 31, 0x00000000, "RW", "io_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RW", "io_lat6", "IO Latency for rank 6 (in DCLKs)"},
#else
{24, 27, 0x00000000, "RW", "io_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "io_lat5", "IO Latency for rank 5 (in DCLKs)"},
#else
{20, 23, 0x00000000, "RW", "io_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "io_lat4", "IO Latency for rank 4 (in DCLKs)"},
#else
{16, 19, 0x00000000, "RW", "io_lat4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "io_lat3", "IO Latency for rank 3 (in DCLKs)"},
#else
{12, 15, 0x00000000, "RW", "io_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "io_lat2", "IO Latency for rank 2 (in DCLKs)"},
#else
{8, 11, 0x00000000, "RW", "io_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "io_lat1", "IO Latency for rank 1 (in DCLKs)"},
#else
{4, 7, 0x00000000, "RW", "io_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "io_lat0", "IO Latency for rank 0 (in DCLKs)"},
#else
{0, 3, 0x00000000, "RW", "io_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo694_DDR[] = {{"ddrintf_io_lat0_ch_1_", "", 0x00013F34, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields695_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW", "io_lat7", "IO Latency for rank 7 (in DCLKs)"},
#else
{28, 31, 0x00000000, "RW", "io_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RW", "io_lat6", "IO Latency for rank 6 (in DCLKs)"},
#else
{24, 27, 0x00000000, "RW", "io_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "io_lat5", "IO Latency for rank 5 (in DCLKs)"},
#else
{20, 23, 0x00000000, "RW", "io_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "io_lat4", "IO Latency for rank 4 (in DCLKs)"},
#else
{16, 19, 0x00000000, "RW", "io_lat4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "io_lat3", "IO Latency for rank 3 (in DCLKs)"},
#else
{12, 15, 0x00000000, "RW", "io_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "io_lat2", "IO Latency for rank 2 (in DCLKs)"},
#else
{8, 11, 0x00000000, "RW", "io_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "io_lat1", "IO Latency for rank 1 (in DCLKs)"},
#else
{4, 7, 0x00000000, "RW", "io_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "io_lat0", "IO Latency for rank 0 (in DCLKs)"},
#else
{0, 3, 0x00000000, "RW", "io_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo695_DDR[] = {{"ddrintf_io_lat0_ch_2_", "", 0x00013F38, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields696_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW", "io_lat7", "IO Latency for rank 7 (in DCLKs)"},
#else
{28, 31, 0x00000000, "RW", "io_lat7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RW", "io_lat6", "IO Latency for rank 6 (in DCLKs)"},
#else
{24, 27, 0x00000000, "RW", "io_lat6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "io_lat5", "IO Latency for rank 5 (in DCLKs)"},
#else
{20, 23, 0x00000000, "RW", "io_lat5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "io_lat4", "IO Latency for rank 4 (in DCLKs)"},
#else
{16, 19, 0x00000000, "RW", "io_lat4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "io_lat3", "IO Latency for rank 3 (in DCLKs)"},
#else
{12, 15, 0x00000000, "RW", "io_lat3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "io_lat2", "IO Latency for rank 2 (in DCLKs)"},
#else
{8, 11, 0x00000000, "RW", "io_lat2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "io_lat1", "IO Latency for rank 1 (in DCLKs)"},
#else
{4, 7, 0x00000000, "RW", "io_lat1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "io_lat0", "IO Latency for rank 0 (in DCLKs)"},
#else
{0, 3, 0x00000000, "RW", "io_lat0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo696_DDR[] = {{"ddrintf_io_lat0_ch_3_", "", 0x00013F3C, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields697_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "io_lat_comp", "Number to indicate additional read data IO latency including inside the receiver (in DCLKs)[br]\r\n"
"                    Expected DDR4: 19[br]\r\n"
"                    Expected DDR5: 20"},
#else
{0, 5, 0x00000000, "RW", "io_lat_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo697_DDR[] = {{"ddrintf_io_lat1_ch_0_", "", 0x00013F40, 1, 0x000000000000003F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields698_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "io_lat_comp", "Number to indicate additional read data IO latency including inside the receiver (in DCLKs)[br]\r\n"
"                    Expected DDR4: 19[br]\r\n"
"                    Expected DDR5: 20"},
#else
{0, 5, 0x00000000, "RW", "io_lat_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo698_DDR[] = {{"ddrintf_io_lat1_ch_1_", "", 0x00013F44, 1, 0x000000000000003F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields699_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "io_lat_comp", "Number to indicate additional read data IO latency including inside the receiver (in DCLKs)[br]\r\n"
"                    Expected DDR4: 19[br]\r\n"
"                    Expected DDR5: 20"},
#else
{0, 5, 0x00000000, "RW", "io_lat_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo699_DDR[] = {{"ddrintf_io_lat1_ch_2_", "", 0x00013F48, 1, 0x000000000000003F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields700_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "io_lat_comp", "Number to indicate additional read data IO latency including inside the receiver (in DCLKs)[br]\r\n"
"                    Expected DDR4: 19[br]\r\n"
"                    Expected DDR5: 20"},
#else
{0, 5, 0x00000000, "RW", "io_lat_comp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo700_DDR[] = {{"ddrintf_io_lat1_ch_3_", "", 0x00013F4C, 1, 0x000000000000003F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields701_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", "This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", "This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2 CAS write latency is the sum this value with ddrt_tcwl."},
#else
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "ddrt_tcwl", "Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2 DIMM's t_cwl."},
#else
{16, 21, 0x00000000, "RW", "ddrt_tcwl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", "This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", "This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5 CAS write latency is the sum this value with ddr_tcwl."},
#else
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "ddr_tcwl", "Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's t_cwl."},
#else
{0, 5, 0x00000000, "RW", "ddr_tcwl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo701_DDR[] = {{"ddrintf_data_timing0_ch_0_", "", 0x00013F50, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields702_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", "This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", "This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2 CAS write latency is the sum this value with ddrt_tcwl."},
#else
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "ddrt_tcwl", "Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2 DIMM's t_cwl."},
#else
{16, 21, 0x00000000, "RW", "ddrt_tcwl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", "This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", "This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5 CAS write latency is the sum this value with ddr_tcwl."},
#else
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "ddr_tcwl", "Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's t_cwl."},
#else
{0, 5, 0x00000000, "RW", "ddr_tcwl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo702_DDR[] = {{"ddrintf_data_timing0_ch_1_", "", 0x00013F54, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields703_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", "This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", "This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2 CAS write latency is the sum this value with ddrt_tcwl."},
#else
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "ddrt_tcwl", "Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2 DIMM's t_cwl."},
#else
{16, 21, 0x00000000, "RW", "ddrt_tcwl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", "This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", "This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5 CAS write latency is the sum this value with ddr_tcwl."},
#else
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "ddr_tcwl", "Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's t_cwl."},
#else
{0, 5, 0x00000000, "RW", "ddr_tcwl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo703_DDR[] = {{"ddrintf_data_timing0_ch_2_", "", 0x00013F58, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields704_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", "This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{27, 31, 0x00000000, "RW", "ddrt_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", "This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2 CAS write latency is the sum this value with ddrt_tcwl."},
#else
{23, 26, 0x00000000, "RW", "ddrt_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 21, 0x00000000, "RW", "ddrt_tcwl", "Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2 DIMM's t_cwl."},
#else
{16, 21, 0x00000000, "RW", "ddrt_tcwl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", "This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write leveling and longer preambles length. The adjust range is -16 to 15.[br]\r\n"
"                    DQS adjust = twcl adjust - preamble length"},
#else
{11, 15, 0x00000000, "RW", "ddr_dqs_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", "This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5 CAS write latency is the sum this value with ddr_tcwl."},
#else
{7, 10, 0x00000000, "RW", "ddr_tcwl_adj", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "ddr_tcwl", "Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's t_cwl."},
#else
{0, 5, 0x00000000, "RW", "ddr_tcwl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo704_DDR[] = {{"ddrintf_data_timing0_ch_3_", "", 0x00013F5C, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields705_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "tcwl_para_sel", "Per rank control to indicate which TCWL parameter is slected[br]\r\n"
"                    0: DDR 4 or DDR 5 [br]\r\n"
"                    1: DDR-T or DDR-T2 [br]\r\n"
"                    Used by delay logic to determine which set of timing CSRs to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will never be accessed."},
#else
{24, 31, 0x00000000, "RW", "tcwl_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", "This field controls the number of DCLK cycles that idle_cnt_valid is asserted before the failing edge of rcven. Used by dqsdeskew to account for interamble scenerios. A CR value of 2 is the max support for DDR4[br]\r\n"
"                    0: 1 Dclk before rcven failing edge[br]\r\n"
"                    1: 2 Dclk before rcven failing edge[br]\r\n"
"                    2: 3 Dclk before rcven failing edge[br]\r\n"
"                    3: 4 Dclk before rcven failing edge"},
#else
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "rx_analog_en_early", "This field controls the number of DCLK cycles that rxaen is asserted before rcven. Used to enable sense amp and odt circuits early.[br]\r\n"
"                    Note: Expected program the same value for all sub-ch. Dependent on preable and frequency. Supported range is 0 to 6.[br]\r\n"
"                    DDR4: 0-2 DCLK[br]\r\n"
"                    DDR5: 0-3 DCLK[br]"},
#else
{7, 10, 0x00000000, "RW", "rx_analog_en_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 5, 0x0000000C, "RW", "rddata_valid_early", "This field controls the number of DCLK cycles that the rddata_valid is sent early to MC. Expected program the same value for all sub-ch."},
#else
{1, 5, 0x0000000C, "RW", "rddata_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo705_DDR[] = {{"ddrintf_data_timing1_ch_0_", "", 0x00013F60, 5, 0x00000000FFFFFFFF, 0x0000000000000018}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields706_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "tcwl_para_sel", "Per rank control to indicate which TCWL parameter is slected[br]\r\n"
"                    0: DDR 4 or DDR 5 [br]\r\n"
"                    1: DDR-T or DDR-T2 [br]\r\n"
"                    Used by delay logic to determine which set of timing CSRs to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will never be accessed."},
#else
{24, 31, 0x00000000, "RW", "tcwl_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", "This field controls the number of DCLK cycles that idle_cnt_valid is asserted before the failing edge of rcven. Used by dqsdeskew to account for interamble scenerios. A CR value of 2 is the max support for DDR4[br]\r\n"
"                    0: 1 Dclk before rcven failing edge[br]\r\n"
"                    1: 2 Dclk before rcven failing edge[br]\r\n"
"                    2: 3 Dclk before rcven failing edge[br]\r\n"
"                    3: 4 Dclk before rcven failing edge"},
#else
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "rx_analog_en_early", "This field controls the number of DCLK cycles that rxaen is asserted before rcven. Used to enable sense amp and odt circuits early.[br]\r\n"
"                    Note: Expected program the same value for all sub-ch. Dependent on preable and frequency. Supported range is 0 to 6.[br]\r\n"
"                    DDR4: 0-2 DCLK[br]\r\n"
"                    DDR5: 0-3 DCLK[br]"},
#else
{7, 10, 0x00000000, "RW", "rx_analog_en_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 5, 0x0000000C, "RW", "rddata_valid_early", "This field controls the number of DCLK cycles that the rddata_valid is sent early to MC. Expected program the same value for all sub-ch."},
#else
{1, 5, 0x0000000C, "RW", "rddata_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo706_DDR[] = {{"ddrintf_data_timing1_ch_1_", "", 0x00013F64, 5, 0x00000000FFFFFFFF, 0x0000000000000018}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields707_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "tcwl_para_sel", "Per rank control to indicate which TCWL parameter is slected[br]\r\n"
"                    0: DDR 4 or DDR 5 [br]\r\n"
"                    1: DDR-T or DDR-T2 [br]\r\n"
"                    Used by delay logic to determine which set of timing CSRs to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will never be accessed."},
#else
{24, 31, 0x00000000, "RW", "tcwl_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", "This field controls the number of DCLK cycles that idle_cnt_valid is asserted before the failing edge of rcven. Used by dqsdeskew to account for interamble scenerios. A CR value of 2 is the max support for DDR4[br]\r\n"
"                    0: 1 Dclk before rcven failing edge[br]\r\n"
"                    1: 2 Dclk before rcven failing edge[br]\r\n"
"                    2: 3 Dclk before rcven failing edge[br]\r\n"
"                    3: 4 Dclk before rcven failing edge"},
#else
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "rx_analog_en_early", "This field controls the number of DCLK cycles that rxaen is asserted before rcven. Used to enable sense amp and odt circuits early.[br]\r\n"
"                    Note: Expected program the same value for all sub-ch. Dependent on preable and frequency. Supported range is 0 to 6.[br]\r\n"
"                    DDR4: 0-2 DCLK[br]\r\n"
"                    DDR5: 0-3 DCLK[br]"},
#else
{7, 10, 0x00000000, "RW", "rx_analog_en_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 5, 0x0000000C, "RW", "rddata_valid_early", "This field controls the number of DCLK cycles that the rddata_valid is sent early to MC. Expected program the same value for all sub-ch."},
#else
{1, 5, 0x0000000C, "RW", "rddata_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo707_DDR[] = {{"ddrintf_data_timing1_ch_2_", "", 0x00013F68, 5, 0x00000000FFFFFFFF, 0x0000000000000018}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields708_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "tcwl_para_sel", "Per rank control to indicate which TCWL parameter is slected[br]\r\n"
"                    0: DDR 4 or DDR 5 [br]\r\n"
"                    1: DDR-T or DDR-T2 [br]\r\n"
"                    Used by delay logic to determine which set of timing CSRs to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will never be accessed."},
#else
{24, 31, 0x00000000, "RW", "tcwl_para_sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", "This field controls the number of DCLK cycles that idle_cnt_valid is asserted before the failing edge of rcven. Used by dqsdeskew to account for interamble scenerios. A CR value of 2 is the max support for DDR4[br]\r\n"
"                    0: 1 Dclk before rcven failing edge[br]\r\n"
"                    1: 2 Dclk before rcven failing edge[br]\r\n"
"                    2: 3 Dclk before rcven failing edge[br]\r\n"
"                    3: 4 Dclk before rcven failing edge"},
#else
{12, 13, 0x00000000, "RW", "idle_cnt_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 10, 0x00000000, "RW", "rx_analog_en_early", "This field controls the number of DCLK cycles that rxaen is asserted before rcven. Used to enable sense amp and odt circuits early.[br]\r\n"
"                    Note: Expected program the same value for all sub-ch. Dependent on preable and frequency. Supported range is 0 to 6.[br]\r\n"
"                    DDR4: 0-2 DCLK[br]\r\n"
"                    DDR5: 0-3 DCLK[br]"},
#else
{7, 10, 0x00000000, "RW", "rx_analog_en_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 5, 0x0000000C, "RW", "rddata_valid_early", "This field controls the number of DCLK cycles that the rddata_valid is sent early to MC. Expected program the same value for all sub-ch."},
#else
{1, 5, 0x0000000C, "RW", "rddata_valid_early", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo708_DDR[] = {{"ddrintf_data_timing1_ch_3_", "", 0x00013F6C, 5, 0x00000000FFFFFFFF, 0x0000000000000018}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields709_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "tx_retrain_time", "Specifies the number of Dclk cycles required for TX retraining values to be applied by the Data FUBs. On the spid interface, indicates the amount of time required to wait before acknowledging ispid_phy_update_req.[br]\r\n"
"                    0: 16 Dclks[br]\r\n"
"                    1: 32 Dclks"},
#else
{31, 31, 0x00000000, "RW", "tx_retrain_time", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 30, 0x0000000A, "RW", "comp_upd_quiet_time", "Specifies the number of Dclk cycles that the spid interface needs to be quiet, in order for comp update to finish (see by the farthest Data FUB). On the SPID interface term, it means after MC asserted Quiet Time Grant to DDR, how many DCLK cycles DDR needs to wait to deassert the Quiet Time Request to MC."},
#else
{27, 30, 0x0000000A, "RW", "comp_upd_quiet_time", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "same_cycle_par_en", "0: Send parity 1 dclk cycle after command. Parity for DDR4 RDIMM is always a cycle late. [br]\r\n"
"                    1: Send parity same cycle as commnad. Used for DDR5 RDIMM and for training. DDR4 UDIMM parity needs to be in the same cycle."},
#else
{26, 26, 0x00000000, "RW", "same_cycle_par_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000001, "RW", "pm_wait_comp_finish", "Enable PM FSM to wait for periodic Comp FSM to finish before return a PM ACK back to MC during a low power state transtion sequence."},
#else
{25, 25, 0x00000001, "RW", "pm_wait_comp_finish", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "pm_train_rst_en", "Enable PM state machine to generate train reset when in PM1 and PM2 states."},
#else
{22, 22, 0x00000001, "RW", "pm_train_rst_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW/V", "force_comp_begin", "DDR Initiated CompBegin via auto-clearing CompComplete, allows BIOS to poll this bit for CompComplete indication. Forces Comp Begin to be sent to COMP bypassing the SPID Comp FSM."},
#else
{21, 21, 0x00000000, "RW/V", "force_comp_begin", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW/V", "force_comp_update", "DDR Initiated CompUpdate via auto-clearing CSR write. Forces Comp Update pulse to be sent to all FUBs bypassing the SPID Comp FSM."},
#else
{20, 20, 0x00000000, "RW/V", "force_comp_update", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "ca7_en", "0: 14 CA bits[br]\r\n"
"                    1: 7 CA bits[br]\r\n"
"                    It is used by INTF for MC input muxing."},
#else
{19, 19, 0x00000000, "RW", "ca7_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "ddr4", "For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2. It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br]\r\n"
"                    Setting this bit to 1 indicate it is operating in DDR/DDR-T. [br]\r\n"
"                    0 inidate it is operating in DDR5/DDR-T2. [br]\r\n"
"                    INTF use this information for the MC input muxing."},
#else
{18, 18, 0x00000000, "RW", "ddr4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "elr_dimm", "Set this bit to 1 for DDR5 ELR DIMM"},
#else
{17, 17, 0x00000000, "RW", "elr_dimm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "lane_reversal_en", "Set to 1 to enable data lane reversal to ease board routing."},
#else
{16, 16, 0x00000000, "RW", "lane_reversal_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "lp_sr_dll_off_dis", "Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in HIGH LATENCY SELF REFRESH state."},
#else
{15, 15, 0x00000000, "RW", "lp_sr_dll_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "lp_pd_dll_off_dis", "Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in SLOW CKE POWER DOWN state."},
#else
{14, 14, 0x00000000, "RW", "lp_pd_dll_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "lp_idle_dll_off_dis", "Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in SLOW IDLE state."},
#else
{13, 13, 0x00000000, "RW", "lp_idle_dll_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW/V", "ch1_train_rst", "Channel 1 SW set, HW clear train reset. This train reset is logical ORed with MC CH1 train reset (level). The intend use case is for BIOS to deassert the MC train reset first and then use this train reset for each training step to reduce the number of SW program step"},
#else
{12, 12, 0x00000000, "RW/V", "ch1_train_rst", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW/V", "ch0_train_rst", "Channel 0 SW set, HW clear train reset. This train reset is logical ORed with MC CH0 train reset (level). The intend use case is for BIOS to deassert the MC train reset first and then use this train reset for each training step to reduce the number of SW program step"},
#else
{11, 11, 0x00000000, "RW/V", "ch0_train_rst", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "force_clk_park0", "Force the clock to park 0 (both P/N 0). Normally asserted in PM1 and PM2 state."},
#else
{9, 9, 0x00000000, "RW", "force_clk_park0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "force_cke_pwr_dn", "Force Channel in CKE power down. Normally asserted based on LPMODE"},
#else
{8, 8, 0x00000000, "RW", "force_cke_pwr_dn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "force_sr", "Force Channel in Self Refresh. Normally asserted based on LPMODE"},
#else
{7, 7, 0x00000000, "RW", "force_sr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "csr_clk_gate_en", "Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]\r\n"
"                    Note: Clock gating must be disable during any training steps. BIOS can enable clock gating for power saving after all the training steps are done."},
#else
{6, 6, 0x00000000, "RW", "csr_clk_gate_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "dll_off_dis", "Set to 1 to disable PM FSM to turn off DLL in PM2 state."},
#else
{5, 5, 0x00000000, "RW", "dll_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "ldo_off_dis", "Set to 1 to disable PM FSM to turn off LDO in PM2 state."},
#else
{4, 4, 0x00000000, "RW", "ldo_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "vsshi_off_dis", "Set to 1 to disable PM FSM to turn off VSSHI in PM2 state."},
#else
{3, 3, 0x00000000, "RW", "vsshi_off_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "clk_park0_dis", "Set to 1 to disable PM FSM to park clock to 0 in PM1 and PM2 state."},
#else
{2, 2, 0x00000000, "RW", "clk_park0_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "cke_pwr_dn_dis", "Set to 1 to dsiable SPID LPMODE CKE power down. "},
#else
{1, 1, 0x00000000, "RW", "cke_pwr_dn_dis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "sr_dis", "Set to 1 to dsiable SPID LPMODE self refresh."},
#else
{0, 0, 0x00000000, "RW", "sr_dis", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo709_DDR[] = {{"ddrintf_ctl0", "", 0x00013F80, 26, 0x00000000FFFFFFFF, 0x0000000052400000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields710_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000000, "RW", "pm2to1_pre_dly", "This delay controls how long to wait between receiving PM1 or PM0 request and actually moving PM FSM from PM2 to PM1. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Time to wait before turning on DLL, LDO, and VSSHI."},
#else
{24, 31, 0x00000000, "RW", "pm2to1_pre_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 23, 0x00000000, "RW", "pm1to0_pre_dly", "This delay controls how long to wait between receiving PM0 request and actually moving PM FSM from PM1 to PM0. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note : Time to wait before un-parking DIMM clcok."},
#else
{16, 23, 0x00000000, "RW", "pm1to0_pre_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000000, "RW", "pm1to2_pre_dly", "This delay controls how long to wait between receiving PM2 request and actually moving PM FSM from PM1 to PM2. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Time wait before turning off DLL, LDO, and VSSHI"},
#else
{8, 15, 0x00000000, "RW", "pm1to2_pre_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000000, "RW", "pm0to1_pre_dly", "This delay controls how long to wait between receiving PM1 or PM2 request and actually moving PM FSM from PM0 to PM1. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Time wait before parking DIMM Clock to 0."},
#else
{0, 7, 0x00000000, "RW", "pm0to1_pre_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo710_DDR[] = {{"ddrintf_pm_timing0", "", 0x00013F84, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields711_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000093, "RW", "pm2to1_post_dly", "After trasiton from PM2 to PM1, this delay controls how long to wait for any functions to be turned on in PM1 state and responding with PM ACK to MC (if request was for PM1) or moving to PM0 state (if request was for PM0). This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Analog componenets wait to turn on are DLL, LDO, and VSSHI."},
#else
{24, 31, 0x00000093, "RW", "pm2to1_post_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 23, 0x00000001, "RW", "pm1to0_post_dly", "After trasiton from PM1 to PM0, this delay controls how long to wait for any functions to be turned on in PM0 state and responding with PM ACK to MC. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Time to wait to un-parking DIMM clock."},
#else
{16, 23, 0x00000001, "RW", "pm1to0_post_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 15, 0x00000001, "RW", "pm1to2_post_dly", "After trasiton from PM1 to PM2, this delay controls how long to wait for any functions to be turned off in PM2 state and responding with PM ACK to MC. This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Analog componenets wait to turn off are DLL, LDO, and VSSHI."},
#else
{8, 15, 0x00000001, "RW", "pm1to2_post_dly", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x00000001, "RW", "pm0to1_post_dly", "After trasiton from PM0 to PM1, this delay controls how long to wait for any functions to be turned off in PM1 state and responding with PM ACK to MC (if request was for PM1) or moving to PM2 state (if request was for PM2). This delay value is in units of 64 Dclks.[br]\r\n"
"                    Note: Time to wait to park the DIMM clock to 0."},
#else
{0, 7, 0x00000001, "RW", "pm0to1_post_dly", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo711_DDR[] = {{"ddrintf_pm_timing1", "", 0x00013F88, 4, 0x00000000FFFFFFFF, 0x0000000093010101}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields712_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RO/V", "ch1_lpmode_status", "Channel 1 LPMODE current state:[br]\r\n"
"                    0 - Active (MC sending commands), Unused/No Action[br]\r\n"
"                    1 - Idle (MC not sending commands), Unused/No Action[br]\r\n"
"                    2 - Idle, DLL Off (MC not sending commands)[br]\r\n"
"                    3 - CKE Powerdown (all CKE are low)[br]\r\n"
"                    4 - Unused/Reserved[br]\r\n"
"                    5 - CKE Powerdown, DLL Off (all CKE are low)[br]\r\n"
"                    6 - SelfRefresh (all ranks in SR)[br]\r\n"
"                    7 - SelfRefresh, DLL Off  (all ranks in SR)"},
#else
{16, 18, 0x00000000, "RO/V", "ch1_lpmode_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RO/V", "ch0_lpmode_status", "Channel 0 LPMODE current state:[br]\r\n"
"                    0 - Active (MC sending commands), Unused/No Action[br]\r\n"
"                    1 - Idle (MC not sending commands), Unused/No Action[br]\r\n"
"                    2 - Idle, DLL Off (MC not sending commands)[br]\r\n"
"                    3 - CKE Powerdown (all CKE are low)[br]\r\n"
"                    4 - Unused/Reserved[br]\r\n"
"                    5 - CKE Powerdown, DLL Off (all CKE are low)[br]\r\n"
"                    6 - SelfRefresh (all ranks in SR)[br]\r\n"
"                    7 - SelfRefresh, DLL Off  (all ranks in SR)"},
#else
{12, 14, 0x00000000, "RO/V", "ch0_lpmode_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RO/V", "ch1_update_fsm_status", "Channel 1 Update FSM current state:[br]\r\n"
"                    0 - Idle[br]\r\n"
"                    1 - COMP Begin[br]\r\n"
"                    2 - Bus Quiet Time Request[br]\r\n"
"                    3 - COMP Update[br]\r\n"
"                    4 - TX Retraining"},
#else
{9, 11, 0x00000000, "RO/V", "ch1_update_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RO/V", "ch0_update_fsm_status", "Channel 0 Update FSM current state:[br]\r\n"
"                    0 - Idle[br]\r\n"
"                    1 - COMP Begin[br]\r\n"
"                    2 - Bus Quiet Time Request[br]\r\n"
"                    3 - COMP Update[br]\r\n"
"                    4 - TX Retraining"},
#else
{6, 8, 0x00000000, "RO/V", "ch0_update_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RO/V", "ch1_pm_fsm_status", "Channel 1 PM FSM current state:[br]\r\n"
"                    0 - PM0 Idle[br]\r\n"
"                    1 - PM0 Delay[br]\r\n"
"                    2 - PM1 Delay[br]\r\n"
"                    3 - PM2 Delay[br]\r\n"
"                    4 - PM2 Idle"},
#else
{3, 5, 0x00000000, "RO/V", "ch1_pm_fsm_status", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RO/V", "ch0_pm_fsm_status", "Channel 0 PM FSM current state:[br]\r\n"
"                    0 - PM0 Idle[br]\r\n"
"                    1 - PM0 Delay[br]\r\n"
"                    2 - PM1 Delay[br]\r\n"
"                    3 - PM2 Delay[br]\r\n"
"                    4 - PM2 Idle"},
#else
{0, 2, 0x00000000, "RO/V", "ch0_pm_fsm_status", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo712_DDR[] = {{"ddrintf_status0", "", 0x00013F8C, 6, 0x000000000007FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields713_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo713_DDR[] = {{"DDRIO_BIOS_RAC_LO", "", 0x0001FF00, 1, 0x00000000FFFFFFFF, 0x000000000300021E}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields714_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo714_DDR[] = {{"DDRIO_BIOS_RAC_HI", "", 0x0001FF04, 1, 0x00000000FFFFFFFF, 0x0000000020000500}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields715_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo715_DDR[] = {{"DDRIO_BIOS_WAC_LO", "", 0x0001FF08, 1, 0x00000000FFFFFFFF, 0x000000000100021A}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields716_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo716_DDR[] = {{"DDRIO_BIOS_WAC_HI", "", 0x0001FF0C, 1, 0x00000000FFFFFFFF, 0x0000000020000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields717_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo717_DDR[] = {{"DDRIO_BIOS_CP_LO", "", 0x0001FF10, 1, 0x00000000FFFFFFFF, 0x0000000001000208}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields718_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo718_DDR[] = {{"DDRIO_BIOS_CP_HI", "", 0x0001FF14, 1, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields719_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo719_DDR[] = {{"CrDefeature0_dfx", "", 0x00002000, 2, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields720_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RW", "spare", "spare"},
#else
{0, 15, 0x00000000, "RW", "spare", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo720_DDR[] = {{"CrDefeature1_dfx", "", 0x00002008, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields721_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo721_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_rd_policy_L", "", 0x00002200, 1, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields722_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo722_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_rd_policy_H", "", 0x00002204, 1, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields723_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo723_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_wr_policy_L", "", 0x00002208, 1, 0x00000000FFFFFFFF, 0x000000000100021A}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields724_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo724_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_wr_policy_H", "", 0x0000220C, 1, 0x00000000FFFFFFFF, 0x0000000020000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields725_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo725_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_cr_policy_L", "", 0x00002210, 1, 0x00000000FFFFFFFF, 0x0000000001000208}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields726_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo726_DDR[] = {{"mcdfxmisc_sai_bios_w_pg_cr_policy_H", "", 0x00002214, 1, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields727_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo727_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_rd_policy_L", "", 0x00002218, 1, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields728_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo728_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_rd_policy_H", "", 0x0000221C, 1, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields729_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo729_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_wr_policy_L", "", 0x00002220, 1, 0x00000000FFFFFFFF, 0x000000000100021A}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields730_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo730_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_wr_policy_H", "", 0x00002224, 1, 0x00000000FFFFFFFF, 0x0000000020000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields731_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo731_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_cr_policy_L", "", 0x00002228, 1, 0x00000000FFFFFFFF, 0x0000000001000208}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields732_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo732_DDR[] = {{"mcdfxmisc_sai_cpgc_pg_cr_policy_H", "", 0x0000222C, 1, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields733_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo733_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_rd_policy_L", "", 0x00002230, 1, 0x00000000FFFFFFFF, 0x000000000100020A}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields734_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo734_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_rd_policy_H", "", 0x00002234, 1, 0x00000000FFFFFFFF, 0x0000000020000500}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields735_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo735_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_wr_policy_L", "", 0x00002238, 1, 0x00000000FFFFFFFF, 0x000000000100020A}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields736_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo736_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_wr_policy_H", "", 0x0000223C, 1, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields737_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo737_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_cr_policy_L", "", 0x00002240, 1, 0x00000000FFFFFFFF, 0x0000000001000208}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields738_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo738_DDR[] = {{"mcdfxmisc_sai_p_u_code_pg_cr_policy_H", "", 0x00002244, 1, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields739_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 11, 0x00000000, "RW", "eADR_per_chnl_disable", "One bit per channel indicating whether that channel has eADR actions to do. Value should match the inverted value of NmCaching Cfg 2lm enable of each channel. If the bit is 1 eADR will not be sent to that Channel and aggregation logic will do an Auto Ack."},
#else
{10, 11, 0x00000000, "RW", "eADR_per_chnl_disable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 9, 0x00000000, "RW", "chnl_unpopulated", "Bit 2 of this field is unused in MC. Set a bit of this field to 1 if the corresponding chnl is unpopulated. Bit1 - chnl1, Bit0 - chnl0    Used for identifying unpopulated chnls and overriding Ack during PM aggregation. Per chnl bit value should logically match ~(dimmmtr_0.dimm_pop || dimmmtr_1.dimm_pop || McDdrtCfg.Slot0 || McDdrtCfg.Slot1) "},
#else
{7, 9, 0x00000000, "RW", "chnl_unpopulated", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "chnl_disabled", "Bit 2 of this three bit field is unused in MC. Indicates if the channel has been disabled by BIOS or by fuse, if yes set to 1. Bit1 - chnl1, Bit0 - chnl0 Used for overriding Acks from individual disabled chnls during PM aggregation. Per chnl bit value should match new_imc_fuse_download.chn_disable_mc0 || mcmtr.chn_disable"},
#else
{4, 6, 0x00000000, "RW", "chnl_disabled", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW/V", "first_rcomp_done", "First RCOMP DONE status, does not distinguish the source of the first rcomp trigger"},
#else
{3, 3, 0x00000000, "RW/V", "first_rcomp_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW/V", "rcomp_in_progress", "rcomp in progress"},
#else
{2, 2, 0x00000000, "RW/V", "rcomp_in_progress", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "dis_rcomp", "Disable rcomp"},
#else
{1, 1, 0x00000000, "RW", "dis_rcomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rcomp", "RCOMP start via message channel control for bios.\r\n"
"RCOMP start only triggered when the register bit output is changing from 0 -> 1\r\n"
"MC will not be responsible for clearing this bit. MC already provides feedback to bias\r\n"
"when Rcomp is done via first_rcomp_done bit field."},
#else
{0, 0, 0x00000000, "RW", "rcomp", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo739_DDR[] = {{"rcomp_globalctrl1", "", 0x0000224C, 7, 0x0000000000000FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields740_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000000, "RW", "ddrt_addr_mode", "\r\n"
"        3b per channel vector that should be set for DDRT. \r\n"
"        If this bit is set then \r\n"
"        - Sequencer uses BL4 addressing mode for adddresses to DDRT scheduler \r\n"
"        "},
#else
{15, 17, 0x00000000, "RW", "ddrt_addr_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "multiwr_singlerd_mode", "when set, CPGC writes are allowed multiple credits, but CPGC reads will only use 1 credit."},
#else
{14, 14, 0x00000000, "RW", "multiwr_singlerd_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "cpgc_crdt_wait", "When enabled, CPGC sequencer will wait for all credits to be returned before moving to the next sub-sequence.\r\n"
"Usage of this de-feature bit is\r\n"
"- limited to WAIT states between two sub-sequences.\r\n"
"- limited to when CPGC is using multi-credit scheme."},
#else
{13, 13, 0x00000000, "RW", "cpgc_crdt_wait", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 11, 0x00000000, "RW", "cpgc_credits", "Programmable credits for CPGC Multi Credit Scheme -\r\n"
"6d-zero: Use hardcoded defaults of 6d16\r\n"
"6d-nonzero: Programmable credits for CPGC Multi-credit scheme"},
#else
{6, 11, 0x00000000, "RW", "cpgc_credits", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "use_bl4_col_addr", "Currently Address bits [2:0] of the Column Addr are hard tied to zero, Setting this bit will\r\n"
"enable bit control over Addres bit [2] as well thus enabling BL4 mode full addressing."},
#else
{5, 5, 0x00000000, "RW", "use_bl4_col_addr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "stop_test_on_any_err", "Setting Global_Stop_Test_On_Any_Error to 1 will immediately force a transition to Loopback.Marker after any error on any channels\r\n"
"(indicated by a no zero value in Channel_Error_Status) that also have their Global Control bit set."},
#else
{4, 4, 0x00000000, "RW", "stop_test_on_any_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW/V", "clear_errs", "Setting Global_Clear_Errors to 1 will immediately clear all error status registers (the same effect as asserting assert the Local_Clear_Errors)\r\n"
"on any channels that have their Global Control bit is set.\r\n"
"Global_Clear_Errors will immediately be reset to 0 after all Channels_Err Status Registers are cleared that have their Global Control bit Set"},
#else
{2, 2, 0x00000000, "RW/V", "clear_errs", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/V", "stop_test", "Setting Global_Stop_Test to 1 will force a transition to Loopback.Marker on all channels that have their Global_Control bit set.\r\n"
"Global_Stop_Test will immediately clear to 0 after forcing a transition to Loopback.Marker on all channels that have their Global_Control bit set."},
#else
{1, 1, 0x00000000, "RW/V", "stop_test", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "start_test", "Setting to 1 will immediately initiate a transition to Loopback.Pattern on all channels that have their global_control bit set.\r\n"
"This field is cleared when all channels transition to Loopback.Marker from loopback.Pattern for channels that have their global_control bit set.\r\n"
"If channels are not expected to transition to Loopback.Marker at the same time (because of programming or other differences)\r\n"
"then start_test bit will not clear by itself.\r\n"
"To start the test again, BIOS will need to clear this bit field followed by setting it to 1 again."},
#else
{0, 0, 0x00000000, "RW/V", "start_test", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo740_DDR[] = {{"cpgc_globalctrl", "", 0x00002250, 9, 0x000000000003FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields741_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000001, "RO/V", "channel_test_done_status_2", "Channel_Test_Done_Status_2 corresponds to Channel 2 and is set in Loopback.Marker and cleared in Loopback.Pattern"},
#else
{18, 18, 0x00000001, "RO/V", "channel_test_done_status_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000001, "RO/V", "channel_test_done_status_1", "Channel_Test_Done_Status_1 corresponds to Channel 1 and is set in Loopback.Marker and cleared in Loopback.Pattern"},
#else
{17, 17, 0x00000001, "RO/V", "channel_test_done_status_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RO/V", "channel_test_done_status_0", "Channel_Test_Done_Status_0 corresponds to Channel 0 and is set in Loopback.Marker and cleared in Loopback.Pattern"},
#else
{16, 16, 0x00000001, "RO/V", "channel_test_done_status_0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "channel_err_status_2", "Channel_Error_Status_2 corresponds to Channel 2. When set this indicated Channel 2 has at least one Data (Data_Error_Status) or ECC\r\n"
"(Ecc_Error_Status) error status bit set.\r\n"
"Channel_Error_Status_2 will be cleared when setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) ."},
#else
{2, 2, 0x00000000, "RO/V", "channel_err_status_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "channel_err_status_1", "Channel_Error_Status_1 corresponds to Channel 1. When set this indicated Channel 1 has at least one Data (Data_Error_Status) or ECC\r\n"
"(Ecc_Error_Status) error status bit set.\r\n"
"Channel_Error_Status_1 will be cleared when setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) ."},
#else
{1, 1, 0x00000000, "RO/V", "channel_err_status_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "channel_err_status_0", "Channel_Error_Status_0 corresponds to Channel 0. When set this indicated Channel 0 has at least one Data (Data_Error_Status) or ECC\r\n"
"(Ecc_Error_Status) error status bit set.\r\n"
"Channel_Error_Status_0 will be cleared when setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) ."},
#else
{0, 0, 0x00000000, "RO/V", "channel_err_status_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo741_DDR[] = {{"cpgc_globalerr", "", 0x00002254, 6, 0x000000000007FFFF, 0x0000000000070000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields742_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo742_DDR[] = {{"rcomp_globalctrl0", "", 0x00002258, 3, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields743_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "credit_init_done", "credit_init_done"},
#else
{31, 31, 0x00000000, "RW", "credit_init_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW/V", "req_ism_credits_initialized", "credits initialized"},
#else
{30, 30, 0x00000000, "RW/V", "req_ism_credits_initialized", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW/V", "rsp_ism_credits_initialized", "credits initialized"},
#else
{29, 29, 0x00000000, "RW/V", "rsp_ism_credits_initialized", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_ism_active_from_parent", "force_ism_active_from_parent"},
#else
{28, 28, 0x00000001, "RW", "force_ism_active_from_parent", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "cmi_trace_enable", "CMI tracing enabled"},
#else
{15, 15, 0x00000000, "RW", "cmi_trace_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 14, 0x00000012, "RW", "rd_cpl_fab_credits", "rd_cpl_fab_credits"},
#else
{10, 14, 0x00000012, "RW", "rd_cpl_fab_credits", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x0000000C, "RW", "rsp_fab_credits", "rsp_fab_credits"},
#else
{5, 9, 0x0000000C, "RW", "rsp_fab_credits", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000007, "RW", "req_fab_credits", "req_fab_credits"},
#else
{0, 4, 0x00000007, "RW", "req_fab_credits", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo743_DDR[] = {{"mcmisc_cmi_credit_config_0_", "", 0x00002260, 8, 0x00000000FFFFFFFF, 0x0000000010004987}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields744_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "credit_init_done", "credit_init_done"},
#else
{31, 31, 0x00000000, "RW", "credit_init_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW/V", "req_ism_credits_initialized", "credits initialized"},
#else
{30, 30, 0x00000000, "RW/V", "req_ism_credits_initialized", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW/V", "rsp_ism_credits_initialized", "credits initialized"},
#else
{29, 29, 0x00000000, "RW/V", "rsp_ism_credits_initialized", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "force_ism_active_from_parent", "force_ism_active_from_parent"},
#else
{28, 28, 0x00000001, "RW", "force_ism_active_from_parent", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "cmi_trace_enable", "CMI tracing enabled"},
#else
{15, 15, 0x00000000, "RW", "cmi_trace_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 14, 0x00000012, "RW", "rd_cpl_fab_credits", "rd_cpl_fab_credits"},
#else
{10, 14, 0x00000012, "RW", "rd_cpl_fab_credits", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 9, 0x0000000C, "RW", "rsp_fab_credits", "rsp_fab_credits"},
#else
{5, 9, 0x0000000C, "RW", "rsp_fab_credits", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000007, "RW", "req_fab_credits", "req_fab_credits"},
#else
{0, 4, 0x00000007, "RW", "req_fab_credits", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo744_DDR[] = {{"mcmisc_cmi_credit_config_1_", "", 0x00002264, 8, 0x00000000FFFFFFFF, 0x0000000010004987}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields745_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000002, "RW", "mcchan_rsp_stall_delay_seed", "MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{30, 31, 0x00000002, "RW", "mcchan_rsp_stall_delay_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 29, 0x000002AA, "RW", "mcchan_rsp_stall_assert_seed", "MCCHAN response stall assert LFSR seed.  Must have at least one bit set in active width."},
#else
{20, 29, 0x000002AA, "RW", "mcchan_rsp_stall_assert_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 19, 0x000002AA, "RW", "scf_req_stall_delay_seed", "SCF request stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{10, 19, 0x000002AA, "RW", "scf_req_stall_delay_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 9, 0x000002AA, "RW", "scf_req_stall_assert_seed", "SCF request stall assert LFSR seed.  Must have at least one bit set in active width."},
#else
{0, 9, 0x000002AA, "RW", "scf_req_stall_assert_seed", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo745_DDR[] = {{"mcmisc_cmi_stall_config_0__L", "", 0x00002270, 4, 0x00000000FFFFFFFF, 0x00000000AAAAAAAA}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields746_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "reg_vld", "Valid to load register fields"},
#else
{31, 31, 0x00000000, "RW", "reg_vld", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "mcchan_rsp_stall_enable", "Bit to enable random mcchan rsp stall injection"},
#else
{30, 30, 0x00000000, "RW", "mcchan_rsp_stall_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "scf_req_stall_enable", "Bit to enable random scf req stall injection"},
#else
{29, 29, 0x00000000, "RW", "scf_req_stall_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "stall_for_stop_req", "Stall outgoing CMI traffic when mcchan asserts stop request"},
#else
{24, 24, 0x00000000, "RW", "stall_for_stop_req", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x0000000A, "RW", "mcchan_rsp_stall_delay_reg_width", "Width for mcchan response delay LFSR"},
#else
{20, 23, 0x0000000A, "RW", "mcchan_rsp_stall_delay_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x0000000A, "RW", "mcchan_rsp_stall_assert_reg_width", "Width for mcchan response assert LFSR"},
#else
{16, 19, 0x0000000A, "RW", "mcchan_rsp_stall_assert_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x0000000A, "RW", "scf_req_stall_delay_reg_width", "Width for scf request delay LFSR"},
#else
{12, 15, 0x0000000A, "RW", "scf_req_stall_delay_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x0000000A, "RW", "scf_req_stall_assert_reg_width", "Width for scf request assert LFSR"},
#else
{8, 11, 0x0000000A, "RW", "scf_req_stall_assert_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000AA, "RW", "mcchan_rsp_stall_delay_seed", "MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{0, 7, 0x000000AA, "RW", "mcchan_rsp_stall_delay_seed", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo746_DDR[] = {{"mcmisc_cmi_stall_config_0__H", "", 0x00002274, 9, 0x00000000FFFFFFFF, 0x0000000000AAAAAA}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields747_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000002, "RW", "mcchan_rsp_stall_delay_seed", "MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{30, 31, 0x00000002, "RW", "mcchan_rsp_stall_delay_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 29, 0x000002AA, "RW", "mcchan_rsp_stall_assert_seed", "MCCHAN response stall assert LFSR seed.  Must have at least one bit set in active width."},
#else
{20, 29, 0x000002AA, "RW", "mcchan_rsp_stall_assert_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 19, 0x000002AA, "RW", "scf_req_stall_delay_seed", "SCF request stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{10, 19, 0x000002AA, "RW", "scf_req_stall_delay_seed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 9, 0x000002AA, "RW", "scf_req_stall_assert_seed", "SCF request stall assert LFSR seed.  Must have at least one bit set in active width."},
#else
{0, 9, 0x000002AA, "RW", "scf_req_stall_assert_seed", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo747_DDR[] = {{"mcmisc_cmi_stall_config_1__L", "", 0x00002278, 4, 0x00000000FFFFFFFF, 0x00000000AAAAAAAA}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields748_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "reg_vld", "Valid to load register fields"},
#else
{31, 31, 0x00000000, "RW", "reg_vld", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "mcchan_rsp_stall_enable", "Bit to enable random mcchan rsp stall injection"},
#else
{30, 30, 0x00000000, "RW", "mcchan_rsp_stall_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "scf_req_stall_enable", "Bit to enable random scf req stall injection"},
#else
{29, 29, 0x00000000, "RW", "scf_req_stall_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "stall_for_stop_req", "Stall outgoing CMI traffic when mcchan asserts stop request"},
#else
{24, 24, 0x00000000, "RW", "stall_for_stop_req", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x0000000A, "RW", "mcchan_rsp_stall_delay_reg_width", "Width for mcchan response delay LFSR"},
#else
{20, 23, 0x0000000A, "RW", "mcchan_rsp_stall_delay_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x0000000A, "RW", "mcchan_rsp_stall_assert_reg_width", "Width for mcchan response assert LFSR"},
#else
{16, 19, 0x0000000A, "RW", "mcchan_rsp_stall_assert_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x0000000A, "RW", "scf_req_stall_delay_reg_width", "Width for scf request delay LFSR"},
#else
{12, 15, 0x0000000A, "RW", "scf_req_stall_delay_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x0000000A, "RW", "scf_req_stall_assert_reg_width", "Width for scf request assert LFSR"},
#else
{8, 11, 0x0000000A, "RW", "scf_req_stall_assert_reg_width", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 7, 0x000000AA, "RW", "mcchan_rsp_stall_delay_seed", "MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active width."},
#else
{0, 7, 0x000000AA, "RW", "mcchan_rsp_stall_delay_seed", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo748_DDR[] = {{"mcmisc_cmi_stall_config_1__H", "", 0x0000227C, 9, 0x00000000FFFFFFFF, 0x0000000000AAAAAA}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields749_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo749_DDR[] = {{"pmon_free_run_cntr_rd_L", "", 0x00002290, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields750_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo750_DDR[] = {{"pmon_free_run_cntr_rd_H", "", 0x00002294, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields751_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo751_DDR[] = {{"pmon_free_run_cntr_wr_L", "", 0x00002298, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields752_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo752_DDR[] = {{"pmon_free_run_cntr_wr_H", "", 0x0000229C, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields753_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo753_DDR[] = {{"pmon_free_run_cntr_rd_ddrt_L", "", 0x000022A0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields754_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo754_DDR[] = {{"pmon_free_run_cntr_rd_ddrt_H", "", 0x000022A4, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields755_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo755_DDR[] = {{"pmon_free_run_cntr_wr_ddrt_L", "", 0x000022A8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields756_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo756_DDR[] = {{"pmon_free_run_cntr_wr_ddrt_H", "", 0x000022AC, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields757_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo757_DDR[] = {{"pmon_free_run_cntr_dclk_L", "", 0x000022B0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields758_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo758_DDR[] = {{"pmon_free_run_cntr_dclk_H", "", 0x000022B4, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields759_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "OS_W_SAI_POL_31", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000001, "RW", "OS_W_SAI_POL_31", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000001, "RW", "OS_W_SAI_POL_30", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000001, "RW", "OS_W_SAI_POL_30", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_29", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_29", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "OS_W_SAI_POL_28", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000001, "RW", "OS_W_SAI_POL_28", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "OS_W_SAI_POL_27", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000001, "RW", "OS_W_SAI_POL_27", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000001, "RW", "OS_W_SAI_POL_26", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000001, "RW", "OS_W_SAI_POL_26", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_25", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_25", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000001, "RO", "OS_W_SAI_POL_24", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000001, "RO", "OS_W_SAI_POL_24", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000001, "RW", "OS_W_SAI_POL_23", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000001, "RW", "OS_W_SAI_POL_23", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "OS_W_SAI_POL_22", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000001, "RW", "OS_W_SAI_POL_22", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000001, "RW", "OS_W_SAI_POL_21", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000001, "RW", "OS_W_SAI_POL_21", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000001, "RW", "OS_W_SAI_POL_20", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000001, "RW", "OS_W_SAI_POL_20", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "OS_W_SAI_POL_19", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000001, "RW", "OS_W_SAI_POL_19", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000001, "RW", "OS_W_SAI_POL_18", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000001, "RW", "OS_W_SAI_POL_18", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000001, "RW", "OS_W_SAI_POL_17", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000001, "RW", "OS_W_SAI_POL_17", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "OS_W_SAI_POL_16", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000001, "RW", "OS_W_SAI_POL_16", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "OS_W_SAI_POL_15", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000001, "RW", "OS_W_SAI_POL_15", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000001, "RW", "OS_W_SAI_POL_14", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000001, "RW", "OS_W_SAI_POL_14", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000001, "RW", "OS_W_SAI_POL_13", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000001, "RW", "OS_W_SAI_POL_13", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000001, "RW", "OS_W_SAI_POL_12", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000001, "RW", "OS_W_SAI_POL_12", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_11", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_11", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000001, "RW", "OS_W_SAI_POL_10", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000001, "RW", "OS_W_SAI_POL_10", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RO", "OS_W_SAI_POL_9", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000001, "RO", "OS_W_SAI_POL_9", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW", "OS_W_SAI_POL_8", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000001, "RW", "OS_W_SAI_POL_8", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RW", "OS_W_SAI_POL_7", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000001, "RW", "OS_W_SAI_POL_7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "OS_W_SAI_POL_6", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000001, "RW", "OS_W_SAI_POL_6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000001, "RW", "OS_W_SAI_POL_5", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000001, "RW", "OS_W_SAI_POL_5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_4", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RO", "OS_W_SAI_POL_3", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000001, "RO", "OS_W_SAI_POL_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_2", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RO", "OS_W_SAI_POL_1", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000001, "RO", "OS_W_SAI_POL_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_0", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo759_DDR[] = {{"mcdfxmisc_sai_os_w_pg_rd_policy_L", "", 0x000022B8, 32, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields760_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "OS_W_SAI_POL_63", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000001, "RW", "OS_W_SAI_POL_63", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000001, "RW", "OS_W_SAI_POL_62", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000001, "RW", "OS_W_SAI_POL_62", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_61", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_61", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000001, "RW", "OS_W_SAI_POL_60", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000001, "RW", "OS_W_SAI_POL_60", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000001, "RW", "OS_W_SAI_POL_59", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000001, "RW", "OS_W_SAI_POL_59", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000001, "RW", "OS_W_SAI_POL_58", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000001, "RW", "OS_W_SAI_POL_58", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_57", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_57", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000001, "RW", "OS_W_SAI_POL_56", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000001, "RW", "OS_W_SAI_POL_56", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000001, "RW", "OS_W_SAI_POL_55", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000001, "RW", "OS_W_SAI_POL_55", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "OS_W_SAI_POL_54", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000001, "RW", "OS_W_SAI_POL_54", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000001, "RW", "OS_W_SAI_POL_53", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000001, "RW", "OS_W_SAI_POL_53", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000001, "RW", "OS_W_SAI_POL_52", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000001, "RW", "OS_W_SAI_POL_52", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "OS_W_SAI_POL_51", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000001, "RW", "OS_W_SAI_POL_51", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000001, "RW", "OS_W_SAI_POL_50", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000001, "RW", "OS_W_SAI_POL_50", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000001, "RW", "OS_W_SAI_POL_49", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000001, "RW", "OS_W_SAI_POL_49", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "OS_W_SAI_POL_48", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000001, "RW", "OS_W_SAI_POL_48", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW", "OS_W_SAI_POL_47", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000001, "RW", "OS_W_SAI_POL_47", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000001, "RW", "OS_W_SAI_POL_46", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000001, "RW", "OS_W_SAI_POL_46", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000001, "RW", "OS_W_SAI_POL_45", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000001, "RW", "OS_W_SAI_POL_45", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000001, "RW", "OS_W_SAI_POL_44", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000001, "RW", "OS_W_SAI_POL_44", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_43", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_43", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000001, "RO", "OS_W_SAI_POL_42", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000001, "RO", "OS_W_SAI_POL_42", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RW", "OS_W_SAI_POL_41", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000001, "RW", "OS_W_SAI_POL_41", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW", "OS_W_SAI_POL_40", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000001, "RW", "OS_W_SAI_POL_40", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RW", "OS_W_SAI_POL_39", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000001, "RW", "OS_W_SAI_POL_39", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RW", "OS_W_SAI_POL_38", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000001, "RW", "OS_W_SAI_POL_38", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000001, "RW", "OS_W_SAI_POL_37", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000001, "RW", "OS_W_SAI_POL_37", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_36", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_36", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RW", "OS_W_SAI_POL_35", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000001, "RW", "OS_W_SAI_POL_35", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_34", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_34", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RW", "OS_W_SAI_POL_33", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000001, "RW", "OS_W_SAI_POL_33", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_32", "Bit-vector used to determine which agents are allowed read access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_32", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo760_DDR[] = {{"mcdfxmisc_sai_os_w_pg_rd_policy_H", "", 0x000022BC, 32, 0x00000000FFFFFFFF, 0x00000000FFFFFFFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields761_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "OS_W_SAI_POL_31", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000000, "RW", "OS_W_SAI_POL_31", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "OS_W_SAI_POL_30", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000000, "RW", "OS_W_SAI_POL_30", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "OS_W_SAI_POL_29", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000000, "RW", "OS_W_SAI_POL_29", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "OS_W_SAI_POL_28", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000000, "RW", "OS_W_SAI_POL_28", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "OS_W_SAI_POL_27", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000000, "RW", "OS_W_SAI_POL_27", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "OS_W_SAI_POL_26", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000000, "RW", "OS_W_SAI_POL_26", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_25", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000001, "RW", "OS_W_SAI_POL_25", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000001, "RO", "OS_W_SAI_POL_24", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000001, "RO", "OS_W_SAI_POL_24", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "OS_W_SAI_POL_23", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000000, "RW", "OS_W_SAI_POL_23", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "OS_W_SAI_POL_22", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000000, "RW", "OS_W_SAI_POL_22", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "OS_W_SAI_POL_21", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000000, "RW", "OS_W_SAI_POL_21", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "OS_W_SAI_POL_20", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000000, "RW", "OS_W_SAI_POL_20", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "OS_W_SAI_POL_19", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000000, "RW", "OS_W_SAI_POL_19", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "OS_W_SAI_POL_18", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000000, "RW", "OS_W_SAI_POL_18", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "OS_W_SAI_POL_17", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000000, "RW", "OS_W_SAI_POL_17", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "OS_W_SAI_POL_16", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000000, "RW", "OS_W_SAI_POL_16", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "OS_W_SAI_POL_15", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000000, "RW", "OS_W_SAI_POL_15", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "OS_W_SAI_POL_14", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000000, "RW", "OS_W_SAI_POL_14", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "OS_W_SAI_POL_13", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000000, "RW", "OS_W_SAI_POL_13", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "OS_W_SAI_POL_12", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000000, "RW", "OS_W_SAI_POL_12", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "OS_W_SAI_POL_11", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000000, "RW", "OS_W_SAI_POL_11", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "OS_W_SAI_POL_10", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000000, "RW", "OS_W_SAI_POL_10", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RO", "OS_W_SAI_POL_9", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000001, "RO", "OS_W_SAI_POL_9", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "OS_W_SAI_POL_8", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000000, "RW", "OS_W_SAI_POL_8", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "OS_W_SAI_POL_7", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000000, "RW", "OS_W_SAI_POL_7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "OS_W_SAI_POL_6", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000000, "RW", "OS_W_SAI_POL_6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "OS_W_SAI_POL_5", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000000, "RW", "OS_W_SAI_POL_5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_4", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000001, "RW", "OS_W_SAI_POL_4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RO", "OS_W_SAI_POL_3", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000001, "RO", "OS_W_SAI_POL_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_2", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000001, "RW", "OS_W_SAI_POL_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RO", "OS_W_SAI_POL_1", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000001, "RO", "OS_W_SAI_POL_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_0", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000001, "RW", "OS_W_SAI_POL_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo761_DDR[] = {{"mcdfxmisc_sai_os_w_pg_wr_policy_L", "", 0x000022C0, 32, 0x00000000FFFFFFFF, 0x000000000300021F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields762_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "OS_W_SAI_POL_63", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000000, "RW", "OS_W_SAI_POL_63", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "OS_W_SAI_POL_62", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000000, "RW", "OS_W_SAI_POL_62", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_61", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000001, "RW", "OS_W_SAI_POL_61", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "OS_W_SAI_POL_60", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000000, "RW", "OS_W_SAI_POL_60", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "OS_W_SAI_POL_59", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000000, "RW", "OS_W_SAI_POL_59", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "OS_W_SAI_POL_58", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000000, "RW", "OS_W_SAI_POL_58", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "OS_W_SAI_POL_57", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000000, "RW", "OS_W_SAI_POL_57", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "OS_W_SAI_POL_56", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000000, "RW", "OS_W_SAI_POL_56", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "OS_W_SAI_POL_55", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000000, "RW", "OS_W_SAI_POL_55", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "OS_W_SAI_POL_54", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000000, "RW", "OS_W_SAI_POL_54", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "OS_W_SAI_POL_53", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000000, "RW", "OS_W_SAI_POL_53", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "OS_W_SAI_POL_52", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000000, "RW", "OS_W_SAI_POL_52", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "OS_W_SAI_POL_51", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000000, "RW", "OS_W_SAI_POL_51", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "OS_W_SAI_POL_50", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000000, "RW", "OS_W_SAI_POL_50", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "OS_W_SAI_POL_49", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000000, "RW", "OS_W_SAI_POL_49", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "OS_W_SAI_POL_48", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000000, "RW", "OS_W_SAI_POL_48", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "OS_W_SAI_POL_47", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000000, "RW", "OS_W_SAI_POL_47", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "OS_W_SAI_POL_46", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000000, "RW", "OS_W_SAI_POL_46", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "OS_W_SAI_POL_45", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000000, "RW", "OS_W_SAI_POL_45", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "OS_W_SAI_POL_44", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000000, "RW", "OS_W_SAI_POL_44", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_43", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000001, "RW", "OS_W_SAI_POL_43", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000001, "RO", "OS_W_SAI_POL_42", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000001, "RO", "OS_W_SAI_POL_42", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "OS_W_SAI_POL_41", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000000, "RW", "OS_W_SAI_POL_41", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "OS_W_SAI_POL_40", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000000, "RW", "OS_W_SAI_POL_40", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "OS_W_SAI_POL_39", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000000, "RW", "OS_W_SAI_POL_39", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "OS_W_SAI_POL_38", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000000, "RW", "OS_W_SAI_POL_38", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "OS_W_SAI_POL_37", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000000, "RW", "OS_W_SAI_POL_37", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "OS_W_SAI_POL_36", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000000, "RW", "OS_W_SAI_POL_36", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "OS_W_SAI_POL_35", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000000, "RW", "OS_W_SAI_POL_35", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "OS_W_SAI_POL_34", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000000, "RW", "OS_W_SAI_POL_34", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "OS_W_SAI_POL_33", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000000, "RW", "OS_W_SAI_POL_33", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "OS_W_SAI_POL_32", "Bit-vector used to determine which agents are allowed write access to registers in OS_W policy group, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000000, "RW", "OS_W_SAI_POL_32", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo762_DDR[] = {{"mcdfxmisc_sai_os_w_pg_wr_policy_H", "", 0x000022C4, 32, 0x00000000FFFFFFFF, 0x0000000020000C00}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields763_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "OS_W_CTRL_POL_31", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000000, "RW", "OS_W_CTRL_POL_31", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "OS_W_CTRL_POL_30", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000000, "RW", "OS_W_CTRL_POL_30", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "OS_W_CTRL_POL_29", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000000, "RW", "OS_W_CTRL_POL_29", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "OS_W_CTRL_POL_28", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000000, "RW", "OS_W_CTRL_POL_28", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "OS_W_CTRL_POL_27", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000000, "RW", "OS_W_CTRL_POL_27", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "OS_W_CTRL_POL_26", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000000, "RW", "OS_W_CTRL_POL_26", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "OS_W_CTRL_POL_25", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000000, "RW", "OS_W_CTRL_POL_25", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000001, "RO", "OS_W_CTRL_POL_24", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000001, "RO", "OS_W_CTRL_POL_24", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "OS_W_CTRL_POL_23", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000000, "RW", "OS_W_CTRL_POL_23", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "OS_W_CTRL_POL_22", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000000, "RW", "OS_W_CTRL_POL_22", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "OS_W_CTRL_POL_21", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000000, "RW", "OS_W_CTRL_POL_21", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "OS_W_CTRL_POL_20", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000000, "RW", "OS_W_CTRL_POL_20", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "OS_W_CTRL_POL_19", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000000, "RW", "OS_W_CTRL_POL_19", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "OS_W_CTRL_POL_18", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000000, "RW", "OS_W_CTRL_POL_18", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "OS_W_CTRL_POL_17", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000000, "RW", "OS_W_CTRL_POL_17", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "OS_W_CTRL_POL_16", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000000, "RW", "OS_W_CTRL_POL_16", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "OS_W_CTRL_POL_15", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000000, "RW", "OS_W_CTRL_POL_15", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "OS_W_CTRL_POL_14", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000000, "RW", "OS_W_CTRL_POL_14", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "OS_W_CTRL_POL_13", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000000, "RW", "OS_W_CTRL_POL_13", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "OS_W_CTRL_POL_12", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000000, "RW", "OS_W_CTRL_POL_12", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "OS_W_CTRL_POL_11", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000000, "RW", "OS_W_CTRL_POL_11", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "OS_W_CTRL_POL_10", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000000, "RW", "OS_W_CTRL_POL_10", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RO", "OS_W_CTRL_POL_9", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000001, "RO", "OS_W_CTRL_POL_9", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "OS_W_CTRL_POL_8", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000000, "RW", "OS_W_CTRL_POL_8", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "OS_W_CTRL_POL_7", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000000, "RW", "OS_W_CTRL_POL_7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "OS_W_CTRL_POL_6", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000000, "RW", "OS_W_CTRL_POL_6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "OS_W_CTRL_POL_5", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000000, "RW", "OS_W_CTRL_POL_5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "OS_W_CTRL_POL_4", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000001, "RW", "OS_W_CTRL_POL_4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RO", "OS_W_CTRL_POL_3", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000001, "RO", "OS_W_CTRL_POL_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "OS_W_CTRL_POL_2", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000000, "RW", "OS_W_CTRL_POL_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "OS_W_CTRL_POL_1", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000000, "RW", "OS_W_CTRL_POL_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "OS_W_CTRL_POL_0", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000000, "RW", "OS_W_CTRL_POL_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo763_DDR[] = {{"mcdfxmisc_sai_os_w_pg_cr_policy_L", "", 0x000022C8, 32, 0x00000000FFFFFFFF, 0x0000000001000218}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields764_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "OS_W_CTRL_POL_63", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{31, 31, 0x00000000, "RW", "OS_W_CTRL_POL_63", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "OS_W_CTRL_POL_62", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{30, 30, 0x00000000, "RW", "OS_W_CTRL_POL_62", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "OS_W_CTRL_POL_61", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{29, 29, 0x00000000, "RW", "OS_W_CTRL_POL_61", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "OS_W_CTRL_POL_60", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{28, 28, 0x00000000, "RW", "OS_W_CTRL_POL_60", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "OS_W_CTRL_POL_59", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{27, 27, 0x00000000, "RW", "OS_W_CTRL_POL_59", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "OS_W_CTRL_POL_58", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{26, 26, 0x00000000, "RW", "OS_W_CTRL_POL_58", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "OS_W_CTRL_POL_57", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{25, 25, 0x00000000, "RW", "OS_W_CTRL_POL_57", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "OS_W_CTRL_POL_56", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{24, 24, 0x00000000, "RW", "OS_W_CTRL_POL_56", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "OS_W_CTRL_POL_55", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{23, 23, 0x00000000, "RW", "OS_W_CTRL_POL_55", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "OS_W_CTRL_POL_54", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{22, 22, 0x00000000, "RW", "OS_W_CTRL_POL_54", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "OS_W_CTRL_POL_53", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{21, 21, 0x00000000, "RW", "OS_W_CTRL_POL_53", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "OS_W_CTRL_POL_52", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{20, 20, 0x00000000, "RW", "OS_W_CTRL_POL_52", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "OS_W_CTRL_POL_51", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{19, 19, 0x00000000, "RW", "OS_W_CTRL_POL_51", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "OS_W_CTRL_POL_50", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{18, 18, 0x00000000, "RW", "OS_W_CTRL_POL_50", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "OS_W_CTRL_POL_49", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{17, 17, 0x00000000, "RW", "OS_W_CTRL_POL_49", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "OS_W_CTRL_POL_48", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{16, 16, 0x00000000, "RW", "OS_W_CTRL_POL_48", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "OS_W_CTRL_POL_47", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{15, 15, 0x00000000, "RW", "OS_W_CTRL_POL_47", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "OS_W_CTRL_POL_46", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{14, 14, 0x00000000, "RW", "OS_W_CTRL_POL_46", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "OS_W_CTRL_POL_45", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{13, 13, 0x00000000, "RW", "OS_W_CTRL_POL_45", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "OS_W_CTRL_POL_44", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{12, 12, 0x00000000, "RW", "OS_W_CTRL_POL_44", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "OS_W_CTRL_POL_43", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{11, 11, 0x00000000, "RW", "OS_W_CTRL_POL_43", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000001, "RO", "OS_W_CTRL_POL_42", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{10, 10, 0x00000001, "RO", "OS_W_CTRL_POL_42", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "OS_W_CTRL_POL_41", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{9, 9, 0x00000000, "RW", "OS_W_CTRL_POL_41", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "OS_W_CTRL_POL_40", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{8, 8, 0x00000000, "RW", "OS_W_CTRL_POL_40", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "OS_W_CTRL_POL_39", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{7, 7, 0x00000000, "RW", "OS_W_CTRL_POL_39", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "OS_W_CTRL_POL_38", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{6, 6, 0x00000000, "RW", "OS_W_CTRL_POL_38", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "OS_W_CTRL_POL_37", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{5, 5, 0x00000000, "RW", "OS_W_CTRL_POL_37", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "OS_W_CTRL_POL_36", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{4, 4, 0x00000000, "RW", "OS_W_CTRL_POL_36", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "OS_W_CTRL_POL_35", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{3, 3, 0x00000000, "RW", "OS_W_CTRL_POL_35", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "OS_W_CTRL_POL_34", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{2, 2, 0x00000000, "RW", "OS_W_CTRL_POL_34", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "OS_W_CTRL_POL_33", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{1, 1, 0x00000000, "RW", "OS_W_CTRL_POL_33", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "OS_W_CTRL_POL_32", "Bit-vector used to determine which agents are allowed write access to OS_W WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field."},
#else
{0, 0, 0x00000000, "RW", "OS_W_CTRL_POL_32", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo764_DDR[] = {{"mcdfxmisc_sai_os_w_pg_cr_policy_H", "", 0x000022CC, 32, 0x00000000FFFFFFFF, 0x0000000000000400}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields765_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW/P", "channel_address_select", "CMI address select \r\n"
"            2'b00: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[21:6];\r\n"
"            end\r\n"
"            2'b01: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[37:22];\r\n"
"            end\r\n"
"            2'b10: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[44:29];\r\n"
"            end\r\n"
"            2'b11: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = {cmiReqCmdIfc111[i].cmd.req_address[44:37],cmiReqCmdIfc111[i].cmd.req_address[13:6]};"},
#else
{31, 31, 0x00000000, "RW/P", "channel_address_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW/P", "dso1_channel0_input_select", "selects between channel0 and channel 1 of the spid data buses coming into this block from the two schedulers and the dedup data \r\n"
"'00: channel0 spid \r\n"
"'01: channel1 spid\r\n"
"'10: channel0 DRA\r\n"
"'11: channel1 DRA"},
#else
{29, 30, 0x00000000, "RW/P", "dso1_channel0_input_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 28, 0x00000000, "RW/P", "cmi_channel1_cpl_read_data_select", "CMI data select for channel1 rd data.\r\n"
"'0000: rd_data[15:0]\r\n"
"'0001: rd_data[31:16]\r\n"
"'0010: rd_data[47:32]\r\n"
"'0011: rd_data[63:48]\r\n"
"'0100: rd_data[79:64]\r\n"
"'0101: rd_data[95:80]\r\n"
"'0110: rd_data[111:96]\r\n"
"'0111: rd_data[127:112]\r\n"
"'1000: rd_data[143:128]\r\n"
"'1001: rd_data[159:144]\r\n"
"'1010: rd_data[175:160]\r\n"
"'1011: rd_data[191:176]\r\n"
"'1100: rd_data[207:192]\r\n"
"'1101: rd_data[223:208]\r\n"
"'1110: rd_data[239:224]\r\n"
"'1111: rd_data[255:240]\r\n"
""},
#else
{25, 28, 0x00000000, "RW/P", "cmi_channel1_cpl_read_data_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 24, 0x00000000, "RW/P", "cmi_channel0_cpl_read_data_select", "CMI data select for channel0 rd data.\r\n"
"'0000: rd_data[15:0]\r\n"
"'0001: rd_data[31:16]\r\n"
"'0010: rd_data[47:32]\r\n"
"'0011: rd_data[63:48]\r\n"
"'0100: rd_data[79:64]\r\n"
"'0101: rd_data[95:80]\r\n"
"'0110: rd_data[111:96]\r\n"
"'0111: rd_data[127:112]\r\n"
"'1000: rd_data[143:128]\r\n"
"'1001: rd_data[159:144]\r\n"
"'1010: rd_data[175:160]\r\n"
"'1011: rd_data[191:176]\r\n"
"'1100: rd_data[207:192]\r\n"
"'1101: rd_data[223:208]\r\n"
"'1110: rd_data[239:224]\r\n"
"'1111: rd_data[255:240]\r\n"
""},
#else
{21, 24, 0x00000000, "RW/P", "cmi_channel0_cpl_read_data_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 20, 0x00000000, "RW/P", "cmi_channel1_cmd_write_data_select", "CMI data select for channel1 write data.\r\n"
"'0000: write_data[15:0]\r\n"
"'0001: write_data[31:16]\r\n"
"'0010: write_data[47:32]\r\n"
"'0011: write_data[63:48]\r\n"
"'0100: write_data[79:64]\r\n"
"'0101: write_data[95:80]\r\n"
"'0110: write_data[111:96]\r\n"
"'0111: write_data[127:112]\r\n"
"'1000: write_data[143:128]\r\n"
"'1001: write_data[159:144]\r\n"
"'1010: write_data[175:160]\r\n"
"'1011: write_data[191:176]\r\n"
"'1100: write_data[207:192]\r\n"
"'1101: write_data[223:208]\r\n"
"'1110: write_data[239:224]\r\n"
"'1111: write_data[255:240]\r\n"
""},
#else
{17, 20, 0x00000000, "RW/P", "cmi_channel1_cmd_write_data_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 16, 0x00000000, "RW/P", "cmi_channel0_cmd_write_data_select", "CMI data select for channel0 write data.\r\n"
"'0000: write_data[15:0]\r\n"
"'0001: write_data[31:16]\r\n"
"'0010: write_data[47:32]\r\n"
"'0011: write_data[63:48]\r\n"
"'0100: write_data[79:64]\r\n"
"'0101: write_data[95:80]\r\n"
"'0110: write_data[111:96]\r\n"
"'0111: write_data[127:112]\r\n"
"'1000: write_data[143:128]\r\n"
"'1001: write_data[159:144]\r\n"
"'1010: write_data[175:160]\r\n"
"'1011: write_data[191:176]\r\n"
"'1100: write_data[207:192]\r\n"
"'1101: write_data[223:208]\r\n"
"'1110: write_data[239:224]\r\n"
"'1111: write_data[255:240]\r\n"
""},
#else
{13, 16, 0x00000000, "RW/P", "cmi_channel0_cmd_write_data_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 12, 0x00000000, "RW/P", "dso0_channel3_input_select", "Dso0 Channel 3 input select: \r\n"
"'0000:CMI completion channel0 \r\n"
"'0001:CMI completion channel1\r\n"
"'0010:CMI completion read data channel0\r\n"
"'0011:CMI completion read data channel1\r\n"
"'0100:CMI request write data channel0\r\n"
"'0101:CMI request write data channel1\r\n"
"'0110:CMI response channel0 \r\n"
"'0111:CMI response channel1\r\n"
"'1000:CMI late completion channel0\r\n"
"'1001:CMI late completion channel1\r\n"
"'1010:CMI Cmd channel0\r\n"
"'1011:CMI Cmd channel1\r\n"
"'1100:Upstream DRA Channel 0\r\n"
"'1101:Upstream DRA Channel 1"},
#else
{9, 12, 0x00000000, "RW/P", "dso0_channel3_input_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000000, "RW/P", "dso0_channel2_input_select", "Dso0 Channel 2 input select: \r\n"
"'000:CMI Request Channel0\r\n"
"'001:CMI Request Channel1\r\n"
"'010:CMI Completion Channel0\r\n"
"'011:CMI Completion Channel1\r\n"
"'100:Upstream DRA Channel 0\r\n"
"'101:Upstream DRA Channel 1"},
#else
{6, 8, 0x00000000, "RW/P", "dso0_channel2_input_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 5, 0x00000000, "RW/P", "dso0_channel1_input_select", "Dso0 Channel 1 input select: \r\n"
"'0000:CMI completion channel0 \r\n"
"'0001:CMI completion channel1\r\n"
"'0010:CMI completion read data channel0\r\n"
"'0011:CMI completion read data channel1\r\n"
"'0100:CMI request write data channel0\r\n"
"'0101:CMI request write data channel1\r\n"
"'0110:CMI response channel0 \r\n"
"'0111:CMI response channel1\r\n"
"'1000:CMI late completion channel0\r\n"
"'1001:CMI late completion channel1"},
#else
{2, 5, 0x00000000, "RW/P", "dso0_channel1_input_select", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000000, "RW/P", "dso0_channel0_input_select", "Dso0 Channel 0 input select: \r\n"
"'00:CMI Request Channel0\r\n"
"'01:CMI Request Channel1\r\n"
"'10: CMI Completion Channel0\r\n"
"'11:CMI Completion Channel1"},
#else
{0, 1, 0x00000000, "RW/P", "dso0_channel0_input_select", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo765_DDR[] = {{"mc_pa_block_cfg_0__L", "", 0x000022D0, 10, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields766_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/P", "channel_address_select", "CMI address select \r\n"
"            2'b00: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[21:6];\r\n"
"            end\r\n"
"            2'b01: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[37:22];\r\n"
"            end\r\n"
"            2'b10: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[44:29];\r\n"
"            end\r\n"
"            2'b11: begin\r\n"
"                spr_cmi_req_to_dso[i].req_address = {cmiReqCmdIfc111[i].cmd.req_address[44:37],cmiReqCmdIfc111[i].cmd.req_address[13:6]};"},
#else
{0, 0, 0x00000000, "RW/P", "channel_address_select", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo766_DDR[] = {{"mc_pa_block_cfg_0__H", "", 0x000022D4, 1, 0x0000000000000001, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields767_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo767_DDR[] = {{"RD_compr_ddr4_BW_tele", "", 0x000022E0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields768_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo768_DDR[] = {{"RD_compr_ddrt_BW_tele", "", 0x000022E4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields769_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo769_DDR[] = {{"WR_compr_ddr4_BW_tele", "", 0x000022E8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields770_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo770_DDR[] = {{"WR_compr_ddrt_BW_tele", "", 0x000022EC, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields771_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo771_DDR[] = {{"thrt_count_chnl_tele", "", 0x000022F0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields772_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo772_DDR[] = {{"cmd_count_tele", "", 0x000022F4, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields773_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo773_DDR[] = {{"compr_pmsum_tele", "", 0x000022F8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields774_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{28, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{24, 27, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 23, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{5, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{4, 4, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{3, 3, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{2, 2, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo774_DDR[] = {{"pma_misc_ctrl0", "", 0x000022FC, 9, 0x00000000FFFFFFFF, 0x0000000000000007}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields775_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 25, 0x00000000, "RO/V", "counter_val", "This is a read-only running counter that is approximately is synchronized between memory subsystem tiles.\r\n"
"This counter counts USync events which are 120ns apart"},
#else
{16, 25, 0x00000000, "RO/V", "counter_val", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "trigger_enable", "This bit enables synchronous trigger start feature. CPGC Global start_test will be set when a trigger is issued."},
#else
{11, 11, 0x00000000, "RW", "trigger_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW/V", "trigger_arm", "This arms the synchronous trigger. This bit is cleared after a trigger event (volatile)."},
#else
{10, 10, 0x00000000, "RW/V", "trigger_arm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 9, 0x00000000, "RW", "trigger_val", "This value is compared with a running counter counter_val. If sync trigger_arm bit is set, then a trigger will be issued for a match.\r\n"
"If sync trigger_enable is set, then a CPGC Global start_test will be set by hardware."},
#else
{0, 9, 0x00000000, "RW", "trigger_val", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo775_DDR[] = {{"cpgc_global_sync", "", 0x00002300, 4, 0x0000000003FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields776_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{21, 21, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 20, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo776_DDR[] = {{"Register_Access_Failure_Log", "", 0x00002310, 4, 0x00000000003FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields777_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo777_DDR[] = {{"pmon_rpq_active_cycles_L", "", 0x00002318, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields778_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo778_DDR[] = {{"pmon_rpq_active_cycles_H", "", 0x0000231C, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields779_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 31, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo779_DDR[] = {{"pmon_wpq_active_cycles_L", "", 0x00002320, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields780_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RO/V", "countervalue", "This is the current value of the counter."},
#else
{0, 15, 0x00000000, "RO/V", "countervalue", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo780_DDR[] = {{"pmon_wpq_active_cycles_H", "", 0x00002324, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields781_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "reset_count", "reset the counter"},
#else
{14, 14, 0x00000000, "RW", "reset_count", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 13, 0x00000000, "RW", "bgf_select_vec", "BGF bit vector to select which BGF to monitor.  SPR encodings as follows.  0: REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: M2M_MISC, RD_CPL_CMD, 5: RD_CPL_DATA, 6: CONSUMER_FLOW_CONTROL, 7: RSP, 8: RD_CPL_LATE, 9: MCCHAN_MISC, 10: ANY_BGF, 11: ANY_REQUEST_BGF, 12: ANY_RESPONSE_BGF.  ATS encodings as follows.  0: REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: RD_CPL_CMD, 4: RD_CPL_DATA, 5: CONSUMER_FLOW_CONTROL, 6: RSP, 7: ANY_BGF, 8: ANY_REQUEST_BGF, 9: ANY_RESPONSE_BGF"},
#else
{3, 13, 0x00000000, "RW", "bgf_select_vec", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "bgf_event", "0: idle, no counting, 1: BGF inserts, 2: BGF deallocations, 3: monitor the current size of the selected BGF, 4: count each cycle that the selected BGF is full, 5: count each cycle that the selected BGF is empty"},
#else
{0, 2, 0x00000000, "RW", "bgf_event", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo781_DDR[] = {{"bgf_pmon_config_0_", "", 0x00002328, 3, 0x0000000000007FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields782_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "reset_count", "reset the counter"},
#else
{14, 14, 0x00000000, "RW", "reset_count", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 13, 0x00000000, "RW", "bgf_select_vec", "BGF bit vector to select which BGF to monitor.  SPR encodings as follows.  0: REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: M2M_MISC, RD_CPL_CMD, 5: RD_CPL_DATA, 6: CONSUMER_FLOW_CONTROL, 7: RSP, 8: RD_CPL_LATE, 9: MCCHAN_MISC, 10: ANY_BGF, 11: ANY_REQUEST_BGF, 12: ANY_RESPONSE_BGF.  ATS encodings as follows.  0: REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: RD_CPL_CMD, 4: RD_CPL_DATA, 5: CONSUMER_FLOW_CONTROL, 6: RSP, 7: ANY_BGF, 8: ANY_REQUEST_BGF, 9: ANY_RESPONSE_BGF"},
#else
{3, 13, 0x00000000, "RW", "bgf_select_vec", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "bgf_event", "0: idle, no counting, 1: BGF inserts, 2: BGF deallocations, 3: monitor the current size of the selected BGF, 4: count each cycle that the selected BGF is full, 5: count each cycle that the selected BGF is empty"},
#else
{0, 2, 0x00000000, "RW", "bgf_event", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo782_DDR[] = {{"bgf_pmon_config_1_", "", 0x0000232C, 3, 0x0000000000007FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields783_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 27, 0x00000000, "RO/V", "value", "This is the current value of the counter."},
#else
{0, 27, 0x00000000, "RO/V", "value", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo783_DDR[] = {{"bgf_pmon_counter_0_", "", 0x00002330, 1, 0x000000000FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields784_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 27, 0x00000000, "RO/V", "value", "This is the current value of the counter."},
#else
{0, 27, 0x00000000, "RO/V", "value", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo784_DDR[] = {{"bgf_pmon_counter_1_", "", 0x00002334, 1, 0x000000000FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields785_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "idle_req_timeout_enable", "This bit controls whether the mcdfxmisc responder ISM will generate an IDLE_REQ NAK message when the programmed idle_req_timeout counter expires."},
#else
{31, 31, 0x00000000, "RW", "idle_req_timeout_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "idle_req_timeout_signal_error", "This bit controls whether the mcdfxmisc responder ISM will signal an error when an idle req timeout is detected"},
#else
{30, 30, 0x00000000, "RW", "idle_req_timeout_signal_error", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RW", "idle_req_timeout", "This is the IDLE_REQ timeout count.  If the ISM responder has not reached IDLE within this time, after the requestor has entered IDLE_REQ, the responder will transition to the IDLE_NAK state to break the deadlock and give the requestor another chance to revert back to ACTIVE."},
#else
{0, 15, 0x00000000, "RW", "idle_req_timeout", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo785_DDR[] = {{"mcmisc_cmi_ism_config_0_", "", 0x00002338, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields786_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "idle_req_timeout_enable", "This bit controls whether the mcdfxmisc responder ISM will generate an IDLE_REQ NAK message when the programmed idle_req_timeout counter expires."},
#else
{31, 31, 0x00000000, "RW", "idle_req_timeout_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "idle_req_timeout_signal_error", "This bit controls whether the mcdfxmisc responder ISM will signal an error when an idle req timeout is detected"},
#else
{30, 30, 0x00000000, "RW", "idle_req_timeout_signal_error", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RW", "idle_req_timeout", "This is the IDLE_REQ timeout count.  If the ISM responder has not reached IDLE within this time, after the requestor has entered IDLE_REQ, the responder will transition to the IDLE_NAK state to break the deadlock and give the requestor another chance to revert back to ACTIVE."},
#else
{0, 15, 0x00000000, "RW", "idle_req_timeout", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo786_DDR[] = {{"mcmisc_cmi_ism_config_1_", "", 0x0000233C, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields787_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo787_DDR[] = {{"NM_DRAM_RULE_CFG0_L", "", 0x00020C00, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields788_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo788_DDR[] = {{"NM_DRAM_RULE_CFG0_H", "", 0x00020C04, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields789_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo789_DDR[] = {{"NM_DRAM_RULE_CFG1_L", "", 0x00020C08, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields790_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo790_DDR[] = {{"NM_DRAM_RULE_CFG1_H", "", 0x00020C0C, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields791_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo791_DDR[] = {{"NM_DRAM_RULE_CFG2_L", "", 0x00020C10, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields792_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo792_DDR[] = {{"NM_DRAM_RULE_CFG2_H", "", 0x00020C14, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields793_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo793_DDR[] = {{"NM_DRAM_RULE_CFG3_L", "", 0x00020C18, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields794_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo794_DDR[] = {{"NM_DRAM_RULE_CFG3_H", "", 0x00020C1C, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields795_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo795_DDR[] = {{"NM_DRAM_RULE_CFG4_L", "", 0x00020C20, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields796_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo796_DDR[] = {{"NM_DRAM_RULE_CFG4_H", "", 0x00020C24, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields797_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo797_DDR[] = {{"NM_DRAM_RULE_CFG5_L", "", 0x00020C28, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields798_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo798_DDR[] = {{"NM_DRAM_RULE_CFG5_H", "", 0x00020C2C, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields799_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo799_DDR[] = {{"NM_DRAM_RULE_CFG6_L", "", 0x00020C30, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields800_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo800_DDR[] = {{"NM_DRAM_RULE_CFG6_H", "", 0x00020C34, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields801_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 31, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{30, 31, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 29, 0x00000000, "RW", "nm_chn_ways", "NmChnWays - Near Memory Channel Ways: used to calculate ChnLID\r\n"
"              000 = 1 way (ChnLID = 0)\r\n"
"              001 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              010 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              011 = 8 ways (ChnLID = module 8 of System Address)\r\n"
"              100 = 4 ways (ChnLID = module 4 of System Address)\r\n"
"        "},
#else
{27, 29, 0x00000000, "RW", "nm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo801_DDR[] = {{"NM_DRAM_RULE_CFG7_L", "", 0x00020C38, 4, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields802_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", "NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID\r\n"
"              NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID\r\n"
"              NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID\r\n"
"              NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in HBM mode\r\n"
"              NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in HBM mode\r\n"
"              Default value maps ChnLID to the same ChnPID\r\n"
"        "},
#else
{4, 27, 0x00FAC688, "RW", "nm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "nm_gran_eq", "When set to 0, indicate near memory target and channel granularity are different, or target way is 1."},
#else
{3, 3, 0x00000000, "RW", "nm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 2, 0x00000000, "RW", "nm_target_ways", "NmTargetWays - Near Memory Target Ways: used to calculate ChnLID\r\n"
"              00 = 1 way\r\n"
"              01 = 2 ways\r\n"
"              10 = 4 ways\r\n"
"              11 = 8 ways\r\n"
"        "},
#else
{1, 2, 0x00000000, "RW", "nm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "nm_chn_gran", "NmChnGran - Near Memory Channel Granularity:\r\n"
"              000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "nm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo802_DDR[] = {{"NM_DRAM_RULE_CFG7_H", "", 0x00020C3C, 4, 0x000000000FFFFFFF, 0x000000000FAC6880}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields803_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 31, 0x00000000, "RW", "SAD2TAD7", "SAD2TAD mapping entry 7 for write through"},
#else
{28, 31, 0x00000000, "RW", "SAD2TAD7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x00000000, "RW", "SAD2TAD6", "SAD2TAD mapping entry 6 for write through"},
#else
{24, 27, 0x00000000, "RW", "SAD2TAD6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 23, 0x00000000, "RW", "SAD2TAD5", "SAD2TAD mapping entry 5 for write through"},
#else
{20, 23, 0x00000000, "RW", "SAD2TAD5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x00000000, "RW", "SAD2TAD4", "SAD2TAD mapping entry 4 for write through"},
#else
{16, 19, 0x00000000, "RW", "SAD2TAD4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "SAD2TAD3", "SAD2TAD mapping entry 3 for write through"},
#else
{12, 15, 0x00000000, "RW", "SAD2TAD3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "SAD2TAD2", "SAD2TAD mapping entry 2 for write through"},
#else
{8, 11, 0x00000000, "RW", "SAD2TAD2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "SAD2TAD1", "SAD2TAD mapping entry 1 for write through"},
#else
{4, 7, 0x00000000, "RW", "SAD2TAD1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "SAD2TAD0", "SAD2TAD mapping entry 0 for write through"},
#else
{0, 3, 0x00000000, "RW", "SAD2TAD0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo803_DDR[] = {{"MC_SAD2TAD_CFG0", "", 0x00020CC4, 8, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields804_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "nvdimm_chn_msk", "Unused - \r\n"
"                         One bit per MC channel.\r\n"
"                         When the bit is set, then a Pcommit will target DDR4 on that channel.\r\n"
"                         When the bit is clear, then a Pcommit will target DDRT on that channel.\r\n"
"                     "},
#else
{0, 2, 0x00000000, "RW", "nvdimm_chn_msk", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo804_DDR[] = {{"pcommit_control", "", 0x00020CD0, 1, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields805_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo805_DDR[] = {{"DRAM_RULE_CFG0_L", "", 0x00020CE8, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields806_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo806_DDR[] = {{"DRAM_RULE_CFG0_H", "", 0x00020CEC, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields807_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo807_DDR[] = {{"DRAM_RULE_CFG1_L", "", 0x00020CF0, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields808_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo808_DDR[] = {{"DRAM_RULE_CFG1_H", "", 0x00020CF4, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields809_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo809_DDR[] = {{"DRAM_RULE_CFG2_L", "", 0x00020CF8, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields810_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo810_DDR[] = {{"DRAM_RULE_CFG2_H", "", 0x00020CFC, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields811_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo811_DDR[] = {{"DRAM_RULE_CFG3_L", "", 0x00020D00, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields812_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo812_DDR[] = {{"DRAM_RULE_CFG3_H", "", 0x00020D04, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields813_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo813_DDR[] = {{"DRAM_RULE_CFG4_L", "", 0x00020D08, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields814_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo814_DDR[] = {{"DRAM_RULE_CFG4_H", "", 0x00020D0C, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields815_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo815_DDR[] = {{"DRAM_RULE_CFG5_L", "", 0x00020D10, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields816_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo816_DDR[] = {{"DRAM_RULE_CFG5_H", "", 0x00020D14, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields817_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo817_DDR[] = {{"DRAM_RULE_CFG6_L", "", 0x00020D18, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields818_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo818_DDR[] = {{"DRAM_RULE_CFG6_H", "", 0x00020D1C, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields819_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "fm_chn_ways", "FmChnWays - Far Memory Channel Ways: used to calculate ChnLID\r\n"
"              00 = 1 way (ChnLID = 0)\r\n"
"              01 = 2 ways (ChnLID = modulo 2 of System Address)\r\n"
"              10 = 3 ways (ChnLID = modulo 3 of System Address)\r\n"
"              11 = Reserved\r\n"
"        "},
#else
{29, 30, 0x00000000, "RW", "fm_chn_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 28, 0x00000000, "RW", "fm_target", "FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all traffic go to."},
#else
{27, 28, 0x00000000, "RW", "fm_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 26, 0x00000000, "RW", "limit", "This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly greater then previous rule, even if this rule is disabled, unless this rule and all following rules are disabled. Lower limit is the previous rule (or 0 if this is the first rule)"},
#else
{1, 26, 0x00000000, "RW", "limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "rule_enable", "Enable for this DRAM rule."},
#else
{0, 0, 0x00000000, "RW", "rule_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo819_DDR[] = {{"DRAM_RULE_CFG7_L", "", 0x00020D20, 4, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields820_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", "FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)\r\n"
"              FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID\r\n"
"              FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID\r\n"
"              FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID\r\n"
"              ChnPID values are 00-01-10, value 11 is not valid\r\n"
"        "},
#else
{7, 12, 0x00000024, "RW", "fm_chn_l2pid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "fm_gran_eq", "When set to 0, indicate far memory target and channel granularity are different, or target way is 1."},
#else
{6, 6, 0x00000000, "RW", "fm_gran_eq", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "fm_target_ways", "FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq = 1\r\n"
"              000 = 1 way\r\n"
"              001 = 2 ways\r\n"
"              010 = 4 ways\r\n"
"              011 = 8 ways\r\n"
"              100 = 16 ways\r\n"
"        "},
#else
{3, 5, 0x00000000, "RW", "fm_target_ways", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "fm_chn_gran", "FmChnGran - Far Memory Channel Granularity:\r\n"
"              001=256B, 010=4KB, 111=2KB, other reserved\r\n"
"        "},
#else
{0, 2, 0x00000000, "RW", "fm_chn_gran", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo820_DDR[] = {{"DRAM_RULE_CFG7_H", "", 0x00020D24, 4, 0x0000000000001FFF, 0x0000000000001200}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields821_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 31, 0x00000000, "RO", "rsvd1", "Reserved"},
#else
{15, 31, 0x00000000, "RO", "rsvd1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "PatForceNM", "Force all patrol transaction destination to 2LM NM."},
#else
{13, 13, 0x00000000, "RW", "PatForceNM", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "NMCachingTADEn", "Enable for TAD index used for 2LM NM for patrol and sparing address generation."},
#else
{12, 12, 0x00000000, "RW", "NMCachingTADEn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "NMCachingTAD", "TAD index used for 2LM NM for patrol and sparing address generation."},
#else
{9, 11, 0x00000000, "RW", "NMCachingTAD", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "McMirrorMode", "Configured for mirroring - far memory is in the same channel as near memory if set. Locked by mirroring disable uCR. This field is programmed on the per iMC basis, i.e. need to maintain consistency with other populated channels in this iMC."},
#else
{8, 8, 0x00000000, "RW", "McMirrorMode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RO", "rsvd0", "Reserved"},
#else
{4, 7, 0x00000000, "RO", "rsvd0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "WCILFOptDis", "For WCILF if NM dir=i/s do not squash the fillrd on a miss if this bit is set"},
#else
{3, 3, 0x00000000, "RW", "WCILFOptDis", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "McNMCachingPmemWt", "For PMem transactions, write to both near and far memory if set. Locked by PMem Write-Thru disable uCR. This field is programmed on the per iMC basis, i.e. need to maintain consistency with other populated channels in this iMC."},
#else
{2, 2, 0x00000000, "RW", "McNMCachingPmemWt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "McPmemEnb", "1LM or 2LM mode but with AG2 memory enabled if set. Locked by PMem disable uCR. This field is programmed on the per iMC basis, i.e. need to maintain consistency with other populated channels in this iMC."},
#else
{1, 1, 0x00000000, "RW", "McPmemEnb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "McNMCachingEnb", "Enables 2LM near memory caching of far memory if set. Locked by 2LM disable uCR. This field is programmed on the per iMC basis, i.e. need to maintain consistency with other populated channels in this iMC.  A related register - McNMCachingCfg2 - is per channel and is located in MC2LMCNTL block."},
#else
{0, 0, 0x00000000, "RW", "McNMCachingEnb", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo821_DDR[] = {{"McNMCachingCfg", "", 0x00020DAC, 11, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields822_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo822_DDR[] = {{"tadbase_0", "", 0x00020DB0, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields823_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo823_DDR[] = {{"tadbase_1", "", 0x00020DB4, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields824_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo824_DDR[] = {{"tadbase_2", "", 0x00020DB8, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields825_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo825_DDR[] = {{"tadbase_3", "", 0x00020DBC, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields826_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo826_DDR[] = {{"tadbase_4", "", 0x00020DC0, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields827_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo827_DDR[] = {{"tadbase_5", "", 0x00020DC4, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields828_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo828_DDR[] = {{"tadbase_6", "", 0x00020DC8, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields829_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dedup_en", "This TAD is used for Dedup region"},
#else
{31, 31, 0x00000000, "RW", "dedup_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 30, 0x00000000, "RW", "failed_ch", "Used when en_failover bit is set for this TAD. Indicates the channel that has failed."},
#else
{29, 30, 0x00000000, "RW", "failed_ch", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 28, 0x00000000, "RW", "base", "lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26]."},
#else
{3, 28, 0x00000000, "RW", "base", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", "Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD range. Use for partial mirroring mode."},
#else
{2, 2, 0x00000000, "RW", "ign_ptrl_uc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "en_failover", "Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the failed channel and also the channel whose mirror channel has failed."},
#else
{1, 1, 0x00000000, "RW", "en_failover", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirror_en", "Mirroring enabled on this TAD "},
#else
{0, 0, 0x00000000, "RW", "mirror_en", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo829_DDR[] = {{"tadbase_7", "", 0x00020DCC, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields830_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo830_DDR[] = {{"tadwayness_0", "", 0x00020DD4, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields831_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo831_DDR[] = {{"tadwayness_1", "", 0x00020DD8, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields832_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo832_DDR[] = {{"tadwayness_2", "", 0x00020DDC, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields833_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo833_DDR[] = {{"tadwayness_3", "", 0x00020DE0, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields834_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo834_DDR[] = {{"tadwayness_4", "", 0x00020DE4, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields835_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo835_DDR[] = {{"tadwayness_5", "", 0x00020DE8, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields836_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo836_DDR[] = {{"tadwayness_6", "", 0x00020DEC, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields837_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 31, 0x00000000, "RW", "tad_limit", "highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26]. In case of 3 channel interleave, exclude the address not accessed by the system, even if the address is valid in memory."},
#else
{6, 31, 0x00000000, "RW", "tad_limit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW", "chn_lid", "ChnLID: channel logical ID. logical channel for channel interleave."},
#else
{3, 5, 0x00000000, "RW", "chn_lid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "target_lid", "\r\n"
"         TargetLID: target logical ID, a.k.a., base_offset\r\n"
"         The position of the MC in the socket interleave list in the SAD rule that maps to this TAD rule.\r\n"
"         If 1-way interleaved to one MC, base_offset is 0.\r\n"
"         If 2-way interleaved across two MCs, base_offset is either 0 or 1.\r\n"
"         4-way, 0 through 3.  8-way, 0 through 7.\r\n"
"      "},
#else
{0, 2, 0x00000000, "RW", "target_lid", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo837_DDR[] = {{"tadwayness_7", "", 0x00020DF0, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields838_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "adddc_exclusive2", "This bit is set to designate access to exclusive functionality in ADDDC. Both adddc_exclusive and adddc_exclusive2 need to be set for the exclusive functionality to work."},
#else
{4, 4, 0x00000000, "RW", "adddc_exclusive2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "monroe_chn_force_sr", "Monroe Technology software channel force SRcontrol. When set, the corresponding channel is ignoring the ForceSRExit. A new transaction arrive at this channel will still cause the SR exit."},
#else
{0, 0, 0x00000000, "RW", "monroe_chn_force_sr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo838_DDR[] = {{"mcmtr2", "", 0x00020DF4, 2, 0x000000000000001F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields839_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW/V", "rcomp_in_progress", "rcomp is in progress."},
#else
{31, 31, 0x00000000, "RW/V", "rcomp_in_progress", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "unused", "Unused. Intel reserved"},
#else
{30, 30, 0x00000000, "RW", "unused", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 29, 0x0000002C, "RW", "rcompblock", "Count for timer to expire before asserting spid_bus_quiet_time_gnt. Value = global sched blocking time + roundtrip time"},
#else
{22, 29, 0x0000002C, "RW", "rcompblock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "ignore_mdll_locked_bit", "ignore mdll locked bit."},
#else
{21, 21, 0x00000000, "RW", "ignore_mdll_locked_bit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "no_mdll_fsm_override", "no mdll fsm override."},
#else
{20, 20, 0x00000000, "RW", "no_mdll_fsm_override", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "increase_rcomp", "Increase RCOMP quiet time."},
#else
{17, 17, 0x00000000, "RW", "increase_rcomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW/V", "first_rcomp_done", "This is a status bit that indicates the first RCOMP has been completed. It is cleared on reset, and set by MC HW when the first RCOMP is completed. Bios should wait until this bit is set before executing any DDR command"},
#else
{16, 16, 0x00000000, "RW/V", "first_rcomp_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000000, "RW", "count", "Unused spare bits.  There is no logic behind this field"},
#else
{0, 15, 0x00000000, "RW", "count", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo839_DDR[] = {{"rcomp_timer", "", 0x00020DFC, 8, 0x00000000FFFFFFFF, 0x000000000B000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields840_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO/V", "fuse_shadow_disable_mcmirrormode", "Disable use of mirroring."},
#else
{31, 31, 0x00000000, "RO/V", "fuse_shadow_disable_mcmirrormode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RO/V", "fuse_shadow_disable_cr_pmem_wt", "Disable use of Persistent Memory Write Through with Crystal Ridge."},
#else
{30, 30, 0x00000000, "RO/V", "fuse_shadow_disable_cr_pmem_wt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO/V", "fuse_shadow_disable_cr_pmem", "Disable use of Persistent Memory with Crystal Ridge."},
#else
{29, 29, 0x00000000, "RO/V", "fuse_shadow_disable_cr_pmem", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RO/V", "fuse_shadow_disable_ddrt", "Disable the use of DDRT devices, once the fuse is blown to one, iMC will not issue any DDRT commands or responding DDRT bus request. Internally, any request targeting DDRT port is treated as programming error. System may hang."},
#else
{28, 28, 0x00000000, "RO/V", "fuse_shadow_disable_ddrt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RO/V", "fuse_shadow_disable_2lm", "Disable two-level memory"},
#else
{27, 27, 0x00000000, "RO/V", "fuse_shadow_disable_2lm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RO/V", "fuse_shadow_disable_mee", "There was a recent change and now this reg does nothing."},
#else
{26, 26, 0x00000000, "RO/V", "fuse_shadow_disable_mee", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RO/V", "fuse_shadow_disable_pcls", "Disable PCLS (Partial Cache Line Sparing)"},
#else
{25, 25, 0x00000000, "RO/V", "fuse_shadow_disable_pcls", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RO/V", "fuse_shadow_disable_bist", "Disable the BIST feature."},
#else
{24, 24, 0x00000000, "RO/V", "fuse_shadow_disable_bist", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x8_plus1", "Single device data correction fuse download. When set, will disable SDDC plus one for x8 SDDC mode."},
#else
{23, 23, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x8_plus1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x4_plus1", "Single device data correction fuse download. When set, will disable SDDC plus one for x4 SDDC mode."},
#else
{22, 22, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x4_plus1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x8", "Single device data correction fuse download. When set, will disable 8-bit device SDDC."},
#else
{21, 21, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x8", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x4", "Single device data correction fuse download. When set, will disable 4-bit device SDDC."},
#else
{20, 20, 0x00000000, "RO/V", "fuse_shadow_disable_sddc_x4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 19, 0x00000000, "RO/V", "fuse_shadow_rfu_2", "Reserved for future use."},
#else
{18, 19, 0x00000000, "RO/V", "fuse_shadow_rfu_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "fuse_shadow_disable_adddc", "Fused ADDDC disable control. When set, all ADDDC regions are disabled. Fuse download may change the default value after reset de-assertion."},
#else
{17, 17, 0x00000000, "RO/V", "fuse_shadow_disable_adddc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "fuse_shadow_disable_sparing", "Fused sparing disable control. When set, all sparing modes are disabled. Fuse download may change the default value after reset de-assertion."},
#else
{16, 16, 0x00000000, "RO/V", "fuse_shadow_disable_sparing", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "fuse_shadow_disable_plus1_corr", "If 1, disable ECC correction for SDDC+1 or ADDDC+1 mode; any error in +1 mode will be uncorrectable."},
#else
{15, 15, 0x00000000, "RO/V", "fuse_shadow_disable_plus1_corr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "fuse_shadow_disable_adddc_high_ras", "If 1, disable the high RAS version of adddc (use standard version of RAS for adddc)."},
#else
{14, 14, 0x00000000, "RO/V", "fuse_shadow_disable_adddc_high_ras", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RO/V", "fuse_shadow_disable_rdimm", "Fused RDIMM disable control. When set, RDIMM support is disabled by forcing the upper 5 bits of the 13b T_STAB register to be zeros, i.e. the T_STAB can only have max of 255 DCLK delay after clock-stopped power down mode which is in sufficient for normal RDIMM clock stablization; hence, users will not be able to support self-refresh with clock off mode (S3, pkg C6) if the RDIMM disable fuse is blown to one.\r\n"
"Fuse download may change the default value after reset de-assertion."},
#else
{13, 13, 0x00000000, "RO/V", "fuse_shadow_disable_rdimm", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000001, "RO/V", "fuse_shadow_mc_mca_recovery", "Fuse for mc_mca_recovery. Blown to 0 for EP, HEDT, ... etc, i.e. Means recovery from uncorrectable Patrol scrub errors is not supported. In addition, iMC hardware logs uncorrectable PS errors in the MCA bank with MCi_STATUS.PCC when set. When the fuse is blown to 1 in in EX only, this means that when poisoning is enabled, recovery from uncorrectable patrol scrub errors is supported. MC hardware will log uncorrectable Patrol scrub errors in the MCA bank with a recoverable error signature. Please refer to MCA HAS for further details."},
#else
{12, 12, 0x00000001, "RO/V", "fuse_shadow_mc_mca_recovery", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RO/V", "fuse_shadow_disable_dir", "Fused DIR disable control. When set, directory is disabled. Fuse download may change the default value after reset de-assertion."},
#else
{11, 11, 0x00000000, "RO/V", "fuse_shadow_disable_dir", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RO/V", "fuse_shadow_disable_ecc", "Fused ECC disable control. When set, ECC is disabled. Fuse download may change the default value after reset de-assertion."},
#else
{10, 10, 0x00000000, "RO/V", "fuse_shadow_disable_ecc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RO/V", "fuse_shadow_dis_asyncsr_adr", "Fused ADR disable control. When set, memory ignores ADR event. Fuse download may change the default value after reset de-assertion."},
#else
{9, 9, 0x00000000, "RO/V", "fuse_shadow_dis_asyncsr_adr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO/V", "fuse_shadow_soc_id", "We're using this bit to know if it is KNH or ICX-SP.  1 = KNH.  0 = ICX-SP."},
#else
{8, 8, 0x00000000, "RO/V", "fuse_shadow_soc_id", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RO/V", "fuse_shadow_disable_16gbit", "Fused 16Gb or higher disable control for DDR4 and 24Gb or higher disable for DDR5. When set, the address decode to the corresponding 16Gb or higher (or 24Gb or higher for DDR5) mapping is disabled. Note: LR-DIMMs logical device density is also limited to 16Gb when this fuse is set. Fuse download may change the default value after reset de-assertion."},
#else
{7, 7, 0x00000000, "RO/V", "fuse_shadow_disable_16gbit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RO/V", "fuse_shadow_disable_3ds", "Fused 3DS (3D stacked die) disable control. When set, the C0, C1 and C2 signals will forced to zero. Fuse download may change the default value after reset de-assertion."},
#else
{6, 6, 0x00000000, "RO/V", "fuse_shadow_disable_3ds", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RO/V", "fuse_shadow_disable_patrol_scrub", "Fused patrol scrub disable control. When set, rank patrol scrub is disabled. Fuse download may change the default value after reset de-assertion."},
#else
{5, 5, 0x00000000, "RO/V", "fuse_shadow_disable_patrol_scrub", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO/V", "fuse_shadow_disable_2_dpc", "Fused 2 DPC disable control. When set, CS signals for DIMM slot 1 (i.e. slot 0 is not disabled) are disabled. Note: some CS may have multiplexed with address signal to support extended addressing. The CS signal disabling is only applicable to CS not the being multiplexed with address. Fuse download may change the default value after reset de-assertion."},
#else
{4, 4, 0x00000000, "RO/V", "fuse_shadow_disable_2_dpc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "fuse_shadow_disable_ddr4_caparity", "Force ddr4 command address parity to be zero. This requires DDR4 DRAMs to be initialized to disable parity checking."},
#else
{3, 3, 0x00000000, "RO/V", "fuse_shadow_disable_ddr4_caparity", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "fuse_shadow_disable_persistent_cache", "Fused channel disable control. When set, the corresponding channel is disabled. Fuse download may change the default value after reset de-assertion. Setting to all 1 may disable msg channel."},
#else
{1, 1, 0x00000000, "RO/V", "fuse_shadow_disable_persistent_cache", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "fuse_shadow_chn_disable_mc0", "Fused channel disable control. When set, the corresponding channel is disabled. Fuse download may change the default value after reset de-assertion. Setting to all 1 may disable msg channel."},
#else
{0, 0, 0x00000000, "RO/V", "fuse_shadow_chn_disable_mc0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo840_DDR[] = {{"imc_fuse_download_shadow", "", 0x00020E00, 30, 0x00000000FFFFFFFF, 0x0000000000001000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields841_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 31, 0x00000055, "RO/V", "fuse_shadow_temp_twoxref", "This fuse csr stores the temperature threshold for the HBM 2x refresh rate.  It gets set by the fuse, and then BIOS reads this CSR in order to know what to write to the mc_thr CSR."},
#else
{24, 31, 0x00000055, "RO/V", "fuse_shadow_temp_twoxref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 23, 0x0000005F, "RO/V", "fuse_shadow_temp_fourxref", "This fuse csr stores the temperature threshold for the HBM 4x refresh rate.  It gets set by the fuse, and then BIOS reads this CSR in order to know what to write to the mc_thr CSR."},
#else
{16, 23, 0x0000005F, "RO/V", "fuse_shadow_temp_fourxref", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RO/V", "fuse_shadow_speed", "DDR/HBM speed."},
#else
{12, 15, 0x00000000, "RO/V", "fuse_shadow_speed", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_11", "Reserved for future use."},
#else
{11, 11, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_11", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_10", "Reserved for future use."},
#else
{10, 10, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_10", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_9", "Reserved for future use."},
#else
{9, 9, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_9", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_8", "Reserved for future use."},
#else
{8, 8, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_8", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_7", "Reserved for future use."},
#else
{7, 7, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_7", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_6", "Reserved for future use."},
#else
{6, 6, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_5", "Reserved for future use."},
#else
{5, 5, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_4", "Reserved for future use."},
#else
{4, 4, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_3", "Reserved for future use."},
#else
{3, 3, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_2", "Reserved for future use."},
#else
{2, 2, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_1", "Reserved for future use."},
#else
{1, 1, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_0", "Reserved for future use."},
#else
{0, 0, 0x00000001, "RO/V", "fuse_shadow_spare_fuse_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo841_DDR[] = {{"imc_fuse_download2_shadow", "", 0x00020E04, 15, 0x00000000FFFFFFFF, 0x00000000555F0FFF}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields842_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/P/L", "clken", "clock enable for debug mux"},
#else
{24, 24, 0x00000000, "RW/P/L", "clken", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 23, 0x00000000, "RW/P/L", "lane3sel", "lane 3 select"},
#else
{18, 23, 0x00000000, "RW/P/L", "lane3sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 17, 0x00000000, "RW/P/L", "lane2sel", "lane 2 select"},
#else
{12, 17, 0x00000000, "RW/P/L", "lane2sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 11, 0x00000000, "RW/P/L", "lane1sel", "lane 1 select"},
#else
{6, 11, 0x00000000, "RW/P/L", "lane1sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW/P/L", "lane0sel", "lane 0 select"},
#else
{0, 5, 0x00000000, "RW/P/L", "lane0sel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo842_DDR[] = {{"mcdecvisacfg", "", 0x00020E0C, 5, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields843_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "defeature_10", "When set to 1, rcomp request is never blocked even if ZQCal is on-going."},
#else
{31, 31, 0x00000000, "RW", "defeature_10", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "dis_asyncsr_habackpress", "When set to 1, the MC will not backpressure the M2M during an ADR sequence.\r\n"
"When set to 0 and the MC receives the AsyncSR signal from the PMA, the MC will immediately backpressure the M2M, stopping any new transactions from being sent to the MC."},
#else
{30, 30, 0x00000000, "RW", "dis_asyncsr_habackpress", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "dis_ptrl_psn", "Disable patrol scrub poison line on finding uncorr error"},
#else
{29, 29, 0x00000000, "RW", "dis_ptrl_psn", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "frc_not_occ_0", "MC PMA interface override for channel when not occupied. When set to 1, MCActive will de-assert and InSRD will assert."},
#else
{25, 25, 0x00000000, "RW", "frc_not_occ_0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 24, 0x00000000, "RW", "rsvd_chkn_b24_b23", "Reserved"},
#else
{23, 24, 0x00000000, "RW", "rsvd_chkn_b24_b23", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "dis_pma_blockack_hold", "When set to 1, disables the hold logic on the BlockAck going to the MC PMA, that keeps the BlockAck asserted once set, until the BlockReq de-asserts"},
#else
{22, 22, 0x00000000, "RW", "dis_pma_blockack_hold", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "dis_leak_cntr", "Disable leaky bucket counter in mc_dec"},
#else
{21, 21, 0x00000000, "RW", "dis_leak_cntr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "freq_chng_flow", "Bug fix for HSD b3123628:\r\n"
"When set, tells MC that this is a frequency_change flow. When the bit is set, following changes take place\r\n"
"1. When PmRsBlock is asserted, we block message channel to M2M\r\n"
"2. PkgC Empty and FullEmpty will ignore msgChEmpty when this bit is set"},
#else
{20, 20, 0x00000000, "RW", "freq_chng_flow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW/P", "bgftune_lock", "Reserved - unused."},
#else
{19, 19, 0x00000000, "RW/P", "bgftune_lock", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "unused2", "Allow patrol to stop at end of rank"},
#else
{18, 18, 0x00000000, "RW", "unused2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "dis_dbg_bgf_push", "Reserved - unused."},
#else
{17, 17, 0x00000000, "RW", "dis_dbg_bgf_push", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "dis_actual_msg_ch_ck_gate_mc", "Disable message channel clock gating"},
#else
{16, 16, 0x00000000, "RW", "dis_actual_msg_ch_ck_gate_mc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "dis_msg_ch_ck_gate_mc", "Disable bug fix for HSX be4768490 when set to 1"},
#else
{15, 15, 0x00000000, "RW", "dis_msg_ch_ck_gate_mc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "increase_rcomp", "Increase RCOMP quiet time"},
#else
{14, 14, 0x00000000, "RW", "increase_rcomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_lcl_ck_gate_mcmain", "Disable local clock gating - mcmains"},
#else
{13, 13, 0x00000000, "RW", "dis_lcl_ck_gate_mcmain", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "unused", "unused"},
#else
{12, 12, 0x00000000, "RW", "unused", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "dis_rcomp", "Disable rcomp"},
#else
{11, 11, 0x00000000, "RW", "dis_rcomp", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "frc_sngl_mtst", "Reserved - unused."},
#else
{10, 10, 0x00000000, "RW", "frc_sngl_mtst", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000001, "RW", "rsvd_chkn_b9", "Reserved"},
#else
{9, 9, 0x00000001, "RW", "rsvd_chkn_b9", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "frc_sngl_ptrl", "Reserved - unused."},
#else
{8, 8, 0x00000000, "RW", "frc_sngl_ptrl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "unused1", "Disable patrol error logging"},
#else
{7, 7, 0x00000000, "RW", "unused1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "dis_ptrl_rty", "Disable patrol retry"},
#else
{6, 6, 0x00000000, "RW", "dis_ptrl_rty", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "dis_spr_rir_updt", "Disable spare RIR update"},
#else
{5, 5, 0x00000000, "RW", "dis_spr_rir_updt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "frc_spr_end", "Keep patrol address to continue after PkgC"},
#else
{4, 4, 0x00000001, "RW", "frc_spr_end", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "frc_spr_strt", "Force spare start"},
#else
{3, 3, 0x00000000, "RW", "frc_spr_strt", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dis_spr_err_log", "Disable spare error logging"},
#else
{2, 2, 0x00000000, "RW", "dis_spr_err_log", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "rsvd_chkn_b1", "Disable signalling of SMI from patrol scrub engine.\r\n"
"Patrol scrub is able to signal SMI when it stops on error or reaches end of address range. See SCRUBCTL for details."},
#else
{1, 1, 0x00000000, "RW", "rsvd_chkn_b1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "pat_skip_non_mirr", "When set to 1, non-mirrored region is only scrubbed once when partial mirroring is enabled. Should only be set to 1 if partial mirroring is used."},
#else
{0, 0, 0x00000000, "RW", "pat_skip_non_mirr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo843_DDR[] = {{"mcmain_chkn_bits", "", 0x00020E14, 28, 0x00000000FFFFFFFF, 0x0000000000000210}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields844_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 31, 0x00000000, "RW", "defeature", "Chicken bits:\r\n"
"           Bit 7  : disable moving back to idle in TXN_DONE state when patrol is disabled;\r\n"
"           Bit 8  : disable fix for SKX b311323\r\n"
"           Bit 9  : \r\n"
"           Bit 10 : disable fix for SKX b311569\r\n"
"           Bit 11 : DDRT PC6 clock stop will not de-assert PMA Queue Full Empty if error FSM comes on.\r\n"
"           Bit 12 : DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if error FSM comes on.\r\n"
"           Bit 13 : DDRT PC6 clock stop will not de-assert PMA Queue Full Empty if DDRT RPQ is not empty.\r\n"
"           Bit 14 : DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if DDRT RPQ is not empty.\r\n"
"           Bit 15 : Set to 1 to disable check for SB empty during sparing flush.\r\n"
"           Bit 16: Clear end signal for eADR done.\r\n"
"           Bit 30:17: reserved and keep at 0\r\n"
"           Bit 31: Disable check for retry FSM idle during spare flush.\r\n"
""},
#else
{7, 31, 0x00000000, "RW", "defeature", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 6, 0x00000000, "RW/P/L", "evict_addr_par_inj_err", "Controls whether to inject a parity error on a NM eviction in 2LM mode:\r\n"
"0 - no injection\r\n"
"1 - always inject errors\r\n"
"2 - reserved\r\n"
"3 - reserved\r\n"
"        "},
#else
{5, 6, 0x00000000, "RW/P/L", "evict_addr_par_inj_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "dis_spr_ddrt_gnt_blk", "When set 1, DDRT gnt is not blocked during sparing before the first spare is issued. This block is done to avoid DDRT read when the round trip delay changes due to sparing (device substitution enabled). Current RDB already stop read from going through datapath when the delay changes so this blocking is likely not needed anymore."},
#else
{4, 4, 0x00000000, "RW", "dis_spr_ddrt_gnt_blk", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "dis_pat_pkgc", "When set 1, PkgCEmpty should check RT empty including patrol transaction"},
#else
{3, 3, 0x00000000, "RW", "dis_pat_pkgc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo844_DDR[] = {{"mcmain_chkn_bits2", "", 0x00020E18, 6, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields845_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V", "rankadd", "Always points to the lower address for the next sparing operation. This register will not be affected by the M2M access to the spare source rank during the M2M window.\r\n"
""},
#else
{0, 31, 0x00000000, "RW/V", "rankadd", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo845_DDR[] = {{"spareaddresslo", "", 0x00020E24, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields846_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "scrub_en", "Scrub Enable when set.  "},
#else
{31, 31, 0x00000000, "RW", "scrub_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "stop_on_cmpl", "Stop patrol scrub at end of memory range. This mode is meant to be used as part of memory migration flow. \r\n"
"            SMI is signalled by default."},
#else
{30, 30, 0x00000000, "RW", "stop_on_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW/V", "ptl_cmpl", "When stop_on_cmpl is enabled, patrol will stop at the end of the address range and set this bit.\r\n"
"Patrol will resume from beginning of address range when this bit or stop_on_cmpl is cleared by BIOS and patrol scrub is still enabled by scrub_en."},
#else
{29, 29, 0x00000000, "RW/V", "ptl_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "stop_on_err", "Reserved; keep this bit at 0."},
#else
{28, 28, 0x00000000, "RW", "stop_on_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW/V", "ptl_stopped", "Reserved"},
#else
{27, 27, 0x00000000, "RW/V", "ptl_stopped", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW/V", "scrubissued", "When Set, the scrub address registers contain the last scrub address issued"},
#else
{26, 26, 0x00000000, "RW/V", "scrubissued", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "issueonce", "When Set, the patrol scrub engine will issue the address in the scrub address registers only once and stop.  Software is responsible to turn off periodic patrol before issuing patrol once. The patrol interval in PMA should be set to 0 in issue once mode. No cross product of patrol once with PkgC is allowed."},
#else
{25, 25, 0x00000000, "RW", "issueonce", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/V", "startscrub", "When Set, the Patrol scrub engine will start from the address in the scrub address registers. Once the scrub is issued this bit is reset. For rank address based patrol scrub (when scrubaddresshi.ptl_sa_mode = 0), this bit should be set to 1 when scrub is enabled."},
#else
{24, 24, 0x00000000, "RW/V", "startscrub", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "dis_ptrl_err_log", "Reserved; keep this bit at 0."},
#else
{23, 23, 0x00000000, "RW", "dis_ptrl_err_log", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000001, "RW", "stop_on_rank", "Reserved; keep this bit at 0."},
#else
{22, 22, 0x00000001, "RW", "stop_on_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{21, 21, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 20, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{17, 20, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo846_DDR[] = {{"scrubctl", "", 0x00020E28, 12, 0x00000000FFFFFFFF, 0x00000000005E0000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields847_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V", "rankadd", "Contains the rank address or bits 37:6 of the system address of the last scrub issued. Can be written to specify the next scrub address with STARTSCRUB. Base system address in scrubaddress2lo/hi also need to be programmed in system address mode for the programmed address to work properly. In system address mode, scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. Bit 0 of this register maps to bit 6 of address. When target or channel XOR is enabled, address in this register wouldn't / shouldn't be the true system address, the system address with XOR applied. Error logging on patrol scrub error will reflect the true system address though."},
#else
{0, 31, 0x00000000, "RW/V", "rankadd", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo847_DDR[] = {{"scrubaddresslo", "", 0x00020E2C, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields848_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000001, "RW", "ptl_sa_mode", "Patrol runs in system address generation mode if patrol is enabled. Keep this bit at 1 for proper operation."},
#else
{31, 31, 0x00000001, "RW", "ptl_sa_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "maximum_tad_rule", "\r\n"
"            Last TAD rule used for patrol address generation. Set to the maximum valid TAD rule number used on the MC to generate system addresses for patrol up to the maximum address mapped to the MC.\r\n"
"        "},
#else
{28, 30, 0x00000000, "RW", "maximum_tad_rule", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 27, 0x00000000, "RW", "minimum_tad_rule", "\r\n"
"            First TAD rule used for patrol address generation. Set to 0 to begin generating system addresses for patrol at the lowest address mapped to the MC.\r\n"
"        "},
#else
{25, 27, 0x00000000, "RW", "minimum_tad_rule", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 24, 0x00000000, "RW/V", "tad_rule", "Contains the TAD rule of the last scrub issued. Can be written to specify the next scrub address with STARTSCRUB. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address written to take effect. RESTRICTION: Patrol Scrubs must be disabled when writing to this field. Only used system address patrol mode."},
#else
{22, 24, 0x00000000, "RW/V", "tad_rule", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 21, 0x00000000, "RW/V", "chnl", "Can be written to specify the next scrub address with STARTSCRUB. This register is updated with channel address of the last scrub address issued. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. Only used for legacy (non system address) patrol mode."},
#else
{19, 21, 0x00000000, "RW/V", "chnl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RW/V", "rank", "Contains the physical rank ID of the last scrub issued. Can be written to specify the next scrub address with STARTSCRUB. RESTRICTION: Patrol Scrubs must be disabled when writing to this field. Only used for legacy (non system address) patrol mode."},
#else
{16, 18, 0x00000000, "RW/V", "rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000001, "RW/V", "mirr_pri", "Contains the primary indication when mirroring is enabled. Can be written to specify the next scrub address. RESTRICTION: Patrol Scrubs must be disabled when writing to this field. Only used for system address patrol mode."},
#else
{15, 15, 0x00000001, "RW/V", "mirr_pri", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 14, 0x00000000, "RW/V", "rankaddhi", "Contains bits 52:38 of the system address of the last scrub issued. Can be written to specify the next scrub address with STARTSCRUB. Base system address in scrubaddress2lo/hi also need to be programmed in system address mode for the programmed address to work properly. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. Only used system address patrol mode."},
#else
{0, 14, 0x00000000, "RW/V", "rankaddhi", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo848_DDR[] = {{"scrubaddresshi", "", 0x00020E30, 8, 0x00000000FFFFFFFF, 0x0000000080008000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields849_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{1, 1, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 0, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo849_DDR[] = {{"hotplug", "", 0x00020E34, 2, 0x0000000000000003, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields850_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 9, 0x00000000, "RW", "ch2_mirror", "The secondary channel number when the primary channel is channel 2 for mirroring. This is used by patrol logic."},
#else
{8, 9, 0x00000000, "RW", "ch2_mirror", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 7, 0x00000000, "RW", "ch1_mirror", "The secondary channel number when the primary channel is channel 1 for mirroring. This is used by patrol logic."},
#else
{6, 7, 0x00000000, "RW", "ch1_mirror", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 5, 0x00000001, "RW", "ch0_mirror", "The secondary channel number when the primary channel is channel 0 for mirroring. This is used by patrol logic."},
#else
{4, 5, 0x00000001, "RW", "ch0_mirror", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "mirroren", "Mirror mode enable. The channel mapping must be set up before this bit will have an effect on IMC operation. This changes the error policy."},
#else
{0, 0, 0x00000000, "RW", "mirroren", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo850_DDR[] = {{"rasenables", "", 0x00020E3C, 4, 0x00000000000003FF, 0x0000000000000010}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields851_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "intrpt_sel_pin", "Enable pin signaling. When set the interrupt is signaled via the err[0] pin to get the attention of a BMC."},
#else
{17, 17, 0x00000000, "RW", "intrpt_sel_pin", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "intrpt_sel_cmci", "(CMCI used as a proxy for NMI signaling). Set to enable NMI signaling. Clear to disable NMI signaling. If both NMI and\r\n"
"SMI enable bits are set then only SMI is sent."},
#else
{16, 16, 0x00000000, "RW", "intrpt_sel_cmci", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "intrpt_sel_smi", "SMI enable. Set to enable SMi signaling. Clear to disable SMI signaling."},
#else
{15, 15, 0x00000000, "RW", "intrpt_sel_smi", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo851_DDR[] = {{"smisparectl", "", 0x00020E40, 3, 0x000000000003FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields852_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 11, 0x00000000, "RW", "leaky_bkt_cfg_hi", "This is the higher order bit select mask of the two hot encoding threshold. The value of this field specify the bit position of the mask:\r\n"
"00h: reserved\r\n"
"01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter\r\n"
"...\r\n"
"1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter\r\n"
"20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter\r\n"
"...\r\n"
"29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter\r\n"
"2Ah - 3F: reserved\r\n"
"When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are set, the 53b leaky bucket counter will be reset and the logic will generate a LEAK pulse to decrement the correctable error counter by 1.\r\n"
"MRC BIOS must program this register to any non-zero value before switching to NORMAL mode."},
#else
{6, 11, 0x00000000, "RW", "leaky_bkt_cfg_hi", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW", "leaky_bkt_cfg_lo", "This is the lower order bit select mask of the two hot encoding threshold. The value of this field specify the bit position of the mask:\r\n"
"00h: reserved\r\n"
"01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter\r\n"
"...\r\n"
"1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter\r\n"
"20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter\r\n"
"...\r\n"
"29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter\r\n"
"2Ah - 3F: reserved\r\n"
"When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are set, the 53b leaky bucket counter will be reset and the logic will generate a LEAK pulse to decrement the correctable error counter by 1.\r\n"
"MRC BIOS must program this register to any non-zero value before switching to NORMAL mode."},
#else
{0, 5, 0x00000000, "RW", "leaky_bkt_cfg_lo", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo852_DDR[] = {{"leaky_bucket_cfg", "", 0x00020E44, 2, 0x0000000000000FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields853_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V", "leaky_bkt_cntr_lo", "This is the lower half of the leaky bucket counter. The full counter is actually a 53b DCLK counter. There is a least significant 11b of the 53b counter is not captured in CSR. The carry strobe from the not-shown least significant 11b counter will trigger this 42b counter pair to count. The 42b counter-pair is compared with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are both set, the 53b counter is reset and the leaky bucket logic will generate a LEAK strobe last for 1 DCLK.  "},
#else
{0, 31, 0x00000000, "RW/V", "leaky_bkt_cntr_lo", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo853_DDR[] = {{"leaky_bucket_cntr_lo", "", 0x00020E48, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields854_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 9, 0x00000000, "RW/V", "leaky_bkt_cntr_hi", "This is the upper half of the leaky bucket counter. The full counter is actually a 53b DCLK counter. There is a least significant 11b of the 53b counter is not captured in CSR. The carry strobe from the not-shown least significant 11b counter will trigger this 42b counter pair to count. The 42b counter-pair is compared with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are both set, the 53b counter is reset and the leaky bucket logic will generate a LEAK strobe last for 1 DCLK.  "},
#else
{0, 9, 0x00000000, "RW/V", "leaky_bkt_cntr_hi", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo854_DDR[] = {{"leaky_bucket_cntr_hi", "", 0x00020E4C, 1, 0x00000000000003FF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields855_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V", "baseadd", "Contains bits 37:6 of the base system address of the last scrub issued. This is the base of the current system address. Can be written to specify the next scrub address with STARTSCRUB. System address in scrubaddresslo/hi also need to be programmed in system address mode for the programmed address to take effect. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. Only used system address patrol mode. When target or channel XOR is enabled, address in this register wouldn't / shouldn't be the true system address, the system address with XOR applied. Error logging on patrol scrub error will reflect the true system address though."},
#else
{0, 31, 0x00000000, "RW/V", "baseadd", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo855_DDR[] = {{"scrubaddress2lo", "", 0x00020E50, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields856_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 14, 0x00000000, "RW/V", "baseaddhi", "Contains bits 52:38 of the base system address of the last scrub issued. This is the base of the current system address. Can be written to specify the next scrub address with STARTSCRUB. System address in scrubaddresslo/hi also need to be programmed in system address mode for the programmed address to work properly. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. Only used system address patrol mode."},
#else
{0, 14, 0x00000000, "RW/V", "baseaddhi", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo856_DDR[] = {{"scrubaddress2hi", "", 0x00020E54, 1, 0x0000000000007FFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields857_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "emcalt_sel_smi", "SMI enable. Set to enable SMI signaling for each correctable error. Clear to disable SMI signaling and signal CMCI when correctable error threshold is reached."},
#else
{0, 0, 0x00000000, "RW", "emcalt_sel_smi", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo857_DDR[] = {{"emcaltctl", "", 0x00020E5C, 1, 0x0000000000000001, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields858_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000008, "RW", "BIT_SELECT", "selects which bit to set in the one-hot payload of the Global Error Message that iMC sends to UBOX. "},
#else
{0, 4, 0x00000008, "RW", "BIT_SELECT", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo858_DDR[] = {{"LBITMAP", "", 0x00020E60, 1, 0x000000000000001F, 0x0000000000000008}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields859_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "link_fail", "link fail."},
#else
{20, 20, 0x00000000, "RW", "link_fail", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 19, 0x00000000, "RW", "rank_dec", "Reserved; keep this field at 0."},
#else
{12, 19, 0x00000000, "RW", "rank_dec", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 10, 0x00000000, "RW", "ch0_rank", "Reserved; keep this field at 0."},
#else
{8, 10, 0x00000000, "RW", "ch0_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "all_ranks", "Reserved; keep this bit at 0."},
#else
{4, 4, 0x00000000, "RW", "all_ranks", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "ch_mask", "Patrol scrub channel mask. Setting this bit will skip patrol scrub on that channel."},
#else
{0, 0, 0x00000000, "RW", "ch_mask", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo859_DDR[] = {{"scrubmask", "", 0x00020E6C, 5, 0x00000000001FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields860_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 19, 0x00000000, "RW", "buddy_cs", "\r\n"
"                         The value in this field is encoded (Chip Selects are normally 1-hot), corresponding to CS0-CS7.  \r\n"
"                         This field is only used for SDDC sparing in x8 mode, or SDDC sparing after ADDDC is enabled.\r\n"
"                         This field specifies the primary rank (Chip Select, CS0-CS7) of an ADDDC transaction whose buddy is in the rank represented by source_cs.\r\n"
"                         This field is used only if buddy_cs_en bit is set to 1.\r\n"
"                      "},
#else
{17, 19, 0x00000000, "RW", "buddy_cs", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "buddy_cs_en", "\r\n"
"                         The enable bit for buddy_cs field. This enable bit is only set for SDDC sparing in x8 mode, or SDDC sparing after ADDDC is enabled.\r\n"
"                      "},
#else
{16, 16, 0x00000000, "RW", "buddy_cs_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 15, 0x00000000, "RW", "source_bg", "\r\n"
"                            For ADDDC used at the bank granularity (region_size=bank), this field specifies the bank group (BG1-BG0) to match for the sparing copy.\r\n"
"                        "},
#else
{14, 15, 0x00000000, "RW", "source_bg", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 13, 0x00000000, "RW", "source_ba", "\r\n"
"                            For ADDDC used at the bank granularity (region_size=bank), this field specifies the bank address (BA2-BA0) to match for the sparing copy.\r\n"
"                        "},
#else
{12, 13, 0x00000000, "RW", "source_ba", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "source_cs", "\r\n"
"                         The value in this field is encoded (Chip Selects are normally 1-hot), corresponding to CS0-CS7.  \r\n"
"                         For SDDC or rank sparing this field specifies the source rank (Chip Select, CS0-CS7) for the sparing copy.  \r\n"
"                         For ADDDC, this field specifies the failed rank for the sparing copy.  \r\n"
"                      "},
#else
{0, 2, 0x00000000, "RW", "source_cs", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo860_DDR[] = {{"sparing_control_source", "", 0x00020E74, 5, 0x00000000000FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields861_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 15, 0x00000000, "RW", "reserved", " Reserved for future use.  "},
#else
{3, 15, 0x00000000, "RW", "reserved", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "destination_cs", "\r\n"
"                          The value in this field is encoded (Chip Selects are normally 1-hot), corresponding to CS0-CS7.  \r\n"
"                          For rank sparing this field specifies the destination rank (Chip Select, CS0-CS7) for the sparing copy.  \r\n"
"                          For all other sparing operation, including ADDDC sparing, this field should have the same value as sparing_control_source.source_cs.\r\n"
"                     "},
#else
{0, 2, 0x00000000, "RW", "destination_cs", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo861_DDR[] = {{"sparing_control_destination", "", 0x00020E78, 2, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields862_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW/1C/V", "patrol_complete", "\r\n"
"                  All memory has been scrubbed. Hardware sets this bit each time the patrol engine steps through all memory locations. If software wants to monitor 0 to 1 transition after the bit has been set, the software will need to clear the bit by writing a one to clear this bit in order to distinguish the next patrol scrub completion. Clearing the bit will not affect the patrol scrub operation. Note, when mirroring is enabled, this bit will be set to 1 after either primary or secondary address scrubbing is done. If software clears this bit to observe 0 to 1 transition, the transition will happen twice to get full address scrubbed.\r\n"
"              "},
#else
{2, 2, 0x00000000, "RW/1C/V", "patrol_complete", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW/V", "copy_complete", "\r\n"
"                  Sparing copy operation complete. Set by hardware once operation is complete. \r\n"
"                  This bit is cleared by hardware when a new operation is enabled.\r\n"
"              "},
#else
{1, 1, 0x00000000, "RW/V", "copy_complete", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "copy_in_progress", "\r\n"
"                  This bit indicates that the sparing copy operation is in progress. \r\n"
"                  This bit is set by hardware once the sparing copy has started. It is cleared by hardware once the copy operation is complete or fails.\r\n"
"              "},
#else
{0, 0, 0x00000000, "RW/V", "copy_in_progress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo862_DDR[] = {{"sparing_patrol_status", "", 0x00020E7C, 3, 0x0000000000000007, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields863_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo863_DDR[] = {{"imc0_poison_source_L", "", 0x00020E80, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields864_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{31, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{30, 30, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{29, 29, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{16, 16, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{15, 15, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 13, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 13, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo864_DDR[] = {{"imc0_poison_source_H", "", 0x00020E84, 7, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields865_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 20, 0x00000007, "RW", "nxt_tad_6", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 6 with the same mirror_en bit as TAD 6 in tadbase."},
#else
{18, 20, 0x00000007, "RW", "nxt_tad_6", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 17, 0x00000006, "RW", "nxt_tad_5", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 5 with the same mirror_en bit as TAD 5 in tadbase."},
#else
{15, 17, 0x00000006, "RW", "nxt_tad_5", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000005, "RW", "nxt_tad_4", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 4 with the same mirror_en bit as TAD 4 in tadbase."},
#else
{12, 14, 0x00000005, "RW", "nxt_tad_4", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000004, "RW", "nxt_tad_3", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 3 with the same mirror_en bit as TAD 3 in tadbase."},
#else
{9, 11, 0x00000004, "RW", "nxt_tad_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 8, 0x00000003, "RW", "nxt_tad_2", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 2 with the same mirror_en bit as TAD 2 in tadbase."},
#else
{6, 8, 0x00000003, "RW", "nxt_tad_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000002, "RW", "nxt_tad_1", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 1 with the same mirror_en bit as TAD 1 in tadbase."},
#else
{3, 5, 0x00000002, "RW", "nxt_tad_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000001, "RW", "nxt_tad_0", "This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field contains the next TAD number from TAD 0 with the same mirror_en bit as TAD 0 in tadbase."},
#else
{0, 2, 0x00000001, "RW", "nxt_tad_0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo865_DDR[] = {{"sparing_control_tad", "", 0x00020E88, 7, 0x00000000001FFFFF, 0x00000000001F58D1}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields866_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x0000000F, "RO/V", "ssa_previous_state", "Previous encoded state of system address FSM for spare copy"},
#else
{24, 27, 0x0000000F, "RO/V", "ssa_previous_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x0000000F, "RO/V", "ssa_current_state", "Current encoded state of system address FSM for spare copy"},
#else
{16, 19, 0x0000000F, "RO/V", "ssa_current_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x0000001F, "RO/V", "spr_previous_state", "Previous encoded state of spare copy FSM"},
#else
{8, 12, 0x0000001F, "RO/V", "spr_previous_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RO/V", "spr_current_state", "Current encoded state of spare copy FSM"},
#else
{0, 4, 0x0000001F, "RO/V", "spr_current_state", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo866_DDR[] = {{"spare_fsm_state", "", 0x00020E8C, 4, 0x000000000FFFFFFF, 0x000000000F0F1F1F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields867_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 27, 0x0000000F, "RO/V", "psa_previous_state", "Previous encoded state of system address FSM for patrol scrub"},
#else
{24, 27, 0x0000000F, "RO/V", "psa_previous_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 19, 0x0000000F, "RO/V", "psa_current_state", "Current encoded state of system address FSM for patrol scrub"},
#else
{16, 19, 0x0000000F, "RO/V", "psa_current_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x0000001F, "RO/V", "pat_previous_state", "Previous encoded state of patrol scrub FSM"},
#else
{8, 12, 0x0000001F, "RO/V", "pat_previous_state", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x0000001F, "RO/V", "pat_current_state", "Current encoded state of patrol scrub FSM"},
#else
{0, 4, 0x0000001F, "RO/V", "pat_current_state", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo867_DDR[] = {{"patrol_fsm_state", "", 0x00020E90, 4, 0x000000000FFFFFFF, 0x000000000F0F1F1F}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields868_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 15, 0x00000000, "RW", "trig_select3", "\r\n"
"        Final MC_TRIGGER3 select:\r\n"
"            0: SPID command filter\r\n"
"            1: DDR-T Debug\r\n"
"            2: VERR state machine \r\n"
"            3: DDR-T FNV drain\r\n"
"            4: CPGC global start\r\n"
"            5: CPGC error\r\n"
"            6: CPGC done\r\n"
"        "},
#else
{12, 15, 0x00000000, "RW", "trig_select3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 11, 0x00000000, "RW", "trig_select2", "\r\n"
"        Final MC_TRIGGER2 select:\r\n"
"            0: SPID command filter\r\n"
"            1: DDR-T Debug\r\n"
"            2: VERR state machine \r\n"
"            3: DDR-T FNV drain\r\n"
"            4: CPGC global start\r\n"
"            5: CPGC error\r\n"
"            6: CPGC done\r\n"
"        "},
#else
{8, 11, 0x00000000, "RW", "trig_select2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 7, 0x00000000, "RW", "trig_select1", "\r\n"
"        Final MC_TRIGGER1 select:\r\n"
"            0: SPID command filter\r\n"
"            1: DDR-T Debug\r\n"
"            2: VERR state machine \r\n"
"            3: DDR-T FNV drain\r\n"
"            4: CPGC global start\r\n"
"            5: CPGC error\r\n"
"            6: CPGC done\r\n"
"        "},
#else
{4, 7, 0x00000000, "RW", "trig_select1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 3, 0x00000000, "RW", "trig_select0", "\r\n"
"        Final MC_TRIGGER0 select:\r\n"
"            0: SPID command filter\r\n"
"            1: DDR-T Debug\r\n"
"            2: VERR state machine \r\n"
"            3: DDR-T FNV drain\r\n"
"            4: CPGC global start\r\n"
"            5: CPGC error\r\n"
"            6: CPGC done\r\n"
"        "},
#else
{0, 3, 0x00000000, "RW", "trig_select0", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo868_DDR[] = {{"final_trig_ctl", "", 0x00020E9C, 4, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields869_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "viral_ch0", "Viral test bit for current channel."},
#else
{4, 4, 0x00000000, "RW", "viral_ch0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "viral_clear", "When set to 1, clears viral level signal in MC. Clear to 0 to allow viral signal to be set again."},
#else
{0, 0, 0x00000000, "RW", "viral_clear", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo869_DDR[] = {{"viralctl", "", 0x00020EB0, 2, 0x000000000000001F, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields870_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "addr_skip_en", "Enable exiting spare window when number of skipped addresses reaches threshold (addr_skip)."},
#else
{16, 16, 0x00000000, "RW", "addr_skip_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000100, "RW", "addr_skip", "Threshold to exit spare window when number of skipped addresses reaches this value. The value shouldn't be programmed to 0 even if addr_skip_en = 0."},
#else
{0, 15, 0x00000100, "RW", "addr_skip", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo870_DDR[] = {{"sparing_control_thresh", "", 0x00020EC8, 2, 0x000000000001FFFF, 0x0000000000000100}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields871_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo871_DDR[] = {{"imc0_mc8_addr_shadow_L", "", 0x00020ED0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields872_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 31, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{26, 31, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 25, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{20, 25, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 19, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{0, 19, 0x00000000, "RO", "Reserved",  NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo872_DDR[] = {{"imc0_mc8_addr_shadow_H", "", 0x00020ED4, 3, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields873_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 31, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo873_DDR[] = {{"retry_rd_err_log_address3_L", "", 0x00020ED8, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields874_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 19, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 19, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo874_DDR[] = {{"retry_rd_err_log_address3_H", "", 0x00020EDC, 1, 0x00000000000FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields875_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 31, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo875_DDR[] = {{"retry_rd_err_set2_log_address3_L", "", 0x00020EE0, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields876_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 19, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 19, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo876_DDR[] = {{"retry_rd_err_set2_log_address3_H", "", 0x00020EE4, 1, 0x00000000000FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields877_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW/P", "cs_oe_en", "Reserved - unused."},
#else
{9, 9, 0x00000000, "RW/P", "cs_oe_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000001, "RW/P", "safe_sr", "This bit indicates if it is safe to keep the MC in SR during MC-reset. If it is clear when reset occurs, it means that the reset is without warning and the DDR-reset should be asserted. If set when reset occurs, it indicates that DDR is already in SR and it can keep it this way. This bit can also indicate MRC if reset without warning has occured, and if it has, cold-reset flow should be selected\r\n"
"Note to MRC BIOS: clear this bit at MRC entry."},
#else
{8, 8, 0x00000001, "RW/P", "safe_sr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "mrc_done", "MRC done."},
#else
{7, 7, 0x00000000, "RW", "mrc_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000001, "RW", "reset_io", "DDR IO reset\r\n"
"In order to reset the IO this bit has to be set for 20 DCLKs and then cleared. Setting this bit will reset the DDRIO receive FIFO registers only.\r\n"
"It is required in some of the training steps.\r\n"
"        "},
#else
{5, 5, 0x00000001, "RW", "reset_io", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dclk_enable", "Reserved - unused."},
#else
{2, 2, 0x00000000, "RW", "dclk_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RW", "ddr_reset", "Reserved - unused."},
#else
{1, 1, 0x00000001, "RW", "ddr_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/P", "pu_mrc_done", "This bit should be set to 1 by bios as soon as the MRC has successfully completed and all required information (e.g. - training) is in the Bios flash. It indicates that first MRC has been completed"},
#else
{0, 0, 0x00000000, "RW/P", "pu_mrc_done", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo877_DDR[] = {{"mc_init_state_g", "", 0x00020EE8, 7, 0x00000000000003FF, 0x0000000000000122}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields878_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 28, 0x00000320, "RW", "numspare", "Sparing operation duration. System requests will be blocked during this interval and only sparing copy operations will be serviced. This needs to be an even number is ADDDC sparing mode. The value needs to be 32 or less in rank sparing mode."},
#else
{16, 28, 0x00000320, "RW", "numspare", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 15, 0x00000C80, "RW", "normopdur", "Normal operation duration. System requests will be serviced during this interval."},
#else
{0, 15, 0x00000C80, "RW", "normopdur", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo878_DDR[] = {{"spareinterval", "", 0x00020EF0, 2, 0x000000001FFFFFFF, 0x0000000003200C80}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields879_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "cpgc_active", "This bit allows CPGC to drive traffic (CMI Mux and Address Decode) while in normal mode. Training Mode implications are not observed by the MC while in this mode. This bit has no effect when normal_mode=0."},
#else
{30, 30, 0x00000000, "RW", "cpgc_active", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO/V", "hbm_mc_mode", "This bit specifies which kind of MC this is, HBM or DDR.  When 1, the MC is an HBM MC.  When 0, it is a DDR MC (this includes both DDR4 and DDRT)."},
#else
{29, 29, 0x00000000, "RO/V", "hbm_mc_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "num_cluster", "Number of cluster indication: 0 = hemi (or 2 clusters); 1 = quad (or 4 clusters)"},
#else
{26, 26, 0x00000000, "RW", "num_cluster", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "trng_target", "Per channel based target. \r\n"
"            0 = CPGC transactions go to DRAM scheduler.\r\n"
"            1 = CPGC transactions go to DDRT scheduler.  \r\n"
"        "},
#else
{25, 25, 0x00000000, "RW", "trng_target", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "SID_xor_enable", "XOR hash enable for subrank bits."},
#else
{24, 24, 0x00000000, "RW", "SID_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "rank_xor_enable", "XOR hash enable for Rank Select of the Rank Target (Bit [1] of 3 bit target rank) This bit should be set only when the channel has DDR5 dual-rank DIMMs. In a 2DPC configuration, both DIMMs need to be identical. This bit cannot be set for a DDR4 channel or if the channel has a single rank DIMM. "},
#else
{23, 23, 0x00000000, "RW", "rank_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW/P", "ch23cmd_ctl_delay", "unused on 10nm"},
#else
{22, 22, 0x00000000, "RW/P", "ch23cmd_ctl_delay", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "cluster_xor_enable", "XOR hash enable for 2 or 4 clusters."},
#else
{21, 21, 0x00000000, "RW", "cluster_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "channel_xor_enable", "XOR hash enable for 2 or 4 or 8 channels."},
#else
{20, 20, 0x00000000, "RW", "channel_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "pch_xor_enable", "XOR hash enable for pseudo channel or sub-channel."},
#else
{19, 19, 0x00000000, "RW", "pch_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW/P", "chn_disable", "Channel disable control. When set, the channel is disabled. \r\n"
"            Note: Message Channel may not work if all channels are set to disable in this field."},
#else
{18, 18, 0x00000000, "RW/P", "chn_disable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dimm_xor_enable", "XOR hash enable for Dimm Select of the Rank Target (Bit [2] of 3 bit target rank) This bit should be set only when the channel has 2 DDR5 DIMMs. Both DIMMs need to be identical. This bit cannot be set for a DDR4 channel or for a 1 DPC DDR5 channel. "},
#else
{13, 13, 0x00000000, "RW", "dimm_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "ddr5_9x4_en", "This bit is used to enable DDR5 9x4 mode.\r\n"
"0 - DDR5 10x4\r\n"
"1 - DDR5   9x4"},
#else
{12, 12, 0x00000000, "RW", "ddr5_9x4_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 11, 0x00000000, "RW", "trng_mode", "00: reserved\r\n"
"01: Native CPGC Mode. (mcmtr.normal must be zero for this mode)\r\n"
"10: reserved\r\n"
"11: Normal Mode (mcmtr.normal is a dont care for this mode)"},
#else
{10, 11, 0x00000000, "RW", "trng_mode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW/P", "bank_xor_enable", "When set, this bit will enable bank XORing. This is targeted at workloads that bank thrashing caused by certain stride or page mappings. If one detects unexpectedly poor page hit rates, one can attempt to flip this bit to see if it helps.\r\n"
"[0]: Our base configuration. Bank selection is done using rank address bits 12:17:18 for open page mapping and bits 6:7:8 for close page mapping.\r\n"
"[1]: Bank XORing enabled. Bank selection is done using rank address bits:\r\n"
"(1219):(1720):(1821) for open page mapping\r\n"
"(619):(720):(821) for close page mapping"},
#else
{9, 9, 0x00000000, "RW/P", "bank_xor_enable", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "normal", "0: Training mode\r\n"
"1: Normal Mode"},
#else
{8, 8, 0x00000000, "RW", "normal", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "write_parity_en", "HBM Only.  Enable parity for memory writes.  This bit is not used in DDR mode."},
#else
{7, 7, 0x00000000, "RW", "write_parity_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "read_parity_en", "HBM Only.  Enable parity for memory reads.  This bit is not used in DDR mode."},
#else
{6, 6, 0x00000000, "RW", "read_parity_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "write_dbi_en", "HBM Only.  Enable DBI for memory writes.  This bit is not used in DDR mode."},
#else
{5, 5, 0x00000000, "RW", "write_dbi_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000001, "RW", "read_dbi_en", "HBM Only.  Enable DBI for memory reads.  This bit is not used in DDR mode."},
#else
{4, 4, 0x00000001, "RW", "read_dbi_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW/V/P", "dir_en", "Directory Enable. Read-Only (RO) with 0 value if not supported. \r\n"
"      This bit is not used by the design. M2M controls directory enable behavior. \r\n"
"        "},
#else
{3, 3, 0x00000000, "RW/V/P", "dir_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW/V/P", "ecc_en", "ECC enable."},
#else
{2, 2, 0x00000000, "RW/V/P", "ecc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/P", "close_pg", "Use close page address mapping if set; otherwise, open page."},
#else
{0, 0, 0x00000000, "RW/P", "close_pg", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo879_DDR[] = {{"mcmtr", "", 0x00020EF8, 23, 0x000000007FFFFFFF, 0x0000000000000010}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields880_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "maximum_tad_rule_nonmirr", "Last TAD rule for non-mirror region used for spare address generation. Set to the maximum valid TAD rule number with mirror_en = 0 used on the MC to generate system addresses for sparing up to the maximum non-mirror address mapped to the MC. This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1."},
#else
{28, 30, 0x00000000, "RW", "maximum_tad_rule_nonmirr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "minimum_tad_rule_nonmirr", "First TAD rule for non-mirror region used for spare address generation. Set to minimum valid TAD rule number with mirror_en = 0 to begin generating system addresses for sparing at the lowest non-mirror address mapped to the MC. This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1."},
#else
{24, 26, 0x00000000, "RW", "minimum_tad_rule_nonmirr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "partial_mirr_en", "Only used when mirr_adddc_en = 1. When set to 1, indicates partial mirroring is enabled and system addresses will be generated 3 times. If set to 0, only full mirroring is enabled and first pass system address will be skipped."},
#else
{21, 21, 0x00000000, "RW", "partial_mirr_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "mirr_adddc_en", "Enabling special spare copy mode for ADDDC and mirroring enable. In this mode, system addresses will be gone through 3 times, with first pass for non-mirror addresses, second pass for mirror primary addresses, and third pass for mirror secondary addresses. For this function to work, amap.mirr_adddc_en needs to be set to 1 in the channel spare copy is done."},
#else
{20, 20, 0x00000000, "RW", "mirr_adddc_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RW", "maximum_tad_rule", "Last TAD rule used for spare address generation. Set to the maximum valid TAD rule number used on the MC to generate system addresses for sparing up to the maximum address mapped to the MC. When mirr_adddc_en = 1 and partial_mirr_en = 1, this represent the last TAD rule with mirror_en = 1."},
#else
{16, 18, 0x00000000, "RW", "maximum_tad_rule", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "minimum_tad_rule", "First TAD rule used for spare address generation. Set to 0 to begin generating system addresses for sparing at the lowest address mapped to the MC. When mirr_adddc_en = 1 and partial_mirr_en = 1, this represent the first TAD rule with mirror_en = 1."},
#else
{12, 14, 0x00000000, "RW", "minimum_tad_rule", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "bank_sparing", "This bit indicates bank sparing is enabled"},
#else
{10, 10, 0x00000000, "RW", "bank_sparing", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 8, 0x00000000, "RW", "region_size", "\r\n"
"                      This field selects the granularity for the sparing copy operation:\r\n"
"                      00=Bank\r\n"
"                      01=Rank\r\n"
"                      1X=Reserved\r\n"
"                  "},
#else
{7, 8, 0x00000000, "RW", "region_size", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "sddc_sparing", "\r\n"
"                  This bit causes the sparing copy to transition ECC to the SDDC state when sparing copy has been started via the spare_enable bit.\r\n"
"                  This bit is mutually exclusive with the adddc_sparing and rank_sparing bits.\r\n"
"                  This register is locked by the DISABLE_SDDC bit from IMC_FUSE_DOWNLOAD register.\r\n"
"              "},
#else
{4, 4, 0x00000000, "RW", "sddc_sparing", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "adddc_sparing", "\r\n"
"                  This bit causes the sparing copy to be ADDDC sparing when sparing copy has been started via the spare_enable bit.\r\n"
"                  This bit is mutually exclusive with the rank_sparing and sddc_sparing bits.\r\n"
"                  This register is locked by the DISABLE_ADDDC_SPARING bit from IMC_FUSE_DOWNLOAD register.\r\n"
"              "},
#else
{3, 3, 0x00000000, "RW", "adddc_sparing", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "rank_sparing", "\r\n"
"                  This bit causes the sparing copy to be rank sparing when sparing copy has been started via the spare_enable bit.\r\n"
"This bit is mutually exclusive with the adddc_sparing and sddc_sparing bits.\r\n"
"                  This register is locked by the DISABLE_RANK_SPARING bit from IMC_FUSE_DOWNLOAD register.\r\n"
"              "},
#else
{2, 2, 0x00000000, "RW", "rank_sparing", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "spare_reverse", "\r\n"
"                  Setting this bit will cause sparing engine to be run in reverse (move from virtual lockstep back to independent) when sparing has been started via the spare_enable bit.\r\n"
"                  Expected usage models are upgrading a region failure from bank to rank and post-silicon testing \r\n"
"              "},
#else
{1, 1, 0x00000000, "RW", "spare_reverse", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW/V", "spare_enable", "Spare enable when set to 1. Hardware clears this bit after the sparing completion."},
#else
{0, 0, 0x00000000, "RW/V", "spare_enable", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo880_DDR[] = {{"sparing_control", "", 0x00020EFC, 13, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields881_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 28, 0x00000000, "RW/P/L", "ln3dbgevsel", "This selects which set of signals will be driven on lane 3 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{24, 28, 0x00000000, "RW/P/L", "ln3dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 20, 0x00000000, "RW/P/L", "ln2dbgevsel", "This selects which set of signals will be driven on lane 2 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{16, 20, 0x00000000, "RW/P/L", "ln2dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW/P/L", "ln1dbgevsel", "This selects which set of signals will be driven on lane 1 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{8, 12, 0x00000000, "RW/P/L", "ln1dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW/P/L", "ln0dbgevsel", "This selects which set of signals will be driven on lane 0 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{0, 4, 0x00000000, "RW/P/L", "ln0dbgevsel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo881_DDR[] = {{"mcmaindbgpresel0", "", 0x00020F00, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields882_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 28, 0x00000000, "RW/P/L", "ln7dbgevsel", "This selects which set of signals will be driven on lane 7 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{24, 28, 0x00000000, "RW/P/L", "ln7dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 20, 0x00000000, "RW/P/L", "ln6dbgevsel", "This selects which set of signals will be driven on lane 6 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{16, 20, 0x00000000, "RW/P/L", "ln6dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 12, 0x00000000, "RW/P/L", "ln5dbgevsel", "This selects which set of signals will be driven on lane 5 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{8, 12, 0x00000000, "RW/P/L", "ln5dbgevsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 4, 0x00000000, "RW/P/L", "ln4dbgevsel", "This selects which set of signals will be driven on lane 4 of the debug bus:\r\n"
"For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of j where the 5-bit j={0-31}:\r\n"
"j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3 : j*32+i*4]"},
#else
{0, 4, 0x00000000, "RW/P/L", "ln4dbgevsel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo882_DDR[] = {{"mcmaindbgpresel1", "", 0x00020F04, 4, 0x000000001FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields883_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW/P/L", "clken", "clock enable for debug mux"},
#else
{24, 24, 0x00000000, "RW/P/L", "clken", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 23, 0x00000000, "RW/P/L", "lane3sel", "lane 3 select"},
#else
{18, 23, 0x00000000, "RW/P/L", "lane3sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 17, 0x00000000, "RW/P/L", "lane2sel", "lane 2 select"},
#else
{12, 17, 0x00000000, "RW/P/L", "lane2sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 11, 0x00000000, "RW/P/L", "lane1sel", "lane 1 select"},
#else
{6, 11, 0x00000000, "RW/P/L", "lane1sel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 5, 0x00000000, "RW/P/L", "lane0sel", "lane 0 select"},
#else
{0, 5, 0x00000000, "RW/P/L", "lane0sel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo883_DDR[] = {{"mcmaindbgsel", "", 0x00020F08, 5, 0x0000000001FFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields884_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 31, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo884_DDR[] = {{"retry_rd_err_set3_log_address3_L", "", 0x00020F10, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields885_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 19, 0x00000000, "RW/V/P", "sysaddress", "System address for last retry"},
#else
{0, 19, 0x00000000, "RW/V/P", "sysaddress", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo885_DDR[] = {{"retry_rd_err_set3_log_address3_H", "", 0x00020F14, 1, 0x00000000000FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields886_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW/P/L", "dbgbusen", "This will enable the debug bus. Can be used to gate clocks for all Debug flops.\r\n"
"This should really be RWS-L but the tool is not allowing me to do that."},
#else
{15, 15, 0x00000000, "RW/P/L", "dbgbusen", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo886_DDR[] = {{"mcdbgbuscntrl1", "", 0x00020F18, 1, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields887_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW", "scratchpad", "SCRATCHPAD"},
#else
{0, 31, 0x00000000, "RW", "scratchpad", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo887_DDR[] = {{"scratchpad", "", 0x00020F20, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields888_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{22, 22, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 21, 0x00000000, "RW/P/L", "glbrsp2stopsel", "This selects the event that will cause the output to be deasserted.\r\n"
"000: MBP[0]\r\n"
"001: MBP[1]\r\n"
"010: ASC[0]\r\n"
"011: ASC[1]\r\n"
"100: CTS Trigger out\r\n"
"101: Stop 1 cycle after start\r\n"
"110: Do it forever\r\n"
"111: Stop when start is false"},
#else
{19, 21, 0x00000000, "RW/P/L", "glbrsp2stopsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000007, "RW/P/L", "glbrsp2starttrigsel", "This selects which trigger will be driven out.\r\n"
"000: MBP_OUT[0]\r\n"
"001: MBP_OUT[1]\r\n"
"010: ASC[0] output\r\n"
"011: ASC[1] output\r\n"
"100: CTS trigger out\r\n"
"101: Reserved\r\n"
"110: Always 1\r\n"
"111: Never assert output"},
#else
{16, 18, 0x00000007, "RW/P/L", "glbrsp2starttrigsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{14, 14, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 13, 0x00000000, "RW/P/L", "glbrsp1stopsel", "This selects the event that will cause the output to be deasserted.\r\n"
"000: MBP[0]\r\n"
"001: MBP[1]\r\n"
"010: ASC[0]\r\n"
"011: ASC[1]\r\n"
"100: CTS Trigger out\r\n"
"101: Stop 1 cycle after start\r\n"
"110: Do it forever\r\n"
"111: Stop when start is false"},
#else
{11, 13, 0x00000000, "RW/P/L", "glbrsp1stopsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 10, 0x00000007, "RW/P/L", "glbrsp1starttrigsel", "This selects which trigger will be driven out.\r\n"
"000: MBP_OUT[0]\r\n"
"001: MBP_OUT[1]\r\n"
"010: ASC[0] output\r\n"
"011: ASC[1] output\r\n"
"100: CTS trigger out\r\n"
"101: Do it forever\r\n"
"110: Always 1\r\n"
"111: Never assert output"},
#else
{8, 10, 0x00000007, "RW/P/L", "glbrsp1starttrigsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RO", "Reserved", "Reserved"},
#else
{6, 6, 0x00000000, "RO", "Reserved",  NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 5, 0x00000000, "RW/P/L", "glbrsp0stopsel", "This selects the event that will cause the output to be deasserted.\r\n"
"000: MBP[0]\r\n"
"001: MBP[1]\r\n"
"010: ASC[0]\r\n"
"011: ASC[1]\r\n"
"100: CTS Trigger out\r\n"
"101: Stop 1 cycle after start\r\n"
"110: Do it forever\r\n"
"111: Stop when start is false"},
#else
{3, 5, 0x00000000, "RW/P/L", "glbrsp0stopsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000007, "RW/P/L", "glbrsp0starttrigsel", "This selects which trigger will be driven out.\r\n"
"000: MBP_OUT[0]\r\n"
"001: MBP_OUT[1]\r\n"
"010: ASC[0] output\r\n"
"011: ASC[1] output\r\n"
"100: CTS trigger out\r\n"
"101: Do it forever\r\n"
"110: Always 1\r\n"
"111: Never assert output"},
#else
{0, 2, 0x00000007, "RW/P/L", "glbrsp0starttrigsel", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo888_DDR[] = {{"mcglbrspcntl", "", 0x00020F28, 9, 0x00000000007FFFFF, 0x0000000000070707}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields889_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW/P/L", "noaen", "This bit enables the NOA logic. No output is sent out on the NOA bus from iMC if this bit is not set.\r\n"
"0: Disable NOA output from MC\r\n"
"1: Enable NOA output from iMC."},
#else
{15, 15, 0x00000000, "RW/P/L", "noaen", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW/P/L", "noaoutsel", "Selects if the full rate or the half rate data should be sent out on the NOA bus.\r\n"
"0: Select full speed data\r\n"
"1: Select half rate data."},
#else
{14, 14, 0x00000000, "RW/P/L", "noaoutsel", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW/P/L", "muxsel2", "This level of muxing will be used for taking only 8 bits of data instead of 16 to reduce the data rate on the NOA bus. The 8 bits selected will be accumulated for 2 cycles and sent as one 16 bit value at half the rate. Output8[7:0]: 0 selects output16[7:0]; 1 selects output16[15:8]"},
#else
{12, 12, 0x00000000, "RW/P/L", "muxsel2", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo889_DDR[] = {{"mcnoasel", "", 0x00020F48, 3, 0x000000000000FFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields890_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/P/L", "visactldata", "Read/Write data for VISA controller data registers"},
#else
{0, 31, 0x00000000, "RW/P/L", "visactldata", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo890_DDR[] = {{"visa_ctl_data", "", 0x00020F50, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields891_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 31, 0x00000000, "RW/1C/V/P", "errorcount", "\r\n"
"            This field shows the number of errors accumulated since the DFx BGF was last started. The error count \r\n"
"            saturates at its maximum value. It may be cleared (write 1 to clear) while the BGF is running.\r\n"
"            (Clearing this field does not reset the pattern generator, BGF or pattern checker; they keep running.)     \r\n"
"            Shouldnt need any flip-flops at register. Value may flow through from error counter. \r\n"
"            Path from error counter to register may be multi-cycle. \r\n"
"            If path is multi-cycle, then BGF should be stopped (see BgfStopOvrd) to read a, reliable, stable error count value.\r\n"
"            When a 1 is written to this field, send a two-cycle long clear signal to the error counter logic. \r\n"
"            The clear signal may be multi-cycle.\r\n"
"        "},
#else
{12, 31, 0x00000000, "RW/1C/V/P", "errorcount", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 10, 0x00000000, "RO/V", "ptrsepeff", "\r\n"
"            Effective Pointer Separation (PtrSepEff):\r\n"
"            This field shows the effective pointer separation applied to the DFx BGF (i.e. it is the primary BGF \r\n"
"            pointer separation minus PtrSepOffset). Note that this value is actually the program value; the\r\n"
"            conceptual pointer separation is the program value plus two.  Shouldnt need any flip-flops at register.\r\n"
"            Value may flow through from logic that computes the effective pointer separation. Path to register may be multi-cycle.\r\n"
"        "},
#else
{8, 10, 0x00000000, "RO/V", "ptrsepeff", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000001, "RW/P", "ptrsepoffset", "\r\n"
"            Pointer Separation Offset (PtrSepOffset):\r\n"
"            This field specifies the offset between the pointer separation of nearby primary, functional BGFs to the pointer \r\n"
"            separation of the DFx BGF. The DFx BGFs pointer separation is the primary BGFs pointer separation minus this offset. \r\n"
"            (This setting should not be changed while the BGF is running. See bgfstopovrd.)  \r\n"
"            Path from register to DFx BGFs pointer separation calculation logic may be multi-cycle.\r\n"
"        "},
#else
{4, 6, 0x00000001, "RW/P", "ptrsepoffset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW/P", "enrdbkbrw", "\r\n"
"            Pointer Separation Offset (EnRdBkBrw):\r\n"
"            While this field (and EnRdDelay) is set to 0, BGF read timing follows standard BGF behavior. \r\n"
"            If this field is set to 1, read data is sampled half a read clock earlier. This setting may be combined\r\n"
"            with EnRdDelay. (This setting should not be changed while the BGF is running. See BgfStopOvrd.)    \r\n"
"            Path from register to pattern checker may be multi-cycle.\r\n"
"        "},
#else
{3, 3, 0x00000000, "RW/P", "enrdbkbrw", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW/P", "enrddelay", "\r\n"
"            Enable Read Delay (EnRdDelay):\r\n"
"            While this field (and EnRdBkBrw) is set to 0, BGF read timing follows standard BGF behavior. If this field is set to 1, \r\n"
"            all reads are delayed by one cycle. This setting may be combined with EnRdBkBrw.  \r\n"
"            (This setting should not be changed while the BGF is running. See BgfStopOvrd.)       \r\n"
"            Path from register to pattern checker may be multi-cycle.\r\n"
"        "},
#else
{2, 2, 0x00000000, "RW/P", "enrddelay", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000001, "RW/P", "patternmode", "\r\n"
"            Pattern Mode (PatternMode):\r\n"
"            This field controls the type of test pattern that runs through the DFx FIFO: \r\n"
"              0 = toggle pattern, \r\n"
"              1 = pseudo-random bit sequence. \r\n"
"            (This setting should not be changed while the BGF is running. See Bgf StopOvrd.) \r\n"
"            Path from register to pattern generator and checker may be multi-cycle.\r\n"
"        "},
#else
{1, 1, 0x00000001, "RW/P", "patternmode", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "bgfstopovrd", "\r\n"
"            BGF Stop Override (BgfStopOvrd):\r\n"
"            The DFx BGF is primarily controlled by the BgfRun signal of primary, functional BGFs in\r\n"
"            DFx BGFs neighborhood. Setting this field to 1, however, forces the DFx BGF to stop. While the BGF is stopped, \r\n"
"            the pattern generator, pattern checker and error counter are not running. When the BGF is restarted \r\n"
"            (i.e. when this field is cleared to 0), the error counter (i.e. the ErrorCount field) is reset.\r\n"
"            \r\n"
"            If the BGFs configuration is changed while it is running, spurious errors will be logged. \r\n"
"            To change configuration (pattern mode, read delay, read back borrow, pointer separation offset), the standard procedure \r\n"
"            is to stop the BGF (i.e. set this field 1), change the configuration, and restart the BGF (set this field back to 0).\r\n"
"            All the other writable fields should be sticky through reset. This field is the exception; it should clear during reset.\r\n"
"        "},
#else
{0, 0, 0x00000000, "RW", "bgfstopovrd", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo891_DDR[] = {{"mcdfxbgfcontrol", "", 0x00020F58, 7, 0x00000000FFFFFFFF, 0x0000000000000012}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields892_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 31, 0x00000000, "RW/P/L", "visactladdr", "Read/Write addr for VISA controller addr registers"},
#else
{0, 31, 0x00000000, "RW/P/L", "visactladdr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo892_DDR[] = {{"visa_ctl_addr", "", 0x00020F60, 1, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields893_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 1, 0x00000003, "RW", "res_lock", "CPGC engine lock control from UCODE. This register controls write access to all cpgc registers\r\n"
"with the excpetion of cpgc_pda_shadow,cpgc_pda,cpgc_patwdbclmux,cpgc_patwdb,cpgc_patwdbcl,\r\n"
"cpgc_patwdb_wr0/cpgc_patwdb_wr1 registers.\r\n"
"00: CPGC is fully unlocked in non_normal mode (training). In normal mode, determined by\r\n"
"MCMTR.normal and MCMTR.trng_mode, this setting operates the same as 10 setting.\r\n"
"margining (MRS issue from CADB) are unlocked.\r\n"
"01: Reserved. CPGC is locked. Nothing can be issued by CPGC engine. mc_init_state_g is locked.\r\n"
"10: Only parts of CPGC engine necessary for Vref margining (MRS issue from CADB) is\r\n"
"unlocked (regardless of value of normal mode); mc_init_state_g is locked. The register fields\r\n"
"which are unlocked in this mode are: cpgc_seqctl*.global_control,cpgc_seqctl*.local_start_test,\r\n"
"all fields of cpgc_patcadbmrs_mrs,all fields of cr_cpgc_patcadbprog*,\r\n"
"cpgc_patcadbwrpntr.write_pointer .\r\n"
"cr_cpgc_seqctl*.initialization_mode is restricted to MRS mode.\r\n"
"11: CPGC is locked. Nothing can be issued by CPGC engine. mc_init_state_g is locked."},
#else
{0, 1, 0x00000003, "RW", "res_lock", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo893_DDR[] = {{"lt_cpgc_control", "", 0x00020F68, 1, 0x0000000000000003, 0x0000000000000003}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields894_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RO/V", "decs_ddrt_specread", "Decoder error"},
#else
{31, 31, 0x00000000, "RO/V", "decs_ddrt_specread", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RO/V", "decs_chn2rir_dec_err", "Decoder error"},
#else
{30, 30, 0x00000000, "RO/V", "decs_chn2rir_dec_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RO/V", "decs_sys2chn_dec_err", "Decoder error"},
#else
{29, 29, 0x00000000, "RO/V", "decs_sys2chn_dec_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RO/V", "decs_bad_accept", "Decoder error"},
#else
{28, 28, 0x00000000, "RO/V", "decs_bad_accept", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RO/V", "mc2lm_sb_index_arr_rden", "2LM controller error"},
#else
{27, 27, 0x00000000, "RO/V", "mc2lm_sb_index_arr_rden", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RO/V", "mc2lm_sb_tag_arr_rden", "2LM controller error"},
#else
{26, 26, 0x00000000, "RO/V", "mc2lm_sb_tag_arr_rden", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RO/V", "mc2lm_patrol_overflow", "2LM controller error"},
#else
{25, 25, 0x00000000, "RO/V", "mc2lm_patrol_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RO/V", "mc2lm_invalid_retry_htid", "2LM controller error"},
#else
{24, 24, 0x00000000, "RO/V", "mc2lm_invalid_retry_htid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RO/V", "mc2lm_ddrt_read_cpl_should_hit_sb", "2LM controller error"},
#else
{23, 23, 0x00000000, "RO/V", "mc2lm_ddrt_read_cpl_should_hit_sb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RO/V", "mc2lm_ddr4_read_cpl_should_hit_sb", "2LM controller error"},
#else
{22, 22, 0x00000000, "RO/V", "mc2lm_ddr4_read_cpl_should_hit_sb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RO/V", "mc2lm_bad_ddrt1_wrt_cmpl", "2LM controller error"},
#else
{21, 21, 0x00000000, "RO/V", "mc2lm_bad_ddrt1_wrt_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "mc2lm_bad_ddrt0_wrt_cmpl", "2LM controller error"},
#else
{20, 20, 0x00000000, "RO/V", "mc2lm_bad_ddrt0_wrt_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "mc2lm_bad_ddr4_wrt_cmpl1", "2LM controller error"},
#else
{19, 19, 0x00000000, "RO/V", "mc2lm_bad_ddr4_wrt_cmpl1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "mc2lm_bad_ddr4_wrt_cmpl0", "2LM controller error"},
#else
{18, 18, 0x00000000, "RO/V", "mc2lm_bad_ddr4_wrt_cmpl0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "mc2lm_erid_cmpl_err", "2LM controller error"},
#else
{17, 17, 0x00000000, "RO/V", "mc2lm_erid_cmpl_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "mc2lm_unexp_wrflush", "2LM controller error"},
#else
{16, 16, 0x00000000, "RO/V", "mc2lm_unexp_wrflush", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "mc2lm_unexp_wrflush_done", "2LM controller error"},
#else
{15, 15, 0x00000000, "RO/V", "mc2lm_unexp_wrflush_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "mc2lm_nmfill_wr_camvec_none", "2LM controller error"},
#else
{14, 14, 0x00000000, "RO/V", "mc2lm_nmfill_wr_camvec_none", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RO/V", "mc2lm_bad_sbentry_nonpatrol", "2LM controller error"},
#else
{13, 13, 0x00000000, "RO/V", "mc2lm_bad_sbentry_nonpatrol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RO/V", "mc2lm_bad_sbentry_patrol", "2LM controller error"},
#else
{12, 12, 0x00000000, "RO/V", "mc2lm_bad_sbentry_patrol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RO/V", "mc2lm_reuse_valid_sbentry", "2LM controller error"},
#else
{11, 11, 0x00000000, "RO/V", "mc2lm_reuse_valid_sbentry", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RO/V", "mc2lm_nm_mirr_bit_set", "2LM controller error"},
#else
{10, 10, 0x00000000, "RO/V", "mc2lm_nm_mirr_bit_set", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RO/V", "mc2lm_bad_ddr4_attr", "2LM controller error"},
#else
{9, 9, 0x00000000, "RO/V", "mc2lm_bad_ddr4_attr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO/V", "mc2lm_unexp_intlv", "2LM controller error"},
#else
{8, 8, 0x00000000, "RO/V", "mc2lm_unexp_intlv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RO/V", "ddrt_wpq_valid_pwr_not_found", "DDRT error"},
#else
{7, 7, 0x00000000, "RO/V", "ddrt_wpq_valid_pwr_not_found", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RO/V", "ddrt2_reads_linkfail", "DDRT error"},
#else
{6, 6, 0x00000000, "RO/V", "ddrt2_reads_linkfail", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RO/V", "com_pkgc_pkgs_err", "PkgC error"},
#else
{5, 5, 0x00000000, "RO/V", "com_pkgc_pkgs_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO/V", "spr_m2m_conflict", "Sparing error"},
#else
{4, 4, 0x00000000, "RO/V", "spr_m2m_conflict", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "spr_sparesissued_underflow", "Sparing error"},
#else
{3, 3, 0x00000000, "RO/V", "spr_sparesissued_underflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "pat_illegal_ack_inc", "Patrol error"},
#else
{2, 2, 0x00000000, "RO/V", "pat_illegal_ack_inc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "pat_illegal_init_addr2", "Programmed scrub starting address above TAD limit"},
#else
{1, 1, 0x00000000, "RO/V", "pat_illegal_init_addr2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "pat_illegal_init_addr", "Programmed scrub starting base address above TAD limit"},
#else
{0, 0, 0x00000000, "RO/V", "pat_illegal_init_addr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo894_DDR[] = {{"internal_error_2lmmisc_L", "", 0x00020F70, 32, 0x00000000FFFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields895_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RO/V", "mc2lm_sbtag_fifo_underflow", "2LM internal error"},
#else
{22, 22, 0x00000000, "RO/V", "mc2lm_sbtag_fifo_underflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RO/V", "mc2lm_sbtag_fifo_overflow", "2LM internal error"},
#else
{21, 21, 0x00000000, "RO/V", "mc2lm_sbtag_fifo_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RO/V", "ddrt2_illegal_conditions", "DDRT error - combined illegal conditions ( invalid req pulse width, info/interrupt packet received on secondary subchannel, read data came on different subchannel etc)"},
#else
{20, 20, 0x00000000, "RO/V", "ddrt2_illegal_conditions", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RO/V", "ddrt2_tgr_starvation", "DDRT error"},
#else
{19, 19, 0x00000000, "RO/V", "ddrt2_tgr_starvation", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RO/V", "ddrt2_wrcrdt_starvation", "DDRT error"},
#else
{18, 18, 0x00000000, "RO/V", "ddrt2_wrcrdt_starvation", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RO/V", "ddrt_wpq_valid_idle", "DDRT error"},
#else
{17, 17, 0x00000000, "RO/V", "ddrt_wpq_valid_idle", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RO/V", "ddrt_rpq_valid_idle", "DDRT error"},
#else
{16, 16, 0x00000000, "RO/V", "ddrt_rpq_valid_idle", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RO/V", "decs_wrong_spr_rank", "Decoder error"},
#else
{15, 15, 0x00000000, "RO/V", "decs_wrong_spr_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RO/V", "mc2lm_sb_overflow", "2LM controller error"},
#else
{14, 14, 0x00000000, "RO/V", "mc2lm_sb_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RO/V", "cmi_rsp_viol_3", "CMI error"},
#else
{13, 13, 0x00000000, "RO/V", "cmi_rsp_viol_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RO/V", "cmi_rsp_viol_2", "CMI error"},
#else
{12, 12, 0x00000000, "RO/V", "cmi_rsp_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RO/V", "cmi_rsp_viol_1", "CMI error"},
#else
{11, 11, 0x00000000, "RO/V", "cmi_rsp_viol_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RO/V", "cmi_req_viol", "CMI error"},
#else
{10, 10, 0x00000000, "RO/V", "cmi_req_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RO/V", "cmi_cpl_data_viol_2", "CMI error"},
#else
{9, 9, 0x00000000, "RO/V", "cmi_cpl_data_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RO/V", "cmi_cpl_data_viol", "CMI error"},
#else
{8, 8, 0x00000000, "RO/V", "cmi_cpl_data_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RO/V", "cmi_cpl_late_viol_3", "CMI error"},
#else
{7, 7, 0x00000000, "RO/V", "cmi_cpl_late_viol_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RO/V", "cmi_cpl_late_viol_2", "CMI error"},
#else
{6, 6, 0x00000000, "RO/V", "cmi_cpl_late_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RO/V", "cmi_cpl_late_viol", "CMI error"},
#else
{5, 5, 0x00000000, "RO/V", "cmi_cpl_late_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RO/V", "cmi_cpl_cmd_fifo_of", "CMI error"},
#else
{4, 4, 0x00000000, "RO/V", "cmi_cpl_cmd_fifo_of", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RO/V", "cmi_cpl_cmd_fifo_uf", "CMI error"},
#else
{3, 3, 0x00000000, "RO/V", "cmi_cpl_cmd_fifo_uf", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RO/V", "cmi_cpl_fifo_of", "CMI error"},
#else
{2, 2, 0x00000000, "RO/V", "cmi_cpl_fifo_of", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RO/V", "cmi_cpl_fifo_uf", "CMI error"},
#else
{1, 1, 0x00000000, "RO/V", "cmi_cpl_fifo_uf", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RO/V", "decs_patrol_retry_confl", "Decoder error"},
#else
{0, 0, 0x00000000, "RO/V", "decs_patrol_retry_confl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo895_DDR[] = {{"internal_error_2lmmisc_H", "", 0x00020F74, 23, 0x00000000007FFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields896_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{31, 31, 0x00000000, "RW", "dis_decs_ddrt_specread", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{31, 31, 0x00000000, "RW", "dis_decs_ddrt_specread", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{30, 30, 0x00000000, "RW", "dis_decs_chn2rir_dec_err", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{30, 30, 0x00000000, "RW", "dis_decs_chn2rir_dec_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{29, 29, 0x00000000, "RW", "dis_decs_sys2chn_dec_err", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{29, 29, 0x00000000, "RW", "dis_decs_sys2chn_dec_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 28, 0x00000000, "RW", "dis_decs_bad_accept", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{28, 28, 0x00000000, "RW", "dis_decs_bad_accept", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{27, 27, 0x00000000, "RW", "dis_mc2lm_sb_index_arr_rden", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{27, 27, 0x00000000, "RW", "dis_mc2lm_sb_index_arr_rden", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{26, 26, 0x00000000, "RW", "dis_mc2lm_sb_tag_arr_rden", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{26, 26, 0x00000000, "RW", "dis_mc2lm_sb_tag_arr_rden", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{25, 25, 0x00000000, "RW", "dis_mc2lm_patrol_overflow", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{25, 25, 0x00000000, "RW", "dis_mc2lm_patrol_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 24, 0x00000000, "RW", "dis_mc2lm_invalid_retry_htid", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{24, 24, 0x00000000, "RW", "dis_mc2lm_invalid_retry_htid", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{23, 23, 0x00000000, "RW", "dis_mc2lm_ddrt_read_cpl_should_hit_sb", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{23, 23, 0x00000000, "RW", "dis_mc2lm_ddrt_read_cpl_should_hit_sb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "dis_mc2lm_ddr4_read_cpl_should_hit_sb", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{22, 22, 0x00000000, "RW", "dis_mc2lm_ddr4_read_cpl_should_hit_sb", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "dis_mc2lm_bad_ddrt1_wrt_cmpl", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{21, 21, 0x00000000, "RW", "dis_mc2lm_bad_ddrt1_wrt_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000000, "RW", "dis_mc2lm_bad_ddrt0_wrt_cmpl", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{20, 20, 0x00000000, "RW", "dis_mc2lm_bad_ddrt0_wrt_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_wrt_cmpl", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{19, 19, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_wrt_cmpl", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_wrt_cmpl0", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{18, 18, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_wrt_cmpl0", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000000, "RW", "dis_mc2lm_erid_cmpl_err", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{17, 17, 0x00000000, "RW", "dis_mc2lm_erid_cmpl_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000000, "RW", "dis_mc2lm_unexp_wrflush", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{16, 16, 0x00000000, "RW", "dis_mc2lm_unexp_wrflush", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "dis_mc2lm_unexp_wrflush_done", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{15, 15, 0x00000000, "RW", "dis_mc2lm_unexp_wrflush_done", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "dis_mc2lm_nmfill_wr_camvec_none", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{14, 14, 0x00000000, "RW", "dis_mc2lm_nmfill_wr_camvec_none", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_mc2lm_bad_sbentry_nonpatrol", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{13, 13, 0x00000000, "RW", "dis_mc2lm_bad_sbentry_nonpatrol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "dis_mc2lm_bad_sbentry_patrol", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{12, 12, 0x00000000, "RW", "dis_mc2lm_bad_sbentry_patrol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "dis_mc2lm_reuse_valid_sbentry", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{11, 11, 0x00000000, "RW", "dis_mc2lm_reuse_valid_sbentry", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "dis_mc2lm_nm_mirr_bit_set", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{10, 10, 0x00000000, "RW", "dis_mc2lm_nm_mirr_bit_set", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_attr", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{9, 9, 0x00000000, "RW", "dis_mc2lm_bad_ddr4_attr", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "dis_mc2lm_unexp_intlv", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{8, 8, 0x00000000, "RW", "dis_mc2lm_unexp_intlv", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "dis_ddrt_wpq_valid_pwr_not_found", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{7, 7, 0x00000000, "RW", "dis_ddrt_wpq_valid_pwr_not_found", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "dis_ddrt2_reads_linkfail", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{6, 6, 0x00000000, "RW", "dis_ddrt2_reads_linkfail", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000001, "RW", "dis_com_pkgc_pkgs_err", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{5, 5, 0x00000001, "RW", "dis_com_pkgc_pkgs_err", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "dis_spr_m2m_conflict", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{4, 4, 0x00000000, "RW", "dis_spr_m2m_conflict", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "dis_spr_sparesissued_underflow", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{3, 3, 0x00000000, "RW", "dis_spr_sparesissued_underflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dis_pat_illegal_ack_inc", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{2, 2, 0x00000000, "RW", "dis_pat_illegal_ack_inc", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "dis_pat_illegal_init_addr2", "Disable error caused by programmed scrub starting address above TAD limit"},
#else
{1, 1, 0x00000000, "RW", "dis_pat_illegal_init_addr2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dis_pat_illegal_init_addr", "Disable error caused by programmed scrub starting base address above TAD limit"},
#else
{0, 0, 0x00000000, "RW", "dis_pat_illegal_init_addr", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo896_DDR[] = {{"dis_internal_error_2lmmisc_L", "", 0x00020F78, 32, 0x00000000FFFFFFFF, 0x0000000000000020}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields897_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{22, 22, 0x00000000, "RW", "dis_mc2lm_sbtag_fifo_underflow", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{22, 22, 0x00000000, "RW", "dis_mc2lm_sbtag_fifo_underflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{21, 21, 0x00000000, "RW", "dis_mc2lm_sbtag_fifo_overflow", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{21, 21, 0x00000000, "RW", "dis_mc2lm_sbtag_fifo_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 20, 0x00000001, "RW", "ddrt2_illegal_conditions", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{20, 20, 0x00000001, "RW", "ddrt2_illegal_conditions", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{19, 19, 0x00000001, "RW", "dis_ddrt2_tgr_starvation", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{19, 19, 0x00000001, "RW", "dis_ddrt2_tgr_starvation", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000001, "RW", "dis_ddrt2_wrcrdt_starvation", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{18, 18, 0x00000001, "RW", "dis_ddrt2_wrcrdt_starvation", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000001, "RW", "dis_ddrt_wpq_valid_idle", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{17, 17, 0x00000001, "RW", "dis_ddrt_wpq_valid_idle", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "dis_ddrt_rpq_valid_idle", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{16, 16, 0x00000001, "RW", "dis_ddrt_rpq_valid_idle", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{15, 15, 0x00000000, "RW", "dis_decs_wrong_spr_rank", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{15, 15, 0x00000000, "RW", "dis_decs_wrong_spr_rank", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{14, 14, 0x00000000, "RW", "dis_mc2lm_sb_overflow", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{14, 14, 0x00000000, "RW", "dis_mc2lm_sb_overflow", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 13, 0x00000000, "RW", "dis_cmi_rsp_viol_3", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{13, 13, 0x00000000, "RW", "dis_cmi_rsp_viol_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "dis_cmi_rsp_viol_2", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{12, 12, 0x00000000, "RW", "dis_cmi_rsp_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{11, 11, 0x00000000, "RW", "dis_cmi_rsp_viol_1", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{11, 11, 0x00000000, "RW", "dis_cmi_rsp_viol_1", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{10, 10, 0x00000000, "RW", "dis_cmi_req_viol", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{10, 10, 0x00000000, "RW", "dis_cmi_req_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 9, 0x00000000, "RW", "dis_cmi_cpl_data_viol_2", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{9, 9, 0x00000000, "RW", "dis_cmi_cpl_data_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "dis_cmi_cpl_data_viol", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{8, 8, 0x00000000, "RW", "dis_cmi_cpl_data_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "dis_cmi_cpl_late_viol_3", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{7, 7, 0x00000000, "RW", "dis_cmi_cpl_late_viol_3", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{6, 6, 0x00000000, "RW", "dis_cmi_cpl_late_viol_2", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{6, 6, 0x00000000, "RW", "dis_cmi_cpl_late_viol_2", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 5, 0x00000000, "RW", "dis_cmi_cpl_late_viol", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{5, 5, 0x00000000, "RW", "dis_cmi_cpl_late_viol", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW", "dis_cmi_cpl_cmd_fifo_of", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{4, 4, 0x00000000, "RW", "dis_cmi_cpl_cmd_fifo_of", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{3, 3, 0x00000000, "RW", "dis_cmi_cpl_cmd_fifo_uf", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{3, 3, 0x00000000, "RW", "dis_cmi_cpl_cmd_fifo_uf", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 2, 0x00000000, "RW", "dis_cmi_cpl_fifo_of", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{2, 2, 0x00000000, "RW", "dis_cmi_cpl_fifo_of", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "dis_cmi_cpl_fifo_uf", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{1, 1, 0x00000000, "RW", "dis_cmi_cpl_fifo_uf", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "dis_decs_patrol_retry_confl", "Disable corresponding error in internal_error_2lmmisc register"},
#else
{0, 0, 0x00000000, "RW", "dis_decs_patrol_retry_confl", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo897_DDR[] = {{"dis_internal_error_2lmmisc_H", "", 0x00020F7C, 23, 0x00000000007FFFFF, 0x00000000001F0000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields898_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{18, 18, 0x00000000, "RW", "cpgc_use_critical_bit", "0x0 = DDR5-only - shifts column to have cpgc lsb at CA4\r\n"
"0x1 = Disables the shift and has cpgc lsb at CA3 (like ddr4)"},
#else
{18, 18, 0x00000000, "RW", "cpgc_use_critical_bit", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{17, 17, 0x00000001, "RW", "cpgc_use_chan_id", "0x0 = CPGC Rank is Sched Rank (rank bit 0 = pseudochan)\r\n"
"0x1 = Sched Rank bit 0 is fixed to pseudochan strap, sched rank bit 1 is cpgc rank bit 0"},
#else
{17, 17, 0x00000001, "RW", "cpgc_use_chan_id", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 16, 0x00000001, "RW", "cpgc_bank_map", "0x0 = BG[1:0] and BA[1:0] are swapped (like normal functional traffic bank)\r\n"
"0x1 = CPGC Bank outputed from the CPGC is 1:1 mapped to the scheduler"},
#else
{16, 16, 0x00000001, "RW", "cpgc_bank_map", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{13, 15, 0x00000000, "RW", "cpgc_mixed_ddrt_rank_match", "MC will send traffic to DDRT for the rank specified by this value if cpgc_mixed_ddrt_rank_en is set"},
#else
{13, 15, 0x00000000, "RW", "cpgc_mixed_ddrt_rank_match", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 12, 0x00000000, "RW", "cpgc_mixed_ddrt_rank_en", "If set, MC will send traffic to DDRT for rank specified in cpgc_mixed_ddrt_rank_match"},
#else
{12, 12, 0x00000000, "RW", "cpgc_mixed_ddrt_rank_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{9, 11, 0x00000000, "RW", "cpgc_nocs_rank_match", "MC will supress traffic CS to the rank specified by this value if cpgc_nocs_rank_en is set"},
#else
{9, 11, 0x00000000, "RW", "cpgc_nocs_rank_match", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 8, 0x00000000, "RW", "cpgc_nocs_rank_en", "If set, MC will supress traffic CS to the rank specified in cpgc_nocs_rank_match"},
#else
{8, 8, 0x00000000, "RW", "cpgc_nocs_rank_en", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{7, 7, 0x00000000, "RW", "cpgc_disable_sb_wakeup", "0x0 = CRNode Request Addr bit 0 wakes up CPGC\r\n"
"0x1 = CRNode Request Addr bit 0 doesn't wake up CPGC"},
#else
{7, 7, 0x00000000, "RW", "cpgc_disable_sb_wakeup", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{5, 6, 0x00000000, "RW", "cpgc_reqlen_replace", "0x0 = No Replace\r\n"
"0x1 = No Replace\r\n"
"0x2 = Replace CPGC ReqLen with 0\r\n"
"0x3 = Replace CPGC ReqLen with 1"},
#else
{5, 6, 0x00000000, "RW", "cpgc_reqlen_replace", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 4, 0x00000000, "RW/V", "cpgc_htid_reset", "Self clearing CR where HTID replacement values are cleared"},
#else
{4, 4, 0x00000000, "RW/V", "cpgc_htid_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{2, 3, 0x00000000, "RW", "cpgc_htid_replace", "0x0 = Replace HTID with contiguous sequenc (0,1,2..)\r\n"
"0x1 = Replace HTID with even sequenc (0,2,4..)\r\n"
"0x2 = Replace HTID with oddsequenc (1,3,5..)\r\n"
"0x3 = Use HTID that came over CMI from CPGC,"},
#else
{2, 3, 0x00000000, "RW", "cpgc_htid_replace", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{1, 1, 0x00000000, "RW", "cpgc_reset", "0x0 = No manual reset asserted from this CR,\r\n"
"0x1 = Manual warm reset asserted (bios needs to clear this bit after setting it)"},
#else
{1, 1, 0x00000000, "RW", "cpgc_reset", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 0, 0x00000000, "RW", "cpgc_safe_mode", "0x0 = Clock gating operates as usual\r\n"
"0x1 = CPGC clock forced to enabled"},
#else
{0, 0, 0x00000000, "RW", "cpgc_safe_mode", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo898_DDR[] = {{"mc_cpgc_ctl", "", 0x00020F80, 13, 0x000000000007FFFF, 0x0000000000030000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields899_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "rank7_mapping", "Rank Address-7 mapping"},
#else
{28, 30, 0x00000000, "RW", "rank7_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rank6_mapping", "Rank Address-6 mapping"},
#else
{24, 26, 0x00000000, "RW", "rank6_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 22, 0x00000000, "RW", "rank5_mapping", "Rank Address-5 mapping"},
#else
{20, 22, 0x00000000, "RW", "rank5_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RW", "rank4_mapping", "Rank Address-4 mapping"},
#else
{16, 18, 0x00000000, "RW", "rank4_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "rank3_mapping", "Rank Address-3 mapping"},
#else
{12, 14, 0x00000000, "RW", "rank3_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 10, 0x00000000, "RW", "rank2_mapping", "Rank Address-2 mapping"},
#else
{8, 10, 0x00000000, "RW", "rank2_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank1_mapping", "Rank Address-1 mapping"},
#else
{4, 6, 0x00000000, "RW", "rank1_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "rank0_mapping", "Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to this logical Rank Address-0\r\n"
"(Sequence Address logic doamin).\r\n"
"It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual Physical Ranks which is useful for more complex\r\n"
"tests where non linear Physical Rank Sequences are needed."},
#else
{0, 2, 0x00000000, "RW", "rank0_mapping", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo899_DDR[] = {{"mc_cpgc_rank_map", "", 0x00020F84, 8, 0x000000007FFFFFFF, 0x0000000000000000}};
#if DUMP_REGISTER_FIELDS_DDR
RegisterField RegisterFields900_DDR[] = {
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{28, 30, 0x00000000, "RW", "rank7_mapping", "Rank Address-7 mapping"},
#else
{28, 30, 0x00000000, "RW", "rank7_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{24, 26, 0x00000000, "RW", "rank6_mapping", "Rank Address-6 mapping"},
#else
{24, 26, 0x00000000, "RW", "rank6_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{20, 22, 0x00000000, "RW", "rank5_mapping", "Rank Address-5 mapping"},
#else
{20, 22, 0x00000000, "RW", "rank5_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{16, 18, 0x00000000, "RW", "rank4_mapping", "Rank Address-4 mapping"},
#else
{16, 18, 0x00000000, "RW", "rank4_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{12, 14, 0x00000000, "RW", "rank3_mapping", "Rank Address-3 mapping"},
#else
{12, 14, 0x00000000, "RW", "rank3_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{8, 10, 0x00000000, "RW", "rank2_mapping", "Rank Address-2 mapping"},
#else
{8, 10, 0x00000000, "RW", "rank2_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{4, 6, 0x00000000, "RW", "rank1_mapping", "Rank Address-1 mapping"},
#else
{4, 6, 0x00000000, "RW", "rank1_mapping", NULL},
#endif
#if DUMP_REGISTER_DESCRIPTIONS_DDR
{0, 2, 0x00000000, "RW", "rank0_mapping", "Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to this logical Rank Address-0\r\n"
"(Sequence Address logic doamin).\r\n"
"It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual Physical Ranks which is useful for more complex\r\n"
"tests where non linear Physical Rank Sequences are needed."},
#else
{0, 2, 0x00000000, "RW", "rank0_mapping", NULL},
#endif
};
#endif // DUMP_REGISTER_FIELDS_DDR
RegisterInformation RegisterInfo900_DDR[] = {{"mc_cpgc_subrank_map", "", 0x00020F90, 8, 0x000000007FFFFFFF, 0x0000000000000000}};
Register Registers_DDR[] = {
#if DUMP_REGISTER_FIELDS_DDR
  {(RegisterInformation *)&RegisterInfo0_DDR, RegisterFields0_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo1_DDR, RegisterFields1_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo2_DDR, RegisterFields2_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo3_DDR, RegisterFields3_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo4_DDR, RegisterFields4_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo5_DDR, RegisterFields5_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo6_DDR, RegisterFields6_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo7_DDR, RegisterFields7_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo8_DDR, RegisterFields8_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo9_DDR, RegisterFields9_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo10_DDR, RegisterFields10_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo11_DDR, RegisterFields11_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo12_DDR, RegisterFields12_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo13_DDR, RegisterFields13_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo14_DDR, RegisterFields14_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo15_DDR, RegisterFields15_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo16_DDR, RegisterFields16_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo17_DDR, RegisterFields17_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo18_DDR, RegisterFields18_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo19_DDR, RegisterFields19_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo20_DDR, RegisterFields20_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo21_DDR, RegisterFields21_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo22_DDR, RegisterFields22_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo23_DDR, RegisterFields23_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo24_DDR, RegisterFields24_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo25_DDR, RegisterFields25_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo26_DDR, RegisterFields26_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo27_DDR, RegisterFields27_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo28_DDR, RegisterFields28_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo29_DDR, RegisterFields29_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo30_DDR, RegisterFields30_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo31_DDR, RegisterFields31_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo32_DDR, RegisterFields32_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo33_DDR, RegisterFields33_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo34_DDR, RegisterFields34_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo35_DDR, RegisterFields35_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo36_DDR, RegisterFields36_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo37_DDR, RegisterFields37_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo38_DDR, RegisterFields38_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo39_DDR, RegisterFields39_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo40_DDR, RegisterFields40_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo41_DDR, RegisterFields41_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo42_DDR, RegisterFields42_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo43_DDR, RegisterFields43_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo44_DDR, RegisterFields44_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo45_DDR, RegisterFields45_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo46_DDR, RegisterFields46_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo47_DDR, RegisterFields47_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo48_DDR, RegisterFields48_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo49_DDR, RegisterFields49_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo50_DDR, RegisterFields50_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo51_DDR, RegisterFields51_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo52_DDR, RegisterFields52_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo53_DDR, RegisterFields53_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo54_DDR, RegisterFields54_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo55_DDR, RegisterFields55_DDR}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo56_DDR, RegisterFields56_DDR}, // DDRCC0_CH0_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo57_DDR, RegisterFields57_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo58_DDR, RegisterFields58_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo59_DDR, RegisterFields59_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo60_DDR, RegisterFields60_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo61_DDR, RegisterFields61_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo62_DDR, RegisterFields62_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo63_DDR, RegisterFields63_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo64_DDR, RegisterFields64_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo65_DDR, RegisterFields65_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo66_DDR, RegisterFields66_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo67_DDR, RegisterFields67_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo68_DDR, RegisterFields68_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo69_DDR, RegisterFields69_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo70_DDR, RegisterFields70_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo71_DDR, RegisterFields71_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo72_DDR, RegisterFields72_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo73_DDR, RegisterFields73_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo74_DDR, RegisterFields74_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo75_DDR, RegisterFields75_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo76_DDR, RegisterFields76_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo77_DDR, RegisterFields77_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo78_DDR, RegisterFields78_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo79_DDR, RegisterFields79_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo80_DDR, RegisterFields80_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo81_DDR, RegisterFields81_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo82_DDR, RegisterFields82_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo83_DDR, RegisterFields83_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo84_DDR, RegisterFields84_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo85_DDR, RegisterFields85_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo86_DDR, RegisterFields86_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo87_DDR, RegisterFields87_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo88_DDR, RegisterFields88_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo89_DDR, RegisterFields89_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo90_DDR, RegisterFields90_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo91_DDR, RegisterFields91_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo92_DDR, RegisterFields92_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo93_DDR, RegisterFields93_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo94_DDR, RegisterFields94_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo95_DDR, RegisterFields95_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo96_DDR, RegisterFields96_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo97_DDR, RegisterFields97_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo98_DDR, RegisterFields98_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo99_DDR, RegisterFields99_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo100_DDR, RegisterFields100_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo101_DDR, RegisterFields101_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo102_DDR, RegisterFields102_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo103_DDR, RegisterFields103_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo104_DDR, RegisterFields104_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo105_DDR, RegisterFields105_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo106_DDR, RegisterFields106_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo107_DDR, RegisterFields107_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo108_DDR, RegisterFields108_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo109_DDR, RegisterFields109_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo110_DDR, RegisterFields110_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo111_DDR, RegisterFields111_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo112_DDR, RegisterFields112_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo113_DDR, RegisterFields113_DDR}, // DDRCC0_CH0A_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo114_DDR, RegisterFields114_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo115_DDR, RegisterFields115_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo116_DDR, RegisterFields116_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo117_DDR, RegisterFields117_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo118_DDR, RegisterFields118_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo119_DDR, RegisterFields119_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo120_DDR, RegisterFields120_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo121_DDR, RegisterFields121_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo122_DDR, RegisterFields122_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo123_DDR, RegisterFields123_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo124_DDR, RegisterFields124_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo125_DDR, RegisterFields125_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo126_DDR, RegisterFields126_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo127_DDR, RegisterFields127_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo128_DDR, RegisterFields128_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo129_DDR, RegisterFields129_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo130_DDR, RegisterFields130_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo131_DDR, RegisterFields131_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo132_DDR, RegisterFields132_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo133_DDR, RegisterFields133_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo134_DDR, RegisterFields134_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo135_DDR, RegisterFields135_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo136_DDR, RegisterFields136_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo137_DDR, RegisterFields137_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo138_DDR, RegisterFields138_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo139_DDR, RegisterFields139_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo140_DDR, RegisterFields140_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo141_DDR, RegisterFields141_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo142_DDR, RegisterFields142_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo143_DDR, RegisterFields143_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo144_DDR, RegisterFields144_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo145_DDR, RegisterFields145_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo146_DDR, RegisterFields146_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo147_DDR, RegisterFields147_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo148_DDR, RegisterFields148_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo149_DDR, RegisterFields149_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo150_DDR, RegisterFields150_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo151_DDR, RegisterFields151_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo152_DDR, RegisterFields152_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo153_DDR, RegisterFields153_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo154_DDR, RegisterFields154_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo155_DDR, RegisterFields155_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo156_DDR, RegisterFields156_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo157_DDR, RegisterFields157_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo158_DDR, RegisterFields158_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo159_DDR, RegisterFields159_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo160_DDR, RegisterFields160_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo161_DDR, RegisterFields161_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo162_DDR, RegisterFields162_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo163_DDR, RegisterFields163_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo164_DDR, RegisterFields164_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo165_DDR, RegisterFields165_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo166_DDR, RegisterFields166_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo167_DDR, RegisterFields167_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo168_DDR, RegisterFields168_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo169_DDR, RegisterFields169_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo170_DDR, RegisterFields170_DDR}, // DDRCC0_CHALL_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo171_DDR, RegisterFields171_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo172_DDR, RegisterFields172_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo173_DDR, RegisterFields173_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo174_DDR, RegisterFields174_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo175_DDR, RegisterFields175_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo176_DDR, RegisterFields176_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo177_DDR, RegisterFields177_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo178_DDR, RegisterFields178_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo179_DDR, RegisterFields179_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo180_DDR, RegisterFields180_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo181_DDR, RegisterFields181_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo182_DDR, RegisterFields182_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo183_DDR, RegisterFields183_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo184_DDR, RegisterFields184_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo185_DDR, RegisterFields185_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo186_DDR, RegisterFields186_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo187_DDR, RegisterFields187_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo188_DDR, RegisterFields188_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo189_DDR, RegisterFields189_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo190_DDR, RegisterFields190_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo191_DDR, RegisterFields191_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo192_DDR, RegisterFields192_DDR}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo193_DDR, RegisterFields193_DDR}, // DDRCC1_CH0_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo194_DDR, RegisterFields194_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo195_DDR, RegisterFields195_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo196_DDR, RegisterFields196_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo197_DDR, RegisterFields197_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo198_DDR, RegisterFields198_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo199_DDR, RegisterFields199_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo200_DDR, RegisterFields200_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo201_DDR, RegisterFields201_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo202_DDR, RegisterFields202_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo203_DDR, RegisterFields203_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo204_DDR, RegisterFields204_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo205_DDR, RegisterFields205_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo206_DDR, RegisterFields206_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo207_DDR, RegisterFields207_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo208_DDR, RegisterFields208_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo209_DDR, RegisterFields209_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo210_DDR, RegisterFields210_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo211_DDR, RegisterFields211_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo212_DDR, RegisterFields212_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo213_DDR, RegisterFields213_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo214_DDR, RegisterFields214_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo215_DDR, RegisterFields215_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo216_DDR, RegisterFields216_DDR}, // DDRCC1_CH0A_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo217_DDR, RegisterFields217_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo218_DDR, RegisterFields218_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo219_DDR, RegisterFields219_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo220_DDR, RegisterFields220_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo221_DDR, RegisterFields221_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo222_DDR, RegisterFields222_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo223_DDR, RegisterFields223_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo224_DDR, RegisterFields224_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo225_DDR, RegisterFields225_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo226_DDR, RegisterFields226_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo227_DDR, RegisterFields227_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo228_DDR, RegisterFields228_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo229_DDR, RegisterFields229_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo230_DDR, RegisterFields230_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo231_DDR, RegisterFields231_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo232_DDR, RegisterFields232_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo233_DDR, RegisterFields233_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo234_DDR, RegisterFields234_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo235_DDR, RegisterFields235_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo236_DDR, RegisterFields236_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo237_DDR, RegisterFields237_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo238_DDR, RegisterFields238_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo239_DDR, RegisterFields239_DDR}, // DDRCC1_CHALL_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo240_DDR, RegisterFields240_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo241_DDR, RegisterFields241_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo242_DDR, RegisterFields242_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo243_DDR, RegisterFields243_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo244_DDR, RegisterFields244_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo245_DDR, RegisterFields245_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo246_DDR, RegisterFields246_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo247_DDR, RegisterFields247_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo248_DDR, RegisterFields248_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo249_DDR, RegisterFields249_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo250_DDR, RegisterFields250_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo251_DDR, RegisterFields251_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo252_DDR, RegisterFields252_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo253_DDR, RegisterFields253_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo254_DDR, RegisterFields254_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo255_DDR, RegisterFields255_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo256_DDR, RegisterFields256_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo257_DDR, RegisterFields257_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo258_DDR, RegisterFields258_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo259_DDR, RegisterFields259_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo260_DDR, RegisterFields260_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo261_DDR, RegisterFields261_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo262_DDR, RegisterFields262_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo263_DDR, RegisterFields263_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo264_DDR, RegisterFields264_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo265_DDR, RegisterFields265_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo266_DDR, RegisterFields266_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo267_DDR, RegisterFields267_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo268_DDR, RegisterFields268_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo269_DDR, RegisterFields269_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo270_DDR, RegisterFields270_DDR}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo271_DDR, RegisterFields271_DDR}, // DDRCLK_CH0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo272_DDR, RegisterFields272_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo273_DDR, RegisterFields273_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo274_DDR, RegisterFields274_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo275_DDR, RegisterFields275_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo276_DDR, RegisterFields276_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo277_DDR, RegisterFields277_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo278_DDR, RegisterFields278_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo279_DDR, RegisterFields279_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo280_DDR, RegisterFields280_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo281_DDR, RegisterFields281_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo282_DDR, RegisterFields282_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo283_DDR, RegisterFields283_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo284_DDR, RegisterFields284_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo285_DDR, RegisterFields285_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo286_DDR, RegisterFields286_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo287_DDR, RegisterFields287_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo288_DDR, RegisterFields288_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo289_DDR, RegisterFields289_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo290_DDR, RegisterFields290_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo291_DDR, RegisterFields291_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo292_DDR, RegisterFields292_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo293_DDR, RegisterFields293_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo294_DDR, RegisterFields294_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo295_DDR, RegisterFields295_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo296_DDR, RegisterFields296_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo297_DDR, RegisterFields297_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo298_DDR, RegisterFields298_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo299_DDR, RegisterFields299_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo300_DDR, RegisterFields300_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo301_DDR, RegisterFields301_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo302_DDR, RegisterFields302_DDR}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo303_DDR, RegisterFields303_DDR}, // DDRCLK_CHALL_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo304_DDR, RegisterFields304_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo305_DDR, RegisterFields305_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo306_DDR, RegisterFields306_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo307_DDR, RegisterFields307_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo308_DDR, RegisterFields308_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo309_DDR, RegisterFields309_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo310_DDR, RegisterFields310_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo311_DDR, RegisterFields311_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo312_DDR, RegisterFields312_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo313_DDR, RegisterFields313_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo314_DDR, RegisterFields314_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo315_DDR, RegisterFields315_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo316_DDR, RegisterFields316_DDR}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo317_DDR, RegisterFields317_DDR}, // DDRCOMP_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo318_DDR, RegisterFields318_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo319_DDR, RegisterFields319_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo320_DDR, RegisterFields320_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo321_DDR, RegisterFields321_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo322_DDR, RegisterFields322_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo323_DDR, RegisterFields323_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo324_DDR, RegisterFields324_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo325_DDR, RegisterFields325_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo326_DDR, RegisterFields326_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo327_DDR, RegisterFields327_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo328_DDR, RegisterFields328_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo329_DDR, RegisterFields329_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo330_DDR, RegisterFields330_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo331_DDR, RegisterFields331_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo332_DDR, RegisterFields332_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo333_DDR, RegisterFields333_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo334_DDR, RegisterFields334_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo335_DDR, RegisterFields335_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo336_DDR, RegisterFields336_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo337_DDR, RegisterFields337_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo338_DDR, RegisterFields338_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo339_DDR, RegisterFields339_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo340_DDR, RegisterFields340_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo341_DDR, RegisterFields341_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo342_DDR, RegisterFields342_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo343_DDR, RegisterFields343_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo344_DDR, RegisterFields344_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo345_DDR, RegisterFields345_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo346_DDR, RegisterFields346_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo347_DDR, RegisterFields347_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo348_DDR, RegisterFields348_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo349_DDR, RegisterFields349_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo350_DDR, RegisterFields350_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo351_DDR, RegisterFields351_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo352_DDR, RegisterFields352_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo353_DDR, RegisterFields353_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo354_DDR, RegisterFields354_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo355_DDR, RegisterFields355_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo356_DDR, RegisterFields356_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo357_DDR, RegisterFields357_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo358_DDR, RegisterFields358_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo359_DDR, RegisterFields359_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo360_DDR, RegisterFields360_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo361_DDR, RegisterFields361_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo362_DDR, RegisterFields362_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo363_DDR, RegisterFields363_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo364_DDR, RegisterFields364_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo365_DDR, RegisterFields365_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo366_DDR, RegisterFields366_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo367_DDR, RegisterFields367_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo368_DDR, RegisterFields368_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo369_DDR, RegisterFields369_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo370_DDR, RegisterFields370_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo371_DDR, RegisterFields371_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo372_DDR, RegisterFields372_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo373_DDR, RegisterFields373_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo374_DDR, RegisterFields374_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo375_DDR, RegisterFields375_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo376_DDR, RegisterFields376_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo377_DDR, RegisterFields377_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo378_DDR, RegisterFields378_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo379_DDR, RegisterFields379_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo380_DDR, RegisterFields380_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo381_DDR, RegisterFields381_DDR}, // DDRD0_N0_CH0_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo382_DDR, RegisterFields382_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo383_DDR, RegisterFields383_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo384_DDR, RegisterFields384_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo385_DDR, RegisterFields385_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo386_DDR, RegisterFields386_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo387_DDR, RegisterFields387_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo388_DDR, RegisterFields388_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo389_DDR, RegisterFields389_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo390_DDR, RegisterFields390_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo391_DDR, RegisterFields391_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo392_DDR, RegisterFields392_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo393_DDR, RegisterFields393_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo394_DDR, RegisterFields394_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo395_DDR, RegisterFields395_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo396_DDR, RegisterFields396_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo397_DDR, RegisterFields397_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo398_DDR, RegisterFields398_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo399_DDR, RegisterFields399_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo400_DDR, RegisterFields400_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo401_DDR, RegisterFields401_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo402_DDR, RegisterFields402_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo403_DDR, RegisterFields403_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo404_DDR, RegisterFields404_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo405_DDR, RegisterFields405_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo406_DDR, RegisterFields406_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo407_DDR, RegisterFields407_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo408_DDR, RegisterFields408_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo409_DDR, RegisterFields409_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo410_DDR, RegisterFields410_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo411_DDR, RegisterFields411_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo412_DDR, RegisterFields412_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo413_DDR, RegisterFields413_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo414_DDR, RegisterFields414_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo415_DDR, RegisterFields415_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo416_DDR, RegisterFields416_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo417_DDR, RegisterFields417_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo418_DDR, RegisterFields418_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo419_DDR, RegisterFields419_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo420_DDR, RegisterFields420_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo421_DDR, RegisterFields421_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo422_DDR, RegisterFields422_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo423_DDR, RegisterFields423_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo424_DDR, RegisterFields424_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo425_DDR, RegisterFields425_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo426_DDR, RegisterFields426_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo427_DDR, RegisterFields427_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo428_DDR, RegisterFields428_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo429_DDR, RegisterFields429_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo430_DDR, RegisterFields430_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo431_DDR, RegisterFields431_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo432_DDR, RegisterFields432_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo433_DDR, RegisterFields433_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo434_DDR, RegisterFields434_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo435_DDR, RegisterFields435_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo436_DDR, RegisterFields436_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo437_DDR, RegisterFields437_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo438_DDR, RegisterFields438_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo439_DDR, RegisterFields439_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo440_DDR, RegisterFields440_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo441_DDR, RegisterFields441_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo442_DDR, RegisterFields442_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo443_DDR, RegisterFields443_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo444_DDR, RegisterFields444_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo445_DDR, RegisterFields445_DDR}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo446_DDR, RegisterFields446_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo447_DDR, RegisterFields447_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo448_DDR, RegisterFields448_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo449_DDR, RegisterFields449_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo450_DDR, RegisterFields450_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo451_DDR, RegisterFields451_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo452_DDR, RegisterFields452_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo453_DDR, RegisterFields453_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo454_DDR, RegisterFields454_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo455_DDR, RegisterFields455_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo456_DDR, RegisterFields456_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo457_DDR, RegisterFields457_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo458_DDR, RegisterFields458_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo459_DDR, RegisterFields459_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo460_DDR, RegisterFields460_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo461_DDR, RegisterFields461_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo462_DDR, RegisterFields462_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo463_DDR, RegisterFields463_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo464_DDR, RegisterFields464_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo465_DDR, RegisterFields465_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo466_DDR, RegisterFields466_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo467_DDR, RegisterFields467_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo468_DDR, RegisterFields468_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo469_DDR, RegisterFields469_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo470_DDR, RegisterFields470_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo471_DDR, RegisterFields471_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo472_DDR, RegisterFields472_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo473_DDR, RegisterFields473_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo474_DDR, RegisterFields474_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo475_DDR, RegisterFields475_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo476_DDR, RegisterFields476_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo477_DDR, RegisterFields477_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo478_DDR, RegisterFields478_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo479_DDR, RegisterFields479_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo480_DDR, RegisterFields480_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo481_DDR, RegisterFields481_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo482_DDR, RegisterFields482_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo483_DDR, RegisterFields483_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo484_DDR, RegisterFields484_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo485_DDR, RegisterFields485_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo486_DDR, RegisterFields486_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo487_DDR, RegisterFields487_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo488_DDR, RegisterFields488_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo489_DDR, RegisterFields489_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo490_DDR, RegisterFields490_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo491_DDR, RegisterFields491_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo492_DDR, RegisterFields492_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo493_DDR, RegisterFields493_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo494_DDR, RegisterFields494_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo495_DDR, RegisterFields495_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo496_DDR, RegisterFields496_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo497_DDR, RegisterFields497_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo498_DDR, RegisterFields498_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo499_DDR, RegisterFields499_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo500_DDR, RegisterFields500_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo501_DDR, RegisterFields501_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo502_DDR, RegisterFields502_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo503_DDR, RegisterFields503_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo504_DDR, RegisterFields504_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo505_DDR, RegisterFields505_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo506_DDR, RegisterFields506_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo507_DDR, RegisterFields507_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo508_DDR, RegisterFields508_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo509_DDR, RegisterFields509_DDR}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo510_DDR, RegisterFields510_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo511_DDR, RegisterFields511_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo512_DDR, RegisterFields512_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo513_DDR, RegisterFields513_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo514_DDR, RegisterFields514_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo515_DDR, RegisterFields515_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo516_DDR, RegisterFields516_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo517_DDR, RegisterFields517_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo518_DDR, RegisterFields518_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo519_DDR, RegisterFields519_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo520_DDR, RegisterFields520_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo521_DDR, RegisterFields521_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo522_DDR, RegisterFields522_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo523_DDR, RegisterFields523_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo524_DDR, RegisterFields524_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo525_DDR, RegisterFields525_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo526_DDR, RegisterFields526_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo527_DDR, RegisterFields527_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo528_DDR, RegisterFields528_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo529_DDR, RegisterFields529_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo530_DDR, RegisterFields530_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo531_DDR, RegisterFields531_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo532_DDR, RegisterFields532_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo533_DDR, RegisterFields533_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo534_DDR, RegisterFields534_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo535_DDR, RegisterFields535_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo536_DDR, RegisterFields536_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo537_DDR, RegisterFields537_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo538_DDR, RegisterFields538_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo539_DDR, RegisterFields539_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo540_DDR, RegisterFields540_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo541_DDR, RegisterFields541_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo542_DDR, RegisterFields542_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo543_DDR, RegisterFields543_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo544_DDR, RegisterFields544_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo545_DDR, RegisterFields545_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo546_DDR, RegisterFields546_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo547_DDR, RegisterFields547_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo548_DDR, RegisterFields548_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo549_DDR, RegisterFields549_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo550_DDR, RegisterFields550_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo551_DDR, RegisterFields551_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo552_DDR, RegisterFields552_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo553_DDR, RegisterFields553_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo554_DDR, RegisterFields554_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo555_DDR, RegisterFields555_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo556_DDR, RegisterFields556_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo557_DDR, RegisterFields557_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo558_DDR, RegisterFields558_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo559_DDR, RegisterFields559_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo560_DDR, RegisterFields560_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo561_DDR, RegisterFields561_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo562_DDR, RegisterFields562_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo563_DDR, RegisterFields563_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo564_DDR, RegisterFields564_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo565_DDR, RegisterFields565_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo566_DDR, RegisterFields566_DDR}, // DDRD1_N0_CH0_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo567_DDR, RegisterFields567_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo568_DDR, RegisterFields568_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo569_DDR, RegisterFields569_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo570_DDR, RegisterFields570_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo571_DDR, RegisterFields571_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo572_DDR, RegisterFields572_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo573_DDR, RegisterFields573_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo574_DDR, RegisterFields574_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo575_DDR, RegisterFields575_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo576_DDR, RegisterFields576_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo577_DDR, RegisterFields577_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo578_DDR, RegisterFields578_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo579_DDR, RegisterFields579_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo580_DDR, RegisterFields580_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo581_DDR, RegisterFields581_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo582_DDR, RegisterFields582_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo583_DDR, RegisterFields583_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo584_DDR, RegisterFields584_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo585_DDR, RegisterFields585_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo586_DDR, RegisterFields586_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo587_DDR, RegisterFields587_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo588_DDR, RegisterFields588_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo589_DDR, RegisterFields589_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo590_DDR, RegisterFields590_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo591_DDR, RegisterFields591_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo592_DDR, RegisterFields592_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo593_DDR, RegisterFields593_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo594_DDR, RegisterFields594_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo595_DDR, RegisterFields595_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo596_DDR, RegisterFields596_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo597_DDR, RegisterFields597_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo598_DDR, RegisterFields598_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo599_DDR, RegisterFields599_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo600_DDR, RegisterFields600_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo601_DDR, RegisterFields601_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo602_DDR, RegisterFields602_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo603_DDR, RegisterFields603_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo604_DDR, RegisterFields604_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo605_DDR, RegisterFields605_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo606_DDR, RegisterFields606_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo607_DDR, RegisterFields607_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo608_DDR, RegisterFields608_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo609_DDR, RegisterFields609_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo610_DDR, RegisterFields610_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo611_DDR, RegisterFields611_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo612_DDR, RegisterFields612_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo613_DDR, RegisterFields613_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo614_DDR, RegisterFields614_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo615_DDR, RegisterFields615_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo616_DDR, RegisterFields616_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo617_DDR, RegisterFields617_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo618_DDR, RegisterFields618_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo619_DDR, RegisterFields619_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo620_DDR, RegisterFields620_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo621_DDR, RegisterFields621_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo622_DDR, RegisterFields622_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo623_DDR, RegisterFields623_DDR}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo624_DDR, RegisterFields624_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo625_DDR, RegisterFields625_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo626_DDR, RegisterFields626_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo627_DDR, RegisterFields627_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo628_DDR, RegisterFields628_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo629_DDR, RegisterFields629_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo630_DDR, RegisterFields630_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo631_DDR, RegisterFields631_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo632_DDR, RegisterFields632_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo633_DDR, RegisterFields633_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo634_DDR, RegisterFields634_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo635_DDR, RegisterFields635_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo636_DDR, RegisterFields636_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo637_DDR, RegisterFields637_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo638_DDR, RegisterFields638_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo639_DDR, RegisterFields639_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo640_DDR, RegisterFields640_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo641_DDR, RegisterFields641_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo642_DDR, RegisterFields642_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo643_DDR, RegisterFields643_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo644_DDR, RegisterFields644_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo645_DDR, RegisterFields645_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo646_DDR, RegisterFields646_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo647_DDR, RegisterFields647_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo648_DDR, RegisterFields648_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo649_DDR, RegisterFields649_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo650_DDR, RegisterFields650_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo651_DDR, RegisterFields651_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo652_DDR, RegisterFields652_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo653_DDR, RegisterFields653_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo654_DDR, RegisterFields654_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo655_DDR, RegisterFields655_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo656_DDR, RegisterFields656_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo657_DDR, RegisterFields657_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo658_DDR, RegisterFields658_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo659_DDR, RegisterFields659_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo660_DDR, RegisterFields660_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo661_DDR, RegisterFields661_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo662_DDR, RegisterFields662_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo663_DDR, RegisterFields663_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo664_DDR, RegisterFields664_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo665_DDR, RegisterFields665_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo666_DDR, RegisterFields666_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo667_DDR, RegisterFields667_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo668_DDR, RegisterFields668_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo669_DDR, RegisterFields669_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo670_DDR, RegisterFields670_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo671_DDR, RegisterFields671_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo672_DDR, RegisterFields672_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo673_DDR, RegisterFields673_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo674_DDR, RegisterFields674_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo675_DDR, RegisterFields675_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo676_DDR, RegisterFields676_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo677_DDR, RegisterFields677_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo678_DDR, RegisterFields678_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo679_DDR, RegisterFields679_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo680_DDR, RegisterFields680_DDR}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo681_DDR, RegisterFields681_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo682_DDR, RegisterFields682_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo683_DDR, RegisterFields683_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo684_DDR, RegisterFields684_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo685_DDR, RegisterFields685_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo686_DDR, RegisterFields686_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo687_DDR, RegisterFields687_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo688_DDR, RegisterFields688_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo689_DDR, RegisterFields689_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo690_DDR, RegisterFields690_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo691_DDR, RegisterFields691_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo692_DDR, RegisterFields692_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo693_DDR, RegisterFields693_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo694_DDR, RegisterFields694_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo695_DDR, RegisterFields695_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo696_DDR, RegisterFields696_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo697_DDR, RegisterFields697_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo698_DDR, RegisterFields698_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo699_DDR, RegisterFields699_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo700_DDR, RegisterFields700_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo701_DDR, RegisterFields701_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo702_DDR, RegisterFields702_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo703_DDR, RegisterFields703_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo704_DDR, RegisterFields704_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo705_DDR, RegisterFields705_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo706_DDR, RegisterFields706_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo707_DDR, RegisterFields707_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo708_DDR, RegisterFields708_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo709_DDR, RegisterFields709_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo710_DDR, RegisterFields710_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo711_DDR, RegisterFields711_DDR}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo712_DDR, RegisterFields712_DDR}, // DDRINTF_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo713_DDR, RegisterFields713_DDR}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo714_DDR, RegisterFields714_DDR}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo715_DDR, RegisterFields715_DDR}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo716_DDR, RegisterFields716_DDR}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo717_DDR, RegisterFields717_DDR}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo718_DDR, RegisterFields718_DDR}, // DDRSAI_DDRSAI_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo719_DDR, RegisterFields719_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo720_DDR, RegisterFields720_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo721_DDR, RegisterFields721_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo722_DDR, RegisterFields722_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo723_DDR, RegisterFields723_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo724_DDR, RegisterFields724_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo725_DDR, RegisterFields725_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo726_DDR, RegisterFields726_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo727_DDR, RegisterFields727_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo728_DDR, RegisterFields728_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo729_DDR, RegisterFields729_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo730_DDR, RegisterFields730_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo731_DDR, RegisterFields731_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo732_DDR, RegisterFields732_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo733_DDR, RegisterFields733_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo734_DDR, RegisterFields734_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo735_DDR, RegisterFields735_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo736_DDR, RegisterFields736_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo737_DDR, RegisterFields737_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo738_DDR, RegisterFields738_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo739_DDR, RegisterFields739_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo740_DDR, RegisterFields740_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo741_DDR, RegisterFields741_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo742_DDR, RegisterFields742_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo743_DDR, RegisterFields743_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo744_DDR, RegisterFields744_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo745_DDR, RegisterFields745_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo746_DDR, RegisterFields746_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo747_DDR, RegisterFields747_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo748_DDR, RegisterFields748_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo749_DDR, RegisterFields749_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo750_DDR, RegisterFields750_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo751_DDR, RegisterFields751_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo752_DDR, RegisterFields752_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo753_DDR, RegisterFields753_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo754_DDR, RegisterFields754_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo755_DDR, RegisterFields755_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo756_DDR, RegisterFields756_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo757_DDR, RegisterFields757_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo758_DDR, RegisterFields758_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo759_DDR, RegisterFields759_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo760_DDR, RegisterFields760_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo761_DDR, RegisterFields761_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo762_DDR, RegisterFields762_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo763_DDR, RegisterFields763_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo764_DDR, RegisterFields764_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo765_DDR, RegisterFields765_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo766_DDR, RegisterFields766_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo767_DDR, RegisterFields767_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo768_DDR, RegisterFields768_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo769_DDR, RegisterFields769_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo770_DDR, RegisterFields770_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo771_DDR, RegisterFields771_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo772_DDR, RegisterFields772_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo773_DDR, RegisterFields773_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo774_DDR, RegisterFields774_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo775_DDR, RegisterFields775_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo776_DDR, RegisterFields776_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo777_DDR, RegisterFields777_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo778_DDR, RegisterFields778_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo779_DDR, RegisterFields779_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo780_DDR, RegisterFields780_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo781_DDR, RegisterFields781_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo782_DDR, RegisterFields782_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo783_DDR, RegisterFields783_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo784_DDR, RegisterFields784_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo785_DDR, RegisterFields785_DDR}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo786_DDR, RegisterFields786_DDR}, // MCMISC_MEM_MCMISC_CSR
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo787_DDR, RegisterFields787_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo788_DDR, RegisterFields788_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo789_DDR, RegisterFields789_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo790_DDR, RegisterFields790_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo791_DDR, RegisterFields791_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo792_DDR, RegisterFields792_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo793_DDR, RegisterFields793_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo794_DDR, RegisterFields794_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo795_DDR, RegisterFields795_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo796_DDR, RegisterFields796_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo797_DDR, RegisterFields797_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo798_DDR, RegisterFields798_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo799_DDR, RegisterFields799_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo800_DDR, RegisterFields800_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo801_DDR, RegisterFields801_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo802_DDR, RegisterFields802_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo803_DDR, RegisterFields803_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo804_DDR, RegisterFields804_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo805_DDR, RegisterFields805_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo806_DDR, RegisterFields806_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo807_DDR, RegisterFields807_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo808_DDR, RegisterFields808_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo809_DDR, RegisterFields809_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo810_DDR, RegisterFields810_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo811_DDR, RegisterFields811_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo812_DDR, RegisterFields812_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo813_DDR, RegisterFields813_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo814_DDR, RegisterFields814_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo815_DDR, RegisterFields815_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo816_DDR, RegisterFields816_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo817_DDR, RegisterFields817_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo818_DDR, RegisterFields818_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo819_DDR, RegisterFields819_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo820_DDR, RegisterFields820_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo821_DDR, RegisterFields821_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo822_DDR, RegisterFields822_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo823_DDR, RegisterFields823_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo824_DDR, RegisterFields824_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo825_DDR, RegisterFields825_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo826_DDR, RegisterFields826_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo827_DDR, RegisterFields827_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo828_DDR, RegisterFields828_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo829_DDR, RegisterFields829_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo830_DDR, RegisterFields830_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo831_DDR, RegisterFields831_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo832_DDR, RegisterFields832_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo833_DDR, RegisterFields833_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo834_DDR, RegisterFields834_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo835_DDR, RegisterFields835_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo836_DDR, RegisterFields836_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo837_DDR, RegisterFields837_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo838_DDR, RegisterFields838_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo839_DDR, RegisterFields839_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo840_DDR, RegisterFields840_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo841_DDR, RegisterFields841_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo842_DDR, RegisterFields842_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo843_DDR, RegisterFields843_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo844_DDR, RegisterFields844_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo845_DDR, RegisterFields845_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo846_DDR, RegisterFields846_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo847_DDR, RegisterFields847_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo848_DDR, RegisterFields848_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo849_DDR, RegisterFields849_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo850_DDR, RegisterFields850_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo851_DDR, RegisterFields851_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo852_DDR, RegisterFields852_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo853_DDR, RegisterFields853_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo854_DDR, RegisterFields854_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo855_DDR, RegisterFields855_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo856_DDR, RegisterFields856_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo857_DDR, RegisterFields857_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo858_DDR, RegisterFields858_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo859_DDR, RegisterFields859_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo860_DDR, RegisterFields860_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo861_DDR, RegisterFields861_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo862_DDR, RegisterFields862_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo863_DDR, RegisterFields863_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo864_DDR, RegisterFields864_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo865_DDR, RegisterFields865_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo866_DDR, RegisterFields866_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo867_DDR, RegisterFields867_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo868_DDR, RegisterFields868_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo869_DDR, RegisterFields869_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo870_DDR, RegisterFields870_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo871_DDR, RegisterFields871_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo872_DDR, RegisterFields872_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo873_DDR, RegisterFields873_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo874_DDR, RegisterFields874_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo875_DDR, RegisterFields875_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo876_DDR, RegisterFields876_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo877_DDR, RegisterFields877_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo878_DDR, RegisterFields878_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo879_DDR, RegisterFields879_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo880_DDR, RegisterFields880_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo881_DDR, RegisterFields881_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo882_DDR, RegisterFields882_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo883_DDR, RegisterFields883_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo884_DDR, RegisterFields884_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo885_DDR, RegisterFields885_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo886_DDR, RegisterFields886_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo887_DDR, RegisterFields887_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo888_DDR, RegisterFields888_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo889_DDR, RegisterFields889_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo890_DDR, RegisterFields890_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo891_DDR, RegisterFields891_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo892_DDR, RegisterFields892_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo893_DDR, RegisterFields893_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo894_DDR, RegisterFields894_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo895_DDR, RegisterFields895_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo896_DDR, RegisterFields896_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo897_DDR, RegisterFields897_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo898_DDR, RegisterFields898_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo899_DDR, RegisterFields899_DDR}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo900_DDR, RegisterFields900_DDR}, // MC_DEC_MEM_CSR
{NULL, NULL},
#else
  {(RegisterInformation *)&RegisterInfo0_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo1_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo2_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo3_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo4_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo5_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo6_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo7_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo8_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo9_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo10_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo11_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo12_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo13_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo14_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo15_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo16_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo17_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo18_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo19_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo20_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo21_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo22_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo23_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo24_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo25_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo26_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo27_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo28_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo29_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo30_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo31_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo32_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo33_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo34_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo35_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo36_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo37_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo38_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo39_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo40_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo41_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo42_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo43_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo44_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo45_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo46_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo47_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo48_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo49_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo50_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo51_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo52_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo53_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo54_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo55_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo56_DDR, NULL}, // DDRCC0_CH0_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo57_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo58_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo59_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo60_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo61_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo62_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo63_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo64_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo65_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo66_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo67_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo68_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo69_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo70_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo71_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo72_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo73_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo74_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo75_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo76_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo77_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo78_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo79_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo80_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo81_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo82_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo83_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo84_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo85_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo86_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo87_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo88_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo89_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo90_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo91_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo92_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo93_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo94_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo95_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo96_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo97_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo98_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo99_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo100_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo101_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo102_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo103_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo104_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo105_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo106_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo107_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo108_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo109_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo110_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo111_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo112_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo113_DDR, NULL}, // DDRCC0_CH0A_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo114_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo115_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo116_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo117_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo118_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo119_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo120_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo121_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo122_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo123_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo124_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo125_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo126_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo127_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo128_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo129_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo130_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo131_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo132_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo133_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo134_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo135_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo136_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo137_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo138_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo139_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo140_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo141_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo142_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo143_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo144_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo145_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo146_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo147_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo148_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo149_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo150_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo151_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo152_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo153_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo154_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo155_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo156_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo157_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo158_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo159_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo160_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo161_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo162_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo163_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo164_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo165_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo166_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo167_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo168_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo169_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
  {(RegisterInformation *)&RegisterInfo170_DDR, NULL}, // DDRCC0_CHALL_DDRCC0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo171_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo172_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo173_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo174_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo175_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo176_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo177_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo178_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo179_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo180_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo181_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo182_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo183_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo184_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo185_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo186_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo187_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo188_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo189_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo190_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo191_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo192_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo193_DDR, NULL}, // DDRCC1_CH0_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo194_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo195_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo196_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo197_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo198_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo199_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo200_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo201_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo202_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo203_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo204_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo205_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo206_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo207_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo208_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo209_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo210_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo211_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo212_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo213_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo214_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo215_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo216_DDR, NULL}, // DDRCC1_CH0A_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo217_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo218_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo219_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo220_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo221_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo222_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo223_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo224_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo225_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo226_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo227_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo228_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo229_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo230_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo231_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo232_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo233_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo234_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo235_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo236_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo237_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo238_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
  {(RegisterInformation *)&RegisterInfo239_DDR, NULL}, // DDRCC1_CHALL_DDRCC1_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo240_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo241_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo242_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo243_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo244_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo245_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo246_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo247_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo248_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo249_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo250_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo251_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo252_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo253_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo254_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo255_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo256_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo257_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo258_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo259_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo260_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo261_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo262_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo263_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo264_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo265_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo266_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo267_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo268_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo269_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo270_DDR, NULL}, // DDRCLK_CH0_MEM
  {(RegisterInformation *)&RegisterInfo271_DDR, NULL}, // DDRCLK_CH0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo272_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo273_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo274_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo275_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo276_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo277_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo278_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo279_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo280_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo281_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo282_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo283_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo284_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo285_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo286_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo287_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo288_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo289_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo290_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo291_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo292_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo293_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo294_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo295_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo296_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo297_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo298_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo299_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo300_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo301_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo302_DDR, NULL}, // DDRCLK_CHALL_MEM
  {(RegisterInformation *)&RegisterInfo303_DDR, NULL}, // DDRCLK_CHALL_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo304_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo305_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo306_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo307_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo308_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo309_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo310_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo311_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo312_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo313_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo314_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo315_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo316_DDR, NULL}, // DDRCOMP_MEM
  {(RegisterInformation *)&RegisterInfo317_DDR, NULL}, // DDRCOMP_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo318_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo319_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo320_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo321_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo322_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo323_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo324_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo325_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo326_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo327_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo328_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo329_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo330_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo331_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo332_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo333_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo334_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo335_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo336_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo337_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo338_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo339_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo340_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo341_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo342_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo343_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo344_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo345_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo346_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo347_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo348_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo349_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo350_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo351_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo352_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo353_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo354_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo355_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo356_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo357_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo358_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo359_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo360_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo361_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo362_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo363_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo364_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo365_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo366_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo367_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo368_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo369_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo370_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo371_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo372_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo373_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo374_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo375_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo376_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo377_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo378_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo379_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo380_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo381_DDR, NULL}, // DDRD0_N0_CH0_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo382_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo383_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo384_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo385_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo386_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo387_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo388_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo389_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo390_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo391_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo392_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo393_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo394_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo395_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo396_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo397_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo398_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo399_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo400_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo401_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo402_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo403_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo404_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo405_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo406_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo407_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo408_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo409_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo410_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo411_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo412_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo413_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo414_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo415_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo416_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo417_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo418_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo419_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo420_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo421_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo422_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo423_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo424_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo425_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo426_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo427_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo428_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo429_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo430_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo431_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo432_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo433_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo434_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo435_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo436_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo437_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo438_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo439_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo440_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo441_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo442_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo443_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo444_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo445_DDR, NULL}, // DDRD0_N0_CH0A_0_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo446_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo447_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo448_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo449_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo450_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo451_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo452_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo453_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo454_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo455_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo456_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo457_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo458_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo459_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo460_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo461_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo462_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo463_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo464_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo465_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo466_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo467_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo468_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo469_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo470_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo471_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo472_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo473_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo474_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo475_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo476_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo477_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo478_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo479_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo480_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo481_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo482_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo483_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo484_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo485_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo486_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo487_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo488_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo489_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo490_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo491_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo492_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo493_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo494_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo495_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo496_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo497_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo498_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo499_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo500_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo501_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo502_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo503_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo504_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo505_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo506_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo507_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo508_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
  {(RegisterInformation *)&RegisterInfo509_DDR, NULL}, // DDRD0_N0_CHALL_DDRD0_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo510_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo511_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo512_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo513_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo514_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo515_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo516_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo517_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo518_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo519_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo520_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo521_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo522_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo523_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo524_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo525_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo526_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo527_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo528_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo529_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo530_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo531_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo532_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo533_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo534_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo535_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo536_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo537_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo538_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo539_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo540_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo541_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo542_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo543_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo544_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo545_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo546_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo547_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo548_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo549_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo550_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo551_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo552_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo553_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo554_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo555_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo556_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo557_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo558_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo559_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo560_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo561_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo562_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo563_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo564_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo565_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo566_DDR, NULL}, // DDRD1_N0_CH0_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo567_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo568_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo569_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo570_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo571_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo572_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo573_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo574_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo575_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo576_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo577_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo578_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo579_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo580_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo581_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo582_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo583_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo584_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo585_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo586_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo587_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo588_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo589_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo590_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo591_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo592_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo593_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo594_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo595_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo596_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo597_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo598_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo599_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo600_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo601_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo602_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo603_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo604_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo605_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo606_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo607_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo608_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo609_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo610_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo611_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo612_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo613_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo614_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo615_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo616_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo617_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo618_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo619_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo620_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo621_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo622_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo623_DDR, NULL}, // DDRD1_N0_CH0A_0_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo624_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo625_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo626_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo627_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo628_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo629_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo630_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo631_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo632_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo633_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo634_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo635_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo636_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo637_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo638_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo639_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo640_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo641_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo642_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo643_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo644_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo645_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo646_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo647_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo648_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo649_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo650_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo651_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo652_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo653_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo654_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo655_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo656_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo657_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo658_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo659_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo660_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo661_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo662_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo663_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo664_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo665_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo666_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo667_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo668_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo669_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo670_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo671_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo672_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo673_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo674_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo675_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo676_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo677_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo678_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo679_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
  {(RegisterInformation *)&RegisterInfo680_DDR, NULL}, // DDRD1_N0_CHALL_DDRD1_N0_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo681_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo682_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo683_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo684_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo685_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo686_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo687_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo688_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo689_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo690_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo691_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo692_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo693_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo694_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo695_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo696_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo697_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo698_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo699_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo700_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo701_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo702_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo703_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo704_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo705_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo706_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo707_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo708_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo709_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo710_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo711_DDR, NULL}, // DDRINTF_MEM
  {(RegisterInformation *)&RegisterInfo712_DDR, NULL}, // DDRINTF_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo713_DDR, NULL}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo714_DDR, NULL}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo715_DDR, NULL}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo716_DDR, NULL}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo717_DDR, NULL}, // DDRSAI_DDRSAI_MEM
  {(RegisterInformation *)&RegisterInfo718_DDR, NULL}, // DDRSAI_DDRSAI_MEM
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo719_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo720_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo721_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo722_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo723_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo724_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo725_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo726_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo727_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo728_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo729_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo730_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo731_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo732_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo733_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo734_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo735_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo736_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo737_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo738_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo739_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo740_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo741_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo742_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo743_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo744_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo745_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo746_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo747_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo748_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo749_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo750_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo751_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo752_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo753_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo754_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo755_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo756_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo757_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo758_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo759_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo760_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo761_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo762_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo763_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo764_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo765_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo766_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo767_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo768_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo769_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo770_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo771_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo772_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo773_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo774_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo775_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo776_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo777_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo778_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo779_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo780_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo781_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo782_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo783_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo784_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo785_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
  {(RegisterInformation *)&RegisterInfo786_DDR, NULL}, // MCMISC_MEM_MCMISC_CSR
{NULL, NULL},
  {(RegisterInformation *)&RegisterInfo787_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo788_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo789_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo790_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo791_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo792_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo793_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo794_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo795_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo796_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo797_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo798_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo799_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo800_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo801_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo802_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo803_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo804_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo805_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo806_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo807_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo808_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo809_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo810_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo811_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo812_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo813_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo814_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo815_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo816_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo817_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo818_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo819_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo820_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo821_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo822_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo823_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo824_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo825_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo826_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo827_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo828_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo829_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo830_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo831_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo832_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo833_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo834_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo835_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo836_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo837_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo838_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo839_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo840_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo841_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo842_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo843_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo844_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo845_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo846_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo847_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo848_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo849_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo850_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo851_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo852_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo853_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo854_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo855_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo856_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo857_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo858_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo859_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo860_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo861_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo862_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo863_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo864_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo865_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo866_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo867_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo868_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo869_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo870_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo871_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo872_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo873_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo874_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo875_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo876_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo877_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo878_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo879_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo880_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo881_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo882_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo883_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo884_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo885_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo886_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo887_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo888_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo889_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo890_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo891_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo892_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo893_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo894_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo895_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo896_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo897_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo898_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo899_DDR, NULL}, // MC_DEC_MEM_CSR
  {(RegisterInformation *)&RegisterInfo900_DDR, NULL}, // MC_DEC_MEM_CSR
{NULL, NULL},
#endif // DUMP_REGISTER_FIELDS_DDR
};

#else
Register Registers_DDR[] = {{NULL, NULL}};
#endif // DUMP_REGISTER_NAMES_DDR

