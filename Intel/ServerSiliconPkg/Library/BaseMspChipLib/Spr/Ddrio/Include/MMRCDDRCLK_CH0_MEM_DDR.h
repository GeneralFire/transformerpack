/** @file
  File name:    MMRCDDRCLK_CH0_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRCLK_CH0_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRCLK_CH0_MEM_DDR_H_DDR_
#define _MMRCDDRCLK_CH0_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRCLK_CTL0_PAIR_0__DDRCLK_CH0_MEM_REG_DDR         0x00012C00
typedef union {
  struct {
    //
    // CLK delay with step size of clkpi/128.[br]
    //                     This value is added with clk_piref_offset and piref_setup_adj
    // to generate the clk_pio_code before send to DLL , so the programed value is relative
    // to the piref odd clock.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: Each clock pair P/N pin share the same delay.[br]
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 clk_dly : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 clk_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br] 
    //                     0: CLK IO is used for RX [br]
    //                     1: CLK IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control.
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 io_dir : 1;
    //
    // Enables output buffers, PI clocks and output datapaths for this clock pair.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 clk_pair_en : 1;
    //
    // In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This
    // bit sets the RXFIFO pointer initialization value. 
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state (DDRT ERID ONLY)[br]
    //                     1: pull low
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // ODT enable per clock pair
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // Senseamp enable per clock pair
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 8;
    //
    // Set to 1 to enable HW to generate PRBS7 pattern for ACIO loopback testing else
    // HW will select clock pattern instead. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_PAIR_0__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_PAIR_1__DDRCLK_CH0_MEM_REG_DDR         0x00012C04
typedef union {
  struct {
    //
    // CLK delay with step size of clkpi/128.[br]
    //                     This value is added with clk_piref_offset and piref_setup_adj
    // to generate the clk_pio_code before send to DLL , so the programed value is relative
    // to the piref odd clock.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: Each clock pair P/N pin share the same delay.[br]
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 clk_dly : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 clk_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br] 
    //                     0: CLK IO is used for RX [br]
    //                     1: CLK IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control.
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 io_dir : 1;
    //
    // Enables output buffers, PI clocks and output datapaths for this clock pair.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 clk_pair_en : 1;
    //
    // In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This
    // bit sets the RXFIFO pointer initialization value. 
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state (DDRT ERID ONLY)[br]
    //                     1: pull low
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // ODT enable per clock pair
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // Senseamp enable per clock pair
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 8;
    //
    // Set to 1 to enable HW to generate PRBS7 pattern for ACIO loopback testing else
    // HW will select clock pattern instead. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_PAIR_1__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_PAIR_2__DDRCLK_CH0_MEM_REG_DDR         0x00012C08
typedef union {
  struct {
    //
    // CLK delay with step size of clkpi/128.[br]
    //                     This value is added with clk_piref_offset and piref_setup_adj
    // to generate the clk_pio_code before send to DLL , so the programed value is relative
    // to the piref odd clock.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: Each clock pair P/N pin share the same delay.[br]
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 clk_dly : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 clk_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br] 
    //                     0: CLK IO is used for RX [br]
    //                     1: CLK IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control.
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 io_dir : 1;
    //
    // Enables output buffers, PI clocks and output datapaths for this clock pair.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 clk_pair_en : 1;
    //
    // In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This
    // bit sets the RXFIFO pointer initialization value. 
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state (DDRT ERID ONLY)[br]
    //                     1: pull low
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // ODT enable per clock pair
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // Senseamp enable per clock pair
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 8;
    //
    // Set to 1 to enable HW to generate PRBS7 pattern for ACIO loopback testing else
    // HW will select clock pattern instead. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_PAIR_2__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_PAIR_3__DDRCLK_CH0_MEM_REG_DDR         0x00012C0C
typedef union {
  struct {
    //
    // CLK delay with step size of clkpi/128.[br]
    //                     This value is added with clk_piref_offset and piref_setup_adj
    // to generate the clk_pio_code before send to DLL , so the programed value is relative
    // to the piref odd clock.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: Each clock pair P/N pin share the same delay.[br]
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 clk_dly : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the clk_pio_code. The result is the clk pi even code (clk_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 clk_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and enable senseamp/ODT (RX).[br] 
    //                     0: CLK IO is used for RX [br]
    //                     1: CLK IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control.
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 io_dir : 1;
    //
    // Enables output buffers, PI clocks and output datapaths for this clock pair.
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 clk_pair_en : 1;
    //
    // In DDRT mode, two clock paris are assigned to receive ERID for slot 0/1. This
    // bit sets the RXFIFO pointer initialization value. 
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state (DDRT ERID ONLY)[br]
    //                     1: pull low
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // ODT enable per clock pair
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // Senseamp enable per clock pair
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 8;
    //
    // Set to 1 to enable HW to generate PRBS7 pattern for ACIO loopback testing else
    // HW will select clock pattern instead. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_PAIR_3__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_RXVREF_CTL_DDRCLK_CH0_MEM_REG_DDR           0x00012C20
typedef union {
  struct {
    //
    // RX Vref control with step size is vccddr_hv/256. Default is 75% vccddr_hv.
    // 
    // Bits[7:0], RW, default = 0xBF
    //
    UINT32 rx_vref_ctl : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 23;
    //
    // enable RX Vref Dfx output for ADC measurement.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_RXVREF_CTL_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_COMP_LA0_DDRCLK_CH0_MEM_REG_DDR             0x00012C24
typedef union {
  struct {
    //
    // Clk Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_up_adj (signed number.
    // Range is -8 to 7) before send it to the clkbuf.[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[4:0], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Clk Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_dn_adj (signed number.
    // Range is -8 to 7) before send it to the clkbuf.[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[11:7], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 20;
  } Bits;
  UINT32 Data;
} DDRCLK_COMP_LA0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_COMP_LA1_DDRCLK_CH0_MEM_REG_DDR             0x00012C28
typedef union {
  struct {
    //
    // Clk TCO Comp Value. It is programmed by BIOS but it is not trained.[br]
    //                     0/64: fastest rise & fall delay[br]
    //                     0->31: increasing fall delay[br]
    //                     64->95: increasing rise delay[br]
    //                     Other values are not used (32-63 & 96-127).[br]
    //                     To get monotonic increasing sweep of dutycycle, sweep from
    // (95 to 65, 0 to 31) 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 tco_comp : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Clk Slew Rate Comp Value.[br]
    //                     It is program by BIOS but it is not trained.[br]
    //                     0 is fastest slew rate, 31 is slowest slew rate.[br]
    //                     The SCOMP Up/Down Code are generated from the following equation:[br]
    //                     SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]
    //                     SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]
    //                     Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down
    // adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINT32 scomp : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 19;
  } Bits;
  UINT32 Data;
} DDRCLK_COMP_LA1_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_COMP_OFFSET_DDRCLK_CH0_MEM_REG_DDR          0x00012C2C
typedef union {
  struct {
    //
    // Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 rcomp_drv_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINT32 rcomp_drv_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 11;
    //
    // Signed number add to scomp to generate the SCOMP Up Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 scomp_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Signed number add to scomp to generate the SCOMP Down Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[28:25], RW, default = 0x0
    //
    UINT32 scomp_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 3;
  } Bits;
  UINT32 Data;
} DDRCLK_COMP_OFFSET_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_DLL_PI_TEST_ADC_DDRCLK_CH0_MEM_REG_DDR      0x00012C30
typedef union {
  struct {
    //
    // Sets to 1 to run test.  SW must clear the bit to stop the test. HW detects deassertion
    // of this control bit to load the pifsm_cnt. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Load the load_cnt CR value  into the PI FSM
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count (0 to 1023 with step
    // size of ~1pS).  Mutex with ModeHVM/ModeADC. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV). Mutex with ModeHVM/ModeDV. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // Load FSM with a starting point for count
    // 
    // Bits[14:5], RW, default = 0x0
    //
    UINT32 reserved_5 : 10;
    //
    // Current Count code from the PI FSM (Read Only)
    // 
    // Bits[24:15], RO/V, default = 0x0
    //
    UINT32 reserved_6 : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} DDRCLK_DLL_PI_TEST_ADC_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_DLL_CSR_DDRCLK_CH0_MEM_REG_DDR              0x00012C34
typedef union {
  struct {
    //
    // DLL Deterministic Lock Status
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 detrm_lock : 1;
    //
    // DLL Raw Lock Status Sticky bit.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 raw_lock : 1;
    //
    // DLL Lock timeout.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 lock_timeout : 1;
    //
    // DLL Reset.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 dll_reset : 1;
    //
    // DLL ADC out.
    // 
    // Bits[13:4], RO/V, default = 0x0
    //
    UINT32 adcout : 10;
    //
    // DLL Long Lock Status.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 long_lock : 1;
    //
    // Detect lock CBB early lock sticky output
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 detlock_earlylockstky : 1;
    //
    // DLL Weak Lock Status.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 weak_lock : 1;
    //
    // DLL ADC done.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 adc_done : 1;
    //
    // DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register,
    // clock gating must be disabled. 
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 pilags : 1;
    //
    // MDLL open loop output
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 openloop : 1;
    //
    // Detect lock CBB lock reset output
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 lockrst_b : 1;
    //
    // BIOS should configure certain analog components based on the value of this register.[br]
    //                     Details will be found in the description of any CSR that relies
    // on this value 
    // 
    // Bits[23:21], RO/V, default = 0x0
    //
    UINT32 analog_tuning : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Bypasses flyby clock and selects H-tree clock when disbled
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 flybyclk_sel : 1;
    //
    // BIOS program this IO Frequency range field based on PLL freq. It is half of the
    // DRAM transfer rate.[br] 
    //                     For example DDR 4800. The PLL freq is 2400.[br]
    //                     2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]
    //                     2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]
    //                     2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]
    //                     2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
    // 
    // Bits[29:28], RW, default = 0x2
    //
    UINT32 iofreq_range : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // BIOS must enable DLL when program the IO freq range.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dll_en : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_DLL_CSR_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_DLL_CTL0_DDRCLK_CH0_MEM_REG_DDR             0x00012C38
typedef union {
  struct {
    //
    // BIOS must program this DLL  discharge timer based on the analog tuning value and
    // hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz
    // and discharge time is 30ns. 
    // 
    // Bits[5:0], RW, default = 0x24
    //
    UINT32 dll_discharge_tmr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // BIOS must program this DLL lock timer based on the analog tuning value and hclk
    // freq before enable the DLL. The default value is based on hclk is 1200 MHz and
    // lock lock is 50ns. 
    // 
    // Bits[13:7], RW, default = 0x3C
    //
    UINT32 dll_lock_tmr : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 18;
  } Bits;
  UINT32 Data;
} DDRCLK_DLL_CTL0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_PIREF_OFFSET0_0__DDRCLK_CH0_MEM_REG_DDR     0x00012C3C
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63) to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This clk piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each clk pair clk_dly[6:0] field, so
    // each clk pair pi odd code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 clk_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_PIREF_OFFSET0_0__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_PIREF_OFFSET0_1__DDRCLK_CH0_MEM_REG_DDR     0x00012C40
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63) to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This clk piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each clk pair clk_dly[6:0] field, so
    // each clk pair pi odd code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 clk_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_PIREF_OFFSET0_1__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_RX_CTL0_DDRCLK_CH0_MEM_REG_DDR              0x00012C44
typedef union {
  struct {
    //
    // Control number of ODT segment enable for clk buf.
    // 
    // Bits[1:0], RW, default = 0x3
    //
    UINT32 odt_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Force the Rx amplifier combiner to a lower static power state during Alert and
    // DDR-T modes,[br] 
    //                     which reduces FiSH temperatures and helps RV.
    // 
    // Bits[3:3], RW, default = 0x1
    //
    UINT32 rx_combiner_alert_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 6;
    //
    // SW set this bit to 1 to ungate the DDRIO to MC RX data path.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 rx_path_ungate : 1;
    //
    // Repurposed for force local receiver bias on for DQbuf.[br]
    //                     When set to 1, it will keep the local bias mirror always enabled.[br]
    //                     When set to 0, local bias gets enabled with senseamp_enable.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 rxgainfuse_ovrd : 1;
    //
    // Rx summer output common mode control[br]
    //                     0: 0.25*vccddra[br]
    //                     1: 0.3*vccddra (default)[br]
    //                     2: 0.35*vccddra[br]
    //                     3: 0.4*vccddra
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINT32 rxbias_vcm_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // 3 Rload Settings (K- 1.5, 2, and 3)
    // 
    // Bits[16:15], RW, default = 0x1
    //
    UINT32 rxbias_rxgain_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 5;
    //
    // Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has
    // weight of 2 and LSB bit has weight of 1. [br] 
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[26:22], RW, default = 0x1F
    //
    UINT32 odt_static_leg_cfg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 5;
  } Bits;
  UINT32 Data;
} DDRCLK_RX_CTL0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_RX_CTL1_DDRCLK_CH0_MEM_REG_DDR              0x00012C48
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 6;
    //
    // enable offset control in clk buf and RX BIAS
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINT32 rx_offset_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 22;
    //
    // Spare bits - potentially for trimming Rload
    // 
    // Bits[31:29], RW, default = 0x0
    //
    UINT32 reserved : 3;
  } Bits;
  UINT32 Data;
} DDRCLK_RX_CTL1_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_TX_CTL0_DDRCLK_CH0_MEM_REG_DDR              0x00012C50
typedef union {
  struct {
    //
    // Sets number of CLK driver (Ron) static legs.[br]
    //                     First 3 MSB bits has weight of 4, 4th MSB has weight of 2
    // and LSB bit has weight of 1.[br] 
    //                     RTL default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[4:0], RW, default = 0x1F
    //
    UINT32 drv_static_leg_cfg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Control number of data sement enable for CLK buf.
    // 
    // Bits[7:6], RW, default = 0x3
    //
    UINT32 data_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 22;
    //
    // Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]
    //                     No need skew based settings, value of 1 seems to work across
    // PVT.[br] 
    //                     May need to set to 0 for slow silicon if we see issues in
    // post silicon. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 tx_serializer_pwradj : 1;
    //
    // 0 : CLK BUF bypass SCOMP and TCO delay in the transmitter.
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 scomp_tco_bypass_dis : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_TX_CTL0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_TX_CTL1_DDRCLK_CH0_MEM_REG_DDR              0x00012C54
typedef union {
  struct {
    //
    // IODirectionValid.[br]
    //                     SW must program the io_pwrdn_pull_low control before set this
    // bit to 1 to ensure the analog logic capture the pwr down pin behavior. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 io_dir_valid : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 31;
  } Bits;
  UINT32 Data;
} DDRCLK_TX_CTL1_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_DFX_CTL0_DDRCLK_CH0_MEM_REG_DDR             0x00012C5C
typedef union {
  struct {
    //
    // Enable to close switch to pass vin to vout in HV Switcher CBB for NTL testing.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Simulation-only control to shorten VSSHI and LDO timers
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // 0 - No Vref power saving in Self Refresh. The clk Vref generators is enabled by
    // rx_vref_en.[br] 
    //                     1 - The clk Vref generators are switched off while in Self
    // Refresh regardless the setting of rx_vref_en. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 sr_vref_dis : 1;
    //
    // 0 - No Vref power saving in CKE power down. All CLK Vref generators is enabled
    // by rx_vref_en.[br] 
    //                     1 - CLK Vref generators are switched off while in CKE power
    // down regardless the setting of rx_vref_en. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 ckepd_vref_dis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 18;
    //
    // Per bit VOC RX pass gate enable for VOC training and NTL testing.
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 rx_voc_pass_gate_en : 8;
  } Bits;
  UINT32 Data;
} DDRCLK_DFX_CTL0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_HW_TRAIN_CTL0_DDRCLK_CH0_MEM_REG_DDR        0x00012C60
typedef union {
  struct {
    //
    // Set to 1 to enable xover training stage
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 xover_stage_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Set to 1 to enable DFE summer offset training stage for all clock bits.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dfe_summer_offset_stage_en : 1;
    //
    // Set to 1 to enable txpiclk training  stage. This state should only be enabled
    // for ACIO LB testing only. In this stage the HW will sweep each bits txpiclk to
    // center align the transmit data to the receiving piref clock. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 to enable loop delay training stage. This state should only be enabled
    // for ACIO LB testing only. In the stage the HW will calculate the loop tx to rx
    // loop delay for each bits. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Set to 1  to double the analog settling time. [br]
    //                     The default settling time for each stage are [br]
    //                     Xover : 32 Dclk for first iteration,  24 Dclk for subsequent
    // [br] 
    //                     DFE summer offset : 24 Dclk [br]
    //                     Txpiclk :  24 Dclk [br]
    //                     Loop Delay:  8 Dclk
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 settling_time_x2 : 1;
    //
    // Number of Sample to evaluate for each iteration step. It applied for all training
    // stages. [br] 
    //                     0: 16[br]
    //                     1: 32[br]
    //                     2: 64[br]
    //                     3: 2 (Should only used to speed up digital simulation)
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINT32 sample_cnt : 2;
    //
    // Sample threshold value for voting logic.
    // 
    // Bits[15:10], RW, default = 0x8
    //
    UINT32 sample_thresh : 6;
    //
    // Set to 1 to enable ACIO loopback. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Set to 1 to enable ACIO pattern checking. This bit should be set after acio_en
    // is set. Also it should be cleared before the acio_en is cleared. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 12;
    //
    // HW calibation enable control per FSM (clk has 2). Set to 1 to enable the HW calibration.
    // [br] 
    //                     They are 4 HW calibration stages that SW can request HW to
    // perform. It is defined in bit 0 to 4 in this register. [br] 
    //                     HW cal FSM will self clear this bit when all the enabled calibration
    // stages are completed. [br] 
    //                     For BIOS training, XOVER, sampler offset, and DFE summer offset
    // training can be enabled by SW.[br] 
    //                     For ACIO testing, all 4 stages can be enabled by SW.
    // 
    // Bits[31:30], RW/V, default = 0x0
    //
    UINT32 hw_cal_en : 2;
  } Bits;
  UINT32 Data;
} DDRCLK_HW_TRAIN_CTL0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_HWCAL_STS0_0__DDRCLK_CH0_MEM_REG_DDR        0x00012C64
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any clock
    // pair within this piref group. SW must clear this bit to 0 when enable HW calibration.
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any clock pair within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any clock pair within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[7:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 0 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCLK_HWCAL_STS0_0__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_HWCAL_STS0_1__DDRCLK_CH0_MEM_REG_DDR        0x00012C68
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any clock
    // pair within this piref group. SW must clear this bit to 0 when enable HW calibration.
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any clock pair within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any clock pair within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[7:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 0 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCLK_HWCAL_STS0_1__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_TRAIN_CTL1_DDRCLK_CH0_MEM_REG_DDR           0x00012C78
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // Set to 1 to enable sample path and unsample path feedback results. [br]
    //                     Note: It is used for SW SA training and SW ACIO txpiclk training.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 rx_path_fb_en : 1;
    //
    // Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform
    // Xover calibraton training.  
    //                     - enable all the DCLK And PI clocks. (may remove clock gating
    // function) 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 xover_cal : 1;
    //
    // Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 vref_highz : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 5;
    //
    // For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2.
    // It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br] 
    //                     Setting this bit to 1 indicate it is operating in DDR4/DDR-T.
    // 0 inidate it is operating in DDR5/DDR-T2. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 ddr4 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Set to 1 to enable HW to gate effective register update CLK for power saving.
    // Default is disable clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 compeff_clk_gate_en : 1;
    //
    // Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power
    // saving. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 bclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 pi_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 piref_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable
    // clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 tx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 rx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training
    // logics). Default is disable clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 train_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 csr_clk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 3;
    //
    // Forces all the clk transmitter driver on.
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 force_txon : 1;
    //
    // Force all the CLK IO weak ODT on. The weak ODT is ignored when drive enable is
    // asserted. [br] 
    //                     Note: For ACIO, ODT is provided by different DDR channel.
    //  
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 force_odt_on : 1;
    //
    // Force Rx Bias and Rx Bias Vref On
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 force_rxbias_on : 1;
    //
    // Force Senseamp on. Use for overclocking support where we may not be able to hit
    // the fast exit latency. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 force_sa_on : 1;
    //
    // Force all the CLK IO strong ODT on. When set, it always enable one segment for
    // ODT regardless the state of the drive enable. [br] 
    //                     The intend use case is for ACIO with burnin.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 force_strong_odt_on : 1;
    //
    // set to 1 to enable CLK vref
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_vref_en : 1;
  } Bits;
  UINT32 Data;
} DDRCLK_TRAIN_CTL1_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_TRAIN_CTL2_DDRCLK_CH0_MEM_REG_DDR           0x00012C7C
typedef union {
  struct {
    //
    // Select which xover phase detect output for DLL Top piref calibration. Legal value
    // is 0 to 9. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 dll_top_xover_cal_mux_sel : 4;
    //
    // Select which xover phase detect output for DLL Bottom piref calibration. Legal
    // value is 0 to 9. 
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 dll_bot_xover_cal_mux_sel : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 24;
  } Bits;
  UINT32 Data;
} DDRCLK_TRAIN_CTL2_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_TRAIN_RESULT0_DDRCLK_CH0_MEM_REG_DDR        0x00012C80
typedef union {
  struct {
    //
    // Xover Calibration Phase Detected Result[br]
    //                     Bit 1 : DLL 0 - piref for clk pair [lb]3:2[rb][br]
    //                     Bit 0 : DLL 0 - piref for clk pair [lb]1:0[rb]
    // 
    // Bits[1:0], RO/V, default = 0x0
    //
    UINT32 xover_cal_pd_result : 2;
    //
    // Per bit senseamp train result
    // 
    // Bits[9:2], RO/V, default = 0x0
    //
    UINT32 sa_train_result : 8;
    //
    // RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training.
    // [br] 
    //                     Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1
    // before reading this fields. 
    // 
    // Bits[17:10], RO/V, default = 0x0
    //
    UINT32 rx_even_sample_path_fb : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 14;
  } Bits;
  UINT32 Data;
} DDRCLK_TRAIN_RESULT0_DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_0__DDRCLK_CH0_MEM_REG_DDR          0x00012CE0
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_0__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_1__DDRCLK_CH0_MEM_REG_DDR          0x00012CE4
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_1__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_2__DDRCLK_CH0_MEM_REG_DDR          0x00012CE8
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_2__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_3__DDRCLK_CH0_MEM_REG_DDR          0x00012CEC
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_3__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_4__DDRCLK_CH0_MEM_REG_DDR          0x00012CF0
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_4__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_5__DDRCLK_CH0_MEM_REG_DDR          0x00012CF4
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_5__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_6__DDRCLK_CH0_MEM_REG_DDR          0x00012CF8
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_6__DDRCLK_CH0_MEM_STRUCT_DDR;

#define DDRCLK_CTL0_BIT_7__DDRCLK_CH0_MEM_REG_DDR          0x00012CFC
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRCLK_CTL0_BIT_7__DDRCLK_CH0_MEM_STRUCT_DDR;


#endif // _MMRCDDRCLK_CH0_MEM_DDR_H_DDR_
