/** @file
  File name:    MMRCMCMISC_MEM_MCMISC_CSR_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCMCMISC_MEM_MCMISC_CSR_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCMCMISC_MEM_MCMISC_CSR_DDR_H_DDR_
#define _MMRCMCMISC_MEM_MCMISC_CSR_DDR_H_DDR_

#include "MspDataTypes.h"

#define CRDEFEATURE0_DFX_MCMISC_MEM_MCMISC_CSR_REG_DDR     0x00002000
typedef union {
  struct {
    //
    // spare
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINT32 reserved : 16;
    //
    // spare
    // 
    // Bits[31:16], RW/P, default = 0x0
    //
    UINT32 reserved_1 : 16;
  } Bits;
  UINT32 Data;
} CRDEFEATURE0_DFX_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define CRDEFEATURE1_DFX_MCMISC_MEM_MCMISC_CSR_REG_DDR     0x00002008
typedef union {
  struct {
    //
    // spare
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINT32 spare : 16;
  } Bits;
  UINT32 Data;
} CRDEFEATURE1_DFX_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002200
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in BIOS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0xFFFFFFFF
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002204
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in BIOS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0xFFFFFFFF
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002208
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in BIOS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x100021A
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000220C
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in BIOS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x20000400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002210
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to BIOS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x1000208
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_BIOS_W_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002214
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to BIOS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_BIOS_W_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002218
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in CPGC security policy group, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0xFFFFFFFF
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000221C
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in CPGC security policy group, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0xFFFFFFFF
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002220
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in CPGC security policy group, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0x100021A
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002224
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in CPGC security policy group, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0x20000400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002228
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to CPGC WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x1000208
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_CPGC_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000222C
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to CPGC WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:0], RW, default = 0x400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_CPGC_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002230
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in P_U_CODE security policy group, based on the value from each agent's 6bit SAI
    // field. 
    // 
    // Bits[31:0], RW, default = 0x100020A
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002234
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in P_U_CODE security policy group, based on the value from each agent's 6bit SAI
    // field. 
    // 
    // Bits[31:0], RW, default = 0x20000500
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002238
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in P_U_CODE security policy group, based on the value from each agent's 6bit SAI
    // field. 
    // 
    // Bits[31:0], RW, default = 0x100020A
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000223C
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in P_U_CODE security policy group, based on the value from each agent's 6bit SAI
    // field. 
    // 
    // Bits[31:0], RW, default = 0x400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002240
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to P_U_CODE
    // WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0x1000208
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_P_U_CODE_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002244
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to P_U_CODE
    // WAC, RAC and CP registers, based on the value from each agent's 6bit SAI field.
    // 
    // Bits[31:0], RW, default = 0x400
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_P_U_CODE_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define RCOMP_GLOBALCTRL1_MCMISC_MEM_MCMISC_CSR_REG_DDR    0x0000224C
typedef union {
  struct {
    //
    // RCOMP start via message channel control for bios.
    // RCOMP start only triggered when the register bit output is changing from 0 ->
    // 1 
    // MC will not be responsible for clearing this bit. MC already provides feedback
    // to bias 
    // when Rcomp is done via first_rcomp_done bit field.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rcomp : 1;
    //
    // Disable rcomp
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 dis_rcomp : 1;
    //
    // rcomp in progress
    // 
    // Bits[2:2], RW/V, default = 0x0
    //
    UINT32 rcomp_in_progress : 1;
    //
    // First RCOMP DONE status, does not distinguish the source of the first rcomp trigger
    // 
    // Bits[3:3], RW/V, default = 0x0
    //
    UINT32 first_rcomp_done : 1;
    //
    // Bit 2 of this three bit field is unused in MC. Indicates if the channel has been
    // disabled by BIOS or by fuse, if yes set to 1. Bit1 - chnl1, Bit0 - chnl0 Used
    // for overriding Acks from individual disabled chnls during PM aggregation. Per
    // chnl bit value should match new_imc_fuse_download.chn_disable_mc0 || mcmtr.chn_disable
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 chnl_disabled : 3;
    //
    // Bit 2 of this field is unused in MC. Set a bit of this field to 1 if the corresponding
    // chnl is unpopulated. Bit1 - chnl1, Bit0 - chnl0    Used for identifying unpopulated
    // chnls and overriding Ack during PM aggregation. Per chnl bit value should logically
    // match ~(dimmmtr_0.dimm_pop || dimmmtr_1.dimm_pop || McDdrtCfg.Slot0 || McDdrtCfg.Slot1)
    //  
    // 
    // Bits[9:7], RW, default = 0x0
    //
    UINT32 chnl_unpopulated : 3;
    //
    // One bit per channel indicating whether that channel has eADR actions to do. Value
    // should match the inverted value of NmCaching Cfg 2lm enable of each channel. If
    // the bit is 1 eADR will not be sent to that Channel and aggregation logic will
    // do an Auto Ack. 
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINT32 eadr_per_chnl_disable : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 20;
  } Bits;
  UINT32 Data;
} RCOMP_GLOBALCTRL1_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define CPGC_GLOBALCTRL_MCMISC_MEM_MCMISC_CSR_REG_DDR      0x00002250
typedef union {
  struct {
    //
    // Setting to 1 will immediately initiate a transition to Loopback.Pattern on all
    // channels that have their global_control bit set. 
    // This field is cleared when all channels transition to Loopback.Marker from loopback.Pattern
    // for channels that have their global_control bit set. 
    // If channels are not expected to transition to Loopback.Marker at the same time
    // (because of programming or other differences) 
    // then start_test bit will not clear by itself.
    // To start the test again, BIOS will need to clear this bit field followed by setting
    // it to 1 again. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 start_test : 1;
    //
    // Setting Global_Stop_Test to 1 will force a transition to Loopback.Marker on all
    // channels that have their Global_Control bit set. 
    // Global_Stop_Test will immediately clear to 0 after forcing a transition to Loopback.Marker
    // on all channels that have their Global_Control bit set. 
    // 
    // Bits[1:1], RW/V, default = 0x0
    //
    UINT32 stop_test : 1;
    //
    // Setting Global_Clear_Errors to 1 will immediately clear all error status registers
    // (the same effect as asserting assert the Local_Clear_Errors) 
    // on any channels that have their Global Control bit is set.
    // Global_Clear_Errors will immediately be reset to 0 after all Channels_Err Status
    // Registers are cleared that have their Global Control bit Set 
    // 
    // Bits[2:2], RW/V, default = 0x0
    //
    UINT32 clear_errs : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Setting Global_Stop_Test_On_Any_Error to 1 will immediately force a transition
    // to Loopback.Marker after any error on any channels 
    // (indicated by a no zero value in Channel_Error_Status) that also have their Global
    // Control bit set. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 stop_test_on_any_err : 1;
    //
    // Currently Address bits [2:0] of the Column Addr are hard tied to zero, Setting
    // this bit will 
    // enable bit control over Addres bit [2] as well thus enabling BL4 mode full addressing.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 use_bl4_col_addr : 1;
    //
    // Programmable credits for CPGC Multi Credit Scheme -
    // 6d-zero: Use hardcoded defaults of 6d16
    // 6d-nonzero: Programmable credits for CPGC Multi-credit scheme
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINT32 cpgc_credits : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // When enabled, CPGC sequencer will wait for all credits to be returned before moving
    // to the next sub-sequence. 
    // Usage of this de-feature bit is
    // - limited to WAIT states between two sub-sequences.
    // - limited to when CPGC is using multi-credit scheme.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 cpgc_crdt_wait : 1;
    //
    // when set, CPGC writes are allowed multiple credits, but CPGC reads will only use
    // 1 credit. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 multiwr_singlerd_mode : 1;
    //
    // 
    //         3b per channel vector that should be set for DDRT. 
    //         If this bit is set then 
    //         - Sequencer uses BL4 addressing mode for adddresses to DDRT scheduler
    //  
    //         
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 ddrt_addr_mode : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 14;
  } Bits;
  UINT32 Data;
} CPGC_GLOBALCTRL_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define CPGC_GLOBALERR_MCMISC_MEM_MCMISC_CSR_REG_DDR       0x00002254
typedef union {
  struct {
    //
    // Channel_Error_Status_0 corresponds to Channel 0. When set this indicated Channel
    // 0 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_0 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 channel_err_status_0 : 1;
    //
    // Channel_Error_Status_1 corresponds to Channel 1. When set this indicated Channel
    // 1 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_1 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 channel_err_status_1 : 1;
    //
    // Channel_Error_Status_2 corresponds to Channel 2. When set this indicated Channel
    // 2 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_2 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 channel_err_status_2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 13;
    //
    // Channel_Test_Done_Status_0 corresponds to Channel 0 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[16:16], RO/V, default = 0x1
    //
    UINT32 channel_test_done_status_0 : 1;
    //
    // Channel_Test_Done_Status_1 corresponds to Channel 1 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[17:17], RO/V, default = 0x1
    //
    UINT32 channel_test_done_status_1 : 1;
    //
    // Channel_Test_Done_Status_2 corresponds to Channel 2 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[18:18], RO/V, default = 0x1
    //
    UINT32 channel_test_done_status_2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 13;
  } Bits;
  UINT32 Data;
} CPGC_GLOBALERR_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define RCOMP_GLOBALCTRL0_MCMISC_MEM_MCMISC_CSR_REG_DDR    0x00002258
typedef union {
  struct {
    //
    // RCOMP start via message channel control.
    // RCOMP start only triggered when the register bit output is changing from 0 ->
    // 1 and not from 1 --> 1. 
    // MC will not be responsible for clearing this bit. MC already provides feedback
    // to PCU when Rcomp is done via PMLink. 
    // Pcode has the responsibility to set and clear this bit using two separate msg
    // ch transactions. Msg channel will guarantee the ordering of these two transactions.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // CR bit to disable PS0 widget. Value 1 will disable PS0 widget i.e., msgs from
    // PMA directly reach channel/sapmas aggregator in mcdfxmisc 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Pcode control to disable Pcode initated Rcomp
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 29;
  } Bits;
  UINT32 Data;
} RCOMP_GLOBALCTRL0_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_CREDIT_CONFIG_0__MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002260
typedef union {
  struct {
    //
    // req_fab_credits
    // 
    // Bits[4:0], RW, default = 0x7
    //
    UINT32 req_fab_credits : 5;
    //
    // rsp_fab_credits
    // 
    // Bits[9:5], RW, default = 0xC
    //
    UINT32 rsp_fab_credits : 5;
    //
    // rd_cpl_fab_credits
    // 
    // Bits[14:10], RW, default = 0x12
    //
    UINT32 rd_cpl_fab_credits : 5;
    //
    // CMI tracing enabled
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 cmi_trace_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
    //
    // force_ism_active_from_parent
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 force_ism_active_from_parent : 1;
    //
    // credits initialized
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINT32 rsp_ism_credits_initialized : 1;
    //
    // credits initialized
    // 
    // Bits[30:30], RW/V, default = 0x0
    //
    UINT32 req_ism_credits_initialized : 1;
    //
    // credit_init_done
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 credit_init_done : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_CREDIT_CONFIG_0__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_CREDIT_CONFIG_1__MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002264
typedef union {
  struct {
    //
    // req_fab_credits
    // 
    // Bits[4:0], RW, default = 0x7
    //
    UINT32 req_fab_credits : 5;
    //
    // rsp_fab_credits
    // 
    // Bits[9:5], RW, default = 0xC
    //
    UINT32 rsp_fab_credits : 5;
    //
    // rd_cpl_fab_credits
    // 
    // Bits[14:10], RW, default = 0x12
    //
    UINT32 rd_cpl_fab_credits : 5;
    //
    // CMI tracing enabled
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 cmi_trace_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
    //
    // force_ism_active_from_parent
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 force_ism_active_from_parent : 1;
    //
    // credits initialized
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINT32 rsp_ism_credits_initialized : 1;
    //
    // credits initialized
    // 
    // Bits[30:30], RW/V, default = 0x0
    //
    UINT32 req_ism_credits_initialized : 1;
    //
    // credit_init_done
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 credit_init_done : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_CREDIT_CONFIG_1__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_STALL_CONFIG_0__L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002270
typedef union {
  struct {
    //
    // SCF request stall assert LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[9:0], RW, default = 0x2AA
    //
    UINT32 scf_req_stall_assert_seed : 10;
    //
    // SCF request stall delay LFSR seed.  Must have at least one bit set in active width.
    // 
    // Bits[19:10], RW, default = 0x2AA
    //
    UINT32 scf_req_stall_delay_seed : 10;
    //
    // MCCHAN response stall assert LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[29:20], RW, default = 0x2AA
    //
    UINT32 mcchan_rsp_stall_assert_seed : 10;
    //
    // MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[31:30], RW, default = 0x2
    //
    UINT32 mcchan_rsp_stall_delay_seed : 2;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_STALL_CONFIG_0__L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_STALL_CONFIG_0__H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002274
typedef union {
  struct {
    //
    // MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[7:0], RW, default = 0xAA
    //
    UINT32 mcchan_rsp_stall_delay_seed : 8;
    //
    // Width for scf request assert LFSR
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINT32 scf_req_stall_assert_reg_width : 4;
    //
    // Width for scf request delay LFSR
    // 
    // Bits[15:12], RW, default = 0xA
    //
    UINT32 scf_req_stall_delay_reg_width : 4;
    //
    // Width for mcchan response assert LFSR
    // 
    // Bits[19:16], RW, default = 0xA
    //
    UINT32 mcchan_rsp_stall_assert_reg_width : 4;
    //
    // Width for mcchan response delay LFSR
    // 
    // Bits[23:20], RW, default = 0xA
    //
    UINT32 mcchan_rsp_stall_delay_reg_width : 4;
    //
    // Stall outgoing CMI traffic when mcchan asserts stop request
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 stall_for_stop_req : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // Bit to enable random scf req stall injection
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 scf_req_stall_enable : 1;
    //
    // Bit to enable random mcchan rsp stall injection
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 mcchan_rsp_stall_enable : 1;
    //
    // Valid to load register fields
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reg_vld : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_STALL_CONFIG_0__H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_STALL_CONFIG_1__L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002278
typedef union {
  struct {
    //
    // SCF request stall assert LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[9:0], RW, default = 0x2AA
    //
    UINT32 scf_req_stall_assert_seed : 10;
    //
    // SCF request stall delay LFSR seed.  Must have at least one bit set in active width.
    // 
    // Bits[19:10], RW, default = 0x2AA
    //
    UINT32 scf_req_stall_delay_seed : 10;
    //
    // MCCHAN response stall assert LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[29:20], RW, default = 0x2AA
    //
    UINT32 mcchan_rsp_stall_assert_seed : 10;
    //
    // MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[31:30], RW, default = 0x2
    //
    UINT32 mcchan_rsp_stall_delay_seed : 2;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_STALL_CONFIG_1__L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_STALL_CONFIG_1__H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000227C
typedef union {
  struct {
    //
    // MCCHAN response stall delay LFSR seed.  Must have at least one bit set in active
    // width. 
    // 
    // Bits[7:0], RW, default = 0xAA
    //
    UINT32 mcchan_rsp_stall_delay_seed : 8;
    //
    // Width for scf request assert LFSR
    // 
    // Bits[11:8], RW, default = 0xA
    //
    UINT32 scf_req_stall_assert_reg_width : 4;
    //
    // Width for scf request delay LFSR
    // 
    // Bits[15:12], RW, default = 0xA
    //
    UINT32 scf_req_stall_delay_reg_width : 4;
    //
    // Width for mcchan response assert LFSR
    // 
    // Bits[19:16], RW, default = 0xA
    //
    UINT32 mcchan_rsp_stall_assert_reg_width : 4;
    //
    // Width for mcchan response delay LFSR
    // 
    // Bits[23:20], RW, default = 0xA
    //
    UINT32 mcchan_rsp_stall_delay_reg_width : 4;
    //
    // Stall outgoing CMI traffic when mcchan asserts stop request
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 stall_for_stop_req : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // Bit to enable random scf req stall injection
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 scf_req_stall_enable : 1;
    //
    // Bit to enable random mcchan rsp stall injection
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 mcchan_rsp_stall_enable : 1;
    //
    // Valid to load register fields
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reg_vld : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_STALL_CONFIG_1__H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_RD_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002290
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_RD_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_RD_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002294
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_RD_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_WR_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002298
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_WR_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_WR_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000229C
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_WR_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_RD_DDRT_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022A0
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_RD_DDRT_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_RD_DDRT_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022A4
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_RD_DDRT_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_WR_DDRT_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022A8
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_WR_DDRT_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_WR_DDRT_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022AC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_WR_DDRT_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_DCLK_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022B0
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_DCLK_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_FREE_RUN_CNTR_DCLK_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022B4
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_FREE_RUN_CNTR_DCLK_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022B8
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_0 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_1 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_2 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_3 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_4 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_5 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_6 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_7 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_8 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_9 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_10 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_11 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_12 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_13 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_14 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_15 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_16 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_17 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_18 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_19 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_20 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_21 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_22 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_23 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_24 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_25 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_26 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_27 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_28 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_29 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_30 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_31 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_RD_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022BC
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_32 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_33 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_34 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_35 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_36 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_37 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_38 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_39 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_40 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_41 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_42 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_43 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_44 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_45 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_46 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_47 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_48 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_49 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_50 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_51 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_52 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_53 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_54 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_55 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_56 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_57 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_58 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_59 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_60 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_61 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_62 : 1;
    //
    // Bit-vector used to determine which agents are allowed read access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_63 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_RD_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022C0
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_0 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_1 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_2 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_3 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_4 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_5 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_6 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_7 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_8 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_9 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_10 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_11 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_12 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_13 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_14 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_15 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_16 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_17 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_18 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_19 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_20 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_21 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_22 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_23 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_24 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_25 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_26 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_27 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_28 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_29 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_30 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_31 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_WR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022C4
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_32 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_33 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_34 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_35 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_36 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_37 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_38 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_39 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_40 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_41 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RO, default = 0x1
    //
    UINT32 os_w_sai_pol_42 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_43 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_44 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_45 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_46 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_47 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_48 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_49 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_50 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_51 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_52 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_53 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_54 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_55 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_56 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_57 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_58 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_59 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_60 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x1
    //
    UINT32 os_w_sai_pol_61 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_62 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to registers
    // in OS_W policy group, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 os_w_sai_pol_63 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_WR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022C8
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_0 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_1 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_2 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RO, default = 0x1
    //
    UINT32 os_w_ctrl_pol_3 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 os_w_ctrl_pol_4 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_5 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_6 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_7 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_8 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RO, default = 0x1
    //
    UINT32 os_w_ctrl_pol_9 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_10 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_11 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_12 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_13 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_14 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_15 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_16 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_17 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_18 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_19 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_20 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_21 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_22 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_23 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RO, default = 0x1
    //
    UINT32 os_w_ctrl_pol_24 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_25 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_26 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_27 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_28 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_29 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_30 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_31 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_CR_POLICY_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCDFXMISC_SAI_OS_W_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022CC
typedef union {
  struct {
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_32 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_33 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_34 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_35 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_36 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_37 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_38 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_39 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_40 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_41 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[10:10], RO, default = 0x1
    //
    UINT32 os_w_ctrl_pol_42 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_43 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_44 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_45 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_46 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_47 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_48 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_49 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_50 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_51 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_52 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_53 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_54 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_55 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_56 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_57 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_58 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_59 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_60 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_61 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_62 : 1;
    //
    // Bit-vector used to determine which agents are allowed write access to OS_W WAC,
    // RAC and CP registers, based on the value from each agent's 6bit SAI field. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 os_w_ctrl_pol_63 : 1;
  } Bits;
  UINT32 Data;
} MCDFXMISC_SAI_OS_W_PG_CR_POLICY_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MC_PA_BLOCK_CFG_0__L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022D0
typedef union {
  struct {
    //
    // Dso0 Channel 0 input select: 
    // '00:CMI Request Channel0
    // '01:CMI Request Channel1
    // '10: CMI Completion Channel0
    // '11:CMI Completion Channel1
    // 
    // Bits[1:0], RW/P, default = 0x0
    //
    UINT32 dso0_channel0_input_select : 2;
    //
    // Dso0 Channel 1 input select: 
    // '0000:CMI completion channel0 
    // '0001:CMI completion channel1
    // '0010:CMI completion read data channel0
    // '0011:CMI completion read data channel1
    // '0100:CMI request write data channel0
    // '0101:CMI request write data channel1
    // '0110:CMI response channel0 
    // '0111:CMI response channel1
    // '1000:CMI late completion channel0
    // '1001:CMI late completion channel1
    // 
    // Bits[5:2], RW/P, default = 0x0
    //
    UINT32 dso0_channel1_input_select : 4;
    //
    // Dso0 Channel 2 input select: 
    // '000:CMI Request Channel0
    // '001:CMI Request Channel1
    // '010:CMI Completion Channel0
    // '011:CMI Completion Channel1
    // '100:Upstream DRA Channel 0
    // '101:Upstream DRA Channel 1
    // 
    // Bits[8:6], RW/P, default = 0x0
    //
    UINT32 dso0_channel2_input_select : 3;
    //
    // Dso0 Channel 3 input select: 
    // '0000:CMI completion channel0 
    // '0001:CMI completion channel1
    // '0010:CMI completion read data channel0
    // '0011:CMI completion read data channel1
    // '0100:CMI request write data channel0
    // '0101:CMI request write data channel1
    // '0110:CMI response channel0 
    // '0111:CMI response channel1
    // '1000:CMI late completion channel0
    // '1001:CMI late completion channel1
    // '1010:CMI Cmd channel0
    // '1011:CMI Cmd channel1
    // '1100:Upstream DRA Channel 0
    // '1101:Upstream DRA Channel 1
    // 
    // Bits[12:9], RW/P, default = 0x0
    //
    UINT32 dso0_channel3_input_select : 4;
    //
    // CMI data select for channel0 write data.
    // '0000: write_data[15:0]
    // '0001: write_data[31:16]
    // '0010: write_data[47:32]
    // '0011: write_data[63:48]
    // '0100: write_data[79:64]
    // '0101: write_data[95:80]
    // '0110: write_data[111:96]
    // '0111: write_data[127:112]
    // '1000: write_data[143:128]
    // '1001: write_data[159:144]
    // '1010: write_data[175:160]
    // '1011: write_data[191:176]
    // '1100: write_data[207:192]
    // '1101: write_data[223:208]
    // '1110: write_data[239:224]
    // '1111: write_data[255:240]
    // 
    // 
    // Bits[16:13], RW/P, default = 0x0
    //
    UINT32 cmi_channel0_cmd_write_data_select : 4;
    //
    // CMI data select for channel1 write data.
    // '0000: write_data[15:0]
    // '0001: write_data[31:16]
    // '0010: write_data[47:32]
    // '0011: write_data[63:48]
    // '0100: write_data[79:64]
    // '0101: write_data[95:80]
    // '0110: write_data[111:96]
    // '0111: write_data[127:112]
    // '1000: write_data[143:128]
    // '1001: write_data[159:144]
    // '1010: write_data[175:160]
    // '1011: write_data[191:176]
    // '1100: write_data[207:192]
    // '1101: write_data[223:208]
    // '1110: write_data[239:224]
    // '1111: write_data[255:240]
    // 
    // 
    // Bits[20:17], RW/P, default = 0x0
    //
    UINT32 cmi_channel1_cmd_write_data_select : 4;
    //
    // CMI data select for channel0 rd data.
    // '0000: rd_data[15:0]
    // '0001: rd_data[31:16]
    // '0010: rd_data[47:32]
    // '0011: rd_data[63:48]
    // '0100: rd_data[79:64]
    // '0101: rd_data[95:80]
    // '0110: rd_data[111:96]
    // '0111: rd_data[127:112]
    // '1000: rd_data[143:128]
    // '1001: rd_data[159:144]
    // '1010: rd_data[175:160]
    // '1011: rd_data[191:176]
    // '1100: rd_data[207:192]
    // '1101: rd_data[223:208]
    // '1110: rd_data[239:224]
    // '1111: rd_data[255:240]
    // 
    // 
    // Bits[24:21], RW/P, default = 0x0
    //
    UINT32 cmi_channel0_cpl_read_data_select : 4;
    //
    // CMI data select for channel1 rd data.
    // '0000: rd_data[15:0]
    // '0001: rd_data[31:16]
    // '0010: rd_data[47:32]
    // '0011: rd_data[63:48]
    // '0100: rd_data[79:64]
    // '0101: rd_data[95:80]
    // '0110: rd_data[111:96]
    // '0111: rd_data[127:112]
    // '1000: rd_data[143:128]
    // '1001: rd_data[159:144]
    // '1010: rd_data[175:160]
    // '1011: rd_data[191:176]
    // '1100: rd_data[207:192]
    // '1101: rd_data[223:208]
    // '1110: rd_data[239:224]
    // '1111: rd_data[255:240]
    // 
    // 
    // Bits[28:25], RW/P, default = 0x0
    //
    UINT32 cmi_channel1_cpl_read_data_select : 4;
    //
    // selects between channel0 and channel 1 of the spid data buses coming into this
    // block from the two schedulers and the dedup data  
    // '00: channel0 spid 
    // '01: channel1 spid
    // '10: channel0 DRA
    // '11: channel1 DRA
    // 
    // Bits[30:29], RW/P, default = 0x0
    //
    UINT32 dso1_channel0_input_select : 2;
    //
    // CMI address select 
    //             2'b00: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[21:6];
    //             end
    //             2'b01: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[37:22];
    //             end
    //             2'b10: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[44:29];
    //             end
    //             2'b11: begin
    //                 spr_cmi_req_to_dso[i].req_address = {cmiReqCmdIfc111[i].cmd.req_address[44:37],cmiReqCmdIfc111[i].cmd.req_address[13:6]};
    // 
    // Bits[31:31], RW/P, default = 0x0
    //
    UINT32 channel_address_select : 1;
  } Bits;
  UINT32 Data;
} MC_PA_BLOCK_CFG_0__L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MC_PA_BLOCK_CFG_0__H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022D4
typedef union {
  struct {
    //
    // CMI address select 
    //             2'b00: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[21:6];
    //             end
    //             2'b01: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[37:22];
    //             end
    //             2'b10: begin
    //                 spr_cmi_req_to_dso[i].req_address = cmiReqCmdIfc111[i].cmd.req_address[44:29];
    //             end
    //             2'b11: begin
    //                 spr_cmi_req_to_dso[i].req_address = {cmiReqCmdIfc111[i].cmd.req_address[44:37],cmiReqCmdIfc111[i].cmd.req_address[13:6]};
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINT32 channel_address_select : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 31;
  } Bits;
  UINT32 Data;
} MC_PA_BLOCK_CFG_0__H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define RD_COMPR_DDR4_BW_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022E0
typedef union {
  struct {
    //
    // DDR4 RD BW Telemetry data for PCODE
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} RD_COMPR_DDR4_BW_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define RD_COMPR_DDRT_BW_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022E4
typedef union {
  struct {
    //
    // DDRt RD BW Telemetry data for PCODE
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} RD_COMPR_DDRT_BW_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define WR_COMPR_DDR4_BW_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022E8
typedef union {
  struct {
    //
    // DDR4 WR BW Telemetry data for PCODE
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} WR_COMPR_DDR4_BW_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define WR_COMPR_DDRT_BW_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022EC
typedef union {
  struct {
    //
    // DDRt WR BW Telemetry data for PCODE
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} WR_COMPR_DDRT_BW_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define THRT_COUNT_CHNL_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x000022F0
typedef union {
  struct {
    //
    // Throttle cycle count
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} THRT_COUNT_CHNL_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define CMD_COUNT_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR       0x000022F4
typedef union {
  struct {
    //
    // Command count, includes all cmds of DDR4 and DDRT
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} CMD_COUNT_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define COMPR_PMSUM_TELE_MCMISC_MEM_MCMISC_CSR_REG_DDR     0x000022F8
typedef union {
  struct {
    //
    // compressed PMSUM, counter which gets incremented everytime bit 8 original PMSUM
    // of any channel goes 0 to 1 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} COMPR_PMSUM_TELE_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMA_MISC_CTRL0_MCMISC_MEM_MCMISC_CSR_REG_DDR       0x000022FC
typedef union {
  struct {
    //
    // Mux to select between memtrip from HBM and aggregated (ORd) trip detected in threshold
    // logic in MC Chan. 
    // 	    Should be 1 for DDR config (choosing channel detected trip, since there is
    // no direct trip signal from DIMM). Can be 0 or 1 for HBM config. See section 5,
    // IPM MEMTRIP Sensing & Disablement, of Thermal HAS for the role of MUX  
    // 
    // Bits[0:0], RW, default = 0x1
    //
    UINT32 reserved : 1;
    //
    // Enable for CAT Trip signaling. Expected to 
    // 	    See section 5, IPM MEMTRIP Sensing & Disablement, of Thermal HAS for the
    // role of MUX  
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINT32 reserved_1 : 1;
    //
    // Enable simple roundrobin patrol distribution among mcddr channels. Only applies
    // to MDDR 
    // 
    // Bits[2:2], RW, default = 0x1
    //
    UINT32 reserved_2 : 1;
    //
    // Disable simple RR of patrol distribution among 8 HBM channels. Value of 1 means
    // only Chnl0 will get patrol reqs. 
    // 	      0 value allows simple round robin (one after other) requests to 8 HBM chnls.
    // Applies to only MCHBM 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Config bit to choose between DDRT RD or GNT for telemetry. 1 choose DDRT Rd
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // spare
    // 
    // Bits[19:5], RW, default = 0x0
    //
    UINT32 reserved_5 : 15;
    //
    // Applies to MCDDR only. # of patrol reqs to distribute to chnl0 before moving to
    // send patrol req to chnl1 
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 reserved_6 : 4;
    //
    // Applies to MCDDR only. # of patrol reqs to distribute to chnl1 before moving to
    // send patrol req to chnl2 
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 reserved_7 : 4;
    //
    // Applies to MCDDR only. # of patrol reqs to distribute to chnl2 before moving to
    // send patrol req to chnl3 
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 reserved_8 : 4;
  } Bits;
  UINT32 Data;
} PMA_MISC_CTRL0_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define CPGC_GLOBAL_SYNC_MCMISC_MEM_MCMISC_CSR_REG_DDR     0x00002300
typedef union {
  struct {
    //
    // This value is compared with a running counter counter_val. If sync trigger_arm
    // bit is set, then a trigger will be issued for a match. 
    // If sync trigger_enable is set, then a CPGC Global start_test will be set by hardware.
    // 
    // Bits[9:0], RW, default = 0x0
    //
    UINT32 trigger_val : 10;
    //
    // This arms the synchronous trigger. This bit is cleared after a trigger event (volatile).
    // 
    // Bits[10:10], RW/V, default = 0x0
    //
    UINT32 trigger_arm : 1;
    //
    // This bit enables synchronous trigger start feature. CPGC Global start_test will
    // be set when a trigger is issued. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 trigger_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // This is a read-only running counter that is approximately is synchronized between
    // memory subsystem tiles. 
    // This counter counts USync events which are 120ns apart
    // 
    // Bits[25:16], RO/V, default = 0x0
    //
    UINT32 counter_val : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 6;
  } Bits;
  UINT32 Data;
} CPGC_GLOBAL_SYNC_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define REGISTER_ACCESS_FAILURE_LOG_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002310
typedef union {
  struct {
    //
    // Offset for which a register access failed. Cfg offset is only 12
    //         bits wide whereas uCR offsets are 16 bits
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 reserved : 16;
    //
    // logs whether the failure is for cfg space or ucr space
    // 
    // Bits[19:16], RO/V, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // logs whether the failure was a SAI miss
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // logs whether the failure was an address miss
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 10;
  } Bits;
  UINT32 Data;
} REGISTER_ACCESS_FAILURE_LOG_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_RPQ_ACTIVE_CYCLES_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002318
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_RPQ_ACTIVE_CYCLES_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_RPQ_ACTIVE_CYCLES_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000231C
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_RPQ_ACTIVE_CYCLES_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_WPQ_ACTIVE_CYCLES_L_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002320
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 32;
  } Bits;
  UINT32 Data;
} PMON_WPQ_ACTIVE_CYCLES_L_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define PMON_WPQ_ACTIVE_CYCLES_H_MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002324
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[15:0], RO/V, default = 0x0
    //
    UINT32 countervalue : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} PMON_WPQ_ACTIVE_CYCLES_H_MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define BGF_PMON_CONFIG_0__MCMISC_MEM_MCMISC_CSR_REG_DDR   0x00002328
typedef union {
  struct {
    //
    // 0: idle, no counting, 1: BGF inserts, 2: BGF deallocations, 3: monitor the current
    // size of the selected BGF, 4: count each cycle that the selected BGF is full, 5:
    // count each cycle that the selected BGF is empty 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 bgf_event : 3;
    //
    // BGF bit vector to select which BGF to monitor.  SPR encodings as follows.  0:
    // REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: M2M_MISC, RD_CPL_CMD, 5: RD_CPL_DATA,
    // 6: CONSUMER_FLOW_CONTROL, 7: RSP, 8: RD_CPL_LATE, 9: MCCHAN_MISC, 10: ANY_BGF,
    // 11: ANY_REQUEST_BGF, 12: ANY_RESPONSE_BGF.  ATS encodings as follows.  0: REQ_CMD,
    // 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: RD_CPL_CMD, 4: RD_CPL_DATA, 5: CONSUMER_FLOW_CONTROL,
    // 6: RSP, 7: ANY_BGF, 8: ANY_REQUEST_BGF, 9: ANY_RESPONSE_BGF 
    // 
    // Bits[13:3], RW, default = 0x0
    //
    UINT32 bgf_select_vec : 11;
    //
    // reset the counter
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 reset_count : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 17;
  } Bits;
  UINT32 Data;
} BGF_PMON_CONFIG_0__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define BGF_PMON_CONFIG_1__MCMISC_MEM_MCMISC_CSR_REG_DDR   0x0000232C
typedef union {
  struct {
    //
    // 0: idle, no counting, 1: BGF inserts, 2: BGF deallocations, 3: monitor the current
    // size of the selected BGF, 4: count each cycle that the selected BGF is full, 5:
    // count each cycle that the selected BGF is empty 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 bgf_event : 3;
    //
    // BGF bit vector to select which BGF to monitor.  SPR encodings as follows.  0:
    // REQ_CMD, 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: M2M_MISC, RD_CPL_CMD, 5: RD_CPL_DATA,
    // 6: CONSUMER_FLOW_CONTROL, 7: RSP, 8: RD_CPL_LATE, 9: MCCHAN_MISC, 10: ANY_BGF,
    // 11: ANY_REQUEST_BGF, 12: ANY_RESPONSE_BGF.  ATS encodings as follows.  0: REQ_CMD,
    // 1: REQ_DATA, 2: PRODUCER_FLOW_CONTROL, 3: RD_CPL_CMD, 4: RD_CPL_DATA, 5: CONSUMER_FLOW_CONTROL,
    // 6: RSP, 7: ANY_BGF, 8: ANY_REQUEST_BGF, 9: ANY_RESPONSE_BGF 
    // 
    // Bits[13:3], RW, default = 0x0
    //
    UINT32 bgf_select_vec : 11;
    //
    // reset the counter
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 reset_count : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 17;
  } Bits;
  UINT32 Data;
} BGF_PMON_CONFIG_1__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define BGF_PMON_COUNTER_0__MCMISC_MEM_MCMISC_CSR_REG_DDR  0x00002330
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[27:0], RO/V, default = 0x0
    //
    UINT32 value : 28;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} BGF_PMON_COUNTER_0__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define BGF_PMON_COUNTER_1__MCMISC_MEM_MCMISC_CSR_REG_DDR  0x00002334
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[27:0], RO/V, default = 0x0
    //
    UINT32 value : 28;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} BGF_PMON_COUNTER_1__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_ISM_CONFIG_0__MCMISC_MEM_MCMISC_CSR_REG_DDR 0x00002338
typedef union {
  struct {
    //
    // This is the IDLE_REQ timeout count.  If the ISM responder has not reached IDLE
    // within this time, after the requestor has entered IDLE_REQ, the responder will
    // transition to the IDLE_NAK state to break the deadlock and give the requestor
    // another chance to revert back to ACTIVE. 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINT32 idle_req_timeout : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 14;
    //
    // This bit controls whether the mcdfxmisc responder ISM will signal an error when
    // an idle req timeout is detected 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 idle_req_timeout_signal_error : 1;
    //
    // This bit controls whether the mcdfxmisc responder ISM will generate an IDLE_REQ
    // NAK message when the programmed idle_req_timeout counter expires. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 idle_req_timeout_enable : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_ISM_CONFIG_0__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;

#define MCMISC_CMI_ISM_CONFIG_1__MCMISC_MEM_MCMISC_CSR_REG_DDR 0x0000233C
typedef union {
  struct {
    //
    // This is the IDLE_REQ timeout count.  If the ISM responder has not reached IDLE
    // within this time, after the requestor has entered IDLE_REQ, the responder will
    // transition to the IDLE_NAK state to break the deadlock and give the requestor
    // another chance to revert back to ACTIVE. 
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINT32 idle_req_timeout : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 14;
    //
    // This bit controls whether the mcdfxmisc responder ISM will signal an error when
    // an idle req timeout is detected 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 idle_req_timeout_signal_error : 1;
    //
    // This bit controls whether the mcdfxmisc responder ISM will generate an IDLE_REQ
    // NAK message when the programmed idle_req_timeout counter expires. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 idle_req_timeout_enable : 1;
  } Bits;
  UINT32 Data;
} MCMISC_CMI_ISM_CONFIG_1__MCMISC_MEM_MCMISC_CSR_STRUCT_DDR;


#endif // _MMRCMCMISC_MEM_MCMISC_CSR_DDR_H_DDR_
