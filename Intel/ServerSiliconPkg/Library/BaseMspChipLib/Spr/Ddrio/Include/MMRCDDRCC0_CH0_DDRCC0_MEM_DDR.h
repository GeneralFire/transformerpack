/** @file
  File name:    MMRCDDRCC0_CH0_DDRCC0_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRCC0_CH0_DDRCC0_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRCC0_CH0_DDRCC0_MEM_DDR_H_DDR_
#define _MMRCDDRCC0_CH0_DDRCC0_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRCC_CTL0_BIT_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A800
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A804
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_2__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A808
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_2__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_3__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A80C
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_3__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_4__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A810
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_4__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_5__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A814
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_5__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_6__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A818
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_6__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_7__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A81C
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_7__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_8__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A820
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_8__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_9__DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A824
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_9__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_10__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A828
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_10__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_11__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A82C
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_11__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_12__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A830
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_12__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_13__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A834
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_13__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_14__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A838
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_14__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_15__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A83C
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_15__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_16__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A840
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_16__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_17__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A844
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_17__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_18__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A848
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_18__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_19__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A84C
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_19__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_20__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A850
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_20__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_CTL0_BIT_21__DDRCC0_CH0_DDRCC0_MEM_REG_DDR   0x0001A854
typedef union {
  struct {
    //
    // CMD delay control. The range is 0 to 8 UI with step size of clkpi/128.[br]
    //                     This field is added with cmd_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). [br] 
    //                     The final delay - [br]
    //                     8:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with cmd_piref_offset and piref_setup_adj,
    // so the programmed value is relative to the piref clock. The result is the cmd
    // pi odd code. [br] 
    //                     Note: bit 6 (MSB)  is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     Note: we have 2 DLL in CMD fub, which generate 4 piref clocks.
    // Please refer to ddrcc_piref_offset0 register definition for piref assignment for
    // each bit[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[8:0], RW/V, default = 0x0
    //
    UINT32 cmd_dly : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This offset is added to the cmd_pio_code. The result is the cmd pi even code (cmd_pie_code)
    // to DLL. Default value is 64. 
    // 
    // Bits[16:10], RW, default = 0x40
    //
    UINT32 cmd_pie_offset : 7;
    //
    // IO direction control during normal function mode. This bit is used to qualify
    // the DDRINTF command output enable (TX) and received data (RX).[br] 
    //                     0: CMD IO is used for RX [br]
    //                     1: CMD IO is used for TX [br]
    //                     Note: This signal need to be qualify by IO direction valid
    // control.[br] 
    //                     Note: For ACIO, both RX/TX are enabled by ACIO control. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 io_dir : 1;
    //
    // IO Analog Power Down Pull low control. This control determines the IO behavior
    // (pull low or tri-state) when analog power domain is down (C6 or S3)[br] 
    //                     0: tri-state[br]
    //                     1: pull low (cke for DDR4 or CS for DDR5)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 io_pwrdn_pull_low : 1;
    //
    // PI N clock enable control. For IO that doesn't require to have the PI N clock
    // on. BIOS can set the corresponding bit to 0 to save power. For example DDRT REQ,
    // alert input don't require PI N clock to receive the data. They are recive on the
    // DCLK. 
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 pi_n_clk_en : 1;
    //
    // BIOS can disable this IO if this CMD IO pin is not used.[br]
    //                     Currently use case is for DDR5 RDIMM. We only pin out 7 of
    // the IOs. The other 7 IOs are not pinout.  
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 io_dis : 1;
    //
    // ODT enable to Command buf.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 odt_en : 1;
    //
    // 0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
    //                     1: unsampled path - ALERT, REQ (DDRT), ERR (DDRT/DDRT2), RSP_A/RSP_B
    // (DDR5) 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 rx_unsample_path_sel : 1;
    //
    // 0: this bit uses CA parameter for ca_imode_en, ca_imode_eq_code, ca_txeq_1st_tap
    // and ca_txeq_2nd_tap.[br] 
    //                     1: this bit uses CS parameter for cs_imode_en, cs_imode_eq_code,
    // cs_txeq_1st_tap and cs_txeq_2nd_tap 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 cs_para_sel : 1;
    //
    // RX FIFO pointer separation control
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rxfifo_ptr_ctl : 3;
    //
    // Sense Amplifier enable to Command buf.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sa_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Transmit Unit Interval. [br]
    //                     Bit 1: Set to 1 if TX UI is 0.5 Dclk [br]
    //                     Bit 0: Set to 1 if TX UI is 2 DCLK. [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (1N mode) : 2'b10 (0.5 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 RDIMM CMD bit (CA7)  (2N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR5 UDIMM CMD bit (CA14) (2N mode) : 2'b01 (2 Dclk) [br]
    //                     - DDR5 CTL bit                        : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD/CTL bit          (1N mode) : 2'b00 (1 Dclk) [br]
    //                     - DDR4 CMD bit              (2N mode) : 2'b01 (2 Dclk)
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 tx_ui : 2;
    //
    // Set to 1 to enable HW selection of PRBS7 or Clock pattern for ACIO loopback testing,
    // else CPGC pattern from MC will be selected.  
    //                     The pattern selection is based on the ddrcc_train_ctl1.tx_pat_gen_sel
    // control.  
    //                     Note: Not all the command bit has input from MC. SW must apply
    // the pin mapping to program this bit propertly. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved : 1;
  } Bits;
  UINT32 Data;
} DDRCC_CTL0_BIT_21__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_RXVREF_CTL_DDRCC0_CH0_DDRCC0_MEM_REG_DDR     0x0001A858
typedef union {
  struct {
    //
    // RX Vref control 0 with step size is vccddr_hv/256. Default is 62.5% vccddr_hv.[br]
    //                     These control is applied for cc bit 0 to 11[br]
    //                     Note: This vref is intended to use for alert_n
    // 
    // Bits[7:0], RW, default = 0xA0
    //
    UINT32 rx_vref_ctl0 : 8;
    //
    // RX Vref control 1 with step size is vccddr_hv/256. Default is 75% vccddr_hv.[br]
    //                     These control is applied for cc bit 12 to 21[br]
    //                     Note: This vref is intended to use for REQ/ERR/RSP_A/RSP_B
    // 
    // Bits[15:8], RW, default = 0xBF
    //
    UINT32 rx_vref_ctl1 : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 14;
    //
    // Per Vref control to enable RX Vref Dfx output for ADC measurement.
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 reserved : 2;
  } Bits;
  UINT32 Data;
} DDRCC_RXVREF_CTL_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_COMP_LA0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR       0x0001A85C
typedef union {
  struct {
    //
    // CMD Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_up_adj (signed number.
    // Range is -8 to 7) before send it to the cmdbuf.[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[4:0], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // CMD Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_dn_adj (signed number.
    // Range is -8 to 7) before send it to the cmdbuf.[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[11:7], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 20;
  } Bits;
  UINT32 Data;
} DDRCC_COMP_LA0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_COMP_LA1_DDRCC0_CH0_DDRCC0_MEM_REG_DDR       0x0001A860
typedef union {
  struct {
    //
    // CMD TCO Comp Value. It is program by BIOS but it is not trained.[br]
    //                     0/64: fastest rise & fall delay[br]
    //                     0->31: increasing fall delay[br]
    //                     64->95: increasing rise delay[br]
    //                     Other values are not used (32-63 & 96-127).[br]
    //                     To get monotonic increasing sweep of dutycycle, sweep from
    // (95 to 65, 0 to 31) 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 tco_comp : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // CMD Slew Rate Comp Value. It is trained by BIOS. [br]
    //                     0 is fastest slew rate, 31 is slowest slew rate. [br]
    //                     The SCOMP Up/Down Code are generated from the following equation:[br]
    //                     SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]
    //                     SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]
    //                     Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down
    // adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br] 
    //                     Note: HW checks for overflow and underflow.
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINT32 scomp : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 19;
  } Bits;
  UINT32 Data;
} DDRCC_COMP_LA1_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_COMP_OFFSET_DDRCC0_CH0_DDRCC0_MEM_REG_DDR    0x0001A864
typedef union {
  struct {
    //
    // Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 rcomp_drv_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINT32 rcomp_drv_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 11;
    //
    // Signed number add to scomp to generate the SCOMP Up Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 scomp_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Signed number add to scomp to generate the SCOMP Down Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[28:25], RW, default = 0x0
    //
    UINT32 scomp_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 3;
  } Bits;
  UINT32 Data;
} DDRCC_COMP_OFFSET_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_VSSHI_CTL_DDRCC0_CH0_DDRCC0_MEM_REG_DDR      0x0001A868
typedef union {
  struct {
    //
    // VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]
    //                     Code should be programmed according to analog_tuning field
    // in dll status register:[br] 
    //                                  DDR5/T2   DDR4/T[br]
    //                     3'd3:        0x45      0x55[br]
    //                     3'd1,3'd2:   0x3a      0x4a[br]
    //                     3'd0:        0x2e      0x40[br]
    //                     Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI.
    // Only the lower 7-bit is controlled by this field. 
    // 
    // Bits[6:0], RW, default = 0x18
    //
    UINT32 vsshi_target_code : 7;
    //
    // Vsshi Bias Current trim.[br]
    //                     The field should be programmed according to analog_tuning
    // field.[br] 
    //                     00: min current (if analog_tuning=3d3, fast skew)[br]
    //                     01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]
    //                     11: max current (if analog_tuning=3d0, slow skew)
    // 
    // Bits[8:7], RW, default = 0x2
    //
    UINT32 vsshi_bias_ctl : 2;
    //
    // Pull VSSHI to VSS
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 vsshi_pulldown_en : 1;
    //
    // Operates VssHi in Close loop mode
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 vsshi_close_loop : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
    //
    // Double the timer for VSSHI settle time. Use for failsafe in case settle time was
    // underestimated.[br] 
    //                     0: 8K+1K=9K Dclk cycles[br]
    //                     1: 16K+2K=18K Dclk cycles[br]
    //                     Doubles the VSSHI settle time counter in case hard-coded value
    // is not adequate 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 vsshi_tmr_ext : 1;
    //
    // Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable
    // clock gating. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 vsshi_dclk_gate_en : 1;
  } Bits;
  UINT32 Data;
} DDRCC_VSSHI_CTL_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_DLL_PI_TEST_ADC_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A86C
typedef union {
  struct {
    //
    // Sets to 1 to run test.  SW must clear the bit to stop the test. HW detects deassertion
    // of this control bit to load the pifsm_cnt. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Load the load_cnt CR value  into the PI FSM
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count (0 to 1023 with step
    // size of ~1pS).  Mutex with ModeHVM/ModeADC. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV). Mutex with ModeHVM/ModeDV. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // Load FSM with a starting point for count
    // 
    // Bits[14:5], RW, default = 0x0
    //
    UINT32 reserved_5 : 10;
    //
    // Current Count code from the PI FSM (Read Only)
    // 
    // Bits[24:15], RO/V, default = 0x0
    //
    UINT32 reserved_6 : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} DDRCC_DLL_PI_TEST_ADC_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_DLL_PI_TEST_ADC_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A870
typedef union {
  struct {
    //
    // Sets to 1 to run test.  SW must clear the bit to stop the test. HW detects deassertion
    // of this control bit to load the pifsm_cnt. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Load the load_cnt CR value  into the PI FSM
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count (0 to 1023 with step
    // size of ~1pS).  Mutex with ModeHVM/ModeADC. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV). Mutex with ModeHVM/ModeDV. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // Load FSM with a starting point for count
    // 
    // Bits[14:5], RW, default = 0x0
    //
    UINT32 reserved_5 : 10;
    //
    // Current Count code from the PI FSM (Read Only)
    // 
    // Bits[24:15], RO/V, default = 0x0
    //
    UINT32 reserved_6 : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} DDRCC_DLL_PI_TEST_ADC_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_DLL_CSR_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR     0x0001A874
typedef union {
  struct {
    //
    // DLL Deterministic Lock Status
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 detrm_lock : 1;
    //
    // DLL Raw Lock Status Sticky bit.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 raw_lock : 1;
    //
    // DLL Lock timeout.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 lock_timeout : 1;
    //
    // DLL Reset.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 dll_reset : 1;
    //
    // DLL ADC out.
    // 
    // Bits[13:4], RO/V, default = 0x0
    //
    UINT32 adcout : 10;
    //
    // DLL Long Lock Status.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 long_lock : 1;
    //
    // Detect lock CBB early lock sticky output
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 detlock_earlylockstky : 1;
    //
    // DLL Weak Lock Status.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 weak_lock : 1;
    //
    // DLL ADC done.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 adc_done : 1;
    //
    // DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register,
    // clock gating must be disabled. 
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 pilags : 1;
    //
    // MDLL open loop output
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 openloop : 1;
    //
    // Detect lock CBB lock reset output
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 lockrst_b : 1;
    //
    // BIOS should configure certain analog components based on the value of this register.[br]
    //                     Details will be found in the description of any CSR that relies
    // on this value 
    // 
    // Bits[23:21], RO/V, default = 0x0
    //
    UINT32 analog_tuning : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Bypasses flyby clock and selects H-tree clock when disbled
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 flybyclk_sel : 1;
    //
    // BIOS program this IO Frequency range field based on PLL freq; It is half of the
    // DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br] 
    //                     2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]
    //                     2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]
    //                     2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]
    //                     2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
    // 
    // Bits[29:28], RW, default = 0x2
    //
    UINT32 iofreq_range : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // BIOS must enable DLL when program the IO freq range.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dll_en : 1;
  } Bits;
  UINT32 Data;
} DDRCC_DLL_CSR_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_DLL_CSR_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR     0x0001A878
typedef union {
  struct {
    //
    // DLL Deterministic Lock Status
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 detrm_lock : 1;
    //
    // DLL Raw Lock Status Sticky bit.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 raw_lock : 1;
    //
    // DLL Lock timeout.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 lock_timeout : 1;
    //
    // DLL Reset.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 dll_reset : 1;
    //
    // DLL ADC out.
    // 
    // Bits[13:4], RO/V, default = 0x0
    //
    UINT32 adcout : 10;
    //
    // DLL Long Lock Status.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 long_lock : 1;
    //
    // Detect lock CBB early lock sticky output
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 detlock_earlylockstky : 1;
    //
    // DLL Weak Lock Status.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 weak_lock : 1;
    //
    // DLL ADC done.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 adc_done : 1;
    //
    // DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register,
    // clock gating must be disabled. 
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 pilags : 1;
    //
    // MDLL open loop output
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 openloop : 1;
    //
    // Detect lock CBB lock reset output
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 lockrst_b : 1;
    //
    // BIOS should configure certain analog components based on the value of this register.[br]
    //                     Details will be found in the description of any CSR that relies
    // on this value 
    // 
    // Bits[23:21], RO/V, default = 0x0
    //
    UINT32 analog_tuning : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Bypasses flyby clock and selects H-tree clock when disbled
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 flybyclk_sel : 1;
    //
    // BIOS program this IO Frequency range field based on PLL freq; It is half of the
    // DRAM transfer rate. For example DDR 4800. The PLL freq is 2400.[br] 
    //                     2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]
    //                     2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]
    //                     2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]
    //                     2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
    // 
    // Bits[29:28], RW, default = 0x2
    //
    UINT32 iofreq_range : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // BIOS must enable DLL when program the IO freq range.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dll_en : 1;
  } Bits;
  UINT32 Data;
} DDRCC_DLL_CSR_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_OFFSET0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A87C
typedef union {
  struct {
    //
    // CMD delay adjust value. It is added to all per bit command delay. It is used by
    // BIOS for margining sweep. The adjust range is -128 to 127. The expected usage
    // model is BIOS broadcast the same adjust value to all the command fubs. 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINT32 cmd_dly_adj : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 24;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_OFFSET0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_PIREF_OFFSET0_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A880
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of  DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This cmd piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each cmd_dly[6:0], so each cmd pi odd
    // code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 cmd_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCC_PIREF_OFFSET0_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_PIREF_OFFSET0_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A884
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of  DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This cmd piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each cmd_dly[6:0], so each cmd pi odd
    // code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 cmd_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCC_PIREF_OFFSET0_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_PIREF_OFFSET0_2__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A888
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of  DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This cmd piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each cmd_dly[6:0], so each cmd pi odd
    // code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 cmd_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCC_PIREF_OFFSET0_2__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_PIREF_OFFSET0_3__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A88C
typedef union {
  struct {
    //
    // It is the train PI odd code to align the PIREF odd clock to the failing edge of
    // DCLK with data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    // value is 63)  to generate the  piref_pio_code to DLL. The xover input is driven
    // from a failing edge of  DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pio_code : 7;
    //
    // This offset is added to the piref_pio_code. The result is the piref pi even code
    // (piref_pie_code) to DLL. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 piref_pie_offset : 7;
    //
    // This cmd piref offset is added with a signed piref_setup_adj (default value is
    // 63). [br] 
    //                     The result is added to each cmd_dly[6:0], so each cmd pi odd
    // code to the DLL is relative to the piref odd clock.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 cmd_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 63 ticks, and we will
    // have 63 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[30:24], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRCC_PIREF_OFFSET0_3__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_RX_CTL0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR        0x0001A890
typedef union {
  struct {
    //
    // Control number of ODT segment enable for cmd buf.
    // 
    // Bits[1:0], RW, default = 0x3
    //
    UINT32 odt_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Force the Rx amplifier combiner to a lower static power state during Alert and
    // DDR-T modes,[br] 
    //                     which reduces FiSH temperatures and helps RV.
    // 
    // Bits[3:3], RW, default = 0x1
    //
    UINT32 rx_combiner_alert_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 6;
    //
    // SW set this bit to 1 to ungate the DDRIO to MC RX data path.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 rx_path_ungate : 1;
    //
    // Repurposed for force local receiver bias on for DQbuf.[br]
    //                     When set to 1, it will keep the local bias mirror always enabled.[br]
    //                     When set to 0, local bias gets enabled with senseamp_enable.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 rxgainfuse_ovrd : 1;
    //
    // Rx summer output common mode control[br]
    //                     0: 0.25*vccddra[br]
    //                     1: 0.3*vccddra (default)[br]
    //                     2: 0.35*vccddra[br]
    //                     3: 0.4*vccddra
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINT32 rxbias_vcm_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // 00  1.5x (default for CMD/CLK)[br]
    //                     01  2x[br]
    //                     10 - 2.5x (default for DQ)[br]
    //                     11  3x
    // 
    // Bits[16:15], RW, default = 0x1
    //
    UINT32 rxbias_rxgain_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 5;
    //
    // Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has
    // weight of 2 and LSB bit has weight of 1. [br] 
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[26:22], RW, default = 0x1F
    //
    UINT32 odt_static_leg_cfg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 5;
  } Bits;
  UINT32 Data;
} DDRCC_RX_CTL0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_RX_CTL1_DDRCC0_CH0_DDRCC0_MEM_REG_DDR        0x0001A894
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 6;
    //
    // enable offset control in cmd buf and RX BIAS
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINT32 rx_offset_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 22;
    //
    // Spare bits - potentially for trimming Rload
    // 
    // Bits[31:29], RW, default = 0x0
    //
    UINT32 reserved : 3;
  } Bits;
  UINT32 Data;
} DDRCC_RX_CTL1_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TX_CTL0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR        0x0001A89C
typedef union {
  struct {
    //
    // Sets number of CmdCtl driver (Ron) static legs. [br]
    //                     First 3 MSB bits has weight of 4, 4th MSB has weight of 2
    // and LSB bit has weight of 1. [br] 
    //                     Hardware default of 0x1F has 15 static legs enabled. [br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[4:0], RW, default = 0x1F
    //
    UINT32 drv_static_leg_cfg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Control number of drive segment enable for CMD buf. Also, it is used by COMP to
    // TXEQ logic to generate the EQCODE. 
    // 
    // Bits[7:6], RW, default = 0x3
    //
    UINT32 data_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // CS Enable Imode EQ per byte lane. [br]
    //                     0: Imode completely off [br]
    //                     1: Imode enabled (Xtalk cancellation OR swing boost selected
    // by ImodeCfg 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 cs_imode_en : 1;
    //
    // CA Enable Imode EQ per byte lane. [br]
    //                     0: Imode completely off [br]
    //                     1: Imode enabled (Xtalk cancellation OR swing boost selected
    // by ImodeCfg 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 ca_imode_en : 1;
    //
    // CS 2nd tap equalization sign bit[br]
    //                     0: +ve equalization[br]
    //                     1: -ve equalization
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 cs_eq_post2_sign : 1;
    //
    // CA 2nd tap equalization sign bit[br]
    //                     0: +ve equalization[br]
    //                     1: -ve equalization
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 ca_eq_post2_sign : 1;
    //
    // CS 2nd tap selection:[br]
    //                     0  txeq_2nd_tap used for 2nd post cursor tap[br]
    //                     1  txeq_2nd_tap used for extending range of 1st tap.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 cs_eq_post2_sel : 1;
    //
    // CA 2nd tap selection:[br]
    //                     0  txeq_2nd_tap used for 2nd post cursor tap[br]
    //                     1  txeq_2nd_tap used for extending range of 1st tap.
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 ca_eq_post2_sel : 1;
    //
    // CS Binary Imode Coefficient, sets Imode current strength.[br]
    //                     (used for either Xtalk cancellation or swing boost)[br]
    //                     Imode coefficient, sets Imode current. Sweep values: (0-15,
    // 40-42, 48-63) for a linear increase of current from 0 to max. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 cs_imode_eq_code : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // CA Binary Imode Coefficient, sets Imode current strength.[br]
    //                     (used for either Xtalk cancellation or swing boost)[br]
    //                     Imode coefficient, sets Imode current. Sweep values: (0-15,
    // 40-42, 48-63) for a linear increase of current from 0 to max. 
    // 
    // Bits[28:23], RW, default = 0x0
    //
    UINT32 ca_imode_eq_code : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]
    //                     No need skew based settings, value of 1 seems to work across
    // PVT.[br] 
    //                     May need to set to 0 for slow silicon if we see issues in
    // post silicon. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 tx_serializer_pwradj : 1;
    //
    // 0 : CMD BUF bypass SCOMP and TCO delay in the transmitter.
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 scomp_tco_bypass_dis : 1;
  } Bits;
  UINT32 Data;
} DDRCC_TX_CTL0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TX_CTL1_DDRCC0_CH0_DDRCC0_MEM_REG_DDR        0x0001A8A0
typedef union {
  struct {
    //
    // Set by BIOS to indicate the io_dir control field is valid.[br]
    //                     - if this bit is not set, force the receive data to 0[br]
    //                     - it is used by the command buf CBB to latch the io_pwrdn_pull_low
    // siganl when set to 1 by BIOS. That sequential is power by always on power (s3localvcc),
    // so when analog power is down, the buf use it to determine to either pull low or
    // tri-state the IO. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 io_dir_valid : 1;
    //
    // CS TxEQ 1st tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[6:1], RW, default = 0x0
    //
    UINT32 cs_txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // CA TxEQ 1st tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINT32 ca_txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // CS TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[18:15], RW, default = 0x0
    //
    UINT32 cs_txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // CA TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 ca_txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRCC_TX_CTL1_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_DFX_CTL0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR       0x0001A8A8
typedef union {
  struct {
    //
    // Per Verf control to enable to close switch to pass vin to vout in HV Switcher
    // CBB for NTL testing. 
    // 
    // Bits[1:0], RW, default = 0x0
    //
    UINT32 reserved : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Simulation-only control to shorten VSSHI and LDO timers
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // 0 - No Vref power saving in Self Refresh. The cmd Vref generators is enabled by
    // rx_vref_en.[br] 
    //                     1 - The cmd Vref generators are switched off while in Self
    // Refresh regardless the setting of rx_vref_en. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 sr_vref_dis : 1;
    //
    // 0 - No Vref power saving in CKE power down. All CMDCTL Vref generators is enabled
    // by rx_vref_en.[br] 
    //                     1 - CMDCTL Vref generators are switched off while in CKE power
    // down regardless the setting of rx_vref_en. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 ckepd_vref_dis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 4;
    //
    // Per bit VOC RX pass gate enable for VOC training and NTL testing.
    // 
    // Bits[31:10], RW, default = 0x0
    //
    UINT32 rx_voc_pass_gate_en : 22;
  } Bits;
  UINT32 Data;
} DDRCC_DFX_CTL0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HW_TRAIN_CTL0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8AC
typedef union {
  struct {
    //
    // Set to 1 to enable xover training stage
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 xover_stage_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Set to 1 to enable DFE summer offset training stage for all bits.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dfe_summer_offset_stage_en : 1;
    //
    // Set to 1 to enable txpiclk training  stage. This state should only be enabled
    // for ACIO LB testing only. In this stage the HW will sweep each bits txpiclk to
    // center align the transmit data to the receiving piref clock. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 to enable loop delay training stage. This state should only be enabled
    // for ACIO LB testing only. In the stage the HW will calculate the loop tx to rx
    // loop delay for each bits. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Set to 1  to double the analog settling time. [br]
    //                     The default settling time for each stage are [br]
    //                     Xover : 32 Dclk for first iteration,  24 Dclk for subsequent
    // [br] 
    //                     DFE summer offset : 24 Dclk [br]
    //                     Txpiclk :  24 Dclk [br]
    //                     Loop Delay:  8 Dclk
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 settling_time_x2 : 1;
    //
    // Number of Sample to evaluate for each iteration step. It applied for all training
    // stages. [br] 
    //                     0: 16[br]
    //                     1: 32[br]
    //                     2: 64[br]
    //                     3: 2 (Should only used to speed up digital simulation)
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINT32 sample_cnt : 2;
    //
    // Sample threshold value for voting logic.
    // 
    // Bits[15:10], RW, default = 0x8
    //
    UINT32 sample_thresh : 6;
    //
    // Set to 1 to enable ACIO loopback. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Set to 1 to enable ACIO pattern checking. This bit should be set after acio_en
    // is set. Also it should be cleared before the acio_en is cleared. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 10;
    //
    // HW calibation enable control per FSM (cmd has 4). Set to 1 to enable the HW calibration.
    // [br] 
    //                     They are 4 HW calibration stages that SW can request HW to
    // perform. It is defined in bit 0 to 4 in this register. [br] 
    //                     HW cal FSM will self clear this bit when all the enabled calibration
    // stages are completed. [br] 
    //                     For BIOS training, XOVER, sampler offset, and DFE summer offset
    // training can be enabled by SW.[br] 
    //                     For ACIO testing, all 4 stages can be enabled by SW.
    // 
    // Bits[31:28], RW/V, default = 0x0
    //
    UINT32 hw_cal_en : 4;
  } Bits;
  UINT32 Data;
} DDRCC_HW_TRAIN_CTL0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS0_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8B0
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any bit within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[9:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 6;
    //
    // Per bit ACIO toggle detection status. SW must clear this bit to 0 when enable
    // ACIO. 
    // 
    // Bits[15:10], RW/1C/V, default = 0x0
    //
    UINT32 reserved_3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS0_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS0_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8B4
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any bit within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[9:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 6;
    //
    // Per bit ACIO toggle detection status. SW must clear this bit to 0 when enable
    // ACIO. 
    // 
    // Bits[15:10], RW/1C/V, default = 0x0
    //
    UINT32 reserved_3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS0_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS0_2__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8B8
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any bit within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[9:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 6;
    //
    // Per bit ACIO toggle detection status. SW must clear this bit to 0 when enable
    // ACIO. 
    // 
    // Bits[15:10], RW/1C/V, default = 0x0
    //
    UINT32 reserved_3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS0_2__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS0_3__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8BC
typedef union {
  struct {
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[0:0], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed for any bit within
    // this piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[1:1], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate txpiclk training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 by HW to indicate loop delay training is failed for any bit within this
    // piref group. SW must clear this bit to 0 when enable HW calibration. 
    // 
    // Bits[3:3], RW/1C/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Sticky error bit when HW detect ACIO test pattern mismatch. SW must clear this
    // bit to 0 when enable ACIO 
    // 
    // Bits[9:4], RW/1C/V, default = 0x0
    //
    UINT32 reserved_2 : 6;
    //
    // Per bit ACIO toggle detection status. SW must clear this bit to 0 when enable
    // ACIO. 
    // 
    // Bits[15:10], RW/1C/V, default = 0x0
    //
    UINT32 reserved_3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS0_3__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS1_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8C0
typedef union {
  struct {
    //
    // Loop delay 0 after training
    // 
    // Bits[3:0], RW/V, default = 0x0
    //
    UINT32 reserved : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[7:4], RW/V, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // Loop delay 2 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 3 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 4 after training
    // 
    // Bits[19:16], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Loop delay 5 after training
    // 
    // Bits[23:20], RW/V, default = 0x0
    //
    UINT32 reserved_5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS1_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS1_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8C4
typedef union {
  struct {
    //
    // Loop delay 0 after training
    // 
    // Bits[3:0], RW/V, default = 0x0
    //
    UINT32 reserved : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[7:4], RW/V, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // Loop delay 2 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 3 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 4 after training
    // 
    // Bits[19:16], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Loop delay 5 after training
    // 
    // Bits[23:20], RW/V, default = 0x0
    //
    UINT32 reserved_5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS1_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS1_2__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8C8
typedef union {
  struct {
    //
    // Loop delay 0 after training
    // 
    // Bits[3:0], RW/V, default = 0x0
    //
    UINT32 reserved : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[7:4], RW/V, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // Loop delay 2 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 3 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 4 after training
    // 
    // Bits[19:16], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Loop delay 5 after training
    // 
    // Bits[23:20], RW/V, default = 0x0
    //
    UINT32 reserved_5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS1_2__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_HWCAL_STS1_3__DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8CC
typedef union {
  struct {
    //
    // Loop delay 0 after training
    // 
    // Bits[3:0], RW/V, default = 0x0
    //
    UINT32 reserved : 4;
    //
    // Loop delay 1 after training
    // 
    // Bits[7:4], RW/V, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // Loop delay 2 after training
    // 
    // Bits[11:8], RW/V, default = 0x0
    //
    UINT32 reserved_2 : 4;
    //
    // Loop delay 3 after training
    // 
    // Bits[15:12], RW/V, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Loop delay 4 after training
    // 
    // Bits[19:16], RW/V, default = 0x0
    //
    UINT32 reserved_4 : 4;
    //
    // Loop delay 5 after training
    // 
    // Bits[23:20], RW/V, default = 0x0
    //
    UINT32 reserved_5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRCC_HWCAL_STS1_3__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_CTL1_DDRCC0_CH0_DDRCC0_MEM_REG_DDR     0x0001A8D4
typedef union {
  struct {
    //
    // Enables the Command Training Counter mode (receivers, ODT needs to be enabled
    // separately before setting this bit), resets the sample counter and starts the
    // counting of the samples. One of these per nibble that is used for feedback (i.e.
    // all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with
    // broadcast). The value of this field remains at 1 until after the Counting Window
    // expires, then returns to 0. Can be polled to determine when the counting has completed.
    // When the Counting Window field is set to 0, this field will not return to 0. In
    // that case, this field must be set to 0 to disable.[br] 
    //                     When the CS Assertion Trigger Enable is set, the counting
    // window start is delayed until the first CS Assertion event  but this delay only
    // applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the
    // DQ counters. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 cmd_train_ctr_en : 1;
    //
    // Set to 1 to enable DDR-T2 Request training
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 ddrt2_req_train_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // It is used to control DDRIO to generate PRBS or Clock pattern for CC ACIO loopback
    // testing by SW.[br] 
    //                     0 - PRBS pattern[br]
    //                     1 - Clock pattern
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 to enable sample path and unsample path feedback results. [br]
    //                     Note: It is used for SW SA training and SW ACIO txpiclk training.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 rx_path_fb_en : 1;
    //
    // Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform
    // Xover calibraton training.  
    //                     - enable all the DCLK And PI clocks. (may remove clock gating
    // function) 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 xover_cal : 1;
    //
    // Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 vref_highz : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 5;
    //
    // For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2.
    // It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br] 
    //                     Setting this bit to 1 indicate it is operating in DDR4/DDR-T.
    // 0 inidate it is operating in DDR5/DDR-T2. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 ddr4 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Set to 1 to enable HW to gate effective register update CLK for power saving.
    // Default is disable clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 compeff_clk_gate_en : 1;
    //
    // Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power
    // saving. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 bclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Set to 1 to enable HW to gate all PI N clocks for power saving. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 pi_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 piref_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate TX CLK  for transmit path logics. Default is disable
    // clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 tx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 rx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training
    // logics). Default is disable clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 train_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 csr_clk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 2;
    //
    // Force all the CMD IO strong ODT on. When set, it always enable one segment for
    // ODT regardless of the state of drive enable. [br] 
    //                     The intend use case is for ACIO with burnin
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 force_strong_odt_on : 1;
    //
    // Forces all the CMD transmitter driver on.
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 force_txon : 1;
    //
    // Force all the CMD IO weak ODT on. The weak ODT is ignored when drive enable is
    // asserted. [br] 
    //                     Note: For ACIO, ODT is provided by different DDR channel.
    //  
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 force_odt_on : 1;
    //
    // Force Rx Bias and Rx Bias Vref On
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 force_rxbias_on : 1;
    //
    // Force Senseamp on. Use for overclocking support where we may not be able to hit
    // the fast exit latency. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 force_sa_on : 1;
    //
    // Per Vref control to enable RX Vref.[br]
    //                     Bit 0: signal index 0-11 [br]
    //                     Bit 1: signal index 12-21
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rx_vref_en : 2;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_CTL1_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_CTL2_DDRCC0_CH0_DDRCC0_MEM_REG_DDR     0x0001A8D8
typedef union {
  struct {
    //
    // Select which IO to count during DCS and DCA training. The count result is stored
    // in ddr_train_cnt_result0 register 0.[br] 
    //                     Note: The current supporting mode is counting only ALERT_n
    // or counting on both RSP_A and RSP_B signals. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 train_cnt_io_sel0 : 5;
    //
    // Select which IO to count during DCS and DCA training. The count result is stored
    // in ddr_train_cnt_result0 register 1.[br] 
    //                     Note: The current supporting mode is counting only ALERT_n
    // or counting on both RSP_A and RSP_B signals. 
    // 
    // Bits[9:5], RW, default = 0x0
    //
    UINT32 train_cnt_io_sel1 : 5;
    //
    // When set to 1, the counting window does not start until the first CS assertion
    // (any CS assertion). This trigger only applies for the counters associated with
    // the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the DQ counters.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 csa_trigger_en : 1;
    //
    // Determines if the command training counter will count 1 or 0.[br]
    //                     0: count 1[br]
    //                     1: count 0
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 sample_sel : 1;
    //
    // Select which xover phase detect output for DLL0 Top piref calibration. Legal value
    // is 0 to 17. 
    // 
    // Bits[16:12], RW, default = 0x0
    //
    UINT32 dll0_top_xover_cal_mux_sel : 5;
    //
    // Select which xover phase detect output for DLL0 Bottom piref calibration. Legal
    // value is 0 to 17. 
    // 
    // Bits[21:17], RW, default = 0x0
    //
    UINT32 dll0_bot_xover_cal_mux_sel : 5;
    //
    // Select which xover phase detect output for DLL1 Top piref calibration. Legal value
    // is 0 to 11. 
    // 
    // Bits[26:22], RW, default = 0x0
    //
    UINT32 dll1_top_xover_cal_mux_sel : 5;
    //
    // Select which xover phase detect output for DLL1 Bottom piref calibration. Legal
    // value is 0 to 17. 
    // 
    // Bits[31:27], RW, default = 0x0
    //
    UINT32 dll1_bot_xover_cal_mux_sel : 5;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_CTL2_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_CNT_WINDOW0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A8DC
typedef union {
  struct {
    //
    // value that sets the number of DCLK cycles that the selected CMDCTL input samples
    // will be counted. Linear setting. This is broadcast to all the CMDCTL fub. When
    // this field is set to 0 the counter will run until it saturates, or until it the
    // CMD Training Counter Mode field is cleared. 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINT32 cnt_window : 32;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_CNT_WINDOW0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_CNT_RESULT_0__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A8E0
typedef union {
  struct {
    //
    // Value that indicates the number of logic 1  or 0 values sampled during the Counting
    // Window (based on sample_sel). This is cleared when the CMD Training Counter mode
    // is enabled..  Whten the cnt_window is set to 0, the counter will run until it
    // saturates. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 train_cnt : 32;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_CNT_RESULT_0__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_CNT_RESULT_1__DDRCC0_CH0_DDRCC0_MEM_REG_DDR 0x0001A8E4
typedef union {
  struct {
    //
    // Value that indicates the number of logic 1  or 0 values sampled during the Counting
    // Window (based on sample_sel). This is cleared when the CMD Training Counter mode
    // is enabled..  Whten the cnt_window is set to 0, the counter will run until it
    // saturates. 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 train_cnt : 32;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_CNT_RESULT_1__DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_RESULT0_DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8E8
typedef union {
  struct {
    //
    // Xover Calibration Phase Detected Result[br]
    //                     Bit 3 : DLL 1 - piref for IO[lb]21:16[rb][br]
    //                     Bit 2 : DLL 1 - piref for IO[lb]15:12[rb][br]
    //                     Bit 1 : DLL 0 - piref for IO[lb]11:6[rb][br]
    //                     Bit 0 : DLL 0 - piref for IO[lb]5:0[rb]
    // 
    // Bits[3:0], RO/V, default = 0x0
    //
    UINT32 xover_cal_pd_result : 4;
    //
    // Per bit senseamp train result[br]
    //                     Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1
    // before reading this fields. 
    // 
    // Bits[25:4], RO/V, default = 0x0
    //
    UINT32 sa_train_result : 22;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 6;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_RESULT0_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;

#define DDRCC_TRAIN_RESULT1_DDRCC0_CH0_DDRCC0_MEM_REG_DDR  0x0001A8EC
typedef union {
  struct {
    //
    // RX even sample path feedback. It is used in SW ACIO loopback txpiclk stage training.
    // [br] 
    //                     Note: SW must set the ddrcc_train_ctl1.rx_path_fb_en to 1
    // before reading this fields. 
    // 
    // Bits[21:0], RO/V, default = 0x0
    //
    UINT32 rx_even_sample_path_fb : 22;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 10;
  } Bits;
  UINT32 Data;
} DDRCC_TRAIN_RESULT1_DDRCC0_CH0_DDRCC0_MEM_STRUCT_DDR;


#endif // _MMRCDDRCC0_CH0_DDRCC0_MEM_DDR_H_DDR_
